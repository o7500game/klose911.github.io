<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>任务执行</title>
<!-- 2016-11-13 Sun 23:54 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="klose" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">任务执行</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">线程中执行任务</a>
<ul>
<li><a href="#sec-1-1">串行执行</a></li>
<li><a href="#sec-1-2">每个请求单独线程</a></li>
</ul>
</li>
<li><a href="#sec-2">Executor框架</a>
<ul>
<li><a href="#sec-2-1">线程执行策略</a></li>
<li><a href="#sec-2-2">线程池</a></li>
<li><a href="#sec-2-3">Executor生命周期：运行，关闭中，终止</a></li>
<li><a href="#sec-2-4">Timer和ScheduledThreadPool</a></li>
</ul>
</li>
<li><a href="#sec-3">发现可利用的并发</a>
<ul>
<li><a href="#sec-3-1">返回结果的任务　</a></li>
<li><a href="#sec-3-2">CompletionService</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">线程中执行任务</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">串行执行</h3>
<div class="outline-text-3" id="text-1-1">
<p>
吞吐量低，响应慢，IO操作中浪费cpu
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">每个请求单独线程</h3>
<div class="outline-text-3" id="text-1-2">
<ol class="org-ol">
<li>线程的创建和销毁会占用一定的资源。如果请求频繁而对请求的处理是轻量级的(大多的web请求符合该情形), 创建一个线程处理请求后将其销毁的方式是不划算的
</li>
<li>过多的线程导致线程切换频繁, 用于处理请求的CPU时间反而会减少. 如果当前的线程数已经让CPU处于忙碌状态, 那么增加更多的线程不会改善应用的性能 
</li>
<li>过多的线程会导致系统稳定性下降　
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Executor框架</h2>
<div class="outline-text-2" id="text-2">
<p>
将创建好的线程组织成线程池, 当请求来临时从池中取出线程处理请求, 处理完毕后将线程归还给线程池, 而不是销毁　<br  />
通过限制线程池中的线程数, 以克服线程过多时性能和稳定性下降的缺陷 <br  />
</p>

<p>
Executor框架包含多个线程池的实现, 所有线程池都派生自Executor接口<br  />
 　
Executor接口只定义了一个方法: execute(Runnable task) 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">Executor</span> {
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">execute</span>(<span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">command</span>);
}
</pre>
</div>

<p>
Executor接口解耦了任务提交和任务执行, 提交任务的线程为生产者, 执行任务的线程为消费者 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">TaskExecutionWebServer</span> {   
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">NTHREADS</span> = 100;   
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21019;&#24314;&#32447;&#31243;&#27744;  </span>
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Executor</span> <span style="color: #eedd82;">exec</span>   
    = Executors.newFixedThreadPool(NTHREADS);   

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">IOException</span> {   
        <span style="color: #98fb98;">ServerSocket</span> <span style="color: #eedd82;">socket</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ServerSocket</span>(80);   
        <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {   
            <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">connection</span> = socket.accept();   
            <span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">task</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Runnable</span>() {   
                    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {   
                        handleRequest(connection);   
                    }   
                };   
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23558;&#20219;&#21153;&#25552;&#20132;&#32473;&#32447;&#31243;&#27744;&#25191;&#34892;  </span>
            exec.execute(task);   
        }   
    }   
}
</pre>
</div>

<p>
使用Executor实现每个请求一个线程
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ThreadPerTaskExecutor</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Executor</span> {
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">execute</span>(<span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">r</span>) {
        <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(r).start();
    };
}
</pre>
</div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">线程执行策略</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>任务在哪个线程中执行
</li>
<li>任务以何种顺序（FIFO, LIFO, 优先级）执行
</li>
<li>同时有多少线程同步执行任务
</li>
<li>多少任务可以等待执行
</li>
<li>当负荷过载时候，那些任务可以被牺牲，如何通知应用这些任务
</li>
<li>任务执行前和执行后需要哪些操作
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">线程池</h3>
<div class="outline-text-3" id="text-2-2">
<p>
ExecutorService接口继承自Executor, 而预定义的线程池类大多实现了ExecutorService接口 
</p>
<ul class="org-ul">
<li>newFixedThreadPool: 最大线程数固定的线程池.
</li>
<li>newCachedThreadPool: 可伸缩式线程池, 当线程池中线程的数量超过程序所需时, 会自动销毁多余的线程; 当线程池中的线程不能需要时再创建新的线程执行提交的任务, 该线程池没有最大线程数的限定
</li>
<li>newSingleThreadExecutor: 仅包含一个线程的线程池, 提交给该线程池执行的任务, 都将在这一单个线程中完成处理
</li>
<li>newScheduledThreadPool. 最大线程数固定且支持延迟和周期性重复执行任务的线程池
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Executor生命周期：运行，关闭中，终止</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">ExecutorService</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Executor</span> {
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">shutdown</span>();
    <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Runnable</span>&gt; <span style="color: #87cefa;">shutdownNow</span>();
    <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">isShutdown</span>();
    <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">isTerminated</span>();
    <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">awaitTermination</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>, <span style="color: #98fb98;">TimeUnit</span> <span style="color: #eedd82;">unit</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span>;
<span style="color: #ff4500;">// </span><span style="color: #ff4500;">... additional convenience methods for task submission</span>
}
</pre>
</div>
<ul class="org-ul">
<li>shutdown: 在关闭前允许执行以前提交的任务, 包括那些已提交但尚未开始执行的任务 
</li>
<li>shutdownNow: 阻止尚未开始执行的任务启动并试图停止当前正在执行的任务, 返回从未开始执行的任务的列表
</li>
<li>isShutdown：判断线程池是否已关闭. 线程池关闭后将拒绝接受新任务, 将抛出RejectedExecutionException
</li>
<li>awaitTermination: 将使得主线程阻塞, 直到线程池转变为终止状态, 通常在调用shutdown方法后紧接着调用awaitTermination方法
</li>
<li>isTerminated: 检测线程池是否处于终止状态, 当线程池已关闭, 并且所有提交给线程池的任务都已完成时, 线程池转变为终止状态
</li>
</ul>


<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LifecycleWebServer</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ExecutorService</span> <span style="color: #eedd82;">exec</span> = ...;
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">start</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">IOException</span> {
        <span style="color: #98fb98;">ServerSocket</span> <span style="color: #eedd82;">socket</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ServerSocket</span>(80);
        <span style="color: #00ffff;">while</span> (!exec.isShutdown()) {
            <span style="color: #00ffff;">try</span> {
                <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">conn</span> = socket.accept();
                exec.execute(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Runnable</span>() {
                        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() { handleRequest(conn); }
                    });
            } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">RejectedExecutionException</span> <span style="color: #eedd82;">e</span>) {
                <span style="color: #00ffff;">if</span> (!exec.isShutdown())
                    log(<span style="color: #ffa07a;">"task submission rejected"</span>, e);
            }
        }
    }
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">stop</span>() { exec.shutdown(); }
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">handleRequest</span>(<span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">connection</span>) {
        <span style="color: #98fb98;">Request</span> <span style="color: #eedd82;">req</span> = readRequest(connection);
        <span style="color: #00ffff;">if</span> (isShutdownRequest(req))
            stop();
        <span style="color: #00ffff;">else</span>
            dispatchRequest(req);
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Timer和ScheduledThreadPool</h3>
<div class="outline-text-3" id="text-2-4">
<p>
两者都可以用于延时或周期性重复执行某个任务, 但是Timer存在一些缺陷:
</p>
<ol class="org-ol">
<li>Timer基于绝对时间来安排任务的调度, 因此系统时钟的改变会对其产生影响. ScheduledThreadPoolExecutor基于相对时间进行任务的调度
</li>
<li>Timer创建单一的线程执行定时任务. 假如Timer对象以10ms的间隔重复执行某个任务, 但是其中的一次执行花去了40ms, 这就意味着少执行了至少4次重复任务. ScheduledThreadPoolExecutor可以使用多个线程执行定时任务
</li>
<li>如果在执行任务的过程中抛出运行时异常, Timer的线程会被终止且没有恢复机制
</li>
</ol>
<p>
几乎没有理由继续使用Timer调度定时任务了
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">发现可利用的并发</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">返回结果的任务　</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Executor的使用Runnable作为基本的任务表达形式，但是Runnable无法返回结果或抛出异常<br  />
Callable作为Runnable的扩展，可以返回结果或抛出异常
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">Callable</span>&lt;<span style="color: #98fb98;">V</span>&gt; {
    <span style="color: #98fb98;">V</span> <span style="color: #87cefa;">call</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span>;
}
</pre>
</div>
<p>
Executor提交的任务有４个生命周期：创建，提交，开始和完成<br  />
已经提交但尚未开始的任务可以取消，已经开始执行但尚未完成的任务只有它们能响应中断才能取消，取消一个已经完成的任务没有任何影响<br  />
Future表示一个任务的生命周期，并提供相应的方法判断任务是否已经开始，完成，取消，以及获取任务结果，取消任务等
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">V</span>&gt; {
    <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">cancel</span>(<span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">mayInterruptIfRunning</span>);
    <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">isCancelled</span>();
    <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">isDone</span>();
    <span style="color: #98fb98;">V</span> <span style="color: #87cefa;">get</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span>, <span style="color: #98fb98;">ExecutionException</span>,
        <span style="color: #98fb98;">CancellationException</span>;
    <span style="color: #98fb98;">V</span> <span style="color: #87cefa;">get</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>, <span style="color: #98fb98;">TimeUnit</span> <span style="color: #eedd82;">unit</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span>, <span style="color: #98fb98;">ExecutionException</span>,
        <span style="color: #98fb98;">CancellationException</span>, <span style="color: #98fb98;">TimeoutException</span>;
}
</pre>
</div>
<p>
get方法的行为取决与任务的状态
</p>
<ul class="org-ul">
<li>已经完成：立即返回结果或者抛出异常ExecutionException, 可以通过getClause获得被封装的初始异常
</li>
<li>没有完成：阻塞主线程直到任务结束
</li>
<li>取消：将抛出CancellationException
</li>
</ul>

<p>
创建Future
</p>
<ul class="org-ul">
<li>ExecutorService中所有submit方法都会返回一个Future, 将Runnable或Callable提交给Executor得到Future
</li>
<li>也可以显式地为Runnable或者Callable创建一个FutureTask提交给Executor
</li>
<li>ExecutorService也可以使用newTaskFor方法为Callable获得Future
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">protected</span> &lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #98fb98;">RunnableFuture</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #87cefa;">newTaskFor</span>(<span style="color: #98fb98;">Callable</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #eedd82;">task</span>) {
    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">FutureTask</span>&lt;<span style="color: #98fb98;">T</span>&gt;(task);
}
</pre>
</div>

<p>
使用Future渲染图片
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">FutureRenderer</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Render</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">NTHREADS</span> = 100;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ExecutorService</span> <span style="color: #eedd82;">executor</span> = Executors.newFixedThreadPool(NTHREADS);

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">renderPage</span>(<span style="color: #98fb98;">CharSequence</span> <span style="color: #eedd82;">source</span>) {
        <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">ImageInfo</span>&gt; <span style="color: #eedd82;">imageInfos</span> = scanForImageInfo(source);
        <span style="color: #98fb98;">Callable</span>&lt;<span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">ImageData</span>&gt;&gt; <span style="color: #eedd82;">task</span>;
        task = () -&gt; {
            <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">ImageData</span>&gt; <span style="color: #eedd82;">result</span>
            = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ArrayList</span>&lt;&gt;();
            imageInfos.forEach((imageInfo) -&gt; {
                    result.add(imageInfo.downloadImage());
                });
            <span style="color: #00ffff;">return</span> result;
        };
        <span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">ImageData</span>&gt;&gt; <span style="color: #eedd82;">future</span> = executor.submit(task);
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#28210;&#26579;&#25991;&#26412;  </span>
        renderText(source);
        <span style="color: #00ffff;">try</span> {
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">get&#26041;&#27861;&#23558;&#38459;&#22622;, &#30452;&#21040;task&#23436;&#25104;&#19979;&#36733;  </span>
            <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">ImageData</span>&gt; <span style="color: #eedd82;">imageData</span> = future.get();
            imageData.forEach((data) -&gt; {
                    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#28210;&#26579;&#22270;&#29255;  </span>
                    renderImage(data);
                });
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Re-assert the thread&#8217;s interrupted status</span>
            Thread.currentThread().interrupt();
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">We don&#8217;t need the result, so cancel the task too</span>
            future.cancel(<span style="color: #7fffd4;">true</span>);
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">ExecutionException</span> <span style="color: #eedd82;">e</span>) {
            <span style="color: #00ffff;">throw</span> launderThrowable(e.getCause());
        }
    }
}
</pre>
</div>

<p>
下载图片任务比渲染文本任务慢的多，可以把下载图片拆分成多个任务
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">CompletionService</h3>
<div class="outline-text-3" id="text-3-2">
<p>
CompletionService把Executor和BlockingQueue融合在一起 <br  />
将Callable任务提交给CompletionService执行，然后使用类似队列操作的take和poll方法来获得已知的结果，这些结果会在全部结束时候封装为Future <br  />
</p>

<p>
ExecutorCompletionService实现了CompletionService <br  />
ExecutorCompletionService的构造函数中创建一个BlockingQueue来保存计算完成的结果。当计算完成时候，调用FutureTask的done方法。当提交某个任务的时候，该任务将包装成为QueueingFuture, 这是FutureTask的一个子类，然后改写子类的done方法，将结果放入BlockingQueue中。take和poll方法委托给BlockingQueue, 这些方法在得出结果前会阻塞
</p>
<div class="org-src-container">

<pre class="src src-java">  <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ExecutorCompletionService</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">CompletionService</span>&lt;<span style="color: #98fb98;">V</span>&gt; {
...
      <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">V</span>&gt;&gt; completionQueue;

      <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">ExecutorCompletionService</span>(<span style="color: #98fb98;">Executor</span> <span style="color: #eedd82;">executor</span>) {
...
          <span style="color: #00ffff;">this</span>.completionQueue = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LinkedBlockingQueue</span>&lt;<span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">V</span>&gt;&gt;();
      }

      <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #87cefa;">submit</span>(<span style="color: #98fb98;">Callable</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #eedd82;">task</span>) {  
          <span style="color: #00ffff;">if</span> (task == <span style="color: #7fffd4;">null</span>) <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">NullPointerException</span>();  
          <span style="color: #98fb98;">RunnableFuture</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #eedd82;">f</span> = newTaskFor(task);  
          <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23558;&#20219;&#21153;&#21253;&#35013;&#25104;QueueingFuture&#23545;&#35937;&#21518;&#22996;&#25176;&#32473;executor&#25191;&#34892;  </span>
          executor.execute(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">QueueingFuture</span>(f));  
          <span style="color: #00ffff;">return</span> f;  
      }

      <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">QueueingFuture</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">FutureTask</span>&lt;<span style="color: #98fb98;">V</span>&gt; {
          <span style="color: #87cefa;">QueueingFuture</span>(<span style="color: #98fb98;">Callable</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #eedd82;">c</span>) { <span style="color: #00ffff;">super</span>(c); }
          <span style="color: #87cefa;">QueueingFuture</span>(<span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">t</span>, <span style="color: #98fb98;">V</span> <span style="color: #eedd82;">r</span>) { <span style="color: #00ffff;">super</span>(t, r); }
          <span style="color: #00ffff;">protected</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">done</span>() {
              completionQueue.add(<span style="color: #00ffff;">this</span>);
          }
      }

      <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #87cefa;">take</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {  
          <span style="color: #00ffff;">return</span> completionQueue.take();  
      }  

      <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">V</span>&gt; <span style="color: #87cefa;">poll</span>() {  
          <span style="color: #00ffff;">return</span> completionQueue.poll();  
      }
      ...
  }
</pre>
</div>

<p>
使用CompletionService渲染
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CompletionRenderer</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Render</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ExecutorService</span> <span style="color: #eedd82;">executor</span> = Executors.newCachedThreadPool();

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">renderPage</span>(<span style="color: #98fb98;">CharSequence</span> <span style="color: #eedd82;">source</span>) {
        <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">ImageInfo</span>&gt; <span style="color: #eedd82;">info</span> = scanForImageInfo(source);
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23558;&#22270;&#29255;&#19979;&#36733;&#25286;&#20998;&#20026;&#22810;&#20010;&#20219;&#21153;  </span>
        <span style="color: #98fb98;">CompletionService</span>&lt;<span style="color: #98fb98;">ImageData</span>&gt; <span style="color: #eedd82;">completionService</span>
            = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ExecutorCompletionService</span>&lt;&gt;(executor);
        info.forEach((imageInfo) -&gt; {
                completionService.submit(() -&gt; imageInfo.downloadImage());
            });
        renderText(source);
        <span style="color: #00ffff;">try</span> {
            <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span> = 0, <span style="color: #eedd82;">n</span> = info.size(); t &lt; <span style="color: #98fb98;">n</span>; t++) {
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">take&#26041;&#27861;&#21487;&#33021;&#38459;&#22622;: &#24403;&#24050;&#23436;&#25104;&#38431;&#21015;&#20013;&#20026;&#31354;&#26102;  </span>
                <span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">ImageData</span>&gt; <span style="color: #eedd82;">f</span> = completionService.take();
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">get&#26041;&#27861;&#19981;&#20250;&#38459;&#22622;, &#22240;&#20026;&#20174;take&#26041;&#27861;&#36820;&#22238;&#30340;Future&#23545;&#35937;&#32943;&#23450;&#26159;&#24050;&#23436;&#25104;&#30340;  </span>
                <span style="color: #98fb98;">ImageData</span> <span style="color: #eedd82;">imageData</span> = f.get();
                renderImage(imageData);
            }
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
            Thread.currentThread().interrupt();
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">ExecutionException</span> <span style="color: #eedd82;">e</span>) {
            <span style="color: #00ffff;">throw</span> launderThrowable(e.getCause());
        }
    }
}
</pre>
</div>

<p>
<a href="cancellation.html">Next:任务取消</a>　<a href="build_blocks.html">Previous:基础模块</a>　<a href="jcip.html">Up:目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: klose</p>
<p class="date">Created: 2016-11-13 Sun 23:54</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
