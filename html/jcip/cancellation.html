<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>取消和关闭</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="executor.html"> UP </a>
 |
 <a accesskey="H" href="jcip.html"> HOME </a>
</div><div id="content">
<h1 class="title">取消和关闭</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">任务取消</a>
<ul>
<li><a href="#sec-1-1">设置自定义flag结束线程</a>
<ul>
<li><a href="#sec-1-1-1">自定义flag的问题</a></li>
</ul>
</li>
<li><a href="#sec-1-2">中断</a>
<ul>
<li><a href="#sec-1-2-1">可中断的阻塞方法</a></li>
<li><a href="#sec-1-2-2">不可中断的阻塞方法</a></li>
</ul>
</li>
<li><a href="#sec-1-3">处理InterruptedException</a>
<ul>
<li><a href="#sec-1-3-1">不catch直接向上层抛出，或者catch住做一些清理工作之后重抛该异常</a></li>
<li><a href="#sec-1-3-2">不能向上抛出InterruptedException异常</a></li>
<li><a href="#sec-1-3-3">发生了InterruptedException异常后仍然继续循环执行某阻塞方法</a></li>
<li><a href="#sec-1-3-4">忽略InterruptedException</a></li>
</ul>
</li>
<li><a href="#sec-1-4">限时运行</a></li>
<li><a href="#sec-1-5">取消Future</a>
<ul>
<li><a href="#sec-1-5-1">取消Future的方法</a></li>
<li><a href="#sec-1-5-2">客户化取消Future</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">取消线程</a>
<ul>
<li><a href="#sec-2-1">基于生产消费者模型的LoggerWriter</a></li>
<li><a href="#sec-2-2">中断线程的问题</a></li>
<li><a href="#sec-2-3">使用ExecutorService简化</a>
<ul>
<li><a href="#sec-2-3-1">shutdownNow的局限性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">异常退出</a>
<ul>
<li><a href="#sec-3-1">未捕获异常处理器</a></li>
</ul>
</li>
<li><a href="#sec-4">关闭JVM</a>
<ul>
<li><a href="#sec-4-1">正常关闭　</a>
<ul>
<li><a href="#sec-4-1-1">关闭钩子</a></li>
<li><a href="#sec-4-1-2">守护线程</a></li>
</ul>
</li>
<li><a href="#sec-4-2">强行关闭</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">任务取消</h2>
<div class="outline-text-2" id="text-1">
<p>
启动任务之后, 大多数时候我们等待运行完成，但是有时我们希望可以提前终止任务的运行:
</p>
<ol class="org-ol">
<li>用户申请取消时，比如用户点击了取消按钮.
</li>
<li>时间限制的任务，有些任务具有时间限制, 如果在一定的时间内仍然没有得到想要的结果, 可能希望终止该任务的运行.
</li>
<li>发生特定的事件时，比如多个任务同时在不同的位置搜索某一文件, 当其中一个搜索到了想要的文件, 应该终止其他仍在运行的任务
</li>
<li>发生错误时，比如发生了磁盘已满的错误, 需要向磁盘写入数据的任务应该提前终止
</li>
<li>应用或者服务被关闭时
</li>
</ol>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">设置自定义flag结束线程</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PrimeGenerator</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Runnable</span> {
    <span style="color: #7fffd4;">@GuardedBy</span>(<span style="color: #ffa07a;">"this"</span>)
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #eedd82;">primes</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ArrayList</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt;();

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#33258;&#23450;&#20041;&#30340;flag, &#20026;&#20445;&#35777;&#32447;&#31243;&#21487;&#35265;&#24615;, &#23558;&#20854;&#22768;&#26126;&#20026;volatile </span>
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">cancelled</span>;

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
        <span style="color: #98fb98;">BigInteger</span> <span style="color: #eedd82;">p</span> = <span style="color: #7fffd4;">BigInteger</span>.ONE;
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#27599;&#27425;&#24490;&#29615;&#20043;&#21069;&#26816;&#26597;cancelled&#26631;&#35760;&#30340;&#20540;, &#22914;&#26524;cancelled&#20026;true, &#24490;&#29615;&#32456;&#27490;, &#32447;&#31243;&#20063;&#23601;&#36816;&#34892;&#32467;&#26463;&#20102; </span>
        <span style="color: #00ffff;">while</span> (!cancelled) {
            p = p.nextProbablePrime();
            <span style="color: #00ffff;">synchronized</span> (<span style="color: #00ffff;">this</span>) {
                primes.add(p);
            }
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cancel</span>() {
        cancelled = <span style="color: #7fffd4;">true</span>;
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">synchronized</span> <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #87cefa;">get</span>() {
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ArrayList</span>&lt;&gt;(primes);
    }
}
</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
    <span style="color: #98fb98;">PrimeGenerator</span> <span style="color: #eedd82;">generator</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">PrimeGenerator</span>();
    <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">t</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(generator);
    t.start();

    <span style="color: #00ffff;">try</span> {
        Thread.sleep(1000);
    } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#38500;&#38750;&#26126;&#30830;&#30693;&#36947;&#20027;&#32447;&#31243;&#24212;&#35813;&#32456;&#27490;&#65292;&#19981;&#28982;&#36890;&#24120;&#24773;&#20917;&#19979;&#24212;&#35813;&#37325;&#26032;&#25243;&#20986;InterruptedException&#25110;&#32773;&#24674;&#22797;&#34987;&#20013;&#26029;&#30340;&#32447;&#31243;</span>
    }
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#36890;&#36807;&#35843;&#29992;cancel&#26041;&#27861;, &#23558;&#33258;&#23450;&#20041;&#30340;cancelled&#26631;&#35760;&#35774;&#32622;&#20026;true, &#20174;&#32780;&#20351;&#24471;&#32447;&#31243;t&#36816;&#34892;&#32456;&#27490;  </span>
    generator.cancel();
    System.out.println(generator.get().size());
}
</pre>
</div>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">自定义flag的问题</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
假如循环中执行了阻塞操作, 那么即使cancelled标记被设置为true, run方法却没有机会去检查cancelled标记的值, 线程将迟迟无法结束！　
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">BrokenPrimeProducer</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Thread</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #eedd82;">queue</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">cancelled</span> = <span style="color: #7fffd4;">false</span>;
    <span style="color: #87cefa;">BrokenPrimeProducer</span>(<span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #eedd82;">queue</span>) {
        <span style="color: #00ffff;">this</span>.queue = queue;
    }
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #98fb98;">BigInteger</span> <span style="color: #eedd82;">p</span> = <span style="color: #7fffd4;">BigInteger</span>.ONE;
            <span style="color: #00ffff;">while</span> (!cancelled)
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24403;&#38431;&#21015;&#24050;&#28385;&#26102;, put&#26041;&#27861;&#23558;&#20250;&#38459;&#22622;. &#19968;&#26086;put&#26041;&#27861;&#38459;&#22622;</span>
                <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#19988;&#27809;&#26377;&#20854;&#20182;&#32447;&#31243;&#20174;&#38431;&#21015;&#20013;&#21462;&#25968;&#25454;&#26102;, &#38459;&#22622;&#23558;&#19968;&#30452;&#25345;&#32493;&#19979;&#21435;  </span>
                queue.put(p = p.nextProbablePrime());
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">consumed</span>) { }
    }
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cancel</span>() { cancelled = <span style="color: #7fffd4;">true</span>; }
}
</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {  
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#35774;&#32622;&#38431;&#21015;&#30340;&#26368;&#22823;&#23481;&#37327;&#20026;10  </span>
    <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #eedd82;">primes</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LinkedBlockingQueue</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt;(10);  
    <span style="color: #98fb98;">BrokenPrimeProducer</span> <span style="color: #eedd82;">producer</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">BrokenPrimeProducer</span>(primes);  
    producer.start();  

    <span style="color: #00ffff;">try</span> {  
        Thread.sleep(1000);  
    } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
    }  
    producer.cancel();  
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">中断</h3>
<div class="outline-text-3" id="text-1-2">
<p>
java没有直接规定如何安全的提前终止线程的运行, 而是提供了不具约束力的协商式机制: 线程A可以请求线程B中断, 但是是否响应, 何时响应, 如何响应中断请求, 由线程B自己决定。每个线程对象都有一个boolean型的中断标记, 其他线程请求目标线程中断时, 会将目标线程的中断标记设置为true, 然后由目标线程自己决定如何处理。所以中断线程时, 需要明确知道目标线程的中断机制, 如果不知道目标线程会怎样处理中断请求, 不要贸然请求其中断
</p>

<p>
Thread类中与中断标记相关的方法有:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Thread</span> {   
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#35831;&#27714;&#32447;&#31243;&#20013;&#26029;, &#35813;&#26041;&#27861;&#20250;&#23558;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#35774;&#32622;&#20026;true. &#22914;&#20309;&#22788;&#29702;&#20013;&#26029;&#30001;&#30446;&#26631;&#32447;&#31243;&#20915;&#23450;  </span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">interrupt</span>() { ... }   
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#36820;&#22238;&#20013;&#26029;&#26631;&#35760;&#30340;&#20540;  </span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">isInterrupted</span>() { ... }  
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38745;&#24577;&#26041;&#27861;&#29992;&#20110;&#37325;&#32622;&#24403;&#21069;&#36827;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;(&#23558;&#20854;&#35774;&#32622;&#20026;false), &#24182;&#36820;&#22238;&#37325;&#32622;&#20043;&#21069;&#30340;&#20540;  </span>
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">interrupted</span>() { ... }   
    ...   
}
</pre>
</div>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">可中断的阻塞方法</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
java API中的大多数阻塞方法都是可中断的, 如Thread.sleep, Object.wait, BlockingQueue.put等 
</p>

<p>
可中断的阻塞方法有一个共同的特点: 声明抛出InterruptedException异常 
</p>

<p>
可中断的阻塞方法在阻塞期间会周期性检查当前线程的中断标记, 如果发现当前线程的中断标记为true, 就重置中断标记后提前从阻塞状态返回, 并抛出InterruptedException异常  
</p>

<p>
使用中断终止PrimeProducer    
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">class</span> <span style="color: #98fb98;">PrimeProducer</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Thread</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #eedd82;">queue</span>;

    <span style="color: #87cefa;">PrimeProducer</span>(<span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #eedd82;">queue</span>) {
        <span style="color: #00ffff;">this</span>.queue = queue;
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #98fb98;">BigInteger</span> <span style="color: #eedd82;">p</span> = <span style="color: #7fffd4;">BigInteger</span>.ONE;
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#27599;&#27425;&#24490;&#29615;&#21069;&#26816;&#26597;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;, &#22914;&#26524;&#20013;&#26029;&#26631;&#35760;&#20026;&#35774;&#23450;&#20026;true, &#21017;&#24490;&#29615;&#32467;&#26463;  </span>
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23601;&#31639;&#24403;&#21069;&#32447;&#31243;&#38459;&#22622;&#22312;put&#26041;&#27861;&#19978;, &#22312;&#38459;&#22622;&#26399;&#38388;&#20063;&#20250;&#21608;&#26399;&#24615;&#26816;&#26597;&#20013;&#26029;&#26631;&#35760;, </span>
            <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#19968;&#26086;&#21457;&#29616;&#20013;&#26029;&#26631;&#35760;&#20026;true, &#23601;&#20250;&#20174;&#38459;&#22622;&#29366;&#24577;&#20013;&#36820;&#22238;, &#24182;&#25243;&#20986;InterruptedException&#24322;&#24120;  </span>
            <span style="color: #00ffff;">while</span> (!Thread.currentThread().isInterrupted()) {
                queue.put(p = p.nextProbablePrime());
            }
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">consumed</span>) {
            System.out.println(<span style="color: #ffa07a;">"InterruptedException happened"</span>);
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cancel</span>() {
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">interrupt&#26041;&#27861;&#20250;&#23558;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#35774;&#32622;&#20026;true  </span>
        interrupt();
    }
}
</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#35774;&#32622;&#38431;&#21015;&#30340;&#26368;&#22823;&#23481;&#37327;&#20026;10  </span>
    <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">BigInteger</span>&gt; <span style="color: #eedd82;">primes</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LinkedBlockingQueue</span>&lt;&gt;(10);
    <span style="color: #98fb98;">PrimeProducer</span> <span style="color: #eedd82;">producer</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">PrimeProducer</span>(primes);
    producer.start();

    <span style="color: #00ffff;">try</span> {
        Thread.sleep(1000);
    } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
    }
    <span style="color: #ff4500;">//</span>
    producer.cancel();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">不可中断的阻塞方法</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
有些方法阻塞的时候不会检查中断标记　
</p>
<ol class="org-ol">
<li>同步socket I/O:　基于InputStream的读写方法不会响应中断，关闭socket可以使阻塞方法退出
</li>
<li>同步nio: 关闭InterruptibleChannel可以扔出AsynchronousCloseException
</li>
<li>异步Selector：关闭selector　
</li>
<li>内置锁：等待获得内置锁不会响应中断，使用新的Lock对象替代内置锁
</li>
</ol>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ReaderThread</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Thread</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">socket</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">InputStream</span> <span style="color: #eedd82;">in</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">BUFSZ</span> = 8192;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">ReaderThread</span>(<span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">socket</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">IOException</span> {
        <span style="color: #00ffff;">this</span>.socket = socket;
        <span style="color: #00ffff;">this</span>.in = socket.getInputStream();
    }


    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">interrupt</span>() {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#26524;&#21457;&#29983;&#20013;&#26029;&#26102;, &#32447;&#31243;&#38459;&#22622;&#22312;read&#26041;&#27861;&#19978;, socket&#30340;&#20851;&#38381;&#20250;&#23548;&#33268;read&#26041;&#27861;&#25243;&#20986;SocketException&#65292;&#28982;&#21518;run&#26041;&#27861;&#36816;&#34892;&#23436;&#27605; </span>
            socket.close();
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">IOException</span> <span style="color: #eedd82;">ignored</span>) {
        } <span style="color: #00ffff;">finally</span> {
            <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;&#38459;&#22622;&#22312;&#19968;&#20010;&#21487;&#21709;&#24212;&#38459;&#22622;&#30340;&#26041;&#27861;&#65292;&#32487;&#32493;&#20256;&#36882;&#19968;&#20010;&#20013;&#26029;</span>
            <span style="color: #00ffff;">super</span>.interrupt();
        }
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">buf</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[BUFSZ];
            <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = in.read(buf);
                <span style="color: #00ffff;">if</span> (count &lt; 0) {
                    <span style="color: #00ffff;">break</span>;
                } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (count &gt; 0) {
                    processBuffer(buf, count);
                }
            }
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">IOException</span> <span style="color: #eedd82;">e</span>) {
            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Allow thread to exit */</span> 
        }
    }

    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">processBuffer</span>(<span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>) {
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">do something ...</span>
    }
}
</pre>
</div>
<p>
覆写Thread的interrupt方法，如果阻塞在不可响应中断的read方法，则关闭socket退出read方法，反之则继续传递一个中断
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">处理InterruptedException</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">不catch直接向上层抛出，或者catch住做一些清理工作之后重抛该异常</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
这样的处理使得你的方法也成为一个可中断的阻塞方法 
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#30452;&#25509;&#21521;&#19978;&#23618;&#25243;&#20986;InterruptedException, dosomething&#26041;&#27861;&#20063;&#26159;&#19968;&#20010;&#21487;&#20013;&#26029;&#30340;&#38459;&#22622;&#26041;&#27861;  </span>
<span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dosomething</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {  
    Thread.sleep(1000);  
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">不能向上抛出InterruptedException异常</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
catch之后, 必须设置当前线程的中断标记为true, 以表明当前线程发生了中断, 以便调用栈上层进行处理
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">InterruptedExceptionHandler</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Runnable</span> {  
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">lock</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Object</span>();  

    <span style="color: #7fffd4;">@Override</span>  
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
        <span style="color: #00ffff;">while</span> (!Thread.currentThread().isInterrupted()) {  
            dosomething();  
        }  
    }  

    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dosomething</span>() {  
        <span style="color: #00ffff;">try</span> {  
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Object.wait&#26159;&#19968;&#20010;&#21487;&#20013;&#26029;&#30340;&#38459;&#22622;&#26041;&#27861;</span>
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#26524;&#22312;&#20854;&#38459;&#22622;&#26399;&#38388;&#26816;&#26597;&#21040;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#20026;true, &#20250;&#37325;&#32622;&#20013;&#26029;&#26631;&#35760;&#21518;&#20174;&#38459;&#22622;&#29366;&#24577;&#36820;&#22238;, &#24182;&#25243;&#20986;InterruptedException&#24322;&#24120;  </span>
            <span style="color: #00ffff;">synchronized</span> (lock) {  
                lock.wait();  <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20250;&#37325;&#32622;&#20013;&#26029;&#26631;&#35760;&#21518;&#20174;&#38459;&#22622;&#29366;&#24577;&#36820;&#22238;, &#24182;&#25243;&#20986;InterruptedException&#24322;&#24120; </span>
            }  
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {  
            System.out.println(<span style="color: #ffa07a;">"InterruptedException happened"</span>);  
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">catch&#20303;InterruptedException&#21518;&#35774;&#32622;&#24403;&#21069;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#20026;true, &#20197;&#20379;&#35843;&#29992;&#26632;&#19978;&#23618;&#36827;&#34892;&#30456;&#24212;&#30340;&#22788;&#29702;  </span>
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22312;&#27492;&#20363;&#20013;, dosomething&#26041;&#27861;&#30340;&#35843;&#29992;&#26632;&#19978;&#23618;&#26159;run&#26041;&#27861;.  </span>
            Thread.currentThread().interrupt();  
        }  
    }  

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {  
        <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">t</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">InterruptedExceptionHandler</span>());  
        t.start();  
        Thread.sleep(1000);
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21551;&#21160;&#32447;&#31243;1s&#21518;&#35774;&#32622;&#20854;&#20013;&#26029;&#26631;&#35760;&#20026;true</span>
        t.interrupt();  
    }  
}
</pre>
</div>
<p>
主线程启动InterruptedExceptionHandler线程1s后, 设置InterruptedExceptionHandler线程的中断标记为true. 此时InterruptedExceptionHandler线程应该阻塞在wait方法上, 由于wait方法是可中断的阻塞方法, 所以其检查到中断标记为true时, 将重置当前线程的中断标记后抛出InterruptedException, dosomething方法catch住InterruptedException异常后, 再次将当前线程的中断标记设置为true, run方法检查到中断标记为true, 循环不再继续 
</p>

<p>
假如dosomething方法catch住InterruptedException异常后没有设置中断标记, 其调用栈上层的run方法就无法得知线程曾经发生过中断, 循环也就无法终止
</p>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">发生了InterruptedException异常后仍然继续循环执行某阻塞方法</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
将中断状态保存下来, 当循环完成后再根据保存下来的中断状态执行相应的操作
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">InterruptedExceptionContinueHandler</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Runnable</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">Integer</span>&gt; <span style="color: #eedd82;">queue</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">InterruptedExceptionContinueHandler</span>(<span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">Integer</span>&gt; <span style="color: #eedd82;">queue</span>) {
        <span style="color: #00ffff;">this</span>.queue = queue;
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
        <span style="color: #00ffff;">while</span> (!Thread.currentThread().isInterrupted()) {
            dosomething();
        }
        System.out.println(queue.size());
    }

    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dosomething</span>() {
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">cancelled&#21464;&#37327;&#29992;&#20110;&#34920;&#26126;&#32447;&#31243;&#26159;&#21542;&#21457;&#29983;&#36807;&#20013;&#26029;</span>
        <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">cancelled</span> = <span style="color: #7fffd4;">false</span>;
        <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10000; i++) {
            <span style="color: #00ffff;">try</span> {
                queue.put(i);
            } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23601;&#31639;&#21457;&#29983;&#20102;InterruptedException, &#24490;&#29615;&#20063;&#24076;&#26395;&#32487;&#32493;&#36816;&#34892;&#19979;&#21435;, &#27492;&#26102;&#23558;cancelled&#35774;&#32622;&#20026;true, &#20197;&#34920;&#26126;&#36941;&#21382;&#36807;&#31243;&#20013;&#21457;&#29983;&#20102;&#20013;&#26029;</span>
                System.out.println(<span style="color: #ffa07a;">"InterruptedException happened when i = "</span> + i);
                cancelled = <span style="color: #7fffd4;">true</span>;
            }
        }
        <span style="color: #00ffff;">if</span> (cancelled) {
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#26524;&#24403;&#21069;&#32447;&#31243;&#26366;&#32463;&#21457;&#29983;&#36807;&#20013;&#26029;, &#23601;&#23558;&#20854;&#20013;&#26029;&#26631;&#35760;&#35774;&#32622;&#20026;true, &#20197;&#36890;&#30693;dosomething&#26041;&#27861;&#30340;&#19978;&#23618;&#35843;&#29992;&#26632;</span>
            Thread.currentThread().interrupt();
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {
        <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">t</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">InterruptedExceptionContinueHandler</span>(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LinkedBlockingQueue</span>&lt;<span style="color: #98fb98;">Integer</span>&gt;()));
        t.start();

        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21551;&#21160;&#32447;&#31243;2ms&#21518;&#35774;&#32622;&#20854;&#20013;&#26029;&#26631;&#35760;&#20026;true</span>
        Thread.sleep(2);
        t.interrupt();
    }
}
</pre>
</div>
<p>
等待doSomething的循环执行完毕，恢复中断状态为true，再run中处理中断
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dosomething</span>() {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 10000; i++) {
        <span style="color: #00ffff;">try</span> {
            queue.put(i);
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
            System.out.println(<span style="color: #ffa07a;">"InterruptedException happened when i = "</span> + i);
            <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36807;&#26089;&#37325;&#32622;&#20013;&#26029;&#29366;&#24577;&#20026;true&#20250;&#23548;&#33268;put&#26041;&#27861;&#21448;&#25243;&#20986;InterruptedException&#24322;&#24120;, &#22914;&#27492;&#24448;&#22797;&#30452;&#21040;&#24490;&#29615;&#32467;&#26463;.</span>
            Thread.currentThread().interrupt();
        }
    }
}
</pre>
</div>
<p>
过早重置中断状态为true会导致put方法又抛出InterruptedException异常, 如此往复直到循环结束 
</p>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">忽略InterruptedException</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
只有当InterruptedException被捕获在调用栈的最上层, 如run方法, 或者main方法中, 且后续代码不检查中断状态时， 其他任何情况下都应该对InterruptedException作处理
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">限时运行</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ScheduledExecutorService</span> <span style="color: #eedd82;">cancelExec</span> = ...;
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">timedRun</span>(<span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">r</span>,
                <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>, <span style="color: #98fb98;">TimeUnit</span> <span style="color: #eedd82;">unit</span>) {
    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">taskThread</span> = Thread.currentThread();
    cancelExec.schedule(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Runnable</span>() {
            <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() { taskThread.interrupt(); }
        }, timeout, unit);
    r.run();
}
</pre>
</div>
<p>
timeRun方法可以在任何一个线程中调用，所以timeRun方法无法知道运行线程处理中断的策略，不应该贸然向对应的线程发出中断请求
</p>
<ul class="org-ul">
<li>在r.run运行完成后，调用线程捕获中断异常是危险的
</li>
<li>如果调用线程忽略了中断异常，那只有r.run运行完毕timeRun才能结束，这会超出所要求的运行时间
</li>
</ul>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ScheduledExecutorService</span> <span style="color: #eedd82;">cancelExec</span> = Executors.newSingleThreadScheduledExecutor();

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">timedRun</span>(<span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">r</span>,
                <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>, <span style="color: #98fb98;">TimeUnit</span> <span style="color: #eedd82;">unit</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {

    <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ReThrowableTask</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Runnable</span> {
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22312;&#24403;&#21069;&#32447;&#31243;&#21644;taskThread&#32447;&#31243;&#20849;&#20139;&#24322;&#24120;</span>
        <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">Throwable</span> <span style="color: #eedd82;">t</span>;

        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
            <span style="color: #00ffff;">try</span> {
                r.run();
            } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">Throwable</span> <span style="color: #eedd82;">t</span>) {
                <span style="color: #00ffff;">this</span>.t = t;
            }
        }

        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rethrow</span>() {
            <span style="color: #00ffff;">if</span> (t != <span style="color: #7fffd4;">null</span>)
                <span style="color: #00ffff;">throw</span> launderThrowable(t);
        }
    }

    <span style="color: #98fb98;">ReThrowableTask</span> <span style="color: #eedd82;">task</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ReThrowableTask</span>();
    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">taskThread</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>(task);
    taskThread.start();
    cancelExec.schedule(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Runnable</span>() {
            <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
                taskThread.interrupt();
            }
        }, timeout, unit);
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20572;&#27490;&#24403;&#21069;&#36827;&#31243;&#65292;&#35753;taskThread&#36816;&#34892;&#38480;&#26102;&#26102;&#38388;</span>
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#26524;&#36229;&#36807;&#38480;&#26102;&#65292;&#21017;&#35753;cancelExec&#32447;&#31243;&#27744;&#30340;&#32447;&#31243;&#23545;taskThread&#21457;&#36215;&#20013;&#26029;&#35831;&#27714;</span>
    taskThread.join(unit.toMillis(timeout));
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;taskThread&#32447;&#31243;&#20869;&#25429;&#33719;&#24322;&#24120;&#65292;&#37325;&#26032;&#25243;&#20986;</span>
    task.rethrow();
}
</pre>
</div>
<ol class="org-ol">
<li>创建taskThread线程，把运行任务包装到taskThread
</li>
<li>通过join方法让taskThread跑限时时间
</li>
<li>超过限时时间，向taskThread发送中断请求
</li>
<li>在taskThread中发现异常，则重新抛出供主线程处理
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">取消Future</h3>
<div class="outline-text-3" id="text-1-5">
<p>
将task提交给线程池运行, 由于不知道task会由线程池中的哪一个线程运行, 也不知道线程池中的线程会怎样处理中断, 所以无法直接调用Thread对象的interrupt方法提前终止线程的运行. 但是ExecutorService类的submit等方法会返回表示task未决结果的Future对象, 调用Future对象的cancel方法, 可以取消task的运行
</p>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">取消Future的方法</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#23581;&#35797;&#21462;&#28040;task&#30340;&#25191;&#34892;</span>
<span style="color: #ffa07a;"> * &#22914;&#26524;task&#24050;&#32463;&#23436;&#25104;, &#25110;&#24050;&#21462;&#28040;, &#25110;&#30001;&#20110;&#26576;&#20123;&#21407;&#22240;&#26080;&#27861;&#21462;&#28040;, &#21017;&#23581;&#35797;&#22833;&#36133;, &#36820;&#22238;false </span>
<span style="color: #ffa07a;"> * &#22914;&#26524;task&#23578;&#26410;&#21551;&#21160;, &#21017;&#25104;&#21151;&#35843;&#29992;&#20854;Future&#23545;&#35937;&#30340;cancel&#26041;&#27861;&#23558;&#23548;&#33268;&#20854;&#27704;&#19981;&#21551;&#21160; </span>
<span style="color: #ffa07a;"> * mayInterruptIfRunning&#22914;&#26524;&#20026;true, &#19988;&#27492;&#26102;task&#27491;&#22312;&#26576;&#20010;&#32447;&#31243;&#20013;&#36816;&#34892;, &#37027;&#20040;&#35813;&#32447;&#31243;&#30340;&#20013;&#26029;&#26631;&#35760;&#23558;&#34987;&#35774;&#32622;&#20026;true </span>
<span style="color: #ffa07a;"> * &#24403;mayInterruptIfRunning&#20026;false&#26102;, &#22914;&#26524;task&#27809;&#26377;&#21551;&#21160;&#21017;&#19981;&#20877;&#21551;&#21160;, &#22914;&#26524;task&#24050;&#32463;&#21551;&#21160;, &#21017;&#23581;&#35797;&#22833;&#36133; </span>
<span style="color: #ffa07a;"> * &#22914;&#26524;task&#27809;&#26377;&#22788;&#29702;&#20013;&#26029;, mayInterruptIfRunning&#24212;&#35813;&#20026;false</span>
<span style="color: #ffa07a;"> * cancel&#26041;&#27861;&#36820;&#22238;&#21518;, isDone&#26041;&#27861;&#23558;&#22987;&#32456;&#36820;&#22238;true, &#22914;&#26524;cancel&#36820;&#22238;true, &#23545;isCancelled&#26041;&#27861;&#30340;&#21518;&#32493;&#35843;&#29992;&#23558;&#22987;&#32456;&#36820;&#22238;true</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">cancel</span>(<span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">mayInterruptIfRunning</span>)
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#22914;&#26524;task&#27491;&#24120;&#23436;&#25104;&#21069;&#34987;&#21462;&#28040;, &#35813;&#26041;&#27861;&#36820;&#22238;true.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">boolean</span> isCancelled();

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#22914;&#26524;task&#24050;&#32463;&#23436;&#25104;, &#35813;&#26041;&#27861;&#36820;&#22238;true. &#23436;&#25104;&#30340;&#24773;&#20917;&#21253;&#25324;&#27491;&#24120;&#23436;&#25104;, task&#34987;&#21462;&#28040;, &#24322;&#24120;&#32456;&#27490;&#31561;</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">isDone</span>();
</pre>
</div>
<p>
如果不知道线程会怎样处理中断, 就不应该调用该线程的interrupt方法, 那么调用Future的cancel方法, 并将mayInterruptIfRunning参数设置为true是否合适? 线程池中用于执行task的线程会将中断的处理委托给task, 所以这样做是合适的(前提是task正确处理了中断)
</p>

<p>
通过取消Future实现timeRun
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">timedRun</span>(<span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">r</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>, <span style="color: #98fb98;">TimeUnit</span> <span style="color: #eedd82;">unit</span>) 
    <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {
    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ExecutorService</span> <span style="color: #eedd82;">taskExec</span> = Executors.newCachedThreadPool();
    <span style="color: #98fb98;">Future</span>&lt;?&gt; <span style="color: #eedd82;">task</span> = taskExec.submit(r);
    <span style="color: #00ffff;">try</span> {
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;&#32447;&#31243;&#27744;&#20013;&#30340;&#32447;&#31243;&#25191;&#34892;&#20219;&#21153;&#36807;&#31243;&#20013;&#35813;&#32447;&#31243;&#21457;&#29983;&#20102;&#20013;&#26029;, &#37027;&#20040;&#35843;&#29992;task&#30340;get&#26041;&#27861;&#23558;&#20250;&#25243;&#20986;InterruptedException&#24322;</span>
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23545;&#20110;InterruptedException, &#25353;&#29031;&#20043;&#21069;&#24635;&#32467;&#30340;&#26041;&#27861;&#22788;&#29702;&#21363;&#21487;. &#27492;&#20363;&#23558;&#20854;&#25243;&#32473;&#19978;&#23618;</span>
        task.get(timeout, unit);
    } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">TimeoutException</span> <span style="color: #eedd82;">e</span>) {
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#26524;&#21457;&#29983;TimeoutException&#24322;&#24120;, &#34920;&#26126;&#25191;&#34892;&#26102;&#38388;&#36229;&#26102;, &#27492;&#26102;&#21462;&#28040;&#35813;&#20219;&#21153;&#21363;&#21487;</span>
    } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">ExecutionException</span> <span style="color: #eedd82;">e</span>) {
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21457;&#29983;&#20854;&#20182;&#24322;&#24120;&#26102;, &#19981;&#20165;&#35201;&#21462;&#28040;&#20219;&#21153;&#30340;&#25191;&#34892;, &#20063;&#24212;&#35813;&#37325;&#25243;&#35813;&#24322;&#24120;</span>
        <span style="color: #00ffff;">throw</span> launderThrowable(e.getCause());
    } <span style="color: #00ffff;">finally</span> {
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">Harmless if task already completed</span>
        task.cancel(<span style="color: #7fffd4;">true</span>); <span style="color: #ff4500;">// </span><span style="color: #ff4500;">interrupt if running</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">客户化取消Future</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
有时候需要覆写Future.cancel方法, 比如对于不可响应中断的阻塞方法需要在其中加入诸如关闭socket的操作等
</p>

<p>
定义CacellableTask接口
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">CancellableTask</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Callable</span>&lt;<span style="color: #98fb98;">T</span>&gt; {
    <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cancel</span>();
    <span style="color: #98fb98;">RunnableFuture</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #87cefa;">newTask</span>();
}
</pre>
</div>

<p>
实现CancellableTask接口 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">SocketUsingTask</span>&lt;<span style="color: #98fb98;">T</span>&gt;
    <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">CancellableTask</span>&lt;<span style="color: #98fb98;">T</span>&gt; {
    <span style="color: #7fffd4;">@GuardedBy</span>(<span style="color: #ffa07a;">"this"</span>)
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">socket</span>;

    <span style="color: #00ffff;">protected</span> <span style="color: #00ffff;">synchronized</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">setSocket</span>(<span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">s</span>) {
        socket = s;
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">synchronized</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cancel</span>() {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #00ffff;">if</span> (socket != <span style="color: #7fffd4;">null</span>) {
                socket.close();
            }
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">IOException</span> <span style="color: #eedd82;">ignored</span>) {
        }
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">RunnableFuture</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #87cefa;">newTask</span>() {
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">FutureTask</span>&lt;<span style="color: #98fb98;">T</span>&gt;(<span style="color: #00ffff;">this</span>) {
            <span style="color: #7fffd4;">@Override</span>
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23450;&#20041;FutureTask&#30340;&#21311;&#21517;&#20869;&#37096;&#31867;, &#24182;&#35206;&#30422;cancel&#26041;&#27861;, &#21521;&#20854;&#20013;&#21152;&#20837;&#20851;&#38381;socket&#30340;&#25805;&#20316;  </span>
            <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">boolean</span> <span style="color: #87cefa;">cancel</span>(<span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">mayInterruptIfRunning</span>) {
                <span style="color: #00ffff;">try</span> {
                    SocketUsingTask.<span style="color: #00ffff;">this</span>.cancel();
                } <span style="color: #00ffff;">finally</span> {
                    <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">super</span>.cancel(mayInterruptIfRunning);
                }
            }
        };
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">T</span> <span style="color: #87cefa;">call</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span> {
        ...
    }
}
</pre>
</div>

<p>
继承ThreadPoolExecutor类并覆盖newTaskFor方法, 返回回自定义的CancelTask对象 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #7fffd4;">@ThreadSafe</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CancellingExecutor</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">ThreadPoolExecutor</span> {

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">CancellingExecutor</span>() {
        <span style="color: #00ffff;">super</span>(10, 10,
              0L, <span style="color: #7fffd4;">TimeUnit</span>.MILLISECONDS,
              <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LinkedBlockingQueue</span>&lt;<span style="color: #98fb98;">Runnable</span>&gt;());
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">protected</span> &lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #98fb98;">RunnableFuture</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #87cefa;">newTaskFor</span>(<span style="color: #98fb98;">Callable</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #eedd82;">callable</span>) {
        <span style="color: #00ffff;">if</span> (callable <span style="color: #00ffff;">instanceof</span> CancellableTask) {
            <span style="color: #00ffff;">return</span> ((<span style="color: #98fb98;">CancellableTask</span>&lt;<span style="color: #98fb98;">T</span>&gt;) callable).newTask();
        } <span style="color: #00ffff;">else</span> {
            <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">super</span>.newTaskFor(callable);
        }
    }
}
</pre>
</div>

<p>
测试代码
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">CancellingExecutorTest</span> {
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">IOException</span> {
        <span style="color: #98fb98;">CancellingExecutor</span> <span style="color: #eedd82;">executor</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">CancellingExecutor</span>();
        <span style="color: #98fb98;">SocketUsingTask</span>&lt;<span style="color: #98fb98;">String</span>&gt; <span style="color: #eedd82;">task</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">SocketUsingTask</span>&lt;&gt;();
        task.setSocket(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Socket</span>(<span style="color: #ffa07a;">"www.baidu.com"</span>, 80));
        <span style="color: #98fb98;">Future</span>&lt;<span style="color: #98fb98;">String</span>&gt; <span style="color: #eedd82;">future</span> = executor.submit(task);
        <span style="color: #00ffff;">try</span> {
            future.get(1000L, <span style="color: #7fffd4;">TimeUnit</span>.MILLISECONDS);
        } <span style="color: #00ffff;">catch</span> (TimeoutException | InterruptedException ex) {
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">ExecutionException</span> <span style="color: #eedd82;">ex</span>) {
            <span style="color: #00ffff;">throw</span> launderThrowable(ex.getCause());
        } <span style="color: #00ffff;">finally</span> {
            future.cancel(<span style="color: #7fffd4;">true</span>); <span style="color: #ff4500;">// </span><span style="color: #ff4500;">interrupt if running</span>
            executor.shutdown();
        }
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">取消线程</h2>
<div class="outline-text-2" id="text-2">
<p>
如果一个线程在创建他的方法结束之后依然运行，那就必须为这个线程提供诸如取消，关闭等生命周期方法, 比如ExecutorService为例提供了shutDown和shutDownNow方法关闭Service, 而Service负责停止其拥有的线程
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">基于生产消费者模型的LoggerWriter</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LogWriter</span> {  
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">String</span>&gt; <span style="color: #eedd82;">queue</span>;  
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">LoggerThread</span> <span style="color: #eedd82;">logger</span>;  

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">LogWriter</span>(<span style="color: #98fb98;">Writer</span> <span style="color: #eedd82;">writer</span>) {  
        <span style="color: #00ffff;">this</span>.queue = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LinkedBlockingQueue</span>&lt;<span style="color: #98fb98;">String</span>&gt;(CAPACITY);  
        <span style="color: #00ffff;">this</span>.logger = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LoggerThread</span>(writer);  
    }  

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">start</span>() {  
        logger.start();  
    }  

    <span style="color: #ffa07a;">/** </span>
<span style="color: #ffa07a;">     * &#38656;&#35201;&#25171;&#21360;&#25968;&#25454;&#30340;&#32447;&#31243;&#35843;&#29992;&#35813;&#26041;&#27861;, &#23558;&#24453;&#25171;&#21360;&#25968;&#25454;&#21152;&#20837;&#38459;&#22622;&#38431;&#21015; </span>
<span style="color: #ffa07a;">     */</span>  
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">log</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">msg</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {  
        queue.put(msg);  
    }  

    <span style="color: #ffa07a;">/** </span>
<span style="color: #ffa07a;">     * &#36127;&#36131;&#20174;&#38459;&#22622;&#38431;&#21015;&#20013;&#21462;&#20986;&#25968;&#25454;&#36755;&#20986;&#30340;&#32447;&#31243; </span>
<span style="color: #ffa07a;">     */</span>  
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LoggerThread</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Thread</span> {  
        <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">writer</span>;  
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">...  </span>
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {  
            <span style="color: #00ffff;">try</span> {  
                <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>)  
                    writer.println(queue.take());  
            } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">ignored</span>) {  
            } <span style="color: #00ffff;">finally</span> {  
                writer.close();  
            }  
        }  
    }  
}
</pre>
</div>

<p>
LogWriter内部封装有LoggerThread线程, 所以LogWriter是一个基于线程构建的Service. 需要在LogWriter中提供停止LoggerThread线程的方法. 在LogWriter中添加shutDown方法
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/** </span>
<span style="color: #ffa07a;"> * &#35813;&#26041;&#27861;&#29992;&#20110;&#20572;&#27490;LoggerThread&#32447;&#31243; </span>
<span style="color: #ffa07a;"> */</span>  
<span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">shutDown</span>() {  
    logger.interrupt();  
}
</pre>
</div>
<p>
当LogWriter.shutDown方法被调用时, LoggerThread线程的中断标记被设置为true, 之后LoggerThread线程执行queue.take()方法时会抛出InterruptedException异常, 从而使得LoggerThread线程结束
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">中断线程的问题</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>丢弃了队列中尚未来得及输出的数据
</li>
<li>更严重的是, 假如线程A对LogWriter.log方法的调用因为队列已满而阻塞, 此时停止LoggerThread线程将导致线程A永远阻塞在queue.put方法上　
</li>
</ol>

<p>
当停止LogService以后，设置状态不在接受新的任务，并处理完所有已经存在的数据, 这种处理方式会导致竞争条件，所以必须手动同步
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LogService</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">BlockingQueue</span>&lt;<span style="color: #98fb98;">String</span>&gt; <span style="color: #eedd82;">queue</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">LoggerThread</span> <span style="color: #eedd82;">loggerThread</span>;
    <span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">     * &#34920;&#31034;&#26159;&#21542;&#20851;&#38381;Service</span>
<span style="color: #ffa07a;">     */</span>
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">boolean</span> <span style="color: #eedd82;">isShutdown</span>;
    <span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">     * &#38431;&#21015;&#20013;&#24453;&#22788;&#29702;&#25968;&#25454;&#30340;&#25968;&#37327;</span>
<span style="color: #ffa07a;">     */</span>
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">reservations</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">LogService</span>(<span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">writer</span>) {
        <span style="color: #00ffff;">this</span>.queue = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LinkedBlockingQueue</span>&lt;&gt;(100);
        <span style="color: #00ffff;">this</span>.loggerThread = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">LoggerThread</span>(writer);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">start</span>() {
        loggerThread.start();
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">shutDown</span>() {
        <span style="color: #00ffff;">synchronized</span> (<span style="color: #00ffff;">this</span>) {
            isShutdown = <span style="color: #7fffd4;">true</span>;
        }
        loggerThread.interrupt();
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">log</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">msg</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {
        <span style="color: #00ffff;">synchronized</span> (<span style="color: #00ffff;">this</span>) {
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">service&#24050;&#20851;&#38381;&#21518;&#35843;&#29992;log&#26041;&#27861;&#30452;&#25509;&#25243;&#20986;&#24322;&#24120;  </span>
            <span style="color: #00ffff;">if</span> (isShutdown) {
                <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">IllegalStateException</span>(<span style="color: #ffa07a;">"Service has been shut down"</span>);
            }
            ++reservations;
        }
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">BlockingQueue&#26412;&#36523;&#23601;&#26159;&#32447;&#31243;&#23433;&#20840;&#30340;, put&#26041;&#27861;&#30340;&#35843;&#29992;&#19981;&#22312;&#21516;&#27493;&#20195;&#30721;&#22359;&#20013;  </span>
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25105;&#20204;&#21482;&#38656;&#35201;&#20445;&#35777;isShutdown&#21644;reservations&#26159;&#32447;&#31243;&#23433;&#20840;&#30340;&#21363;&#21487;  </span>
        queue.put(msg);
    }

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LoggerThread</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Thread</span> {
        <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">writer</span>;
        <span style="color: #00ffff;">private</span> <span style="color: #87cefa;">LoggerThread</span>(<span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">writer</span>) {
            <span style="color: #00ffff;">this</span>.writer = writer;
        }

        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
            <span style="color: #00ffff;">try</span> {
                <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
                    <span style="color: #00ffff;">try</span> {
                        <span style="color: #00ffff;">synchronized</span> (<span style="color: #00ffff;">this</span>) {
                            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#24403;service&#24050;&#20851;&#38381;&#19988;&#22788;&#29702;&#23436;&#38431;&#21015;&#20013;&#30340;&#25152;&#26377;&#25968;&#25454;&#26102;&#25165;&#36339;&#20986;while&#24490;&#29615;  </span>
                            <span style="color: #00ffff;">if</span> (isShutdown &amp;&amp; reservations == 0) {
                                <span style="color: #00ffff;">break</span>;
                            }
                        }
                        <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">msg</span> = queue.take();
                        <span style="color: #00ffff;">synchronized</span> (<span style="color: #00ffff;">this</span>) {
                            --reservations;
                        }
                        writer.println(msg);
                    } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">e</span>) {
                        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21457;&#29983;InterruptedException&#24322;&#24120;&#26102;&#19981;&#24212;&#35813;&#31435;&#21051;&#36339;&#20986;while&#24490;&#29615;  </span>
                        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#32780;&#24212;&#35813;&#32487;&#32493;&#36755;&#20986;log, &#30452;&#21040;&#22788;&#29702;&#23436;&#38431;&#21015;&#20013;&#30340;&#25152;&#26377;&#25968;&#25454;  </span>
                    }
                }
            } <span style="color: #00ffff;">finally</span> {
                writer.close();
            }
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">使用ExecutorService简化</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">LogService</span> {

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ExecutorService</span> <span style="color: #eedd82;">exec</span> = Executors.newSingleThreadExecutor();
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">writer</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">LogService</span>(<span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">writer</span>) {
        <span style="color: #00ffff;">this</span>.writer = writer;
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">shutdown</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">InterruptedException</span> {
        <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">TIMEOUT</span> = 10L; 
        <span style="color: #00ffff;">try</span> {
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20851;&#38381;ExecutorService&#21518;&#20877;&#35843;&#29992;&#20854;awaitTermination&#23558;&#23548;&#33268;&#24403;&#21069;&#32447;&#31243;&#38459;&#22622;, &#30452;&#21040;&#25152;&#26377;&#24050;&#25552;&#20132;&#30340;&#20219;&#21153;&#25191;&#34892;&#23436;&#27605;, &#25110;&#32773;&#21457;&#29983;&#36229;&#26102;  </span>
            exec.shutdown();
            exec.awaitTermination(TIMEOUT, <span style="color: #7fffd4;">TimeUnit</span>.SECONDS);
        } <span style="color: #00ffff;">finally</span> {
            writer.close();
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">log</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">msg</span>) {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#32447;&#31243;&#27744;&#20851;&#38381;&#21518;&#20877;&#35843;&#29992;&#20854;execute&#26041;&#27861;&#23558;&#25243;&#20986;RejectedExecutionException&#24322;&#24120;  </span>
            exec.execute(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">WriteTask</span>(msg));
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">RejectedExecutionException</span> <span style="color: #eedd82;">ignored</span>) {
        }
    }

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">WriteTask</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">Runnable</span> {
        <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">msg</span>;
        <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">WriteTask</span>(<span style="color: #98fb98;">String</span> <span style="color: #eedd82;">msg</span>) {
            <span style="color: #00ffff;">this</span>.msg = msg;
        }

        <span style="color: #7fffd4;">@Override</span>
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
            writer.println(msg);
        }
    }
}
</pre>
</div>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">shutdownNow的局限性</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
　无法知道那些正在运行任务的最终结束状态，必须手动记录那些被中断的任务　
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">abstract</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">TrackingExecutor</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">AbstractExecutorService</span> {

    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">ExecutorService</span> <span style="color: #eedd82;">exec</span> = Executors.newCachedThreadPool();
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#24050;&#32463;&#21551;&#21160;&#36824;&#27809;&#26377;&#32467;&#26463;&#34987;cancel&#30340;&#32447;&#31243;&#23384;&#25918;&#22312;&#36825;&#37324;</span>
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Set</span>&lt;<span style="color: #98fb98;">Runnable</span>&gt; <span style="color: #eedd82;">tasksCancelledAtShutdown</span>
    = Collections.synchronizedSet(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">HashSet</span>&lt;&gt;());

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Runnable</span>&gt; <span style="color: #87cefa;">getCancelledTasks</span>() {
        <span style="color: #00ffff;">if</span> (!exec.isTerminated()) {
            <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">IllegalStateException</span>(<span style="color: #ffa07a;">"illegal task status"</span>);
        }
        <span style="color: #00ffff;">return</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ArrayList</span>&lt;&gt;(tasksCancelledAtShutdown);
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">execute</span>(<span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Runnable</span> <span style="color: #eedd82;">runnable</span>) {
        exec.execute(() -&gt; {
                <span style="color: #00ffff;">try</span> {
                    runnable.run();
                } <span style="color: #00ffff;">finally</span> {
                    <span style="color: #00ffff;">if</span> (isShutdown()
                        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25191;&#34892;&#30340;&#20219;&#21153;&#24517;&#39035;&#20445;&#35777;&#27491;&#30830;&#22320;&#25226;&#20013;&#26029;&#29366;&#24577;&#20256;&#36882;&#22238;&#26469;</span>
                        &amp;&amp; Thread.currentThread().isInterrupted()) {
                        tasksCancelledAtShutdown.add(runnable);
                    }
                }
            });
    }
}
</pre>
</div>
<p>
极小的概率可能发生在关闭线程池的那一刻某个任务实际上已经执行完最后一条指令，但还没来得及记录任务运行结束。这种情况下就会造成将来重复执行任务。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">异常退出</h2>
<div class="outline-text-2" id="text-3">
<p>
线程异常退出的主要原因是RunTimeException,这种情况下往往不会通知主线程，在某些情况下需要捕获这些RunTimeException
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
    <span style="color: #98fb98;">Throwable</span> <span style="color: #eedd82;">thrown</span> = <span style="color: #7fffd4;">null</span>;
    <span style="color: #00ffff;">try</span> {
        <span style="color: #00ffff;">while</span> (!isInterrupted())
            runTask(getTaskFromWorkQueue());
    } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">Throwable</span> <span style="color: #eedd82;">e</span>) {
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#20445;&#23384;&#25152;&#26377;&#24322;&#24120;</span>
        thrown = e;
    } <span style="color: #00ffff;">finally</span> {
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36890;&#30693;&#20027;&#32447;&#31243;&#20445;&#23384;&#30340;&#24322;&#24120;</span>
        threadExited(<span style="color: #00ffff;">this</span>, thrown);
    }
}
</pre>
</div>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">未捕获异常处理器</h3>
<div class="outline-text-3" id="text-3-1">
<p>
长时间运行的应用，对于未捕获的异常至少要在日志记录下来　
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">UEHLogger</span> <span style="color: #00ffff;">implements</span> <span style="color: #7fffd4;">Thread</span>.<span style="color: #98fb98;">UncaughtExceptionHandler</span> {
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">uncaughtException</span>(<span style="color: #98fb98;">Thread</span> <span style="color: #eedd82;">t</span>, <span style="color: #98fb98;">Throwable</span> <span style="color: #eedd82;">e</span>) {
        <span style="color: #98fb98;">Logger</span> <span style="color: #eedd82;">logger</span> = Logger.getAnonymousLogger();
        logger.log(<span style="color: #7fffd4;">Level</span>.SEVERE,
               <span style="color: #ffa07a;">"Thread terminated with exception: "</span> + t.getName(),
               e);
    }
}
</pre>
</div>
<p>
通过线程池构造器的ThreadFactory参数可以使用自定义UncaughtExceptionHandler　
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">关闭JVM</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">正常关闭　</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li>运行完主线程最后一条命令
</li>
<li>调用System.exit
</li>
<li>发送SIGINT信号(CTRL+C)
</li>
</ol>

<p>
正常关闭的时候，会开始运行注册在Runtime.addShutdownHook的钩子线程。等到所有的钩子线程运行完毕，如果runFinalizersOnExit被设置的话，JVM开始运行finializer,最后停止JVM。JVM不会主动关闭或者中断任何其他线程
</p>
</div>
<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">关闭钩子</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>钩子线程必须是同步
</li>
<li>钩子线程不能死锁，不然JVM无法关闭
</li>
<li>所有的钩子线程会同时运行，尽量使用一个钩子关闭所有的服务
</li>
</ul>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">start</span>() {
    Runtime.getRuntime().addShutdownHook(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Thread</span>() {
            <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
                <span style="color: #00ffff;">try</span> { LogService.<span style="color: #00ffff;">this</span>.stop(); }
                <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">InterruptedException</span> <span style="color: #eedd82;">ignored</span>) {}
            }
        });
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">守护线程</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
守护线程在被关闭的时候不会运行finializer，回收函数栈。当JVM停止的那一刻，守护线程只是被抛弃。慎用守护线程！
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">强行关闭</h3>
<div class="outline-text-3" id="text-4-2">
<ol class="org-ol">
<li>调用RunTime.halt
</li>
<li>发送SIGKILL信号(kill -9) 
</li>
</ol>

<p>
<a href="thread_pool.html">Next:线程池</a>
</p>

<p>
<a href="executor.html">Previous:任务执行</a>
</p>

<p>
<a href="jcip.html">Up:目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

     <br/>
     <!-- DISQUS  -->
     <div id="disqus_thread"></div>
     <script type="text/javascript">
         /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
         var disqus_shortname = 'https-klose911-github-io'; // required: replace example with your forum shortname

         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
         })();
     </script>
     <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
     <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90850421-1', 'auto');
  ga('send', 'pageview');
</script>
</div>
</body>
</html>
