<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>线程池</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="cancellation.html"> UP </a>
 |
 <a accesskey="H" href="jcip.html"> HOME </a>
</div><div id="content">
<h1 class="title">线程池</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org08c5c8a">任务和执行策略的隐形耦合</a>
<ul>
<li><a href="#orga8dec5f">线程饥饿死锁</a></li>
<li><a href="#org985e341">长时间运行任务</a></li>
</ul>
</li>
<li><a href="#org8841dc9">线程池大小</a></li>
<li><a href="#orgad2f694">线程池配置</a>
<ul>
<li><a href="#org4594a05">线程的创建和销毁</a></li>
<li><a href="#org6797865">任务队列</a></li>
<li><a href="#org58c6981">饱和策略</a>
<ul>
<li><a href="#org006af9e">使用CallerRunsPolicy处理请求过载</a></li>
<li><a href="#org70c194c">BoundExecutor</a></li>
</ul>
</li>
<li><a href="#org3f8e2bb">ThreadFactory</a></li>
</ul>
</li>
<li><a href="#org612ea7c">扩展线程池</a></li>
<li><a href="#orgdaa187c">并行执行递归算法</a></li>
</ul>
</div>
</div>
<div id="outline-container-org08c5c8a" class="outline-2">
<h2 id="org08c5c8a">任务和执行策略的隐形耦合</h2>
<div class="outline-text-2" id="text-org08c5c8a">
<p>
某些任务的特质会要求或者排除某些特定的执行策略
</p>
<ul class="org-ul">
<li>有相互依赖的任务在同一个线程池会要求线程池无限大</li>
<li>依赖于线程封闭的任务只能用单线程执行的线程池</li>
<li>快速响应的任务不适合单线程执行的线程池</li>
<li>使用ThreadLocal的任务不适合线程池</li>
</ul>
</div>

<div id="outline-container-orga8dec5f" class="outline-3">
<h3 id="orga8dec5f">线程饥饿死锁</h3>
<div class="outline-text-3" id="text-orga8dec5f">
<p>
相互依赖的任务在一个线程池中执行，就可能出现饥饿死锁
</p>

<p>
比如在一个单线程执行的线程池中，线程B需要等待线程A执行完毕才能进入线程池执行，而线程A又要等待线程B执行完毕才能完毕。这样就造成了死锁。
当线程池容量更大一点的情况下，依然可能所有存在于线程池中的线程都在等待“未能进入线程池”的线程执行完毕
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">ThreadDeadlock</span> {
    <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #4eee94;">exec</span> = Executors.newSingleThreadExecutor();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">RenderPageTask</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">Callable</span>&lt;<span style="color: #98f5ff;">String</span>&gt; {
        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">String</span> <span style="color: #daa520; font-weight: bold;">call</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">Exception</span> {
            <span style="color: #98f5ff;">Future</span>&lt;<span style="color: #98f5ff;">String</span>&gt; <span style="color: #4eee94;">header</span>, <span style="color: #4eee94;">footer</span>;
            header = exec.submit(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LoadFileTask</span>(<span style="color: #deb887;">"header.html"</span>)); 
            footer = exec.submit(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LoadFileTask</span>(<span style="color: #deb887;">"footer.html"</span>));
            <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">page</span> = renderBody();
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Will deadlock -- task waiting for result of subtask</span>
            <span style="color: #00bfff; font-weight: bold;">return</span> header.get() + page + footer.get();
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org985e341" class="outline-3">
<h3 id="org985e341">长时间运行任务</h3>
<div class="outline-text-3" id="text-org985e341">
<p>
线程池包含许多运行长时间的任务会导致所有任务哪怕本来响应很快的响应变慢 
</p>

<p>
使用timeout机制，标记那些超时的任务为失败，在未来串行执行
</p>
</div>
</div>
</div>

<div id="outline-container-org8841dc9" class="outline-2">
<h2 id="org8841dc9">线程池大小</h2>
<div class="outline-text-2" id="text-org8841dc9">
<ul class="org-ul">
<li>对于计算密集型task, 合适的size大约为CPU数量+1</li>
<li>对于I/O占较大比例的task, 合适的size可以通过以下公式确定: size = CPU数量 * CPU利用率 * (1 + I/O时间比例)</li>
</ul>

<p>
实际size还受到内存, 文件句柄, socket, 数据库连接数等稀缺资源的约束。将总的稀缺资源除以每一个task使用的资源数, 能得到线程数的上限
</p>
</div>
</div>

<div id="outline-container-orgad2f694" class="outline-2">
<h2 id="orgad2f694">线程池配置</h2>
<div class="outline-text-2" id="text-orgad2f694">
</div>
<div id="outline-container-org4594a05" class="outline-3">
<h3 id="org4594a05">线程的创建和销毁</h3>
<div class="outline-text-3" id="text-org4594a05">
<p>
ThreadPoolExecutor构造函数中的corePoolSize, maximumPoolSize, keepAliveTime参数与线程的创建和销毁 
</p>
<ol class="org-ol">
<li>corePoolSize：线程池中持有的核心线程数, 除非task队列已满, ThreadPoolExecutor不会创建超过核心线程数的线程(corePoolSize为0时是一种特殊情况, 此时就算task队列没有饱和, 向线程池第一次提交task时仍然会创建新的线程), 核心线程一旦创建就不会销毁, 除非设置了allowCoreThreadTimeOut(true), 或者关闭线程池</li>
<li>maximumPoolSize：线程池中持有的最大线程数.</li>
<li><p>
keepAliveTime：对于超过核心线程数的线程, 如果在指定的超时时间内没有使用到, 就会被销毁
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #daa520; font-weight: bold;">newCachedThreadPool</span>() {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26680;&#24515;&#32447;&#31243;&#25968;&#20026;0, &#26368;&#22823;&#32447;&#31243;&#25968;&#20026;Integer.MAX_VALUE, &#36229;&#26102;&#26102;&#38388;&#20026;60s  </span>
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(0, <span style="color: #ffd700;">Integer</span>.MAX_VALUE, 60L, <span style="color: #ffd700;">TimeUnit</span>.SECONDS, <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">SynchronousQueue</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt;());  
}  

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #daa520; font-weight: bold;">newFixedThreadPool</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nThreads</span>) {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26680;&#24515;&#32447;&#31243;&#25968;&#21644;&#26368;&#22823;&#32447;&#31243;&#25968;&#37117;&#20026;&#35843;&#29992;&#26041;&#25351;&#23450;&#30340;&#20540;nThreads, &#36229;&#26102;&#26102;&#38388;&#20026;0  </span>
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(nThreads, nThreads, 0L, <span style="color: #ffd700;">TimeUnit</span>.MILLISECONDS,  
                      <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LinkedBlockingQueue</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt;());  
}  

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">ScheduledExecutorService</span> <span style="color: #daa520; font-weight: bold;">newScheduledThreadPool</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">corePoolSize</span>) {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#26680;&#24515;&#32447;&#31243;&#25968;&#30001;&#35843;&#29992;&#26041;&#25351;&#23450;, &#26368;&#22823;&#32447;&#31243;&#25968;&#20026;Integer.MAX_VALUE, &#36229;&#26102;&#26102;&#38388;&#20026;0  </span>
    <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(corePoolSize, <span style="color: #ffd700;">Integer</span>.MAX_VALUE, 0, <span style="color: #ffd700;">TimeUnit</span>.NANOSECONDS, <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">DelayedWorkQueue</span>());  
}   
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org6797865" class="outline-3">
<h3 id="org6797865">任务队列</h3>
<div class="outline-text-3" id="text-org6797865">
<p>
线程池内部持有一个任务队列, 当任务的提交速度超过任务的执行速度时, 任务将被缓存在任务队列中等待有线程可用时再执行. ThreadPoolExecutor在创建时可以为其指定任务队列。
</p>

<p>
一般有三种选择: 
</p>
<ol class="org-ol">
<li>有界队列</li>
<li>无界队列：newFixedThreadPool, newScheduledThreadPool</li>
<li>同步队列：newCashedThreadPool</li>
</ol>

<p>
为线程数不多的线程池指定一个容量大的队列(或者无界队列), 有助于减少线程间切换, CPU等方面的消耗, 代价是可能会造成吞吐量下降。如果使用的是有界队列, 队列可能会被填满, 将根据指定的饱和策略进行处理
</p>

<p>
对于线程数很大的线程池, 可以使用同步队列. 同步队列其实不能算是一种队列, 因为同步队列没有缓存的作用。使用同步队列时, task被提交时, 直接由线程池中的线程接手. 如果此时线程池中没有可用的线程, 线程池将创建新的线程接手. 如果线程池无法创建新的线程(比如线程数已到达maximumPoolSize), 则根据指定的饱和策略进行处理 
</p>
</div>
</div>

<div id="outline-container-org58c6981" class="outline-3">
<h3 id="org58c6981">饱和策略</h3>
<div class="outline-text-3" id="text-org58c6981">
<ul class="org-ul">
<li>有界队列满时继续提交task时, 饱和策略会被触发.</li>
<li>同步队列当线程池无法创建新的线程接手task时, 饱和策略会被触发.</li>
<li>线程池被关闭后, 向其提交task时, 饱和策略也会被触发.</li>
</ul>

<p>
ThreadPoolExecutor.setRejectedExecutionHandler方法用于设定饱和策略
</p>

<p>
预定义RejectedExecutionHandler的实现类
</p>
<ol class="org-ol">
<li><p>
AbortPolicy: 默认的饱和策略, 抛出RejectedExecutionException异常 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #00bfff; font-weight: bold;">throw</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">RejectedExecutionException</span>();  
}   
</pre>
</div></li>
<li><p>
CallerRunsPolicy: 在提交task的线程中执行task, 而不是由线程池中的线程执行
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #00bfff; font-weight: bold;">if</span> (!e.isShutdown()) {  
        r.run();  
    }  
}  
</pre>
</div></li>
<li><p>
DiscardPolicy: 将最新提交的任务丢弃
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20002;&#24323;, &#19981;&#20570;&#20219;&#20309;&#22788;&#29702;  </span>
}   
</pre>
</div></li>

<li><p>
DiscardOldestPolicy: 将队列头部的任务丢弃，然后尝试重新提交新的任务
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rejectedExecution</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">e</span>) {  
    <span style="color: #00bfff; font-weight: bold;">if</span> (!e.isShutdown()) {  
        e.getQueue().poll();  
        e.execute(r);  
    }  
}   
</pre>
</div></li>
</ol>
</div>

<div id="outline-container-org006af9e" class="outline-4">
<h4 id="org006af9e">使用CallerRunsPolicy处理请求过载</h4>
<div class="outline-text-4" id="text-org006af9e">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">LifecycleWebServer</span> {  
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">MAX_THREAD_COUNT&#21644;MAX_QUEUE_COUNT&#30340;&#20540;&#26681;&#25454;&#31995;&#32479;&#30340;&#23454;&#38469;&#24773;&#20917;&#30830;&#23450;  </span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">MAX_THREAD_COUNT</span> = 100;  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">MAX_QUEUE_COUNT</span> = 1000;  

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#26377;&#30028;&#38431;&#21015;&#20316;&#20026;task&#38431;&#21015;, &#24403;&#26377;&#30028;&#38431;&#21015;&#28385;&#26102;, &#23558;&#35302;&#21457;&#39281;&#21644;&#31574;&#30053;  </span>
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span> <span style="color: #4eee94;">exec</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span>(0, MAX_THREAD_COUNT, 60L, <span style="color: #ffd700;">TimeUnit</span>.SECONDS,  
                                       <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ArrayBlockingQueue</span>&lt;<span style="color: #98f5ff;">Runnable</span>&gt;(MAX_QUEUE_COUNT));  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">start</span>() <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">IOException</span> {  
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#39281;&#21644;&#31574;&#30053;&#20026;CallerRunsPolicy  </span>
        exec.setRejectedExecutionHandler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #ffd700;">ThreadPoolExecutor</span>.<span style="color: #98f5ff;">CallerRunsPolicy</span>());  
        <span style="color: #98f5ff;">ServerSocket</span> <span style="color: #4eee94;">socket</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ServerSocket</span>(80);  
        <span style="color: #00bfff; font-weight: bold;">while</span> (!exec.isShutdown()) {  
            <span style="color: #00bfff; font-weight: bold;">try</span> {  
                <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">conn</span> = socket.accept();  
                exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {  
                        <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {  
                            handleRequest(conn);  
                        }  
                    });  
            } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">RejectedExecutionException</span> <span style="color: #4eee94;">e</span>) {  
                <span style="color: #00bfff; font-weight: bold;">if</span> (!exec.isShutdown())  
                    log(<span style="color: #deb887;">"task submission rejected"</span>, e);  
            }  
        }  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">stop</span>() {  
        exec.shutdown();  
    }  

    <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">handleRequest</span>(<span style="color: #98f5ff;">Socket</span> <span style="color: #4eee94;">connection</span>) {  
        <span style="color: #98f5ff;">Request</span> <span style="color: #4eee94;">req</span> = readRequest(connection);  
        <span style="color: #00bfff; font-weight: bold;">if</span> (isShutdownRequest(req))  
            stop();  
        <span style="color: #00bfff; font-weight: bold;">else</span>  
            dispatchRequest(req);  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {  
        <span style="color: #98f5ff;">LifecycleWebServer</span> <span style="color: #4eee94;">server</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">LifecycleWebServer</span>();  
        <span style="color: #00bfff; font-weight: bold;">try</span> {  
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22312;main&#32447;&#31243;&#20013;&#21551;&#21160;server  </span>
            server.start();  
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">IOException</span> <span style="color: #4eee94;">e</span>) {  
            e.printStackTrace();  
        }  
    }  
}   
</pre>
</div>
<p>
如果线程池饱和时主线程仍然向线程池提交任务, 那么任务将在主线程中执行。主线程执行任务是需要一定时间的，这样就给了线程池喘息的机会, 而且主线程在执行任务的时间内无法接受socket连接, 因此socket连接请求将缓存在tcp层。如果server过载持续的时间较长, 使得tcp层的缓存不够, 那么tcp缓存将根据其策略丢弃部分请求
</p>

<p>
整个系统的过载压力逐步向外扩散: 线程池-线程池中的队列-main线程-tcp层-client。不会因为过多的请求而导致系统资源耗尽, 也不会一发生过载时就拒绝服务, 只有发生长时间系统过载时才会出现客户端无法连接的情况
</p>
</div>
</div>

<div id="outline-container-org70c194c" class="outline-4">
<h4 id="org70c194c">BoundExecutor</h4>
<div class="outline-text-4" id="text-org70c194c">
<p>
没有预定的饱和策略来限定线程池中执行任务线程的数量，可以结合Semaphore来实现
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">BoundedExecutor</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Semaphore</span> <span style="color: #4eee94;">semaphore</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">BoundedExecutor</span>(<span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">bound</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>.exec = exec;
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#23450;&#20449;&#21495;&#37327;permit&#30340;&#19978;&#38480;</span>
        <span style="color: #00bfff; font-weight: bold;">this</span>.semaphore = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Semaphore</span>(bound);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">submitTask</span>(<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">command</span>) <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25552;&#20132;task&#21069;&#20808;&#30003;&#35831;permit, &#22914;&#26524;&#26080;&#27861;&#30003;&#35831;&#21040;permit, &#35843;&#29992;submitTask&#30340;&#32447;&#31243;&#23558;&#34987;&#38459;&#22622;, &#30452;&#21040;&#26377;permit&#21487;&#29992;</span>
        semaphore.acquire();
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                        <span style="color: #00bfff; font-weight: bold;">try</span> {
                            command.run();
                        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
                            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#25552;&#20132;&#25104;&#21151;&#20102;, &#36816;&#34892;task&#21518;&#37322;&#25918;permit</span>
                            semaphore.release();
                        }
                    }
                });
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">RejectedExecutionException</span> <span style="color: #4eee94;">e</span>) {
            <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#25552;&#20132;&#25104;&#21151;, &#20063;&#38656;&#35201;&#37322;&#25918;permit</span>
            semaphore.release();
        }
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3f8e2bb" class="outline-3">
<h3 id="org3f8e2bb">ThreadFactory</h3>
<div class="outline-text-3" id="text-org3f8e2bb">
<p>
创建ThreadPoolExecutor时还可以为其指定ThreadFactory, 当线程池需要创建新的线程时会调用ThreadFactory的newThread方法
</p>

<p>
默认的ThreadFactory创建的线程是nonDaemon, 线程优先级为普通的线程, 并且为其指定了可识别的线程名称 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">Thread</span> <span style="color: #daa520; font-weight: bold;">newThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>) {  
    <span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), 0);  
    <span style="color: #00bfff; font-weight: bold;">if</span> (t.isDaemon())  
        t.setDaemon(<span style="color: #ffd700;">false</span>);  
    <span style="color: #00bfff; font-weight: bold;">if</span> (t.getPriority() != <span style="color: #ffd700;">Thread</span>.NORM_PRIORITY)  
        t.setPriority(<span style="color: #ffd700;">Thread</span>.NORM_PRIORITY);  
    <span style="color: #00bfff; font-weight: bold;">return</span> t;  
}  
</pre>
</div>

<p>
客户化的MyAppThread
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MyAppThread</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">Thread</span> {
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">DEFAULT_NAME</span> = <span style="color: #deb887;">"MyAppThread"</span>;
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicInteger</span> <span style="color: #4eee94;">created</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicInteger</span>();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicInteger</span> <span style="color: #4eee94;">alive</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicInteger</span>();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Logger</span> <span style="color: #4eee94;">log</span> = Logger.getAnonymousLogger();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">debugLifecycle</span> = <span style="color: #ffd700;">false</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">MyAppThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>) {
        <span style="color: #00bfff; font-weight: bold;">this</span>(r, DEFAULT_NAME);
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">MyAppThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">runnable</span>, <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">name</span>) {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#20026;&#33258;&#23450;&#20041;&#30340;Thread&#31867;&#25351;&#23450;&#32447;&#31243;&#21517;&#31216;</span>
        <span style="color: #00bfff; font-weight: bold;">super</span>(runnable, name + <span style="color: #deb887;">"-"</span> + created.incrementAndGet());
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;UncaughtExceptionHandler. UncaughtExceptionHandler&#30340;uncaughtException&#26041;&#27861;&#23558;&#22312;&#32447;&#31243;&#36816;&#34892;&#20013;&#25243;&#20986;&#26410;&#25429;&#33719;&#24322;&#24120;&#26102;&#30001;&#31995;&#32479;&#35843;&#29992;</span>
        setUncaughtExceptionHandler(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #ffd700;">Thread</span>.<span style="color: #98f5ff;">UncaughtExceptionHandler</span>() {
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">uncaughtException</span>(<span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span>, <span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">e</span>) {
                    log.log(<span style="color: #ffd700;">Level</span>.SEVERE, <span style="color: #deb887;">"UNCAUGHT in thread "</span> + t.getName(), e);
                }
            });
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getThreadsCreated</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> created.get();
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getThreadsAlive</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> alive.get();
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #daa520; font-weight: bold;">getDebug</span>() {
        <span style="color: #00bfff; font-weight: bold;">return</span> debugLifecycle;
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">setDebug</span>(<span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">b</span>) {
        debugLifecycle = b;
    }

    <span style="color: #ffd700;">@Override</span>
    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Copy debug flag to ensure consistent value throughout.</span>
        <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">debug</span> = debugLifecycle;
        <span style="color: #00bfff; font-weight: bold;">if</span> (debug)
            log.log(<span style="color: #ffd700;">Level</span>.FINE, <span style="color: #deb887;">"Created "</span> + getName());
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            alive.incrementAndGet();
            <span style="color: #00bfff; font-weight: bold;">super</span>.run();
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            alive.decrementAndGet();
            <span style="color: #00bfff; font-weight: bold;">if</span> (debug)
                log.log(<span style="color: #ffd700;">Level</span>.FINE, <span style="color: #deb887;">"Exiting "</span> + getName());
        }
    }
}
</pre>
</div>

<p>
客户化ThreadFactory返回MyAppThread
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">MyThreadFactory</span> <span style="color: #00bfff; font-weight: bold;">implements</span> <span style="color: #98f5ff;">ThreadFactory</span> {  
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">poolName</span>;  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #daa520; font-weight: bold;">MyThreadFactory</span>(<span style="color: #98f5ff;">String</span> <span style="color: #4eee94;">poolName</span>) {  
        <span style="color: #00bfff; font-weight: bold;">this</span>.poolName = poolName;  
    }  

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">Thread</span> <span style="color: #daa520; font-weight: bold;">newThread</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">runnable</span>) {  
        <span style="color: #00bfff; font-weight: bold;">return</span> <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">MyAppThread</span>(runnable, poolName);  
    }  
}  
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org612ea7c" class="outline-2">
<h2 id="org612ea7c">扩展线程池</h2>
<div class="outline-text-2" id="text-org612ea7c">
<p>
ThreadPoolExecutor类提供了多个"钩子"方法, 以供其子类实现
</p>
<ol class="org-ol">
<li>beforeExecute: 任务执行前</li>
<li>afterExecute: 任务执行后</li>
<li>terminated: 线程池被关闭后(释放线程池申请的资源)</li>
</ol>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">runTask</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">task</span>) {  
    <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ReentrantLock</span> <span style="color: #4eee94;">runLock</span> = <span style="color: #00bfff; font-weight: bold;">this</span>.runLock;  
    runLock.lock();  
    <span style="color: #00bfff; font-weight: bold;">try</span> {  
        <span style="color: #00bfff; font-weight: bold;">if</span> (runState &lt; <span style="color: #98f5ff;">STOP</span> &amp;&amp; Thread.interrupted() &amp;&amp; runState &gt;= STOP)  
            thread.interrupt();  
        <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">ran</span> = <span style="color: #ffd700;">false</span>;  
        beforeExecute(thread, task);  
        <span style="color: #00bfff; font-weight: bold;">try</span> {  
            task.run();  
            ran = <span style="color: #ffd700;">true</span>;  
            afterExecute(task, <span style="color: #ffd700;">null</span>);  
            ++completedTasks;  
        } <span style="color: #00bfff; font-weight: bold;">catch</span> (<span style="color: #98f5ff;">RuntimeException</span> <span style="color: #4eee94;">ex</span>) {  
            <span style="color: #00bfff; font-weight: bold;">if</span> (!ran)  
                afterExecute(task, ex);  
            <span style="color: #00bfff; font-weight: bold;">throw</span> ex;  
        }  
    } <span style="color: #00bfff; font-weight: bold;">finally</span> {  
        runLock.unlock();  
    }  
}   
</pre>
</div>

<p>
扩展线程池，在在日志中记录每个任务执行时间
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">TimingThreadPool</span> <span style="color: #00bfff; font-weight: bold;">extends</span> <span style="color: #98f5ff;">ThreadPoolExecutor</span> {
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">ThreadLocal</span>&lt;<span style="color: #98f5ff;">Long</span>&gt; <span style="color: #4eee94;">startTime</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ThreadLocal</span>&lt;<span style="color: #98f5ff;">Long</span>&gt;();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Logger</span> <span style="color: #4eee94;">log</span> = Logger.getLogger(<span style="color: #deb887;">"TimingThreadPool"</span>);
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicLong</span> <span style="color: #4eee94;">numTasks</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicLong</span>();
    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">AtomicLong</span> <span style="color: #4eee94;">totalTime</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">AtomicLong</span>();

    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">beforeExecute</span>(<span style="color: #98f5ff;">Thread</span> <span style="color: #4eee94;">t</span>, <span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>) {
        <span style="color: #00bfff; font-weight: bold;">super</span>.beforeExecute(t, r);
        log.fine(String.format(<span style="color: #deb887;">"Thread %s: start %s"</span>, t, r));
        startTime.set(System.nanoTime());
    }

    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">afterExecute</span>(<span style="color: #98f5ff;">Runnable</span> <span style="color: #4eee94;">r</span>, <span style="color: #98f5ff;">Throwable</span> <span style="color: #4eee94;">t</span>) {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">endTime</span> = System.nanoTime();
            <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">taskTime</span> = endTime - startTime.get();
            numTasks.incrementAndGet();
            totalTime.addAndGet(taskTime);
            log.fine(String.format(<span style="color: #deb887;">"Thread %s: end %s, time=%dns"</span>,
                           t, r, taskTime));
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            <span style="color: #00bfff; font-weight: bold;">super</span>.afterExecute(r, t);
        }
    }

    <span style="color: #00bfff; font-weight: bold;">protected</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">terminated</span>() {
        <span style="color: #00bfff; font-weight: bold;">try</span> {
            log.info(String.format(<span style="color: #deb887;">"Terminated: avg time=%dns"</span>,
                           totalTime.get() / numTasks.get()));
        } <span style="color: #00bfff; font-weight: bold;">finally</span> {
            <span style="color: #00bfff; font-weight: bold;">super</span>.terminated();
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdaa187c" class="outline-2">
<h2 id="orgdaa187c">并行执行递归算法</h2>
<div class="outline-text-2" id="text-orgdaa187c">
<p>
如果循环体所进行的操作是相互独立的, 这样的循环可以并发的运行 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">processSequentially</span>(<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Element</span>&gt; <span style="color: #4eee94;">elements</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">Element</span> <span style="color: #4eee94;">e</span> : elements)
        process(e);
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#23558;&#30456;&#20114;&#29420;&#31435;&#30340;&#24490;&#29615;&#25805;&#20316;&#36716;&#21464;&#20026;&#24182;&#21457;&#25805;&#20316;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">processInParallel</span>(<span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>, <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Element</span>&gt; <span style="color: #4eee94;">elements</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Element</span> <span style="color: #4eee94;">e</span> : elements)
        exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() { process(e); }
            });
    exec.shutdown();   
    exec.awaitTermination(<span style="color: #ffd700;">Long</span>.MAX_VALUE, <span style="color: #ffd700;">TimeUnit</span>.SECONDS); 
}
</pre>
</div>

<p>
有循环的递归操作也可以并发进行计算
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sequentialRecursive</span>(<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt;&gt; <span style="color: #4eee94;">nodes</span>,
                   <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">results</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">n</span> : nodes) {
        results.add(n.compute());
        sequentialRecursive(n.getChildren(), results);
    }
}

<span style="color: #00bfff; font-weight: bold;">public</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">parallelRecursive</span>(<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Executor</span> <span style="color: #4eee94;">exec</span>,
                 <span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt;&gt; <span style="color: #4eee94;">nodes</span>,
                 <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">results</span>) {
    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">n</span> : nodes) {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#24182;&#21457;&#36827;&#34892;&#35745;&#31639;</span>
        exec.execute(<span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Runnable</span>() {
                <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">run</span>() {
                    results.add(n.compute());
                }
            });
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#36941;&#21382;&#20381;&#26087;&#26159;&#36882;&#24402;</span>
        parallelRecursive(exec, n.getChildren(), results);
    }
}

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#33719;&#21462;&#26368;&#32456;&#32467;&#26524;</span>
<span style="color: #00bfff; font-weight: bold;">public</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #98f5ff;">Collection</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #daa520; font-weight: bold;">getParallelResults</span>(<span style="color: #98f5ff;">List</span>&lt;<span style="color: #98f5ff;">Node</span>&lt;<span style="color: #98f5ff;">T</span>&gt;&gt; <span style="color: #4eee94;">nodes</span>)
    <span style="color: #00bfff; font-weight: bold;">throws</span> <span style="color: #98f5ff;">InterruptedException</span> {
    <span style="color: #98f5ff;">ExecutorService</span> <span style="color: #4eee94;">exec</span> = Executors.newCachedThreadPool();
    <span style="color: #98f5ff;">Queue</span>&lt;<span style="color: #98f5ff;">T</span>&gt; <span style="color: #4eee94;">resultQueue</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">ConcurrentLinkedQueue</span>&lt;<span style="color: #98f5ff;">T</span>&gt;();
    parallelRecursive(exec, nodes, resultQueue);
    exec.shutdown();
    exec.awaitTermination(<span style="color: #ffd700;">Long</span>.MAX_VALUE, <span style="color: #ffd700;">TimeUnit</span>.SECONDS);
    <span style="color: #00bfff; font-weight: bold;">return</span> resultQueue;
}
</pre>
</div>

<p>
<a href="explicit_lock.html">Next:显式锁</a>
</p>

<p>
<a href="cancellation.html">Previous:任务取消</a>
</p>

<p>
<a href="jcip.html">Up:目录</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
