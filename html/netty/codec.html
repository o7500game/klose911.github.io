<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Codec 编码</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="channel.html"> UP </a>
 |
 <a accesskey="H" href="netty.html"> HOME </a>
</div><div id="content">
<h1 class="title">Codec 编码</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Codec</a>
<ul>
<li><a href="#sec-1-1">Decoder</a>
<ul>
<li><a href="#sec-1-1-1">ByteToMessageDecoder</a></li>
<li><a href="#sec-1-1-2">ReplayingDecoder</a>
<ul>
<li><a href="#sec-1-1-2-1">ByteToMessageDecoder VS ReplayingDecoder</a></li>
<li><a href="#sec-1-1-2-2">更多 Decoder</a></li>
</ul>
</li>
<li><a href="#sec-1-1-3">MessageToMessageDecoder</a>
<ul>
<li><a href="#sec-1-1-3-1">HttpObjectAggregator</a></li>
</ul>
</li>
<li><a href="#sec-1-1-4">在解码时处理太大的帧</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Encoder</a></li>
<li><a href="#sec-1-3">抽象 Codec 类</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章介绍：
</p>
<ul class="org-ul">
<li>Decoder(解码器)
</li>
<li>Encoder(编码器)
</li>
<li>Codec(编解码器)
</li>
</ul>

<p>
在前面的章节中，我们讨论了连接到拦截操作或数据处理链的不同方式，展示了如何使用 ChannelHandler 及其相关的类来实现几乎任何一种应用程序所需的逻辑。但正如标准架构模式通常有专门的框架，通用处理模式很适合使用目标实现，可以节省我们大量的开发时间和精力
</p>

<p>
在这一章，我们将研究编码和解码： <b>数据从一种特定协议格式到另一种格式的转换</b> 。这种处理模式是由通常被称为 <b>codecs</b> 的组件来处理的。Netty提供了一些组件，利用它们可以很容易地为各种不同协议编写编解码器。例如，如果您正在构建一个基于 Netty 的邮件服务器，你可以使用POP3, IMAP 和 SMTP的现成的实现
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Codec</h2>
<div class="outline-text-2" id="text-1">
<p>
编写一个网络应用程序需要实现某种 codec (编解码器)，codec的作用就是 <b>将原始字节数据与目标程序数据格式进行互转</b> 。网络中都是以字节码的数据形式来传输数据的，codec 由两部分组成：
</p>
<ul class="org-ul">
<li>decoder: 解码器
</li>
<li>encoder: 编码器
</li>
</ul>

<p>
编码器和解码器一个字节序列转换为另一个业务对象。一个 <b>消息</b> 是一个结构化的字节序列，语义为一个特定的应用程序的 <b>数据</b> 。encoder 是组件，转换消息格式适合传输(就像字节流)，而相应的 decoder 转换传输数据回到程序的消息格式。逻辑上,  <b>从</b> 消息转换来是当作操作  <b>outbound（出站）</b> 数据,而转换， <b>到</b> 消息是处理  <b>inbound（入站）</b> 数据
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Decoder</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Netty 提供了丰富的解码器抽象基类，可以很容易的实现这些基类来自定义解码器。主要分两类：
</p>
<ul class="org-ul">
<li>解码字节到消息
<ul class="org-ul">
<li>ByteToMessageDecoder
</li>
<li>ReplayingDecoder
</li>
</ul>
</li>
<li>解码消息到消息
+MessageToMessageDecoder
</li>
</ul>

<p>
decoder 负责将 <b>入站</b> 数据从一种格式转换到另一种格式，Netty的解码器是一种 ChannelInboundHandler 的抽象实现。实践中使用解码器很简单，就是将入站数据转换格式后传递到 ChannelPipeline 中的下一个ChannelInboundHandler 进行处理
</p>

<p>
这样的处理是很灵活的，可以将解码器放在 ChannelPipeline 中，重用逻辑
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">ByteToMessageDecoder</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
ByteToMessageDecoder 是用于将字节转为消息（或其他字节序列）
</p>

<p>
不能确定远端是否会一次发送完一个完整的信息，因此这个类会缓存入站的数据，直到准备好了用于处理。表7.1说明了它的两个最重要的方法：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> ByteToMessageDecoder 方法</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">方法</td>
<td class="left">描述</td>
</tr>

<tr>
<td class="left">decode</td>
<td class="left">This is the only abstract method you need to implement. It is called with a ByteBuf having the incoming bytes and a List into which decoded messages are added. decode() is called repeatedly until the List is empty on return. The contents of the List are then passed to the next handler in the pipeline</td>
</tr>

<tr>
<td class="left">decodeLast</td>
<td class="left">The default implementation provided simply calls decode().This method is called once, when the Channel goes inactive. Override to provide special handling</td>
</tr>
</tbody>
</table>

<p>
假设我们接收一个包含简单整数的字节流，每个都单独处理。在本例中，将从入站 ByteBuf 读取每个整数并将其传递给 pipeline 中的下一个ChannelInboundHandler。扩展ByteToMessageDecoder来实现解码字节流成整数，如图7.1所示：
</p>

<div class="figure">
<p><img src="pic/to-integer-decoder.jpg" alt="to-integer-decoder.jpg" width="70%" />
</p>
</div>

<p>
每次从入站的 ByteBuf 读取四个字节，解码成整形，并添加到一个 List ，当不能再添加数据到 List 时，它所包含的内容就会被发送到下个 ChannelInboundHandler：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ToIntegerDecoder</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">ByteToMessageDecoder</span> {  <span style="color: #ff4500;">//</span><span style="color: #ff4500;">1 &#23454;&#29616;&#32487;&#25215;&#20102; ByteToMessageDecode &#29992;&#20110;&#23558;&#23383;&#33410;&#35299;&#30721;&#20026;&#28040;&#24687;</span>
    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">decode</span>(<span style="color: #98fb98;">ChannelHandlerContext</span> <span style="color: #eedd82;">ctx</span>, <span style="color: #98fb98;">ByteBuf</span> <span style="color: #eedd82;">in</span>, <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Object</span>&gt; <span style="color: #eedd82;">out</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span> {
        <span style="color: #00ffff;">if</span> (in.readableBytes() &gt;= 4) {  <span style="color: #ff4500;">//</span><span style="color: #ff4500;">2 &#26816;&#26597;&#21487;&#35835;&#30340;&#23383;&#33410;&#26159;&#21542;&#33267;&#23569;&#26377;4&#20010; ( int &#26159;4&#20010;&#23383;&#33410;&#38271;&#24230;)</span>
            out.add(in.readInt());  <span style="color: #ff4500;">//</span><span style="color: #ff4500;">3 &#20174;&#20837;&#31449; ByteBuf &#35835;&#21462; int &#65292; &#28155;&#21152;&#21040;&#35299;&#30721;&#28040;&#24687;&#30340; List &#20013;</span>
        }
    }
}
</pre>
</div>

<p>
尽管 ByteToMessageDecoder 简化了这个模式，你会发现它还是有点烦人。在实际的读操作(readInt)之前，必须要验证输入的 ByteBuf 要有足够的数据。在下一节中将看看 ReplayingDecoder，一个特殊的解码器
</p>

<p>
引用计数对于编码器和解码器来说，这个过程非常简单。一旦一个消息被编码或解码它自动被调用ReferenceCountUtil.release(message) 。如果你稍后还需要用到这个引用而不是马上释放，你可以调用 <b>ReferenceCountUtil.retain(message)</b> 。这将 <b>增加引用计数防止消息被释放</b>
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">ReplayingDecoder</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
ReplayingDecoder 是 byte-to-message 解码的一种特殊的抽象基类，读取缓冲区的数据之前需要检查缓冲区是否有足够的字节，使用ReplayingDecoder就无需自己检查：
</p>
<ul class="org-ul">
<li>若ByteBuf中有足够的字节，则会正常读取
</li>
<li>若没有足够的字节则会停止解码
</li>
</ul>
</div>

<div id="outline-container-sec-1-1-2-1" class="outline-5">
<h5 id="sec-1-1-2-1">ByteToMessageDecoder VS ReplayingDecoder</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<p>
ReplayingDecoder 继承自 ByteToMessageDecoder ，所以两者 API 是相同的。也正因为这样的包装使得 ReplayingDecoder 带有一定的局限性：
</p>
<ul class="org-ul">
<li>不是所有的标准 ByteBuf 操作都被支持，如果调用一个不支持的操作会抛出 UnreplayableOperationException
</li>
<li>ReplayingDecoder 略慢于 ByteToMessageDecoder
</li>
</ul>

<p>
如果这些限制是可以接受你可能更喜欢使用 ReplayingDecoder。下面是一个简单的准则：
</p>
<pre class="example">
如果不引入过多的复杂性 使用 ByteToMessageDecoder ，否则使用ReplayingDecoder
</pre>

<p>
使用 ReplayingDecoder 更简单：
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ToIntegerDecoder2</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">ReplayingDecoder</span>&lt;<span style="color: #98fb98;">Void</span>&gt; {   <span style="color: #ff4500;">//</span><span style="color: #ff4500;">1 &#23454;&#29616;&#32487;&#25215;&#33258; ReplayingDecoder &#29992;&#20110;&#23558;&#23383;&#33410;&#35299;&#30721;&#20026;&#28040;&#24687;</span>

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">decode</span>(<span style="color: #98fb98;">ChannelHandlerContext</span> <span style="color: #eedd82;">ctx</span>, <span style="color: #98fb98;">ByteBuf</span> <span style="color: #eedd82;">in</span>, <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Object</span>&gt; <span style="color: #eedd82;">out</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span> {
        out.add(in.readInt());  <span style="color: #ff4500;">//</span><span style="color: #ff4500;">2 &#20174;&#20837;&#31449; ByteBuf &#35835;&#21462;&#25972;&#22411;&#65292;&#24182;&#28155;&#21152;&#21040;&#35299;&#30721;&#28040;&#24687;&#30340; List &#20013;</span>
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-2-2" class="outline-5">
<h5 id="sec-1-1-2-2">更多 Decoder</h5>
<div class="outline-text-5" id="text-1-1-2-2">
<ul class="org-ul">
<li>io.netty.handler.codec.LineBasedFrameDecoder: 通过结束控制符( <b>\n</b> 或 <b>\r\n</b> )解析入站数据
</li>
<li>io.netty.handler.codec.http.HttpObjectDecoder: 用于 HTTP 数据解码
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">MessageToMessageDecoder</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
用于从一种消息解码为另外一种消息（例如 POJO 到 POJO），下表展示了方法：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> ByteToMessageDecoder 方法</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">方法</td>
<td class="left">描述</td>
</tr>

<tr>
<td class="left">decode</td>
<td class="left">decode is the only abstract method you need to implement. It is called for each inbound message to be decoded to another format . The decoded messages are then passed to the next ChannelInboundHandler in the pipeline</td>
</tr>

<tr>
<td class="left">decodeLast</td>
<td class="left">The default implementation provided simply calls decode().This method is called once, when the Channel goes inactive. Override to provide special handling</td>
</tr>
</tbody>
</table>

<p>
将 Integer 转为 String，提供了 IntegerToStringDecoder，继承自 MessageToMessageDecoder。因为这是一个参数化的类，所以实现的签名是：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">IntegerToStringDecoder</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">MessageToMessageDecoder</span>&lt;<span style="color: #98fb98;">Integer</span>&gt;
</pre>
</div>

<p>
decode() 方法的签名是：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">protected</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">decode</span>( <span style="color: #98fb98;">ChannelHandlerContext</span> <span style="color: #eedd82;">ctx</span>,
               <span style="color: #98fb98;">Integer</span> <span style="color: #eedd82;">msg</span>, <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Object</span>&gt; <span style="color: #eedd82;">out</span> ) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span>
</pre>
</div>

<p>
也就是说，入站消息是按照在 <b>类定义中声明的参数类型</b> (Integer) 而不是 ByteBuf来解析的。 <b>解码消息</b> (String)将被添加到List，并传递到下个 ChannelInboundHandler。 这是如图7.2所示：
</p>


<div class="figure">
<p><img src="pic/integer-to-string-decoder.jpg" alt="integer-to-string-decoder.jpg" width="70%" />
</p>
</div>

<p>
实现如下：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">IntegerToStringDecoder</span> <span style="color: #00ffff;">extends</span>
                    <span style="color: #98fb98;">MessageToMessageDecoder</span>&lt;<span style="color: #98fb98;">Integer</span>&gt; { <span style="color: #ff4500;">//</span><span style="color: #ff4500;">1 &#23454;&#29616;&#32487;&#25215;&#33258; MessageToMessageDecoder </span>

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">decode</span>(<span style="color: #98fb98;">ChannelHandlerContext</span> <span style="color: #eedd82;">ctx</span>, <span style="color: #98fb98;">Integer</span> <span style="color: #eedd82;">msg</span>, <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Object</span>&gt; <span style="color: #eedd82;">out</span>)
        <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span> {
        out.add(String.valueOf(msg)); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">2 &#36890;&#36807; String.valueOf() &#36716;&#25442; Integer &#28040;&#24687;&#23383;&#31526;&#20018;</span>
    }
}
</pre>
</div>

<p>
正如上面指出的：decode()方法的消息参数的类型是由给这个类指定的泛型的类型(Integer)确定的
</p>
</div>

<div id="outline-container-sec-1-1-3-1" class="outline-5">
<h5 id="sec-1-1-3-1">HttpObjectAggregator</h5>
<div class="outline-text-5" id="text-1-1-3-1">
<p>
更多复杂的示例，请查看类 io.netty.handler.codec.http.HttpObjectAggregator，继承自MessageToMessageDecoder
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">在解码时处理太大的帧</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
Netty 是异步框架需要缓冲区字节在内存中，直到能够解码它们。因此，不能让你的解码器缓存太多的数据以免耗尽可用内存。为了解决这个共同关心的问题， Netty 提供了一个 TooLongFrameException ，通常由解码器在帧太长时抛出
</p>

<p>
为了避免这个问题，可以在你的解码器里设置一个最大字节数阈值。如果超出，将导致 TooLongFrameException 抛出(并由 ChannelHandler.exceptionCaught() 捕获)。然后由译码器的用户决定如何处理它。虽然一些协议,比如 HTTP、允许这种情况下有一个特殊的响应,有些可能没有，事件唯一的选择可能就是关闭连接
</p>

<p>
如下所示 ByteToMessageDecoder 可以利用 TooLongFrameException 通知其他 ChannelPipeline 中的 ChannelHandler：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">SafeByteToMessageDecoder</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">ByteToMessageDecoder</span> {  <span style="color: #ff4500;">//</span><span style="color: #ff4500;">1 &#23454;&#29616;&#32487;&#25215; ByteToMessageDecoder &#26469;&#23558;&#23383;&#33410;&#35299;&#30721;&#20026;&#28040;&#24687;</span>
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">MAX_FRAME_SIZE</span> = 1024;

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">decode</span>(<span style="color: #98fb98;">ChannelHandlerContext</span> <span style="color: #eedd82;">ctx</span>, <span style="color: #98fb98;">ByteBuf</span> <span style="color: #eedd82;">in</span>,
               <span style="color: #98fb98;">List</span>&lt;<span style="color: #98fb98;">Object</span>&gt; <span style="color: #eedd82;">out</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">readable</span> = in.readableBytes();
        <span style="color: #00ffff;">if</span> (readable &gt; MAX_FRAME_SIZE) { <span style="color: #ff4500;">//</span><span style="color: #ff4500;">2 &#26816;&#27979;&#32531;&#20914;&#21306;&#25968;&#25454;&#26159;&#21542;&#22823;&#20110; MAX_FRAME_SIZE</span>
            in.skipBytes(readable);        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">3 &#24573;&#30053;&#25152;&#26377;&#21487;&#35835;&#30340;&#23383;&#33410;&#65292;&#24182;&#25243;&#20986; TooLongFrameException &#26469;&#36890;&#30693; ChannelPipeline &#20013;&#30340; ChannelHandler</span>
            <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">TooLongFrameException</span>(<span style="color: #ffa07a;">"Frame too big!"</span>);
        }
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">do something</span>
    }
}
</pre>
</div>

<p>
这种保护是很重要的，尤其是当你解码一个有可变帧大小的协议的时候 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Encoder</h3>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">抽象 Codec 类</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
