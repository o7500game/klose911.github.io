<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Effective Go</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Effective Go</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">格式化</a></li>
<li><a href="#sec-2">注释</a>
<ul>
<li><a href="#sec-2-1">包注释</a></li>
<li><a href="#sec-2-2">文档注释</a></li>
</ul>
</li>
<li><a href="#sec-3">命名</a>
<ul>
<li><a href="#sec-3-1">包名</a></li>
<li><a href="#sec-3-2">setter</a></li>
<li><a href="#sec-3-3">接口名</a></li>
<li><a href="#sec-3-4">驼峰记法</a></li>
</ul>
</li>
<li><a href="#sec-4">分号</a></li>
<li><a href="#sec-5">控制结构</a>
<ul>
<li><a href="#sec-5-1">if</a>
<ul>
<li><a href="#sec-5-1-1">重新声明与再次赋值</a></li>
</ul>
</li>
<li><a href="#sec-5-2">for</a></li>
<li><a href="#sec-5-3">switch</a>
<ul>
<li><a href="#sec-5-3-1">break</a></li>
<li><a href="#sec-5-3-2">类型选择</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">函数</a>
<ul>
<li><a href="#sec-6-1">多值返回</a></li>
<li><a href="#sec-6-2">可命名结果形参</a></li>
<li><a href="#sec-6-3">defer</a></li>
</ul>
</li>
<li><a href="#sec-7">数据</a>
<ul>
<li><a href="#sec-7-1">new 分配</a></li>
<li><a href="#sec-7-2">构造函数与复合字面</a></li>
<li><a href="#sec-7-3">make分配</a></li>
<li><a href="#sec-7-4">数组</a></li>
<li><a href="#sec-7-5">切片</a>
<ul>
<li><a href="#sec-7-5-1">二维切片</a></li>
</ul>
</li>
<li><a href="#sec-7-6">映射</a></li>
<li><a href="#sec-7-7">打印</a></li>
<li><a href="#sec-7-8">追加</a></li>
</ul>
</li>
<li><a href="#sec-8">初始化</a>
<ul>
<li><a href="#sec-8-1">常量</a></li>
<li><a href="#sec-8-2">变量</a></li>
<li><a href="#sec-8-3">初始化</a></li>
</ul>
</li>
<li><a href="#sec-9">方法</a>
<ul>
<li><a href="#sec-9-1">指针 vs 值</a></li>
</ul>
</li>
<li><a href="#sec-10">接口与其它类型</a>
<ul>
<li><a href="#sec-10-1">接口</a></li>
<li><a href="#sec-10-2">类型转换</a></li>
<li><a href="#sec-10-3">接口转换与类型断言</a></li>
<li><a href="#sec-10-4">通用性</a></li>
<li><a href="#sec-10-5">接口与方法</a></li>
</ul>
</li>
<li><a href="#sec-11">空白标识符</a>
<ul>
<li><a href="#sec-11-1">多重赋值中的空白标识符</a></li>
<li><a href="#sec-11-2">未使用的导入和变量</a></li>
<li><a href="#sec-11-3">为副作用而导入</a></li>
<li><a href="#sec-11-4">接口检查</a></li>
</ul>
</li>
<li><a href="#sec-12">内嵌</a></li>
<li><a href="#sec-13">并发</a>
<ul>
<li><a href="#sec-13-1">通过通信共享内存</a></li>
<li><a href="#sec-13-2">Go程</a></li>
<li><a href="#sec-13-3">信道</a></li>
<li><a href="#sec-13-4">信道中的信道</a></li>
<li><a href="#sec-13-5">并行化</a></li>
<li><a href="#sec-13-6">可能泄露的缓冲区</a></li>
</ul>
</li>
<li><a href="#sec-14">错误</a>
<ul>
<li><a href="#sec-14-1">panic</a></li>
<li><a href="#sec-14-2">恢复</a></li>
</ul>
</li>
<li><a href="#sec-15">一个Web服务器</a></li>
</ul>
</div>
</div>
<p>
Go 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用Go编程在本质上就不同于其它语言。将现有的C++或Java程序直译为Go 程序并不能令人满意。毕竟Java程序是用Java编写的，而不是Go。 另一方面，若从Go的角度去分析问题，你就能编写出同样可行但大不相同的程序。 换句话说，要想将Go程序写得好，就必须理解其特性和风格。了解命名、格式化、 程序结构等既定规则也同样重要，这样你编写的程序才能更容易被其他程序员所理解
</p>

<p>
本文档就如何编写清晰、地道的Go代码提供了一些技巧。它是对语言规范、 Go语言之旅以及 如何使用Go编程的补充说明
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">格式化</h2>
<div class="outline-text-2" id="text-1">
<p>
格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格， 但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范
</p>

<p>
在Go中另辟蹊径，让机器来处理大部分的格式化问题。 <b>gofmt</b> 程序（也可用 go fmt，它以包为处理对象而非源文件）将Go程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。若你想知道如何处理一些新的代码布局，请尝试运行 gofmt；若结果仍不尽人意，请重新组织你的程序（或提交有关 gofmt 的Bug），而不必为此纠结
</p>

<p>
举例来说，你无需花时间将结构体中的字段注释对齐，gofmt 将为你代劳。 假如有以下声明
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">T</span> <span style="color: #00ffff;">struct</span> {
     name string <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23545;&#35937;&#21517;</span>
           value int <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23545;&#35937;&#20540;</span>
}
</pre>
</div>

<p>
gofmt 会将它按列对齐为： 
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">T</span> <span style="color: #00ffff;">struct</span> {
        name    string <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23545;&#35937;&#21517;</span>
        value   int    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23545;&#35937;&#20540;</span>
}
</pre>
</div>

<p>
标准包中所有的Go代码都已经用 gofmt 格式化过了
</p>

<p>
还有一些关于格式化的细节，它们非常简短：
</p>
<ul class="org-ul">
<li>缩进：使用制表符（tab）缩进，gofmt 默认也使用它。在认为 <b>确实有必要时再使用空格</b>
</li>
<li>行的长度： <b>Go对行的长度没有限制</b> 。如果一行实在太长，也可进行折行并插入适当的tab缩进
</li>
<li>括号：比起C和Java，Go所需的括号更少：控制结构（if、for 和 switch）在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁
</li>
</ul>
<div class="org-src-container">

<pre class="src src-go">x&lt;&lt;8 + y&lt;&lt;16
</pre>
</div>
<p>
空格符表述了需要所传达的含义
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">注释</h2>
<div class="outline-text-2" id="text-2">
<p>
Go语言支持C风格的块注释 <i>* *</i> 和C++风格的行注释 //
</p>

<p>
<b>行注释更为常用，而块注释则主要用作包的注释</b> ，当然也可在禁用一大段代码时使用
</p>

<p>
<b>godoc</b> 既是一个程序，又是一个Web服务器，它对Go的源码进行处理，并提取包中的文档内容。 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。 这些注释的类型和风格决定了 godoc 生成的文档质量
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">包注释</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li><b>每个包都应包含一段包注释</b> ，即放置在包子句前的一个块注释
</li>
<li>对于包含多个文件的包， <b>包注释只需出现在其中的任一文件中即可</b> 
</li>
<li>包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 godoc 页面中的最上面，并为紧随其后的内容建立详细的文档

<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">/*</span>
<span style="color: #ff4500;">        regexp &#21253;&#20026;&#27491;&#21017;&#34920;&#36798;&#24335;&#23454;&#29616;&#20102;&#19968;&#20010;&#31616;&#21333;&#30340;&#24211;&#12290;</span>

<span style="color: #ff4500;">        &#35813;&#24211;&#25509;&#21463;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#35821;&#27861;&#20026;&#65306;</span>

<span style="color: #ff4500;">        &#27491;&#21017;&#34920;&#36798;&#24335;:</span>
<span style="color: #ff4500;">                &#20018;&#32852; { '|' &#20018;&#32852; }</span>
<span style="color: #ff4500;">        &#20018;&#32852;:</span>
<span style="color: #ff4500;">                { &#38381;&#21253; }</span>
<span style="color: #ff4500;">        &#38381;&#21253;:</span>
<span style="color: #ff4500;">                &#26465;&#30446; [ '*' | '+' | '?' ]</span>
<span style="color: #ff4500;">        &#26465;&#30446;:</span>
<span style="color: #ff4500;">                '^'</span>
<span style="color: #ff4500;">                '$'</span>
<span style="color: #ff4500;">                '.'</span>
<span style="color: #ff4500;">                &#23383;&#31526;</span>
<span style="color: #ff4500;">                '[' [ '^' ] &#23383;&#31526;&#36941;&#21382; ']'</span>
<span style="color: #ff4500;">                '(' &#27491;&#21017;&#34920;&#36798;&#24335; ')'</span>
<span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">package</span> regexp
</pre>
</div>
</li>

<li>若某个包比较简单，包注释同样可以简洁些
</li>
</ul>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">path &#21253;&#23454;&#29616;&#20102;&#19968;&#20123;&#24120;&#29992;&#30340;&#24037;&#20855;&#65292;&#20197;&#20415;&#20110;&#25805;&#20316;&#29992;&#21453;&#26012;&#26464;&#20998;&#38548;&#30340;&#36335;&#24452;.</span>
</pre>
</div>

<p>
注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示， 因此不要依赖于空格对齐，godoc 会像 gofmt 那样处理好这一切。 注释是不会被解析的纯文本，因此像HTML或其它类似于 <span class="underline">这样</span> 的东西将按照 原样 输出，因此不应使用它们。godoc 所做的调整， 就是将已缩进的文本以等宽字体显示，来适应对应的程序片段。 fmt 包的注释就用了这种不错的效果
</p>

<p>
godoc 是否会重新格式化注释取决于上下文，因此必须确保它们看起来清晰易辨： 使用正确的拼写、标点和语句结构以及折叠长行等
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">文档注释</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>在包中 <b>任何顶级声明前面的注释都将作为该声明的文档注释</b> 
</li>
<li>在程序中 <b>每个可导出（首字母大写）的名称都应该有文档注释</b>
</li>
<li>文档注释最好是 <b>完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要</b> 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Compile &#29992;&#20110;&#35299;&#26512;&#27491;&#21017;&#34920;&#36798;&#24335;&#24182;&#36820;&#22238;&#65292;&#22914;&#26524;&#25104;&#21151;&#65292;&#21017; Regexp &#23545;&#35937;&#23601;&#21487;&#29992;&#20110;&#21305;&#37197;&#25152;&#38024;&#23545;&#30340;&#25991;&#26412;&#12290;</span>
<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Compile</span>(str <span style="color: #98fb98;">string</span>) (regexp *<span style="color: #98fb98;">Regexp</span>, err <span style="color: #98fb98;">error</span>) {
</pre>
</div>

<ul class="org-ul">
<li>若注释总是以名称开头，godoc 的输出就能通过 <b>grep</b> 变得更加有用
</li>

<li>Go的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。 由于是整体声明，这种注释往往较为笼统
</li>
</ul>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#34920;&#36798;&#24335;&#35299;&#26512;&#22833;&#36133;&#21518;&#36820;&#22238;&#38169;&#35823;&#20195;&#30721;&#12290;</span>
<span style="color: #00ffff;">var</span> (
        ErrInternal      = errors.<span style="color: #87cefa;">New</span>(<span style="color: #ffa07a;">"regexp: internal error"</span>)
        ErrUnmatchedLpar = errors.<span style="color: #87cefa;">New</span>(<span style="color: #ffa07a;">"regexp: unmatched '('"</span>)
        ErrUnmatchedRpar = errors.<span style="color: #87cefa;">New</span>(<span style="color: #ffa07a;">"regexp: unmatched ')'"</span>)
        ...
)
</pre>
</div>

<ul class="org-ul">
<li>即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量
</li>
</ul>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">var</span> (
        countLock   sync.Mutex
        inputCount  uint32
        outputCount uint32
        errorCount  uint32
)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">命名</h2>
<div class="outline-text-2" id="text-3">
<p>
正如命名在其它语言中的地位，它在 Go 中同样重要。有时它们甚至会影响语义： 例如， <b>某个名称在包外是否可见，就取决于其首个字符是否为大写字母</b>  因此有必要花点时间来讨论Go程序中的命名约定
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">包名</h3>
<div class="outline-text-3" id="text-3-1">
<p>
当一个包被导入后， <b>包名就会成了内容的访问器</b>  
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">import</span> <span style="color: #ffa07a;">"bytes"</span>
</pre>
</div>

<p>
之后，被导入的包就能通过 <b>bytes.Buffer</b> 来引用了。 若所有人都以相同的名称来引用其内容将大有裨益， 这也就意味着包应当有个恰当的名称：其名称应该简洁明了而易于理解。按照惯例，  <b>包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法</b> 。err 的命名就是出于简短考虑的，因为任何使用该包的人都会键入该名称。 不必担心引用次序的冲突。 <b>包名就是导入时所需的唯一默认名称， 它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下， 也可为导入的包选择一个别名来局部使用</b> 无论如何，通过文件名来判定使用的包，都是不会产生混淆的
</p>

<p>
另一个约定就是包名应为其源码目录的基本名称。在 <b>src/pkg/encoding/base64</b> 中的包应作为  <b>encoding/base64</b> 导入，其包名应为 <b>base64</b>  而非 encoding<sub>base64</sub> 或 encodingBase64
</p>

<p>
包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。 （请勿使用 <b>import . 记法</b> ，它可以简化必须在被测试包外运行的测试， 除此之外应尽量避免使用）例如，bufio 包中的缓存读取器类型叫做 Reader 而非 BufReader，因为用户将它看做 <b>bufio.Reader</b> ，这是个清楚而简洁的名称。 此外，由于被导入的项总是通过它们的包名来确定，因此 bufio.Reader 不会与 io.Reader 发生冲突。同样，用于创建 ring.Ring 的新实例的函数（这就是Go中的构造函数）一般会称之为 <b>NewRing</b> ，但由于 Ring 是该包所导出的唯一类型，且该包也叫 ring，因此它可以只叫做 <b>New</b> ，它跟在包的后面，就像 <b>ring.New</b> 使用包结构可以帮助你选择好的名称
</p>

<p>
另一个简短的例子是 <b>once.Do</b> ，once.Do(setup) 表述足够清晰， 使用 <b>once.DoOrWaitUntilDone(setup)</b> 完全就是画蛇添足。 长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值 
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">setter</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Go并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但 <b>若要将 Get 放到获取器的名字中，既不符合习惯，也没有必要</b> 。*若你有个名为 owner （小写，未导出）的字段，其获取器应当名为 Owner（大写，可导出）而非 GetOwner* 。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 <b>若要提供设置器方法，SetOwner 是个不错的选择</b> 。两个命名看起来都很合理：
</p>
<div class="org-src-container">

<pre class="src src-go">owner := obj.<span style="color: #87cefa;">Owner</span>()
<span style="color: #00ffff;">if</span> owner != user {
        obj.<span style="color: #87cefa;">SetOwner</span>(user)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">接口名</h3>
<div class="outline-text-3" id="text-3-3">
<p>
按照约定， <b>只包含一个方法的接口应当以该方法的名称加上-er后缀来命名</b>  如 Reader、Writer、 Formatter、CloseNotifier 等。
</p>

<p>
诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。 Read、Write、Close、Flush、 String 等都具有典型的签名和意义。 <b>为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同</b> 。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 <b>请将字符串转换方法命名为 String 而非 ToString</b> 
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">驼峰记法</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Go中约定使用驼峰记法 <b>MixedCaps</b> 或 <b>mixedCaps</b> 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">分号</h2>
<div class="outline-text-2" id="text-4">
<p>
和C一样，Go的正式语法使用分号来结束语句；和C不同的是，这些分号并不在源码中出现。 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此因此源码中基本就不用分号了
</p>

<p>
规则是这样的： <b>若在新行前的最后一个标记为标识符（包括 int 和 float64 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一</b> 
</p>
<pre class="example">
break continue fallthrough return ++ -- ) }
</pre>

<p>
则词法分析将始终在该标记后面插入分号。这点可以概括为： <b>如果新行前的标记为语句的末尾，则插入分号</b> 
</p>

<p>
分号也可在闭括号之前直接省略，因此像 
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">go</span> <span style="color: #00ffff;">func</span>() { <span style="color: #00ffff;">for</span> { dst &lt;- &lt;-src } }()
</pre>
</div>

<p>
这样的语句无需分号。通常Go程序只在诸如 for 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开
</p>

<p>
警告： <b>无论如何，你都不应将一个控制结构（if、for、switch 或 select）的左大括号放在下一行</b> 如果这样做，就会在大括号前面插入一个分号，这可能引起不需要的效果。 你应该这样写 
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">if</span> i &lt; <span style="color: #87cefa;">f</span>() {
        <span style="color: #87cefa;">g</span>()
}
</pre>
</div>

<p>
而不是这样 
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">if</span> i &lt; <span style="color: #87cefa;">f</span>()  <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38169;&#65281;</span>
{           <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38169;&#65281;</span>
        <span style="color: #87cefa;">g</span>()
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">控制结构</h2>
<div class="outline-text-2" id="text-5">
<p>
Go中的结构控制与C有许多相似之处，但其不同之处才是独到之处：
</p>
<ul class="org-ul">
<li>Go不再使用 <b>do</b> 或 <b>while</b> 循环，只有一个更通用的 <b>for</b>
</li>
<li>switch 要更灵活一点, <b>if 和 switch 像 for一样可接受可选的初始化语句</b>
</li>
<li>一个包含类型选择和多路通信复用器的新控制结构：*select* 其语法也有些许不同 <b>没有圆括号，而其主体必须始终使用大括号括住</b> 
</li>
</ul>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">if</h3>
<div class="outline-text-3" id="text-5-1">
<p>
在Go中，一个简单的 if 语句看起来像这样： 
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">if</span> x &gt; 0 {
        <span style="color: #00ffff;">return</span> y
}
</pre>
</div>

<p>
强制的大括号促使你将简单的 if 语句分成多行。特别是在主体中包含 return 或 break 等控制语句时，这种编码风格的好处一比便知
</p>

<p>
由于 if 和 switch 可接受初始化语句， 因此 <b>用它们来设置局部变量十分常见</b> 
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">if</span> err := file.<span style="color: #87cefa;">Chmod</span>(0664); err != <span style="color: #7fffd4;">nil</span> {
        log.<span style="color: #87cefa;">Print</span>(err)
        <span style="color: #00ffff;">return</span> err
}
</pre>
</div>

<p>
在Go的库中，你会发现若 if 语句不会执行到下一条语句时，亦即其 <b>执行体 以 break、continue、goto 或 return 结束时，不必要的 else 会被省略</b> 
</p>

<div class="org-src-container">

<pre class="src src-go">f, err := os.<span style="color: #87cefa;">Open</span>(name)
<span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
        <span style="color: #00ffff;">return</span> err
}
<span style="color: #87cefa;">codeUsing</span>(f)
</pre>
</div>

<p>
下例是一种常见的情况，代码必须防范一系列的错误条件。若控制流成功继续， 则说明程序已排除错误。由于出错时将以return 结束， 之后的代码也就无需 else 了
</p>

<div class="org-src-container">

<pre class="src src-go">f, err := os.<span style="color: #87cefa;">Open</span>(name)
<span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
        <span style="color: #00ffff;">return</span> err
}
d, err := f.<span style="color: #87cefa;">Stat</span>()
<span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
        f.<span style="color: #87cefa;">Close</span>()
        <span style="color: #00ffff;">return</span> err
}
<span style="color: #87cefa;">codeUsing</span>(f, d)
</pre>
</div>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">重新声明与再次赋值</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
最后一个示例展示了短声明 := 如何使用。 调用了 os.Open 的声明为
</p>
<div class="org-src-container">

<pre class="src src-go">f, err := os.<span style="color: #87cefa;">Open</span>(name)
</pre>
</div>

<p>
该语句声明了两个变量 f 和 err。在几行之后，又通过 
</p>

<div class="org-src-container">

<pre class="src src-go">d, err := f.<span style="color: #87cefa;">Stat</span>()
</pre>
</div>

<p>
调用了 f.Stat。它看起来似乎是声明了 d 和 err。 注意 <b>尽管两个语句中都出现了 err，但这种重复仍然是合法的</b> ：err 在第一条语句中被声明，但在第二条语句中只是被再次赋值罢了。也就是说，调用 f.Stat 使用的是前面已经声明的 err，它只是被重新赋值了而已
</p>

<p>
在满足下列条件时，已被声明的变量 v 可出现在:= 声明中：
</p>
<ul class="org-ul">
<li>本次声明与已声明的 v 处于同一作用域中（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量§）
</li>
<li>在初始化中与其类型相应的值才能赋予 v，且在此次声明中至少另有一个变量是新声明的
</li>
</ul>

<p>
值得一提的是， <b>即便Go中的函数形参和返回值在词法上处于大括号之外， 但它们的作用域和该函数体仍然相同</b> 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">for</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Go的 for 循环类似于C，但却不尽相同
</p>

<ul class="org-ul">
<li><b>它统一了 for 和 while，不再有 do-while 了，它有三种形式，但只有一种需要分号</b>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#21516;C&#30340;for&#24490;&#29615;</span>
<span style="color: #00ffff;">for</span> init; condition; post { }

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#21516;C&#30340;while&#24490;&#29615;</span>
<span style="color: #00ffff;">for</span> condition { }

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22914;&#21516;C&#30340;for(;;)&#24490;&#29615;</span>
<span style="color: #00ffff;">for</span> { }
</pre>
</div>

<ul class="org-ul">
<li>简短声明能更容易在循环中声明下标变量：
</li>
</ul>
<div class="org-src-container">

<pre class="src src-go">sum := 0
<span style="color: #00ffff;">for</span> i := 0; i &lt; 10; i++ {
        sum += i
}
</pre>
</div>

<ul class="org-ul">
<li><b>若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， range 子句能够帮你轻松实现循环</b> 
</li>
</ul>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">for</span> key, value := <span style="color: #00ffff;">range</span> oldMap {
        newMap[key] = value
}
</pre>
</div>

<ul class="org-ul">
<li>若只需要该遍历中的第一个项（键或下标），去掉第二个就行了
</li>
</ul>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">for</span> key := <span style="color: #00ffff;">range</span> m {
        <span style="color: #00ffff;">if</span> key.<span style="color: #87cefa;">expired</span>() {
                <span style="color: #b0c4de;">delete</span>(m, key)
        }
}
</pre>
</div>

<ul class="org-ul">
<li>若你只需要该遍历中的第二个项（值），请使用空白标识符，即下划线来丢弃第一个值
</li>
</ul>
<div class="org-src-container">

<pre class="src src-go">sum := 0
<span style="color: #00ffff;">for</span> _, value := <span style="color: #00ffff;">range</span> array {
        sum += value
}
</pre>
</div>

<p>
对于字符串，range 能够提供更多便利。它能通过解析UTF-8， 将每个独立的Unicode码点分离出来。错误的编码将占用一个字节，并以符文U+FFFD来代替。 （名称 <b>符文</b> 和内建类型 <b>rune</b> 是Go对单个Unicode码点的成称谓。 详情见语言规范） 
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">for</span> pos, char := <span style="color: #00ffff;">range</span> <span style="color: #ffa07a;">"&#26085;&#26412;\x80&#35486;"</span> { <span style="color: #ff4500;">// </span><span style="color: #ff4500;">\x80 &#26159;&#20010;&#38750;&#27861;&#30340;UTF-8&#32534;&#30721;</span>
        fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"&#23383;&#31526; %#U &#22987;&#20110;&#23383;&#33410;&#20301;&#32622; %d\n"</span>, char, pos)
}
</pre>
</div>

<pre class="example">
字符 U+65E5 '日' 始于字节位置 0
字符 U+672C '本' 始于字节位置 3
字符 U+FFFD '?' 始于字节位置 6
字符 U+8A9E '語' 始于字节位置 7
</pre>

<ul class="org-ul">
<li>若想要在 for 中使用多个变量，应采用平行赋值的方式，它会拒绝 ++ 和 &#x2013;
</li>
</ul>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21453;&#36716; a</span>
<span style="color: #00ffff;">for</span> i, j := 0, <span style="color: #b0c4de;">len</span>(a)-1; i &lt; j; i, j = i+1, j-1 {
        a[i], a[j] = a[j], a[i]
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">switch</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Go的 <b>switch</b> 比C的更通用。 <b>其表达式无需为常量或整数</b> case 语句会自上而下逐一进行求值直到匹配为止。若 switch 后面没有表达式，它将匹配 true，因此，可以将 if-else-if-else 链写成一个 switch，这也更符合Go的风格
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">unhex</span>(c <span style="color: #98fb98;">byte</span>) <span style="color: #98fb98;">byte</span> {
        <span style="color: #00ffff;">switch</span> {
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'0'</span> &lt;= c &amp;&amp; c &lt;= <span style="color: #ffa07a;">'9'</span>:
                <span style="color: #00ffff;">return</span> c - <span style="color: #ffa07a;">'0'</span>
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'a'</span> &lt;= c &amp;&amp; c &lt;= <span style="color: #ffa07a;">'f'</span>:
                <span style="color: #00ffff;">return</span> c - <span style="color: #ffa07a;">'a'</span> + 10
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'A'</span> &lt;= c &amp;&amp; c &lt;= <span style="color: #ffa07a;">'F'</span>:
                <span style="color: #00ffff;">return</span> c - <span style="color: #ffa07a;">'A'</span> + 10
        }
        <span style="color: #00ffff;">return</span> 0
}
</pre>
</div>

<ul class="org-ul">
<li>switch 并不会自动下溯，但 case 可通过逗号分隔来列举相同的处理条件
</li>
</ul>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">shouldEscape</span>(c <span style="color: #98fb98;">byte</span>) <span style="color: #98fb98;">bool</span> {
        <span style="color: #00ffff;">switch</span> c {
        <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">' '</span>, <span style="color: #ffa07a;">'?'</span>, <span style="color: #ffa07a;">'&amp;'</span>, <span style="color: #ffa07a;">'='</span>, <span style="color: #ffa07a;">'#'</span>, <span style="color: #ffa07a;">'+'</span>, <span style="color: #ffa07a;">'%'</span>:
                <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>
        }
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>
}
</pre>
</div>
</div>
<div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1">break</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
break 语句可以使 switch 提前终止。不仅是 switch， 有时候也必须打破层层的循环。在Go中，我们只需将标签放置到循环外，然后 “蹦”到那里即可。下面的例子展示了二者的用法
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #7fffd4;">Loop</span>:
<span style="color: #00ffff;">for</span> n := 0; n &lt; <span style="color: #b0c4de;">len</span>(src); n += size {
        <span style="color: #00ffff;">switch</span> {
        <span style="color: #00ffff;">case</span> src[n] &lt; sizeOne:
                <span style="color: #00ffff;">if</span> validateOnly {
                        <span style="color: #00ffff;">break</span>
                }
                size = 1
                <span style="color: #87cefa;">update</span>(src[n])

        <span style="color: #00ffff;">case</span> src[n] &lt; sizeTwo:
                <span style="color: #00ffff;">if</span> n+1 &gt;= <span style="color: #b0c4de;">len</span>(src) {
                        err = errShortInput
                        <span style="color: #00ffff;">break</span> <span style="color: #7fffd4;">Loop</span>
                }
                <span style="color: #00ffff;">if</span> validateOnly {
                        <span style="color: #00ffff;">break</span>
                }
                size = 2
                <span style="color: #87cefa;">update</span>(src[n] + src[n+1]&lt;&lt;shift)
        }
}
</pre>
</div>

<p>
<b>continue 语句也能接受一个可选的标签，不过它只能在循环中使用</b> 
</p>

<p>
通过使用两个 switch 语句对字节数组进行比较：
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Compare &#25353;&#23383;&#20856;&#39034;&#24207;&#27604;&#36739;&#20004;&#20010;&#23383;&#33410;&#20999;&#29255;&#24182;&#36820;&#22238;&#19968;&#20010;&#25972;&#25968;&#12290;</span>
<span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#33509; a == b&#65292;&#21017;&#32467;&#26524;&#20026;&#38646;&#65307;&#33509; a &lt; b&#65307;&#21017;&#32467;&#26524;&#20026; -1&#65307;&#33509; a &gt; b&#65292;&#21017;&#32467;&#26524;&#20026; +1&#12290;</span>
<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Compare</span>(a, b []<span style="color: #98fb98;">byte</span>) <span style="color: #98fb98;">int</span> {
        <span style="color: #00ffff;">for</span> i := 0; i &lt; <span style="color: #b0c4de;">len</span>(a) &amp;&amp; i &lt; <span style="color: #b0c4de;">len</span>(b); i++ {
                <span style="color: #00ffff;">switch</span> {
                <span style="color: #00ffff;">case</span> a[i] &gt; b[i]:
                        <span style="color: #00ffff;">return</span> 1
                <span style="color: #00ffff;">case</span> a[i] &lt; b[i]:
                        <span style="color: #00ffff;">return</span> -1
                }
        }
        <span style="color: #00ffff;">switch</span> {
        <span style="color: #00ffff;">case</span> <span style="color: #b0c4de;">len</span>(a) &gt; <span style="color: #b0c4de;">len</span>(b):
                <span style="color: #00ffff;">return</span> 1
        <span style="color: #00ffff;">case</span> <span style="color: #b0c4de;">len</span>(a) &lt; <span style="color: #b0c4de;">len</span>(b):
                <span style="color: #00ffff;">return</span> -1
        }
        <span style="color: #00ffff;">return</span> 0
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2">类型选择</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
switch 也可用于判断接口变量的动态类型。如 <b>类型选择</b> 通过圆括号中的关键字 <b>type</b> 使用类型断言语法。若 switch 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">var</span> t <span style="color: #00ffff;">interface</span>{}
t = <span style="color: #87cefa;">functionOfSomeType</span>()
<span style="color: #00ffff;">switch</span> t := t.(<span style="color: #00ffff;">type</span>) {
<span style="color: #00ffff;">default</span>:
        fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"unexpected type %T"</span>, t)       <span style="color: #ff4500;">// </span><span style="color: #ff4500;">%T &#36755;&#20986; t &#26159;&#20160;&#20040;&#31867;&#22411;</span>
<span style="color: #00ffff;">case</span> bool:
        fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"boolean %t\n"</span>, t)             <span style="color: #ff4500;">// </span><span style="color: #ff4500;">t &#26159; bool &#31867;&#22411;</span>
<span style="color: #00ffff;">case</span> int:
        fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"integer %d\n"</span>, t)             <span style="color: #ff4500;">// </span><span style="color: #ff4500;">t &#26159; int &#31867;&#22411;</span>
<span style="color: #00ffff;">case</span> *bool:
        fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"pointer to boolean %t\n"</span>, *t) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">t &#26159; *bool &#31867;&#22411;</span>
<span style="color: #00ffff;">case</span> *int:
        fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"pointer to integer %d\n"</span>, *t) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">t &#26159; *int &#31867;&#22411;</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">函数</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">多值返回</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Go与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善C中一些笨拙的习惯： 将错误值返回（例如用 -1 表示 EOF）和修改通过地址传入的实参
</p>

<p>
在C中，写入操作发生的错误会用一个负数标记，而错误码会隐藏在某个不确定的位置。 而在Go中，Write 会返回写入的字节数以及一个错误： <span class="underline">是的，您写入了一些字节，但并未全部写入，因为设备已满</span> 。在 os 包中，File.Write 的签名为： 
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> (file *<span style="color: #98fb98;">File</span>) <span style="color: #87cefa;">Write</span>(b []<span style="color: #98fb98;">byte</span>) (n <span style="color: #98fb98;">int</span>, err <span style="color: #98fb98;">error</span>)
</pre>
</div>

<p>
正如文档所述，它返回写入的字节数，并在n != len(b) 时返回一个非 nil 的 error 错误值 
</p>

<ul class="org-ul">
<li>可以采用一种简单的方法。来避免为模拟引用参数而传入指针。 以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">nextInt</span>(b []<span style="color: #98fb98;">byte</span>, i <span style="color: #98fb98;">int</span>) (<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>) {
        <span style="color: #00ffff;">for</span> ; i &lt; <span style="color: #b0c4de;">len</span>(b) &amp;&amp; !<span style="color: #87cefa;">isDigit</span>(b[i]); i++ {
        }
        x := 0
        <span style="color: #00ffff;">for</span> ; i &lt; <span style="color: #b0c4de;">len</span>(b) &amp;&amp; <span style="color: #87cefa;">isDigit</span>(b[i]); i++ {
                x = x*10 + <span style="color: #87cefa;">int</span>(b[i]) - <span style="color: #ffa07a;">'0'</span>
        }
        <span style="color: #00ffff;">return</span> x, i
}
</pre>
</div>

<p>
可以像下面这样，通过它扫描输入的切片 b 来获取数字 
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">for</span> i := 0; i &lt; <span style="color: #b0c4de;">len</span>(b); {
        x, i = <span style="color: #87cefa;">nextInt</span>(b, i)
        fmt.<span style="color: #87cefa;">Println</span>(x)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">可命名结果形参</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Go函数的返回值或结果 <b>形参</b> 可被命名，并作为常规变量使用，就像传入的形参一样。 <b>命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值, 若该函数执行了一条不带实参的 return 语句，则结果形参的当前值将被返回</b> 
</p>

<p>
此名称不是强制性的，但它们能使代码更加简短清晰：它们就是文档。若我们命名了 nextInt 的结果，那么它返回的 int 就值如其意了 
</p>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">nextInt</span>(b []<span style="color: #98fb98;">byte</span>, pos <span style="color: #98fb98;">int</span>) (value, nextPos <span style="color: #98fb98;">int</span>) {
</pre>
</div>

<p>
由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 io.ReadFull 就是个很好的例子： 
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">ReadFull</span>(r <span style="color: #98fb98;">Reader</span>, buf []<span style="color: #98fb98;">byte</span>) (n <span style="color: #98fb98;">int</span>, err <span style="color: #98fb98;">error</span>) {
        <span style="color: #00ffff;">for</span> <span style="color: #b0c4de;">len</span>(buf) &gt; 0 &amp;&amp; err == <span style="color: #7fffd4;">nil</span> {
                <span style="color: #00ffff;">var</span> nr int
                nr, err = r.<span style="color: #87cefa;">Read</span>(buf)
                n += nr
                buf = buf[nr:]
        }
        <span style="color: #00ffff;">return</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#26080;&#38656;&#20889;return n, err</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">defer</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Go的 defer 语句用于预设一个函数调用（ <b>推迟执行函数</b> ）， 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是 <b>解锁互斥和关闭文件</b> 
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">Contents &#23558;&#25991;&#20214;&#30340;&#20869;&#23481;&#20316;&#20026;&#23383;&#31526;&#20018;&#36820;&#22238;&#12290;</span>
<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">Contents</span>(filename <span style="color: #98fb98;">string</span>) (<span style="color: #98fb98;">string</span>, <span style="color: #98fb98;">error</span>) {
        f, err := os.<span style="color: #87cefa;">Open</span>(filename)
        <span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
                <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">""</span>, err
        }
        <span style="color: #00ffff;">defer</span> f.<span style="color: #87cefa;">Close</span>()  <span style="color: #ff4500;">// </span><span style="color: #ff4500;">f.Close &#20250;&#22312;&#25105;&#20204;&#32467;&#26463;&#21518;&#36816;&#34892;&#12290;</span>

        <span style="color: #00ffff;">var</span> result []<span style="color: #98fb98;">byte</span>
        buf := <span style="color: #b0c4de;">make</span>([]<span style="color: #98fb98;">byte</span>, 100)
        <span style="color: #00ffff;">for</span> {
                n, err := f.<span style="color: #87cefa;">Read</span>(buf[0:])
                result = <span style="color: #b0c4de;">append</span>(result, buf[0:n]...) <span style="color: #ff4500;">// </span><span style="color: #ff4500;">append &#23558;&#22312;&#21518;&#38754;&#35752;&#35770;&#12290;</span>
                <span style="color: #00ffff;">if</span> err != <span style="color: #7fffd4;">nil</span> {
                        <span style="color: #00ffff;">if</span> err == io.EOF {
                                <span style="color: #00ffff;">break</span>
                        }
                        <span style="color: #00ffff;">return</span> <span style="color: #ffa07a;">""</span>, err  <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25105;&#20204;&#22312;&#36825;&#37324;&#36820;&#22238;&#21518;&#65292;f &#23601;&#20250;&#34987;&#20851;&#38381;&#12290;</span>
                }
        }
        <span style="color: #00ffff;">return</span> <span style="color: #87cefa;">string</span>(result), <span style="color: #7fffd4;">nil</span> <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#25105;&#20204;&#22312;&#36825;&#37324;&#36820;&#22238;&#21518;&#65292;f &#23601;&#20250;&#34987;&#20851;&#38381;&#12290;</span>
}
</pre>
</div>

<p>
推迟诸如 Close 之类的函数调用有两点好处：
</p>
<ol class="org-ol">
<li>它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时， 这种情况往往就会发生
</li>
<li>它意味着 <span class="underline">关闭</span> 离 <span class="underline">打开</span> 很近， 这总比将它放在函数结尾处要清晰明了
</li>
</ol>

<p>
<b>被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值</b> 这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">for</span> i := 0; i &lt; 5; i++ {
        <span style="color: #00ffff;">defer</span> fmt.<span style="color: #87cefa;">Printf</span>(<span style="color: #ffa07a;">"%d "</span>, i)
}
</pre>
</div>

<p>
被推迟的函数按照 <b>后进先出</b> （LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0。一个更具实际意义的例子是通过一种简单的方法， 用程序来跟踪函数的执行。可以编写一对简单的跟踪例程：
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">trace</span>(s <span style="color: #98fb98;">string</span>)   { fmt.<span style="color: #87cefa;">Println</span>(<span style="color: #ffa07a;">"entering:"</span>, s) }
<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">untrace</span>(s <span style="color: #98fb98;">string</span>) { fmt.<span style="color: #87cefa;">Println</span>(<span style="color: #ffa07a;">"leaving:"</span>, s) }

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20687;&#36825;&#26679;&#20351;&#29992;&#23427;&#20204;&#65306;</span>
<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">a</span>() {
        <span style="color: #87cefa;">trace</span>(<span style="color: #ffa07a;">"a"</span>)
        <span style="color: #00ffff;">defer</span> <span style="color: #87cefa;">untrace</span>(<span style="color: #ffa07a;">"a"</span>)
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20570;&#19968;&#20123;&#20107;&#24773;....</span>
</pre>
</div>

<p>
可以充分利用这个特点，即被推迟函数的实参在 defer 执行时才会被求值。 跟踪例程可针对反跟踪例程设置实参。以下例子：
</p>

<div class="org-src-container">

<pre class="src src-go"><span style="color: #00ffff;">func</span> <span style="color: #87cefa;">trace</span>(s <span style="color: #98fb98;">string</span>) <span style="color: #98fb98;">string</span> {
        fmt.<span style="color: #87cefa;">Println</span>(<span style="color: #ffa07a;">"entering:"</span>, s)
        <span style="color: #00ffff;">return</span> s
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">un</span>(s <span style="color: #98fb98;">string</span>) {
        fmt.<span style="color: #87cefa;">Println</span>(<span style="color: #ffa07a;">"leaving:"</span>, s)
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">a</span>() {
        <span style="color: #00ffff;">defer</span> <span style="color: #87cefa;">un</span>(<span style="color: #87cefa;">trace</span>(<span style="color: #ffa07a;">"a"</span>))
        fmt.<span style="color: #87cefa;">Println</span>(<span style="color: #ffa07a;">"in a"</span>)
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">b</span>() {
        <span style="color: #00ffff;">defer</span> <span style="color: #87cefa;">un</span>(<span style="color: #87cefa;">trace</span>(<span style="color: #ffa07a;">"b"</span>))
        fmt.<span style="color: #87cefa;">Println</span>(<span style="color: #ffa07a;">"in b"</span>)
        <span style="color: #87cefa;">a</span>()
}

<span style="color: #00ffff;">func</span> <span style="color: #87cefa;">main</span>() {
        <span style="color: #87cefa;">b</span>()
}
</pre>
</div>

<pre class="example">
entering: b
in b
entering: a
in a
leaving: a
leaving: b
</pre>

<p>
对于习惯其它语言中块级资源管理的程序员，defer 似乎有点怪异， 但它 <b>最有趣而强大的应用恰恰来自于其基于函数而非块的特点</b> 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">数据</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">new 分配</h3>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">构造函数与复合字面</h3>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">make分配</h3>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">数组</h3>
</div>

<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">切片</h3>
<div class="outline-text-3" id="text-7-5">
</div><div id="outline-container-sec-7-5-1" class="outline-4">
<h4 id="sec-7-5-1">二维切片</h4>
</div>
</div>

<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6">映射</h3>
</div>

<div id="outline-container-sec-7-7" class="outline-3">
<h3 id="sec-7-7">打印</h3>
</div>

<div id="outline-container-sec-7-8" class="outline-3">
<h3 id="sec-7-8">追加</h3>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">初始化</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">常量</h3>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">变量</h3>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">初始化</h3>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">方法</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">指针 vs 值</h3>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">接口与其它类型</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">接口</h3>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">类型转换</h3>
</div>

<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">接口转换与类型断言</h3>
</div>

<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4">通用性</h3>
</div>

<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5">接口与方法</h3>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">空白标识符</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">多重赋值中的空白标识符</h3>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">未使用的导入和变量</h3>
</div>

<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">为副作用而导入</h3>
</div>

<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4">接口检查</h3>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">内嵌</h2>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">并发</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">通过通信共享内存</h3>
</div>

<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">Go程</h3>
</div>

<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3">信道</h3>
</div>

<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4">信道中的信道</h3>
</div>

<div id="outline-container-sec-13-5" class="outline-3">
<h3 id="sec-13-5">并行化</h3>
</div>

<div id="outline-container-sec-13-6" class="outline-3">
<h3 id="sec-13-6">可能泄露的缓冲区</h3>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">错误</h2>
<div class="outline-text-2" id="text-14">
</div><div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">panic</h3>
</div>

<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">恢复</h3>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">一个Web服务器</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
