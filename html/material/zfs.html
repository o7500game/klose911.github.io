<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZFS文件系统</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">ZFS文件系统</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org27d9a2d">ZFS 简介</a>
<ul>
<li><a href="#org501e49f">存储池</a></li>
<li><a href="#org08684ce">即写即拷</a></li>
<li><a href="#org0944a5d">数据保护</a></li>
<li><a href="#orgd8a67a2">校验和</a></li>
<li><a href="#orgd07a798">快照和克隆</a></li>
<li><a href="#orgdcad2f6">可变块大小</a></li>
<li><a href="#org7751160">其他</a></li>
</ul>
</li>
<li><a href="#org775f725">入门</a>
<ul>
<li><a href="#orge6dbf5a">单个磁盘存储池</a></li>
<li><a href="#org70d9c75">RAID-Z</a></li>
<li><a href="#org9796e98">数据校验</a></li>
</ul>
</li>
<li><a href="#org81493e1">管理</a>
<ul>
<li><a href="#org59b0df8">zpool</a>
<ul>
<li><a href="#orgf69964d">创建和销毁存储池</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org27d9a2d" class="outline-2">
<h2 id="org27d9a2d">ZFS 简介</h2>
<div class="outline-text-2" id="text-org27d9a2d">
<p>
将 ZFS 称为文件系统有点名不副实，因为它在传统意义上不仅仅是个文件系统。ZFS 将 <span class="underline">逻辑卷管理器</span> 的概念与功能丰富的和 <span class="underline">可大规模扩展</span> 的文件系统结合起来。首先探索一些 ZFS 所基于的原则：
</p>
<ul class="org-ul">
<li>ZFS 使用 <b>池存储</b> 模型，而不是传统的基于卷的模型： ZFS 视存储为可根据需要动态分配（和缩减）的共享池。这优于传统模型，在传统模型中，文件系统位于卷上，使用独立卷管理器来管理这些资产</li>
<li>ZFS 内嵌入的是重要功能集
<ul class="org-ul">
<li>快照</li>
<li>即写即拷，克隆</li>
<li>连续完整性检查</li>
<li>通过 RAID-Z 的数据保护</li>
</ul></li>
<li>可以在 ZFS 卷的顶端使用其他的文件系统（如 ext4）：这意味着可以获得那些 ZFS 的功能，如独立文件系统中的快照（该文件系统可能并不直接支持它们）</li>
</ul>

<p>
ZFS 不只是组成有用文件系统的功能集合。相反，它是 <b>构建出色文件系统</b> 的集成和 <b>补充功能</b> 的集合
</p>
</div>
<div id="outline-container-org501e49f" class="outline-3">
<h3 id="org501e49f">存储池</h3>
<div class="outline-text-3" id="text-org501e49f">
<p>
ZFS 合并了 <b>卷管理</b> 功能来提取 <span class="underline">底层物理存储设备</span> 到文件系统：
</p>
<ul class="org-ul">
<li>ZFS 对存储池（zpools）进行操作，而不是直接查看物理块设备，存储池构建自 <span class="underline">虚拟驱动器</span> ，可由驱动器或驱动器的一部分物理地进行表示</li>
<li>可以动态构造这些池，甚至这些池正在活跃地使用时也可以</li>
</ul>
</div>
</div>
<div id="outline-container-org08684ce" class="outline-3">
<h3 id="org08684ce">即写即拷</h3>
<div class="outline-text-3" id="text-org08684ce">
<p>
ZFS 使用 <b>即写即拷</b> 模型来管理存储中的数据。虽然这意味着数据永远不会写入到位（从来没有被覆盖），而是写入新块并更新元数据来引用数据。即写即拷有利的原因有多个，不仅仅是因为它可以启用的快照和克隆等一些功能：
</p>
<ul class="org-ul">
<li>由于从来不覆盖数据，这可以更简单地确保存储 <b>永远不会处于不一致</b> 的状态：因为在新的写入操作完成以后较早的数据仍保留</li>
<li>这允许 ZFS 基于 <span class="underline">事务</span> ，且更容易实现类似原子操作等的功能</li>
<li>文件系统的所有写入都成为 <b>顺序写入</b> （因为始终进行重新映射）：避免存储中的热点并利用顺序写入的性能（比随机写入更快）</li>
</ul>
</div>
</div>
<div id="outline-container-org0944a5d" class="outline-3">
<h3 id="org0944a5d">数据保护</h3>
<div class="outline-text-3" id="text-org0944a5d">
<p>
可以使用 ZFS 的众多保护方案之一来保护由虚拟设备组成的存储池：
</p>
<ul class="org-ul">
<li><span class="underline">跨两个或多个设备</span> (RAID 1)来对池进行镜像</li>
<li>通过 <span class="underline">奇偶校验</span> 来保护该池（类似于 RAID 5）</li>
<li><span class="underline">跨动态带区宽度</span> 来镜像池</li>
</ul>

<p>
基于池中设备数量，ZFS 支持各种不同的的奇偶校验方案：
</p>
<ul class="org-ul">
<li>通过 RAID-Z (RAID-Z 1) 来保护三个设备</li>
<li>对于四个设备，可以使用 RAID-Z 2（双重奇偶校验，类似于 RAID6）</li>
<li>对于更大的保护来说，可以将 RAID-Z 3 用于更大数量的磁盘进行三重奇偶校验</li>
<li>为提高速度（不存在错误检测以外的数据保护），可以跨设备进行条带化（RAID 0）</li>
<li>可以创建条带化镜像（来镜像条带化设备），类似于 RAID 10</li>
</ul>

<pre class="example">
ZFS 的一个有趣属性随 RAID-Z、即写即拷事务和动态条带宽度的组合而来

在传统的 RAID 5 体系结构中，所有磁盘都必须在条带内具有其自己的数据，或者条带不一致
因为没有方法自动更新所有磁盘，所以这可能产生众所周知的 RAID 5 写入漏洞问题（其中在 RAID 集的驱动器中条带是不一致的）
假设 ZFS 处理事务且从不需要写入到位，则写入漏洞问题就消除了

此方法的另外一个便捷性体现在磁盘出现故障且需要重建时
传统的 RAID 5 系统使用来自该集中其他磁盘的数据来重建新驱动器的数据
RAID-Z 遍历可用的元数据以便只读取有关几何学的数据并避免读取磁盘上未使用的空间
随着磁盘变得更大以及重建次数的增加，此行为变得更加重要
</pre>
</div>
</div>
<div id="outline-container-orgd8a67a2" class="outline-3">
<h3 id="orgd8a67a2">校验和</h3>
<div class="outline-text-3" id="text-orgd8a67a2">
<p>
虽然数据保护提供了在故障时重新生成数据的能力，但是这并不涉及处于第一位的数据的有效性。ZFS 通过为写入的每个块的元数据生成 <span class="underline">32 位校验和</span> （或 256 位散列）解决了此问题：
</p>
<ul class="org-ul">
<li>在读取块时，将 <b>验证此校验和</b> 以避免静默数据损坏问题</li>
<li>在有数据保护（镜像或 AID-Z）的卷中，可自动读取或 <b>重新生成备用数据</b></li>
</ul>

<p>
在 ZFS 上校验和与元数据存储在一起，因此如果提供数据保护（RAID-Z） ，可以检测并更正错位写入
</p>
</div>
</div>
<div id="outline-container-orgd07a798" class="outline-3">
<h3 id="orgd07a798">快照和克隆</h3>
<div class="outline-text-3" id="text-orgd07a798">
<p>
由于 ZFS 的即写即拷性质，类似快照和克隆的功能变得易于提供。因为 ZFS 从不覆盖数据而是写入到新的位置，所以可以保护较早的数据（但是在不重要的情况下被标记为删除以逆转磁盘空间）：
</p>
<ul class="org-ul">
<li>快照：旧块的保存以便及时维护给定实例中的文件系统状态。这种方法也是空间有效的，因为无需复制（除非重新写入文件系统中的所有数据）
<ul class="org-ul">
<li>克隆：一种快照形式，在其中获取可写入的快照。在这种情况下，由每一个克隆共享初始的未写入块，且被写入的块仅可用于特定文件系统克隆</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdcad2f6" class="outline-3">
<h3 id="orgdcad2f6">可变块大小</h3>
<div class="outline-text-3" id="text-orgdcad2f6">
<p>
传统的文件系统由匹配后端存储（512 字节）的静态大小的块组成。ZFS 为各种不同的使用实现了 <span class="underline">可变块大小</span> （通常大小达到 128KB，但是您可以变更此值）：
</p>
<ul class="org-ul">
<li>可变块大小的一个重要使用是 <span class="underline">压缩</span> （因为压缩时的结果块大小理想情况下将小于初始大小）
<ul class="org-ul">
<li>除了提供更好的存储网络利用外，此功能也使存储系统中的 <b>浪费最小化</b> （因为传输更好的数据到存储需要更少的时间）</li>
</ul></li>
<li>支持可变块大小还意味着您可以针对所期望的特定工作量优化块大小，以便改进性能</li>
</ul>
</div>
</div>
<div id="outline-container-org7751160" class="outline-3">
<h3 id="org7751160">其他</h3>
<div class="outline-text-3" id="text-org7751160">
<p>
ZFS 并入了许多其他功能，如 <b>重复数据删除</b> （最小化数据重复）、 <b>可配置的复制</b> 、 <b>加密</b> 、 <b>缓存管理的自适应更换缓存</b> 以及 <b>在线磁盘清理</b> （标识并修复在不使用保护时可以修复的潜在错误）。它通过巨大的可扩展性来实现该功能，支持 16 千兆兆个字节的可寻址存储（2<sup>64</sup> 字节）
</p>
</div>
</div>
</div>
<div id="outline-container-org775f725" class="outline-2">
<h2 id="org775f725">入门</h2>
<div class="outline-text-2" id="text-org775f725">
</div>
<div id="outline-container-orge6dbf5a" class="outline-3">
<h3 id="orge6dbf5a">单个磁盘存储池</h3>
<div class="outline-text-3" id="text-orge6dbf5a">
<p>
在单个磁盘上创建一个简单， 非冗余的 ZFS， 使用 zpool 命令：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create example /dev/da0
</pre>
</div>

<p>
可以通过 df 的输出查看新的存储池：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ df

Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example
</pre>
</div>

<p>
这份输出清楚的表明了 example 存储池不仅创建成功而且被挂载了。 能像访问普通的文件系统那样访问它， 就像以下例子中演示的那样，用户能够在上面创建文件并浏览：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cd /example
$ ls

$ touch testfile
$ ls -al
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile
</pre>
</div>

<p>
遗憾的是这个存储池并没有利用到 ZFS 的任何特性。 在这个存储池上创建一个文件系统，并启用压缩：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs create example/compressed
$ zfs set <span style="color: #4eee94;">compression</span>=gzip example/compressed
</pre>
</div>

<p>
现在 example/compressed 是一个启用了压缩的 ZFS 文件系统了。 可以尝试复制一些大的文件到 /example/compressed
</p>

<p>
使用这个命令可以禁用压缩：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs set <span style="color: #4eee94;">compression</span>=off example/compressed
</pre>
</div>

<p>
使用如下的命令卸载这个文件系统，并用 df 工具确认：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs umount example/compressed
$ df

Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example
</pre>
</div>

<p>
重新挂在这个文件系统使之能被访问， 并用 df 确认：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs mount example/compressed
$ df

Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
</pre>
</div>

<p>
存储池与文件系统也可通过 mount 的输出查看：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mount

/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
example on /example (zfs, local)
example/data on /example/data (zfs, local)
example/compressed on /example/compressed (zfs, local)
</pre>
</div>

<p>
正如前面所提到的，ZFS 文件系统， 在创建之后就能像普通的文件系统那样使用。然而， 还有很多其他的特性是可用的。在下面的例子中， 将创建一个新的文件系统，data。 并要在上面存储些重要的文件， 所以文件系统需要被设置成把每一个数据块都保存两份拷贝：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs create example/data
$ zfs set <span style="color: #4eee94;">copies</span>=2 example/data
</pre>
</div>

<p>
现在可以再次使用 df 查看数据和空间的使用状况：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ df

Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data
</pre>
</div>

<p>
注意：存储池上的 <b>每一个文件系统都有着相同数量的可用空间</b>  
</p>
<pre class="example">
这就是在这些例子中使用 df 的原因， 是为了文件系统都是从相同的存储池取得它们所需的空间

ZFS 去掉了诸如卷和分区此类的概念， 并允许多个文件系统占用同一个存储池
</pre>

<p>
不再需要文件系统与存储池的时候能像这样销毁它们：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zfs destroy example/compressed
$ zfs destroy example/data
$ zpool destroy example
</pre>
</div>
</div>
</div>
<div id="outline-container-org70d9c75" class="outline-3">
<h3 id="org70d9c75">RAID-Z</h3>
<div class="outline-text-3" id="text-org70d9c75">
<p>
磁盘无法避免的会坏掉和停止运转。 当这块磁盘坏掉的时候，上面的数据都将丢失。 一个避免因磁盘损坏而丢失数据的方法是使用 RAID。ZFS 在它的存储池设计中支持这样的特性。假设存在 3 个 SCSI 设备， da0， da1 和 da2 。 使用如下的命令创建一个 RAID-Z 存储池：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create storage raidz da0 da1 da2
</pre>
</div>
</div>
</div>
<div id="outline-container-org9796e98" class="outline-3">
<h3 id="org9796e98">数据校验</h3>
<div class="outline-text-3" id="text-org9796e98">
<p>
ZFS 使用 <b>校验和</b> (checksum) 来检查存储数据的完整性。 这时在文件系统创建时 <b>自动启用</b> 的，可使用以下的命令禁用：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zfs set <span style="color: #4eee94;">checksum</span>=off storage/home
</pre>
</div>

<p>
这不是个明智的选择，因为校验和 不仅非常有用而且只需占用少量的存储空间。 并且启用它们也不会明显的消耗过多资源。 启用后就可以让 ZFS 使用校验和校验来检查数据的完整。 这个过程通常称为 <span class="underline">scrubbing</span> 。 可以使用以下的命令检查 storage 存储池里数据的完整性：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool scrub storage
</pre>
</div>

<p>
这个过程需花费相当长的时间，取决于存储的数据量。 而且 I/O 非常密集， 所以在任何时间只能执行一个这样的操作。 在 scrub 完成之后，状态就会被更新， 可使用如下的命令查看：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool status storage

pool: storage
state: ONLINE
scrub: scrub completed with 0 errors on Sat Aug 30 19:57:37 2008
config:

NAME        STATE     READ WRITE CKSUM
storage     ONLINE       0     0     0
raidz1    ONLINE       0     0     0
da0     ONLINE       0     0     0
da1     ONLINE       0     0     0
da2     ONLINE       0     0     0

errors: No known data errors
</pre>
</div>

<p>
这个例子中完成时间非常的清楚。 这个特性可以帮助你在很长的一段时间内确保数据的完整
</p>
</div>
</div>
</div>
<div id="outline-container-org81493e1" class="outline-2">
<h2 id="org81493e1">管理</h2>
<div class="outline-text-2" id="text-org81493e1">
<p>
ZFS 管理由两个工具组成：
</p>
<ul class="org-ul">
<li>zpool: 控制存储池和增加、删除、替换和管理磁盘</li>
<li>zfs: 增加、删除和管理文件系统和卷</li>
</ul>
</div>
<div id="outline-container-org59b0df8" class="outline-3">
<h3 id="org59b0df8">zpool</h3>
<div class="outline-text-3" id="text-org59b0df8">
</div>
<div id="outline-container-orgf69964d" class="outline-4">
<h4 id="orgf69964d">创建和销毁存储池</h4>
<div class="outline-text-4" id="text-orgf69964d">
<p>
创建一个ZFS寸尺池包含许多预先的设定，因为存储池的结构在创建之后是没法改变的。 最重要的决定是什么类型的虚拟磁盘(vdev)来构成物理磁盘。一旦存储池构建完毕后，绝大多数类型的虚拟磁盘不允许添加额外的物理磁盘，例外是镜像(mirrors)和条带（stripe: 可以从镜像升级）。尽管额外的虚拟磁盘可以被添加到存储池，但是存储池的布局在创建存储池之后仍然不会被改变。因此，在销毁和重建存储池之前必须备份 
</p>

<p>
创建一个简单的镜像池：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ zpool create mypool mirror /dev/ada1 /dev/ada2
$ zpool status

pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors
</pre>
</div>

<p>
多个虚拟磁盘可以被同时创建，之间用 <span class="underline">虚拟磁盘类型</span> 来分割：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors
</pre>
</div>

<p>
存储池可以使用分区来构建，而不是使用整块硬盘，使用分区来创建 RAID-Z2 存储池：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3
$ zpool status

  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors

</pre>
</div>

<p>
存储池可以被销毁来回收空间。 销毁存储池之间必须把
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
