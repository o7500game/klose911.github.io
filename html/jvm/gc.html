<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>垃圾回收器</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="memory.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">垃圾回收器</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">对象存活判定</a>
<ul>
<li><a href="#sec-1-1">引用计数算法</a></li>
<li><a href="#sec-1-2">可达性分析算法</a>
<ul>
<li><a href="#sec-1-2-1">引用</a></li>
<li><a href="#sec-1-2-2">生存还是死亡</a></li>
</ul>
</li>
<li><a href="#sec-1-3">回收方法区</a></li>
</ul>
</li>
<li><a href="#sec-2">垃圾回收算法</a>
<ul>
<li><a href="#sec-2-1">标记-清除算法</a></li>
<li><a href="#sec-2-2">复制算法</a>
<ul>
<li><a href="#sec-2-2-1">改进的复制算法</a></li>
</ul>
</li>
<li><a href="#sec-2-3">标记-整理算法</a></li>
<li><a href="#sec-2-4">分代收集</a></li>
</ul>
</li>
<li><a href="#sec-3">垃圾收集器</a>
<ul>
<li><a href="#sec-3-1">Serial</a></li>
<li><a href="#sec-3-2">ParNew收集器</a></li>
<li><a href="#sec-3-3">Parallel Scavenge 收集器</a></li>
<li><a href="#sec-3-4">Serial Old收集器</a></li>
<li><a href="#sec-3-5">Parallel Old收集器</a></li>
<li><a href="#sec-3-6">CMS收集器</a>
<ul>
<li><a href="#sec-3-6-1">优点</a></li>
<li><a href="#sec-3-6-2">缺点</a></li>
</ul>
</li>
<li><a href="#sec-3-7">G1收集器</a></li>
<li><a href="#sec-3-8">GC日志</a></li>
<li><a href="#sec-3-9">GC参数</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
上一章介绍了Java内存运行时区域的各个部分,其中 <b>程序计数器</b> 、 <b>虚拟机栈</b> 、 <b>本地方法栈</b> 3个区域随线程而生,随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。因此这几个区域的内存分配和回收都具备确定性,在这几个区域内就不需要过多考虑回收的问题 ,因为方法结束或者线程结束时,内存自然就跟随着回收了。而 <b>Java堆</b> 和 <b>方法区</b> 则不一样，一个接口中的多个实现类需要的内存可能不一样,一个方法中的多个分支需要的内存也可能不一样,只有在程序处于运行期间时才能知道会创建哪些对象,这部分内存的分配和回收都是动态的,垃圾收集器所关注的是这部分内存
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">对象存活判定</h2>
<div class="outline-text-2" id="text-1">
<p>
在堆里面存放着Java世界中几乎所有的对象实例,垃圾收集器在对堆进行回收前,第一件事情就是要确定这些对象之中哪些还 <span class="underline">存活</span> 着 ,哪些已经 <span class="underline">死去</span> (即不可能再被任何途径使用的对象)
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">引用计数算法</h3>
<div class="outline-text-3" id="text-1-1">
<p>
为每个对象中添加一个引用计数器：
</p>
<ul class="org-ul">
<li>每当有—个地方引用它时,计数器值就加1
</li>
<li>当引用失效时,计数器值就减1
</li>
<li>任何时刻计数器为0的对象就是不可能再被使用的
</li>
</ul>

<p>
客观地说,引用计数算法的实现简单,判定效率也很高,在大部分情况下它都是一个不错的算法,也有一些比较著名的应用案例,例如微软公司的COM技术、使用ActionScript 3, Python等都使用了引用计数算法进行内存管理。但是至少主流的Java虚拟机里面没有选用引用计数算法来管理内存,其中最主要的原因是它 <b>很难解决对象之间相互循环引用的问题</b> 
</p>

<p>
举个简单的例子,下面代码中的 <span class="underline">testGC()</span> 方法:对象objA和objB都有字段 <span class="underline">instance</span> , 赋值令 <b>objA.instance=objB</b> 及 <b>objB.instance=objA</b> 。此外,这两个对象再无任何引用 ,实际上这两个对象已经不可能再被访问,但是它们因为互相引用着对方,导致它们的引用计数都不为0,于是引用计数算法无法通知GC收集器回收它们
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * testGC()&#26041;&#27861;&#25191;&#34892;&#21518;&#65292;objA&#21644;objB&#20250;&#19981;&#20250;&#34987;GC&#21602;&#65311; </span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@author</span><span style="color: #ffa07a;"> zzm</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ReferenceCountingGC</span> {

        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">instance</span> = <span style="color: #7fffd4;">null</span>;

        <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">_1MB</span> = 1024 * 1024;

        <span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">         * &#36825;&#20010;&#25104;&#21592;&#23646;&#24615;&#30340;&#21807;&#19968;&#24847;&#20041;&#23601;&#26159;&#21344;&#28857;&#20869;&#23384;&#65292;&#20197;&#20415;&#22312;&#33021;&#22312;GC&#26085;&#24535;&#20013;&#30475;&#28165;&#26970;&#26159;&#21542;&#26377;&#22238;&#25910;&#36807;</span>
<span style="color: #ffa07a;">         */</span>
        <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">bigSize</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[2 * _1MB];

        <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">testGC</span>() {
                <span style="color: #98fb98;">ReferenceCountingGC</span> <span style="color: #eedd82;">objA</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ReferenceCountingGC</span>();
                <span style="color: #98fb98;">ReferenceCountingGC</span> <span style="color: #eedd82;">objB</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ReferenceCountingGC</span>();
                objA.instance = objB;
                objB.instance = objA;

                objA = <span style="color: #7fffd4;">null</span>;
                objB = <span style="color: #7fffd4;">null</span>;

                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20551;&#35774;&#22312;&#36825;&#34892;&#21457;&#29983;GC&#65292;objA&#21644;objB&#26159;&#21542;&#33021;&#34987;&#22238;&#25910;&#65311;</span>
                System.gc();
        }
}
</pre>
</div>

<pre class="example">
[Fu11 GC(System)[Tenured:0 K-&gt;210K(10240K),0.0149142 secs]4603K-&gt;21OK(19456K),[Perm:2999K-&gt; 2999K(2124 8K )] ,0.0150007 secs] [Times :user=0.01 sys=0.00 ,real=0.02 secs ]                                                                                                                                                                                                                                                                                         
Heap                                                                                                                                                                                                                                                                                                                                                                                                                                                               
def new generation total 9216K,used 82K[0x00000000055e0000 ,0x0000000005feO000 ,0x0000000005feOO00 )                                                                                                                                                                                                                                                                                                                                                               
Eden space 8192K ,llused[0x00000000055e0000 ,0x00000000055f4850 ,0x0000000005de0000 )                                                                                                                                                                                                                                                                                                                                                                              
from space 1024K, Olusedf0x0000000005de0000 ,0x0000000005de0000 ,0x0000000005ee0000 )                                                                                                                                                                                                                                                                                                                                                                              
to space 1024K ,0lused[0x0000000005ee0000 ,0x0000000005ee0000 ,0x0000000005fe0000 )                                                                                                                                                                                                                                                                                                                                                                                
tenured generation total 1024OK,used 21OK[0x0000000005feO000 ,0x00000000069e0000 ,0x00000000069e0000 ) the space 10240K ,2lused[0x0000000005fe0000 ,0x0000000006014al8 ,0x0000000006014cO0 ,0x00000000069e0000 ) compacting perm gen total 21248K,used 3016K[0x00000000069e0000 ,0x0000000007ea0000 ,0x00000000ObdeO000 ) the space 21248K ,14lused[0x00000000069e0000 ,0x0000000006cd2398 ,0x0000000006cd2400 ,0x0000000007ea0000 ) Mo shared spaces configured.  
</pre>


<p>
从运行结果中可以清楚看到，GC日志中包含 <span class="underline">4603K-&gt;210K</span> ,意味着虚拟机并没有因为这两个对象互相引用就不回收它们,这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">可达性分析算法</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在主流的商用程序语言的主流实现中, 都是称通过可达性分析来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为 <span class="underline">GC Roots</span> 的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的。如下图所示,对象 <span class="underline">object 5</span> 、 <span class="underline">object 6</span> 、 <span class="underline">object 7</span> 虽然互相有矣联,但是它们到GC Roots是不可达的 ,所以它们将会被判定为是 <b>可回收的对象</b> 
</p>


<div class="figure">
<p><img src="pic/gc-root.png" alt="gc-root.png" width="70%" /> 
</p>
</div>


<p>
在Java语言中可作为 <b>GC Roots</b> 的对象包括下面几种:
</p>
<ul class="org-ul">
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象
</li>
<li>方法区中类静态属性引用的对象
</li>
<li>方法区中常量引用的对象
</li>
<li>本地方法栈中JNI(native方法)引用的对象
</li>
</ul>
</div>


<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">引用</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与 <b>引用</b> <span class="underline">reference</span> 有关。在JDK1.2之后，Java对引用的概念进行了扩充：
</p>
<ul class="org-ul">
<li><b>强引用</b> ：在程序代码之中普遍存在的，类似 <span class="underline">Object object = new Object()</span> 这类的引用， <b>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</b>
</li>
<li><b>软引用</b> ：描述一些还在用但并非必需的对象。对于软引用关联着的对象，在 <b>系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收</b> ，如果这次回收完成还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后提供了 <span class="underline">SoftReference</span> 类来实现软引用
</li>
<li><b>弱引用</b> ：描述非必需对象的，但是它的强度比软引用要更弱一些， <b>被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</b> 。在JDK1.2之后提供了 <span class="underline">WeakReference</span> 类来实现弱引用
</li>
<li><b>虚引用</b> ：　也称为 <span class="underline">幻影引用</span> ，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 <b>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</b> 。在JDK1.2之后提供了 <span class="underline">PhantomReference</span> 类来实现虚引用。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">生存还是死亡</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
即使在可达性分析算法中不可达的对象, 也并非是 <span class="underline">非死不可</span> 的, 这时候它们暂时处于 <span class="underline">缓刑</span> 阶段, 要真正宣告一个对象死亡, 至少要经历两次标记过程: 
</p>
<ul class="org-ul">
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被 <b>第一次标记并且进行一次筛选</b> , 筛选的条件是 <b>此对象是否有必要执行finalize()方法</b> 
<ul class="org-ul">
<li>当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为 <span class="underline">没有必要执行</span>
</li>
<li>如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做 <b>F-Queue</b> 的队列之中
<ul class="org-ul">
<li>稍后由一个由虚拟机自动建立的、低优先级的 <b>Finalizer线程</b> 去执行它。所谓的 <span class="underline">执行</span> 是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是： <b>如果一个对象在finalize()方法中执行缓慢,或者发生了死循环将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃</b>
</li>
<li>finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对 <b>F-Queue中的对象进行第二次小规模的标记</b>
<ul class="org-ul">
<li>如果对象要在finalize()中成功拯救自己: 只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将被移除出 <span class="underline">即将回收</span> 的集合
</li>
<li>如果对象这时候还没有逃脱,那基本上它就真的被回收了
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>
下面代码中可以看到一个对象的finalize()被执行,但是它仍然可以存活：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#27492;&#20195;&#30721;&#28436;&#31034;&#20102;&#20004;&#28857;&#65306; </span>
<span style="color: #ffa07a;"> * 1.&#23545;&#35937;&#21487;&#20197;&#22312;&#34987;GC&#26102;&#33258;&#25105;&#25327;&#25937;&#12290; </span>
<span style="color: #ffa07a;"> * 2.&#36825;&#31181;&#33258;&#25937;&#30340;&#26426;&#20250;&#21482;&#26377;&#19968;&#27425;&#65292;&#22240;&#20026;&#19968;&#20010;&#23545;&#35937;&#30340;finalize()&#26041;&#27861;&#26368;&#22810;&#21482;&#20250;&#34987;&#31995;&#32479;&#33258;&#21160;&#35843;&#29992;&#19968;&#27425;</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@author</span><span style="color: #ffa07a;"> zzm</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">FinalizeEscapeGC</span> {

        <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">FinalizeEscapeGC</span> <span style="color: #eedd82;">SAVE_HOOK</span> = <span style="color: #7fffd4;">null</span>;

        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">isAlive</span>() {
                System.out.println(<span style="color: #ffa07a;">"yes, i am still alive :)"</span>);
        }

        <span style="color: #7fffd4;">@Override</span>
        <span style="color: #00ffff;">protected</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">finalize</span>() <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Throwable</span> {
                <span style="color: #00ffff;">super</span>.finalize();
                System.out.println(<span style="color: #ffa07a;">"finalize mehtod executed!"</span>);
                <span style="color: #7fffd4;">FinalizeEscapeGC</span>.SAVE_HOOK = <span style="color: #00ffff;">this</span>;
        }

        <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Throwable</span> {
                SAVE_HOOK = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">FinalizeEscapeGC</span>();

                <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23545;&#35937;&#31532;&#19968;&#27425;&#25104;&#21151;&#25327;&#25937;&#33258;&#24049;</span>
                SAVE_HOOK = <span style="color: #7fffd4;">null</span>;
                System.gc();
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22240;&#20026;Finalizer&#26041;&#27861;&#20248;&#20808;&#32423;&#24456;&#20302;&#65292;&#26242;&#20572;0.5&#31186;&#65292;&#20197;&#31561;&#24453;&#23427;</span>
                Thread.sleep(500);
                <span style="color: #00ffff;">if</span> (SAVE_HOOK != <span style="color: #7fffd4;">null</span>) {
                        SAVE_HOOK.isAlive();
                } <span style="color: #00ffff;">else</span> {
                        System.out.println(<span style="color: #ffa07a;">"no, i am dead :("</span>);
                }

                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#19979;&#38754;&#36825;&#27573;&#20195;&#30721;&#19982;&#19978;&#38754;&#30340;&#23436;&#20840;&#30456;&#21516;&#65292;&#20294;&#26159;&#36825;&#27425;&#33258;&#25937;&#21364;&#22833;&#36133;&#20102;</span>
                SAVE_HOOK = <span style="color: #7fffd4;">null</span>;
                System.gc();
                <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#22240;&#20026;Finalizer&#26041;&#27861;&#20248;&#20808;&#32423;&#24456;&#20302;&#65292;&#26242;&#20572;0.5&#31186;&#65292;&#20197;&#31561;&#24453;&#23427;</span>
                Thread.sleep(500);
                <span style="color: #00ffff;">if</span> (SAVE_HOOK != <span style="color: #7fffd4;">null</span>) {
                        SAVE_HOOK.isAlive();
                } <span style="color: #00ffff;">else</span> {
                        System.out.println(<span style="color: #ffa07a;">"no, i am dead :("</span>);
                }
        }
}
</pre>
</div>

<pre class="example">
finalize mehtod executed ! 
yes,i am still alive : )
no,i am dead : (
</pre>

<ul class="org-ul">
<li>SAVE<sub>HOOK对象的finalize</sub>()方法确实被GC收集器触发过,并且在被收集前成功逃脱了
</li>
<li>代码中有两段完全一样的代码片段,执行结果却是一次逃脱成功,一次失败,这是因为 <b>任何一个对象的finalize()方法都只会被系统自动调用一次</b> , 如果对象面临下一次回收,它的finalize()方法不会被再次执行,因此第二段代码的自救行动失败了
</li>
</ul>

<pre class="example">
建议大家尽量避免使用finalize方法,因为它不是C/C++中的析构函数,而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协

它的运行代价高昂,不确定性大,无法保证各个对象的调用顺序

finalize()能做的所有工作,使用try-finally或者其他方式都可以做得更好，更及时
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">回收方法区</h3>
<div class="outline-text-3" id="text-1-3">
<p>
很多人认为方法区(以前的永久代)是没有垃圾收集的,Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集,而且在方法区中进行垃圾收集的 <span class="underline">性价比</span> 一般比较低。在堆中尤其是在新生代中,常规应用进行一次垃圾收集一般可以回收70%〜95%的空间,而永久代的垃圾收集效率远低于此
</p>

<p>
永久代的垃圾收集主要回收两部分内容:
</p>
<ul class="org-ul">
<li>废弃常量
</li>
<li>无用的类
</li>
</ul>

<p>
回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例,假如一个字符串 <span class="underline">abc</span> 已经进入了常量池中,但是当前系统没有任何一个String对象是叫做 <span class="underline">abc</span> 的，换句话说就是没有任何String对象引用常量池中的 <span class="underline">abc</span> 常量, 也没有其他地方引用了这个字面量,如果这时发生内存回收,而且必要的话,这个 <span class="underline">abc</span> 常量就会被系统清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似
</p>

<p>
判定一个常量是否是 <span class="underline">废弃常量</span> 比较简单,而要判定一个类是否是 <span class="underline">无用的类</span> 的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 <span class="underline">无用的类</span> :
</p>
<ol class="org-ol">
<li>该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例
</li>
<li>加载该类的ClassLoader已经被回收
</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法
</li>
</ol>

<p>
虚拟机可以对满足上述3个条件的无用类进行回收,这里说的仅仅是 <b>可以</b> ,而并不是和对象一样,不使用了就必然会回收。是否对类进行回收,HotSpot虚拟机提供了 <span class="underline">-XX:noclassgc</span> 参数进行控制 ,还可以使用 <span class="underline">-verbose:class</span> 以及 <span class="underline">-XX:+TraceClassLoading</span> 、 <span class="underline">-XX:+TraceClassUnLoading</span> 查看类加载和卸载信息,其中 <span class="underline">-verbose:class</span> 和 <span class="underline">-XX:+TraceClassLoading</span> 可以在 <b>Product</b> 版的虚拟机中使用, <span class="underline">-XX:+TraceClassUnLoading</span> 参数需要 <b>FastDebug</b> 版的虚拟机支持
</p>

<pre class="example">
  在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">垃圾回收算法</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">标记-清除算法</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<b>标记—清除</b> 算法是最基础的收集算法，它分为 <b>标记</b> 和 <b>清除</b> 两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。标记—清除算法的执行情况如下图所示：
</p>

<ul class="org-ul">
<li>回收前状态：

<div class="figure">
<p><img src="pic/mark.png" alt="mark.png" width="70%" />
</p>
</div>
</li>

<li>回收后状态：

<div class="figure">
<p><img src="pic/swept.png" alt="swept.png" width="70%" />
</p>
</div>
</li>
</ul>


<p>
该算法有如下缺点：
</p>
<ol class="org-ol">
<li>标记和清除过程的 <b>效率都不高</b> 
</li>
<li>标记清除后会 <b>产生大量不连续的内存碎片</b> ，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">复制算法</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<b>复制算法</b> 是针对 <span class="underline">标记—清除</span> 算法的缺点，在其基础上进行改进而得到的，它将可用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉
</p>

<ul class="org-ul">
<li>回收前状态：

<div class="figure">
<p><img src="pic/before-copy.png" alt="before-copy.png" width="70%" />
</p>
</div>
</li>

<li>回收后状态：

<div class="figure">
<p><img src="pic/after-copy.png" alt="after-copy.png" width="70%" />
</p>
</div>


<div class="figure">
<p><img src="pic/gc-copy.png" alt="gc-copy.png" width="70%" />
</p>
</div>
</li>
</ul>

<p>
优点：
</p>
<ol class="org-ol">
<li>每次 <span class="underline">只对一块内存</span> 进行回收， <b>运行高效</b> 
</li>
<li>只需 <span class="underline">移动栈顶指针</span> ，按顺序分配内存即可， <b>实现简单</b> 
</li>
<li>内存回收时 <b>不用考虑内存碎片</b> 的出现
</li>
</ol>

<p>
缺点：
</p>
<ul class="org-ul">
<li>可一次性分配的最大内存缩小了一半
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">改进的复制算法</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
根据新生代的特点，98%的对象朝生夕死，并不需要按照1:1的比例来划分内存空间，而是将内存划分为 <b>一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor</b> 。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间，最后清理掉Eden和刚才用过的Survivor空间，清理完成后，刚刚被清理的Eden和另一块在回收时放入存活对象的Survivor空间作为使用内存，刚被清理的Survivor作为保留空间，以便后面用来回收之用。
</p>

<p>
这种改进的收集算法也有一个问题，就是在回收时那块空的Survivor空间能否放得下Eden和使用的Survivor空间中还存活的对象， <b>如果Survivor空间不够存放上一次新生代收集下来的存活对象</b> ，此时就需要向老年代 <span class="underline">借</span> 内存，那些剩余未放下的对象就通过分配担保机制进入老年代
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">标记-整理算法</h3>
<div class="outline-text-3" id="text-2-3">
<p>
复制算法如果 <b>在对象存活率较高时，就需要进行较多次的复制操作</b> ，效率也会变低。而对于老年代中的对象，一般存活率都较高，因此需要选用其他收集算法： <b>标记-整理</b> 算法。标记过程仍然与 <span class="underline">标记-清除</span> 算法中一样，但是在标记完成后并不直接对可回收对象进行清理，而是 <b>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</b> 。算法示意图如下：
</p>

<ul class="org-ul">
<li>回收前状态：

<div class="figure">
<p><img src="pic/before-compact.png" alt="before-compact.png" width="70%" />
</p>
</div>
</li>

<li>回收后状态：

<div class="figure">
<p><img src="pic/after-compact.png" alt="after-compact.png" width="70%" />
</p>
</div>


<div class="figure">
<p><img src="pic/gc-mark-compact.png" alt="gc-mark-compact.png" width="70%" />
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">分代收集</h3>
<div class="outline-text-3" id="text-2-4">
<p>
当前商业虚拟机的垃圾收集 都采用 <b>分代收集</b> ，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为 <b>新生代</b> 和 <b>老年代</b> 。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用 <span class="underline">复制算法</span> 来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 <span class="underline">标记—清除</span> 算法或 <span class="underline">标记—整理</span> 算法来进行回收
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">垃圾收集器</h2>
<div class="outline-text-2" id="text-3">
<p>
垃圾收集器是垃圾收集算法的具体实现。Java规范对垃圾收集器的实现没有做任何规定，因此不同的虚拟机提供的垃圾收集器可能有很大差异。HotSpot虚拟机1.7版本使用了多种收集器。如下图：
</p>


<div class="figure">
<p><img src="pic/jvm-gc.jpg" alt="jvm-gc.jpg" width="70%" />
</p>
</div>

<p>
共有7种作用不不同分代的收集器，其中
</p>
<ul class="org-ul">
<li>新生代：
<ul class="org-ul">
<li>Serial
</li>
<li>ParNew
</li>
<li>Parallel Scavenge
</li>
<li>G1
</li>
</ul>
</li>
<li>老年代：
<ul class="org-ul">
<li>CMS
</li>
<li>Serial Old（MSC）
</li>
<li>Parallel Old
</li>
<li>G1
</li>
</ul>
</li>
</ul>

<p>
相互连线表示收集器可以搭配使用
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Serial</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<b>Serial</b> 收集器是最基本、发展历史最为悠久的收集器。在曾经的JDK1.3之前是新生代收集的唯一选择。
</p>

<p>
这个收集器是一个单线程的收集器， <span class="underline">只会使用一个CPU或一条收集线程</span> ，在它进行垃圾收集的时，必须暂停其他所有的工作线程，直到它收集结束。这个过程是由虚拟机后台发起并自动完成的，对用户不可见的情况下把用户正常的工作线程全部停掉，这对许多应用是无法接受的。下图展示了运行过程：
</p>


<div class="figure">
<p><img src="pic/serial-gc.jpg" alt="serial-gc.jpg" width="70%" />
</p>
</div>

<p>
虽然Serial有着 <span class="underline">Stop The World</span> 无法消除的影响，但是它仍旧是虚拟机运行在Client模式下的默认新生代收集器。在单CPU环境来说，Serial由于没有线程交互的开销，专心做垃圾收集，因而具有最高的收集效率。在用户的桌面应用中，分配给虚拟机的内存一般不会很大，收集一两百M的新生代所用的停顿时间完全可以控制在一百ms之内。所以Serial收集器对于运行在Client模式下的虚拟机来说是一个很好地选择
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">ParNew收集器</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<b>ParNew</b> 收集器其实就是 <b>Serial收集器的多线程版本</b> ，除了使用多条线程进行垃圾收集之外，其他行为和Serial收集器一样。ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因，除了Serial收集器外，目前只有ParNew能与老年代的CMS收集器配合使用
</p>

<p>
ParNew是一种 <b>并行</b> 的收集器。在垃圾回收中：
</p>
<ul class="org-ul">
<li>并行： <b>多条垃圾收集线程并行工作，用户线程处于等待状态</b>
</li>
<li>并发： 用户线程与垃圾收集线程同时执行
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Parallel Scavenge 收集器</h3>
<div class="outline-text-3" id="text-3-3">
<p>
<b>Parallel Scavenge</b> 收集器使用的是复制算法，也是一个并行的多线程收集器
</p>

<p>
和ParNew相似，但是Parallel Scavenge的关注点不同，其他收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的 <b>吞吐量</b> 
</p>

<pre class="example">
  吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
</pre>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Serial Old收集器</h3>
<div class="outline-text-3" id="text-3-4">
<p>
<b>Serial Old</b> 收集器是新生代Serial收集器的老年代版本，同样是一个单线程收集器，使用 <span class="underline">标记-整理</span> 算法，Serial Old的主要意义也是在于给Client模式下的虚拟机使用
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Parallel Old收集器</h3>
<div class="outline-text-3" id="text-3-5">
<p>
<b>Parallel Old</b> 是新生代收集器 <span class="underline">Prarllel Scavenge</span> 的老年代版本，使用多线程和 <span class="underline">标记-整理</span> 算法。运行流程如下：
</p>


<div class="figure">
<p><img src="pic/para-old-gc.png" alt="para-old-gc.png" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">CMS收集器</h3>
<div class="outline-text-3" id="text-3-6">
<p>
<b>CMS</b> ( <span class="underline">Concurrent Mark Sweep</span> )收集器是一种以获取最短回收停顿时间为目标的收集器。主要用于互联网或B/S系统的服务端，这类应用尤其重视服务的响应速度
</p>

<p>
CMS是基于 <span class="underline">标记-清除</span> 算法的，运作过程更加复杂一些，分为4个步骤：
</p>
<ol class="org-ol">
<li>初始标记：标记GC Roots直接关联的对象
</li>
<li>并发标记：可达性分析算法
</li>
<li>重新标记：并发变动修改
</li>
<li>并发清除
</li>
</ol>

<p>
其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记阶段稍长，但比并发标记阶段要短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说， <b>CMS收集器的内存回收过程是与用户线程一起并发执行的</b> 。执行过程如下图
</p>


<div class="figure">
<p><img src="pic/cms-gc.png" alt="cms-gc.png" width="70%" />
</p>
</div>
</div>

<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">优点</h4>
<div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>并发收集
</li>
<li>低停顿
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2">缺点</h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>对CPU资源非常敏感，虽然不至于导致用户线程停顿，但是会降低吞吐率
</li>
<li>无法清理 <span class="underline">浮动垃圾</span> ，由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断出现，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次的GC
</li>
<li>会产生 <b>大量空间碎片</b> ，因为CMS是基于 <span class="underline">标记-清除</span> 算法，这种算法的最大缺点就是会产生大量空间碎片，CMS提供了一个 <span class="underline">-XX:+UseCMSCompaceAtFullCollection</span> 的开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">G1收集器</h3>
<div class="outline-text-3" id="text-3-7">
<p>
<b>G1</b> 收集器是最新的一款收集器，是一种面向服务端应用的垃圾收集器，有如下特点：
</p>
<ol class="org-ol">
<li><b>并行与并发</b> ：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间
</li>
<li><b>分代收集</b> ：分代概念在G1中依然得以保留。虽然G1可以不需其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果
</li>
<li><b>空间整合</b> ：与CMS的 <span class="underline">标记-清理</span> 算法不同，G1从整体看来是基于 <span class="underline">标记-整理</span> 算法实现的收集器，从局部（两个Region之间）上看是基于 <span class="underline">复制</span> 算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存
</li>
<li><b>可预测的停顿时间</b> 
</li>
</ol>

<p>
使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域 <span class="underline">Region</span> ，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合
</p>

<p>
G1的收集过程分为以下几个步骤：
</p>
<ol class="org-ol">
<li>初始标记
</li>
<li>并发标记
</li>
<li>最终标记
</li>
<li>筛选回收
</li>
</ol>

<p>
前几个步骤和CMS有很多相似之处。运行示意图如下：
</p>


<div class="figure">
<p><img src="pic/g1-gc.png" alt="g1-gc.png" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8">GC日志</h3>
</div>

<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9">GC参数</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
