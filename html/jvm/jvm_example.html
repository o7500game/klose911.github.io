<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>虚拟机实践</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="class_loader.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">虚拟机实践</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1489657">类加载器</a>
<ul>
<li><a href="#orgbd7e811">Tomcat</a></li>
<li><a href="#org86d23d2">OSGi</a></li>
</ul>
</li>
<li><a href="#orge53d614">字节码</a>
<ul>
<li><a href="#org5f1e544">动态代理的实现</a></li>
<li><a href="#orgb05b536">Retrotranslator</a></li>
</ul>
</li>
<li><a href="#org97262f8">自己动手实现远程执行功能</a></li>
</ul>
</div>
</div>
<p>
在Class文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。能通过程序进行操作的，主要是 <b>字节码生成</b> 与 <b>类加载器</b> 这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为了许多常用功能和程序实现的基础
</p>
<div id="outline-container-org1489657" class="outline-2">
<h2 id="org1489657">类加载器</h2>
<div class="outline-text-2" id="text-org1489657">
</div>
<div id="outline-container-orgbd7e811" class="outline-3">
<h3 id="orgbd7e811">Tomcat</h3>
<div class="outline-text-3" id="text-orgbd7e811">
<p>
主流的Java Web服务器，如 <span class="underline">Tomcat</span> 、 <span class="underline">Jetty</span> 、 <span class="underline">WebLogic</span> 、 <span class="underline">WebSphere</span> 等，都 <b>实现了自己定义的类加载器</b> (一般都不止一个)。因为一个功能健全的Web服务器，要解决如下几个问题:
</p>
<ul class="org-ul">
<li><b>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离</b></li>
</ul>

<pre class="example">
     两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当保证两个应用程序的类库可以互相独立使用
</pre>

<ul class="org-ul">
<li><p>
<b>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享</b> 
</p>
<pre class="example">
       用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费

       这主要倒不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方法区就会很容易出现过度膨胀
</pre></li>

<li>服务器需要尽可能地 <b>保证自身的安全不受部署的Web应用程序影响</b></li>
</ul>
<pre class="example">
     有许多主流的Java Web服务器自身也是使用Java语言来实现的

     因此，服务器本身也有类库依赖的问题

     一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立
</pre>

<ul class="org-ul">
<li>支持 <span class="underline">JSP</span> 应用的Web服务器，大多数都需要 <b>支持热部署</b> 功能</li>
</ul>
<pre class="example">
JSP文件最终要编译成Java Class才能由虚拟机执行，但JSP文件由于其纯文本存储的特性，运行时修改的概率远远大于第三方类库或程序自身的Class文件

ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的优势来看待，因此主流的Web服务器都会支持JSP生成类的热替换

当然也有非主流的，如运行在生产模式(Production Mode)下的Web Logic服务器默认就不会处理JSP文件的变化
</pre>

<p>
由于存在上述问题，在部署Web应用时，单独的一个ClassPath就无法满足需求了，所以各种Web服务器都地提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般都以 <span class="underline">lib</span> 或 <span class="underline">classes</span> 命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常，每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。以Tomcat服务器为例，看一看Tomcat具体是如何规划用户类库结构和类加载器的
</p>

<p>
在Tomcat目录结构中，有3组目录 <span class="underline">/common/*</span> 、 <span class="underline">/server/*</span> 和 <span class="underline">/shared/*</span> )可以存放Java类库，另外还可以加上Web应用程序自身的目录 <span class="underline">/WEB-INF/*</span> ，一共4组，把Java类库放置在这些目录中的含义分别如下：
</p>
<ul class="org-ul">
<li>放置在 <span class="underline">/common</span> 目录中：类库可 <b>被Tomcat和所有的Web应用程序</b> 共同使用</li>
<li>放置在 <span class="underline">/server</span> 目录中：类库可 <b>被Tomcat使用</b> ，对所有的Web应用程序都不可见</li>
<li>放置在 <span class="underline">/shared</span> 目录中：类库可被 <b>所有的Web应用程序共同使用</b> ，但对Tomcat自己不可见</li>
<li>放置在 <span class="underline">/WebApp/WEB-INF</span> 目录中：类库 <b>仅仅可以被此Web应用程序</b> 使用，对Tomcat和其他Web应用程序都不可见</li>
</ul>

<p>
为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的 <span class="underline">双亲委派模型</span> 来实现，其关系如图所示：
</p>



<div class="figure">
<p><img src="pic/tomcat-class-loader.png" alt="tomcat-class-loader.png" width="50%" /> 
</p>
</div>

<p>
最上层的3个类加载器是JDK默认提供的类加载器，这3个加载器的作用已经介绍过了。 、 、和 则是Tomcat自己定义的类加载器，
</p>
<ul class="org-ul">
<li><b>CommonClassLoader</b> : 加载 <span class="underline">/common/*</span></li>
<li><b>CatalinaClassLoader</b> : 加载 <span class="underline">/server/*</span></li>
<li><b>SharedClassLoader</b> : 加载 <span class="underline">/shared/*</span></li>
<li><b>WebappClassLoader</b> : 加载 <span class="underline">/WebApp/WEB-INF/*</span> 中的Java类库
<ul class="org-ul">
<li><b>JsperLoader</b> : 加载 <span class="underline">/WebApp/WEB-INF/*</span> 中的Jsp文件</li>
</ul></li>
</ul>

<p>
WebApp类加载器和Jsp类加载器通常会存在多个实例：
</p>
<ul class="org-ul">
<li>每一个Web应用程序对应一个WebApp类加载器</li>
<li>每一个JSP文件对应一个Jsp类加载器</li>
</ul>

<p>
从图中委派关系可以看出：
</p>
<ul class="org-ul">
<li><span class="underline">CommonClassLoader</span> 能加载的类都可以被 <span class="underline">CatalinaClassLoader</span> 和 <span class="underline">SharedClassLoader</span> 使用</li>
<li><span class="underline">CatalinaClassLoader</span> 和 <span class="underline">SharedClassLoader</span> 自己能加载的类则与对方相互隔离</li>
<li><span class="underline">WebAppClassLoader</span> 可以使用 <span class="underline">SharedClassLoader</span> 加载到的类，各个 <span class="underline">WebAppClassLoader</span> 实例之间相互隔离</li>
<li><span class="underline">JasperLoader</span> 的加载范围仅仅是这个JSP文件所编译出来的那一个Class，它出现的目的就是 <b>为了被丢弃</b> :
<ul class="org-ul">
<li>当服务器检测到JSP文件被修改时，会替掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的Hot Swap功能</li>
</ul></li>
</ul>

<pre class="example">
    对于Tomcat的6.x版本的默认配置下，/common、/server和/shared三个目录已经合并到一起变成/lib目录了，这个目录里的类库相当于以前/common目录中类库的作用
  
    只有指定了catalina.properties配置文件的server.loader和share.loader项后才会真正建立CatalinaClassLoader和SharedClassLoader的实例，否则会用到这两个类加载器的地方会用CommonClassLoader的实例代替

    这是Tomcat设计团队为了简化大多数的部署场景所做的一项改进，如果默认设置不能满足需要，用户可以通过修改配置文件指定server.loader和share.loader的方式重新启用Tomcat5.x的加载器架构
</pre>

<p>
总结：Tomcat加载器的实现 <b>清晰易懂</b> ，并且采用了官方推荐的 <span class="underline">正统</span> 的使用类加载器的方式
</p>

<pre class="example">
如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring放到Common或Shared目录下让这些程序共享

Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的，那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问不在其加载范围内的用户程序？

可以尝试的答案是：使用线程上下文加载器
</pre>
</div>
</div>

<div id="outline-container-org86d23d2" class="outline-3">
<h3 id="org86d23d2">OSGi</h3>
<div class="outline-text-3" id="text-org86d23d2">
<p>
<b>OSGi</b> 是OSGi联盟制定的一个基于Java语言的动态模块化规范，这个规范最初由Sun、IBM、爰立信等公司联合发起，目的是使服务提供商通过住宅网关为各种家用智能设备提供各种服务，后来这个规范在Java的其他技术领域也有相当不错的发展，现在已经成为Java世界中“事实上”的模块化标准，并且已经有了Equinox、Felix等成熟的实现。OSGi在Java程序员中最著名的应用案例就是 <span class="underline">Eclipse</span> ，另外还有许多大型的软件平台和中间件服务器都基于或声明将会基于OSGi规范来实现，如IBM <span class="underline">Jazz平台</span> 、 <span class="underline">GlassFish服务器</span> 、 <span class="underline">jBoss OSGi</span> 等
</p>

<p>
OSGi中的每个模块(称为 <span class="underline">Bundle</span> )与普通的Java类库区别并不太大，两者一般都以 <b>JAR</b> 格式进行封装，并且内部存储的都是Java <b>Package</b> 和 <b>Class</b> 。但是一个Bundle可以 <b>声明它所依赖的Java Package</b> (通过 <span class="underline">Import-Package</span> 描述)，也可以声明它 <b>允许导出发布的Java Package</b> (通过 <span class="underline">Export-Package</span> 描述)。在OSGi里面， <b>Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖</b> (至少外观上如此)，而且 <b>类库的可见性能得到非常精确的控制</b> ，一个模块里只有被Export过的Package才可能由外界访问，其他的Package和Class将会隐藏起来。除了更精确的模块划分和可见性控制外，基于OSGi的程序很可能(只是很可能，并不是一定会)可以实现 <b>模块级的热插拔</b> 功能，当程序升级更新或调试除错时，可以只停用、重新安装然后启用程序的其中一部分，这对企业级程序开发来说是一个非常有诱惑力的特性
</p>


<p>
OSGi之所以能有上述“诱人”的特点，要归功于它 <b>灵活的类加载器架构</b> 。OSGi的Bundle类加载器之间只有规则，没有固定的委派关系：
</p>
<ul class="org-ul">
<li>某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明发布了这个Package，那么 <b>所有对这个 <span class="underline">Package的类加载动作</span> 都会委派给发布它的Bundle类加载器</b> 去完成
<ul class="org-ul">
<li>不涉及某个具体的Package时，各个Bundle加载器都是平级关系，只有具体使用某个Package和Class的时候，才会 <b>根据 <span class="underline">Package导入导出</span> 定义来构造Bundle间的委派和依赖</b></li>
</ul></li>
<li>一个Bundle类加载器为其他Bundle提供服务时，会 <b>根据 <span class="underline">Export-Package</span> 列表严格控制访问范围</b> 
<ul class="org-ul">
<li>如果一个类存在于Bundle的类库中但是没有被Export，那么这个Bundle的类加载器能找到这个类，但不会提供给其他Bundle使用，而且OSGi平台也不会把其他Bundle的类加载请求分配给这个Bundle来办理</li>
</ul></li>
</ul>

<p>
假设存在 <span class="underline">Bundle A</span> 、 <span class="underline">Bundle B</span> 、 <span class="underline">Bundle C</span> 三个模块，并且这三个Bundle定义的依赖关系如下：
</p>
<ul class="org-ul">
<li>Bundle A: 声明发布了 <span class="underline">package A</span> ，依赖了 <span class="underline">java.*</span> 的包</li>
<li>Bundle B: 声明依赖了 <span class="underline">package A</span> 和 <span class="underline">package C</span> ，同时也依赖了 <span class="underline">java.*</span> 的包</li>
<li>Bundle C: 声明发布了 <span class="underline">package C</span> ，依赖了 <span class="underline">package A</span></li>
</ul>

<p>
那么，这三个Bundle之间的类加载器及父类加载器之间的关系如图所示：
</p>


<div class="figure">
<p><img src="pic/osgi-class-loader.png" alt="osgi-class-loader.png" width="50%" /> 
</p>
</div>

<p>
图中的类加载器都没有指明具体的加载器实现，只是一个体现了加载器之间关系的概念模型，并且只是体现了OSGi中 <b>最简单的加载器委派关系</b> 。一般来说，在OSGi中，加载一个类可能发生的查找行为和委派关系会复杂得多，类加载时可能进行的查找规则如下:
</p>
<ol class="org-ol">
<li>以 <span class="underline">java.*</span> 开头的类，委派给 <b>父类加载器</b> 加载</li>
<li><span class="underline">委派列表名单内</span> 的类，委派给 <b>父类加载器</b> 加载</li>
<li><span class="underline">Import列表</span> 中的类，委派给 <b>Export这个类的Bundle的类加载器</b> 加载</li>
<li>查找 <span class="underline">当前Bundle的Classpath</span> ，使用 <b>自己的类加载器</b> 加载</li>
<li>查找是否在 <span class="underline">自己的Fragment Bundle</span> 中，如果是，则委派给 <b>Fragment Bundle的类加载器</b> 加载</li>
<li>查找 <span class="underline">Dynamic Import列表的Bundle</span> ，委派给 <b>对应Bundle的类加载器</b> 加载</li>
<li>类查找失败</li>
</ol>

<p>
在OSGi里面，加载器之间的关系不再是 <span class="underline">双亲委派模型的树形结构</span> ，而是已经进一步发展成了一种更为复杂的、 <b>运行时才能确定的网状结构</b> 
</p>
<pre class="example">
这种网状的类加载器架构在带来更好的灵活性的同时，也可能会产生许多新的隐患。在高并发环境下经常出现死锁

如果出现了Bundle A依赖Bundle B的Package B，而Bundle B又依赖了Bundle A的Package A，这两个Bundle进行类加载时就很容易发生死锁

当Bundle A加载Package B的类时，首先需要锁定当前类加载器的实例对象(java.lang.ClassLoader.loadClass()是一个synchronized方法)
然后把请求委派给Bundle B的加载器处理，如果这时候Bundle B也正好想加载Package A的类，它也先锁定自己的加载器再去请求Bundle A的加载器处理
这样，两个加载器都在等待对方处理自己的请求，而对方处理完之前自己又一直处于同步锁定的状态，因此它们就互相死锁，永远无法完成加载请求了

Equinox的BugList中有关于这类问题的Bug，也提供了一个以牺牲性能为代价的解决方案：
   用户可以用osgi.classloader.singleThreadLoads参数来按单线程串行化的方式强制进行类加载动作

在JDK1.7中，为非树状继承关系下的类加载器架构进行了一次专门的升级，目的是从底层避免这类死锁出现的可能
</pre>


<p>
总结：OSGi描绘了一个很美好的模块化开发的目标，而且定义了实现这个目标所需要的各种服务，同时也有成熟框架对其提供实现支持：
</p>
<ul class="org-ul">
<li>对于单个虚拟机下的应用，从开发初期就建立在OSGi上是一个很不错的选择，这样便于 <b>约束依赖</b></li>
<li>但并非所有的应用都适合采用OSGi作为基础架构，OSGi在提供强大功能的同时，也引入了 <b>额外的复杂度</b> ，带来了 <b>线程死锁</b> 和 <b>内存泄漏</b> 的风险</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orge53d614" class="outline-2">
<h2 id="orge53d614">字节码</h2>
<div class="outline-text-2" id="text-orge53d614">
<p>
在Java里面使用字节码生成的例子：
</p>
<ul class="org-ul">
<li>如Web服务器中的JSP编译器</li>
<li>编译时植入的AOP框架</li>
<li>动态代理技术，</li>
<li>使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度</li>
</ul>
</div>

<div id="outline-container-org5f1e544" class="outline-3">
<h3 id="org5f1e544">动态代理的实现</h3>
<div class="outline-text-3" id="text-org5f1e544">
<pre class="example">
字节码生成并不是什么高深的技术，也先不必去想诸如Javassist 、 CGLib 、 ASM之类的字节码类库，因为JDK里面的javac命令就是字节码生成技术的“老祖宗”

javac也是一个由Java语言写成的程序，它的代码存放在OpenJDK的langtools/src/share/classes/com/sun/tools/javac目录中

要深入了解字节码生成，阅读javac的源码是个很好的途径 
</pre>


<p>
即使没有直接使用过 <span class="underline">Java.lang.reflect.Proxy</span> 或实现过 <span class="underline">java.lang.reflect.InvocationHandler</span> 接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况都会用过动态代理，因为如果Bean是面向接口编程，那么在Spring内部都是通过 <span class="underline">动态代理</span> 的方式来对Bean进行增强的
</p>

<p>
动态代理中所谓的 <b>动态</b> ，是针对使用Java代码实际编写了代理类的 <b>静态</b> 代理而言的，它的优势不在于省去了编写代理类那一点工作量，而是实现了可以 <b>在原始类和接口还未知的时候，就确定代理类的代理行为</b> ，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">lang</span>.<span style="color: #7fffd4;">reflect</span>.<span style="color: #98fb98;">InvocationHandler</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">lang</span>.<span style="color: #7fffd4;">reflect</span>.<span style="color: #98fb98;">Method</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">lang</span>.<span style="color: #7fffd4;">reflect</span>.<span style="color: #98fb98;">Proxy</span>;

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DynamicProxyTest</span> {
    <span style="color: #00ffff;">interface</span> <span style="color: #98fb98;">IHello</span> {
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>();
    }

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Hello</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">IHello</span> {

        <span style="color: #7fffd4;">@Override</span>
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>() {
            System.out.println(<span style="color: #ffa07a;">"hello world"</span>);
        }
    }

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DynamicProxy</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">InvocationHandler</span> {

        <span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">originObj</span>;

        <span style="color: #98fb98;">Object</span> <span style="color: #87cefa;">bind</span>(<span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">obj</span>) {
            <span style="color: #00ffff;">this</span>.originObj = obj;
            <span style="color: #00ffff;">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span style="color: #00ffff;">this</span>);
        }

        <span style="color: #7fffd4;">@Override</span>
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">Object</span> <span style="color: #87cefa;">invoke</span>(<span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">proxy</span>, <span style="color: #98fb98;">Method</span> <span style="color: #eedd82;">method</span>, <span style="color: #98fb98;">Object</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Throwable</span> {
            System.out.println(<span style="color: #ffa07a;">"welcome"</span>);
            <span style="color: #00ffff;">return</span> method.invoke(originObj, args);
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        <span style="color: #98fb98;">IHello</span> <span style="color: #eedd82;">hello</span> = (<span style="color: #98fb98;">IHello</span>) <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">DynamicProxy</span>().bind(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Hello</span>());
        hello.sayHello();
    }
}
</pre>
</div>

<pre class="example">
welcome
hello world

</pre>

<p>
上述代码里，唯一的 <b>黑厘子</b> 就是 <span class="underline">Proxy.newProxyInstance()</span> 方法，除此之外再没有任何特殊之处。这个方法返回一个实现了 <span class="underline">IHello</span> 的接口，并且代理了 <span class="underline">newHello()</span> 实例行为的对象。跟踪这个方法的源码，可以看到程序进行了 <span class="underline">验证</span> 、 <span class="underline">优化</span> 、 <span class="underline">缓存</span> 、 <span class="underline">同步</span> 、 <b>生成字节码</b> 、 <span class="underline">显式类加载</span> 等操作，前面的步骤并不是关注的重点，而最后它调用了 <span class="underline">sun.misc.ProxyGenerator.generateProxyClass()</span> 方法来完成生成字节码的动作，这个方法可以在 <b>运行时产生一个描述代理类的字节码byte[]数组</b> 。如果想看一看这个在运行时产生的代理类中写了些什么，可以在main()方法中加入下面这句:
</p>
<div class="org-src-container">
<pre class="src src-java">System.getProperties().put (<span style="color: #ffa07a;">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span> ,<span style="color: #ffa07a;">"true"</span>);
</pre>
</div>

<p>
加入这句代码后再次运行程序，磁盘中将会产生一个名为 <span class="underline">$Proxy0.class</span> 的代理类Class文件，反编译后可以看见：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">DynamicProxyTest</span>.<span style="color: #98fb98;">IHello</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">lang</span>.<span style="color: #7fffd4;">reflect</span>.<span style="color: #98fb98;">InvocationHandler</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">lang</span>.<span style="color: #7fffd4;">reflect</span>.<span style="color: #98fb98;">Method</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">lang</span>.<span style="color: #7fffd4;">reflect</span>.<span style="color: #98fb98;">Proxy</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">lang</span>.<span style="color: #7fffd4;">reflect</span>.<span style="color: #98fb98;">UndeclaredThrowableException</span>;

<span style="color: #00ffff;">final</span> <span style="color: #00ffff;">class</span> $Proxy0 <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Proxy</span> <span style="color: #00ffff;">implements</span> <span style="color: #98fb98;">IHello</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Method</span> <span style="color: #eedd82;">m1</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Method</span> <span style="color: #eedd82;">m3</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Method</span> <span style="color: #eedd82;">m2</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Method</span> <span style="color: #eedd82;">m0</span>;

    <span style="color: #00ffff;">public</span> $Proxy0(<span style="color: #98fb98;">InvocationHandler</span> <span style="color: #eedd82;">var1</span>) <span style="color: #00ffff;">throws</span>  {
        <span style="color: #00ffff;">super</span>(var1);
    }


    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>() <span style="color: #00ffff;">throws</span>  {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #ff4500;">//</span><span style="color: #ff4500;">super.h&#23454;&#38469;&#26159;Proxy.newProxyInstance()&#36825;&#20010;&#26041;&#27861;&#30340;&#31532;&#19977;&#20010;&#32465;&#23450;&#30340;&#21442;&#25968;</span>
            <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#20063;&#23601;&#26159;new DynamicProxy()&#29983;&#25104;&#30340;&#23454;&#20363;&#21464;&#37327;</span>
            <span style="color: #00ffff;">super</span>.h.invoke(<span style="color: #00ffff;">this</span>, m3, (Object[])<span style="color: #7fffd4;">null</span>); 
        } <span style="color: #00ffff;">catch</span> (RuntimeException | Error var2) {
            <span style="color: #00ffff;">throw</span> var2;
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">Throwable</span> <span style="color: #eedd82;">var3</span>) {
            <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">UndeclaredThrowableException</span>(var3);
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">String</span> <span style="color: #87cefa;">toString</span>() <span style="color: #00ffff;">throws</span>  {
        <span style="color: #00ffff;">try</span> {
            <span style="color: #00ffff;">return</span> (String)<span style="color: #00ffff;">super</span>.h.invoke(<span style="color: #00ffff;">this</span>, m2, (Object[])<span style="color: #7fffd4;">null</span>);
        } <span style="color: #00ffff;">catch</span> (RuntimeException | Error var2) {
            <span style="color: #00ffff;">throw</span> var2;
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">Throwable</span> <span style="color: #eedd82;">var3</span>) {
            <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">UndeclaredThrowableException</span>(var3);
        }
    }

    <span style="color: #00ffff;">static</span> {
        <span style="color: #00ffff;">try</span> {
            m1 = Class.forName(<span style="color: #ffa07a;">"java.lang.Object"</span>).getMethod(<span style="color: #ffa07a;">"equals"</span>, Class.forName(<span style="color: #ffa07a;">"java.lang.Object"</span>));
            m3 = Class.forName(<span style="color: #ffa07a;">"DynamicProxyTest$IHello"</span>).getMethod(<span style="color: #ffa07a;">"sayHello"</span>);
            m2 = Class.forName(<span style="color: #ffa07a;">"java.lang.Object"</span>).getMethod(<span style="color: #ffa07a;">"toString"</span>);
            m0 = Class.forName(<span style="color: #ffa07a;">"java.lang.Object"</span>).getMethod(<span style="color: #ffa07a;">"hashCode"</span>);
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">NoSuchMethodException</span> <span style="color: #eedd82;">var2</span>) {
            <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">NoSuchMethodError</span>(var2.getMessage());
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">ClassNotFoundException</span> <span style="color: #eedd82;">var3</span>) {
            <span style="color: #00ffff;">throw</span> <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">NoClassDefFoundError</span>(var3.getMessage());
        }
    }
}

</pre>
</div>

<p>
<span class="underline">$Proxy0</span> 这个代理类为传入接口中的每一个方法，以及从 <span class="underline">java.lang.Object</span> 中继承来的 <span class="underline">equals()</span> 、 <span class="underline">hashCode()</span> 、 <span class="underline">toString()</span> 方法都生成了对应的实现，并且统一调用了 <b>InvocationHandler对象的 <span class="underline">invoke()</span> 方法</b> : 代码中的 <span class="underline">this.h</span> 就是父类Proxy中保存的 <span class="underline">InvocationHandler</span> 实例变量)来实现这些方法的内容，各个方法的区别不过是 <b>传入的参数和Method对象有所不同</b> 而已，所以无论调用动态代理的哪一个方法，实际上都是在 <span class="underline">执行InvocationHandler.invoke()</span> 中的代理逻辑
</p>

<pre class="example">
  这个例子中并没有讲到generateProxyClass()方法具体是如何产生代理类“$Proxy0.class”的字节码的，大致的生成过程其实就是根据Class文件的格式规范去拼装字节码

  但在实际开发中，以byte为单位直接拼装出字节码的应用场合很少见，这种生成方式也只能产生一些高度模板化的代码

  对于用户的程序代码来说，如果有要大量操作字节码的需求，还是使用封装好的字节码类库比较合适

  如果对动态代理的字节码拼装过程很感兴趣，可以在OpenJDK的jdk/src/share/classes/sun/misc目录下找到sun.misc.ProxyGenerator的源码
</pre>
</div>
</div>

<div id="outline-container-orgb05b536" class="outline-3">
<h3 id="orgb05b536">Retrotranslator</h3>
<div class="outline-text-3" id="text-orgb05b536">
<pre class="example">
  在Java世界里，每一次JDK大版本的发布，都伴随着一场大规模的技术革新，而对Java程序编写习惯改变最大的，无疑是JDK1.5的发布

  自动装箱、泛型、动态注解、枚举、变长参数、遍历循环(foreach循环)……

  在没有这些语法特性的年代，Java程序也照样能写，但是现在看来，上述每一种语法的改进几乎都是“必不可少”的

  但因为要保护现有投资、维持程序结构稳定等，必须使用1.5以前版本的JDK

  为了把JDK1.5中编写的代码放到JDK1.4或1.3的环境中去部署使用，一种名为Java逆向移植的工具应运而生， 而Retrotranslator是这类工具中较出色的一个
</pre>

<p>
<span class="underline">Retrotranslator</span> 的作用是将JDK 1.5编译出来的Class文件转变为可以在JDK 1.4或 1.3上部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK1.5中新增的集合改进、并发包以及对泛型、注解等的反射操作
</p>

<p>
首先要弄清楚JDK升级中会提供哪些新的功能。JDK每次升级新增的功能大致可以分为以下4类: 
</p>
<ol class="org-ol">
<li><b>编译器</b> ：
<ul class="org-ul">
<li><b>自动装箱拆箱</b> ：实际上就是编译器在程序中使用到包装对象的地方自动插入了很多 <span class="underline">Integer.valueOf()</span> 、 <span class="underline">Float.valueOf()</span> 之类的代码</li>
<li><b>变长参数</b> ：在编译之后就 <span class="underline">自动转化成了一个数组</span> 来完成参数传递</li>
<li><b>泛型</b> ：信息则在 <span class="underline">编译阶段就已经擦除掉了</span> (但是在 <b>元数据中还保留</b> 着)，相应的地方被编译器自动插入了 <span class="underline">类型转换代码</span></li>
</ul></li>
<li><b>Java API</b> 的代码增强：
<ul class="org-ul">
<li>JDK 1.2时代引入的 <span class="underline">java.util.Collections</span> 等一系列 <b>集合类</b></li>
<li>JDK 1.5时代引入的 <span class="underline">java.util.concurrent</span>  <b>并发包</b> 等</li>
</ul></li>
<li><b>字节码</b> 中进行支持的改动，字节码指令集一直处于相对比较稳定的状态，这种需要在字节码层面直接进行的改动是比较少见的：
<ul class="org-ul">
<li>JDK 1.7里面新加入的语法特性: <b>动态语言支持</b> ，就需要在虚拟机中新增一条 <span class="underline">invokedynamic</span> 字节码指令来实现相关的调用功能</li>
</ul></li>
<li><b>虚拟机内部</b> ，这类改动对于程序员编写代码基本是透明的，但会对程序运行时产生影响：
<ul class="org-ul">
<li>JDK 1.5中实现的 <span class="underline">JSR-133</span> 规范重新定义的 <b>Java内存模型</b></li>
<li><b>CMS收集器</b> 之类的改动</li>
</ul></li>
</ol>

<p>
上述4类新功能中，Retrotranslator只能模拟前两类，对于后面两类直接在虚拟机内部实现的改进，一般所有的逆向移植工具都是无能为力的，至少不能完整地或者在可接受的效率上完成全部模拟，否则虚拟机设计团队也没有必要舍近求远地改动处于JDK底层的虚拟机。在可以模拟的两类功能中，第二类模拟相对更容易实现一些，如JDK 1.5引入的java.util.concurrent包，实际是由多线程大师DougLea开发的一套并发包，在JDK1.5出现之前就已经存在(那时候名字叫做dl.util.concurrent)，所以要在旧的JDK中支持这部分功能，以独立类库的方式便可实现。Retrotranslator中附带了一个名叫 <span class="underline">backport-util-concurrent.jar</span> 的类库来代替JDK 1.5的并发包
</p>

<p>
至于JDK在 <span class="underline">编译阶段进行处理的那些改进</span> ，Retrotranslator则是使用 <b>ASM框架直接对字节码</b> 进行处理。由于组成Class文件的字节码指令数量并没有改变，所以无论是JDK 1.3、JDK 1.4还是JDK 1.5，能用字节码表达的语义范围应该是一致的。当然，肯定不可能简单地把Class的文件版本号从49.0改回48.0就能解决问题了，虽然字节码指令的数量没有变化，但是元数据信息和一些语法支持的内容还是要做相应的修改。以枚举为例，在JDK 1.5中增加了 <b>enum</b> 关键字，但是Class文件常量池的 <b>CONSTANT_Class_info</b> 类型常量并没有发生任何语义变化，仍然是代表一个类或接口的符号引用，没有加入枚举，也没有增加过 <b>CONSTANT_Enum_info</b> 之类的 <b>枚举符号引用</b> 常量。所以使用 <span class="underline">enum</span> 关键字定义常量，虽然从Java语法上看起来与使用class关键字定义类、使用 <span class="underline">interface</span> 关键字定义接口是同一层次的，但实际上这是由Javac编译器做出来的假象，从字节码的角度来看， <b>枚举仅仅是一个继承于 <span class="underline">java.lang.Enum</span> 、自动生成了 <span class="underline">values()</span> 和 <span class="underline">valueOf()</span> 方法的普通类</b> 而已
</p>

<p>
Retrotranslator对枚举所做的主要处理：
</p>
<ol class="org-ol">
<li>枚举类的父类从 <b>java.lang.Enum</b> 替换为它运行时类库中包含的 <b>net.sf.retrotranslator.runtime.java.lang.Enum_</b></li>
<li>在类和字段的访问标志中抹去 <b>ACC_ENUM</b> 标志位</li>
</ol>

<pre class="example">
  当然，这只是处理的总体思路，具体的实现要比上面说的复杂得多

  可以想象既然两个父类实现都不一样，values()和valueOf()的方法自然需要重写

  常量池需要引入大量新的来自父类的符号引用，这些都是实现细节
</pre>

<p>
下图是一个使用JDK 1.5编译的枚举类与被Retrotranslator转换处理后的字节码的对比图：
</p>


<div class="figure">
<p><img src="pic/retrotranslator-enum.jpg" alt="retrotranslator-enum.jpg" width="70%" /> 
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org97262f8" class="outline-2">
<h2 id="org97262f8">自己动手实现远程执行功能</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
