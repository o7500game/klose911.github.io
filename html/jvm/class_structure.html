<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>类文件结构</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="optimize.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">类文件结构</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">无关性的基石</a></li>
<li><a href="#sec-2">Class类文件</a>
<ul>
<li><a href="#sec-2-1">魔数与Class文件的版本</a></li>
<li><a href="#sec-2-2">常量池</a>
<ul>
<li><a href="#sec-2-2-1">CONSTANT_Class_info</a></li>
<li><a href="#sec-2-2-2">CONSTANT_Utf8_info</a></li>
<li><a href="#sec-2-2-3">常量池总结</a></li>
</ul>
</li>
<li><a href="#sec-2-3">访问标志</a></li>
<li><a href="#sec-2-4">类索引、父类索引与接口索引集合</a></li>
<li><a href="#sec-2-5">字段表集合</a>
<ul>
<li><a href="#sec-2-5-1">access_flags</a></li>
<li><a href="#sec-2-5-2">name_index</a></li>
<li><a href="#sec-2-5-3">descriptor_index</a></li>
<li><a href="#sec-2-5-4">attributes</a></li>
<li><a href="#sec-2-5-5">实例</a></li>
</ul>
</li>
<li><a href="#sec-2-6">方法表集合</a>
<ul>
<li><a href="#sec-2-6-1">实例</a></li>
</ul>
</li>
<li><a href="#sec-2-7">属性表集合</a>
<ul>
<li><a href="#sec-2-7-1">Code 属性</a>
<ul>
<li><a href="#sec-2-7-1-1">Code属性实例</a></li>
<li><a href="#sec-2-7-1-2">异常处理表集合</a></li>
</ul>
</li>
<li><a href="#sec-2-7-2">Exception 属性</a></li>
<li><a href="#sec-2-7-3">LineNumberTable属性</a></li>
<li><a href="#sec-2-7-4">LocalVariableTable属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">无关性的基石</h2>
<div class="outline-text-2" id="text-1">
<p>
实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与 <b>Class文件</b> 这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台， 任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如 ，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器同样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言，如图所示：
</p>


<div class="figure">
<p><img src="pic/javav.jpg" alt="javav.jpg" width="70%" /> 
</p>
</div>

<p>
Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。因此有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Class类文件</h2>
<div class="outline-text-2" id="text-2">
<p>
关于Class文件结构的讲解中，将以《Java虚拟机规范(第2版)》(1999年发布，对应于JDK1.4时代的Java虚拟机)中的定义为主线，这部分内容虽然古老，但它所包含的指令、属性是Class文件中最重要和最基础的。同时，也会以后续JDK1.5〜JDK1.7中添加的内容为支线进行较为简略的、介绍性的讲解
</p>

<p>
注意： <span class="underline">任何一个Class文件都对应着唯一一个类或接口的定义信息</span>  ，但反过来说， <b>类或接口并不一定都得定义在文件里</b> (譬如类或接口也可以通过类加载器直接生成)。只是通俗地将任意一个有效的类或接口所应当满足的格式称为 <span class="underline">Class文件格式</span> ，实际上它并不一定以磁盘文件的形式存在
</p>

<p>
Class文件是 <b>一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符</b> ，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。 <span class="underline">当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储</span> 
</p>

<p>
根据Java虚拟机规范的规定，Class文件格式采用一种 <span class="underline">类似于C语言结构体的伪结构</span> 来存储数据，这种伪结构中只有两种数据类型: <b>无符号数</b> 和 <b>表</b> ，后面的解析都要以这两种数据类型为基础：
</p>
<ul class="org-ul">
<li>无符号数：基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述 
<ul class="org-ul">
<li><b>数字</b> 
</li>
<li><b>索引引用</b> 
</li>
<li><b>数量值</b> 
</li>
<li><b>UTF-8编码构成字符串值</b> 
</li>
</ul>
</li>
<li>表： <b>由多个无符号数或者其他表作为数据项构成的复合数据类型</b> ，所有表都习惯性地以 <b><span class="underline">info</span></b> 结尾。表用于描述 <b>有层次关系的复合结构的数据</b> 
</li>
</ul>

<p>
整个Class文件本质上就是一张表，它由下表所示的数据项构成：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> Class文件结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u4</td>
<td class="left">magic</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">minor_version</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">major_version</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">constant_pool_count</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">cp_info</td>
<td class="left">constant_pool</td>
<td class="right">constant_pool_count - 1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">access_flags</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">this_class</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">super_class</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">interfaces_count</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">interfaces</td>
<td class="right">interfaces_count</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">fields_count</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">field_info</td>
<td class="left">fields</td>
<td class="right">fields_count</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">methods_count</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">method_info</td>
<td class="left">methods</td>
<td class="right">methods_count</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attributes_count</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">attribute_info</td>
<td class="left">attributes</td>
<td class="right">attributes_count</td>
</tr>
</tbody>
</table>

<p>
无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称 <span class="underline">这一系列连续的某一类型的数据为某一类型的集合</span> 
</p>

<p>
需要再重复强调， <b>Class的结构不像XML等描述语言，它没有任何分隔符号</b> ，所以在表6-1中的数据项，无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">魔数与Class文件的版本</h3>
<div class="outline-text-3" id="text-2-1">
<p>
每个Class文件的头4个字节称为 <b>魔数</b> (Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class文件的魔数的值为: <span class="underline">OxCAFEBABE</span> :-) 
</p>

<p>
紧接着魔数的4个字节存储的是 <b>Class文件的版本号</b> :
</p>
<ul class="org-ul">
<li>第5和第6个字节是 <span class="underline">次版本号</span> (Minor Version)
</li>
<li>第7和第8个字节是 <span class="underline">主版本号</span> (Major Version)
</li>
</ul>

<p>
Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1(JDK1.0〜1.1使用了45.0〜45.3的版本号)，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件， <b>即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件</b>
</p>

<p>
例如，JDK1.1能支持版本号为45.0〜45.65535的Class文件，无法执行版本号为46.0以上的Class文件，而JDK1.2则能支持45.0〜46.65535的Class文件。现在最新的JDK版本为1.7，可生成的Class文件主版本号最大值为51.0
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">package</span> org.fenixsoft.<span style="color: #7fffd4;">clazz</span>;

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">TestClass</span> {

    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">inc</span>() {
        <span style="color: #00ffff;">return</span> m + 1;
    }
}
</pre>
</div>

<p>
图6-2显示的是使用十六进制编辑器WinHex打开这个Class文件的结果，可以清楚地看见开头4个字节的十六进制表示是 <span class="underline">OxCAFEBABE</span> ，代表次版本号的第5个和第6个字节值为 <span class="underline">0x0000</span> ，而主版本号的值为 <span class="underline">0x0032</span> ，也即是十进制的50，该版本号说明这个文件是可以被JDK1.6或以上版本虚拟机执行的Class文件
</p>


<div class="figure">
<p><img src="pic/class-version.jpg" alt="class-version.jpg" width="70%" /> 
</p>
</div>

<p>
下表列出了从JDK1.1到JDK1.7，主流JDK版本编译器输出的默认和可支持的Class文件版本号：
</p>


<div class="figure">
<p><img src="pic/version-table.jpg" alt="version-table.jpg" width="70%" /> 
</p>
</div>

<p>
这种顺序称为 <span class="underline">Big-Endian</span> ，具体是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据，它是SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反的 <span class="underline">Little-Endian</span> 顺序来存储数据
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">常量池</h3>
<div class="outline-text-3" id="text-2-2">
<p>
紧接着主版本号的就是 <b>常量池</b> ，常量池可以理解为class文件的资源仓库，它是class文件结构中与其它项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一，也是class文件中第一个出现的表类型数据项目
</p>

<p>
由于常量池中常量的数量不是固定的，所以常量池入口需要放置一项u2类型的数据，代表常量池中的容量计数。不过，这里需要注意的是， <b>这个容器计数是从1开始的而不是从0开始</b> ，也就是说， <span class="underline">常量池中常量的个数是这个容器计数-1</span> 。将0空出来的目的是 <b>满足后面某些指向常量池的索引值的数据在特定情况下需要表达 <span class="underline">不引用任何一个常量池项目</span> 的含义</b> 。class文件中只有常量池的容量计数是从1开始的，对于其它集合类型，比如接口索引集合、字段表集合、方法表集合等的容量计数都是从0开始的
</p>

<p>
常量池中主要存放两大类常量： 
</p>
<ul class="org-ul">
<li><b>字面量</b> ：比较接近Java语言的常量概念
<ul class="org-ul">
<li>文本字符串
</li>
<li>声明为final的常量 等
</li>
</ul>
</li>
<li><b>符号引用</b> 则属于编译原理方面的概念，它包括三方面的内容：
<ul class="org-ul">
<li>类和接口的全限定名
</li>
<li>字段的名称和描述符
</li>
<li>方法的名称和描述符
</li>
</ul>
</li>
</ul>

<p>
Java代码在进行javac编译的时候并不像C和C++那样有 <span class="underline">链接</span> 这一步，而是在虚拟机 <b>加载class文件</b> 的时候进行 <span class="underline">动态链接</span> 。也就是说， <span class="underline">在class文件中不会保存各个方法、字段的最终内存布局信息</span> ，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，虚拟机也就无法使用。当虚拟机运行时， <b>需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中</b> 
</p>

<p>
常量池中的每一项都是一个表，在JDK1.7之前有11中结构不同的表结构，在JDK1.7中为了更好的支持动态语言调用，又增加了3种：
</p>
<ul class="org-ul">
<li>CONSTANT_MethodHandle_info
</li>
<li>CONSTANT_MethodType_info
</li>
<li>CONSTANT_InvokeDynamic_info
</li>
</ul>

<p>
这14个表的开始第一个字节是一个 <span class="underline">u1类型的tag</span> ，用来 <b>标识是哪一种常量类型</b> 。这14种常量类型所代表的含义如下：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 常量池的项目类型</caption>

<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="right">标志</td>
<td class="left">含义</td>
</tr>

<tr>
<td class="left">CONSTANT_Utf8_info</td>
<td class="right">1</td>
<td class="left">UTF-8编码的字符串</td>
</tr>

<tr>
<td class="left">CONSTANT_Integer_info</td>
<td class="right">3</td>
<td class="left">整型字面量</td>
</tr>

<tr>
<td class="left">CONSTANT_Float_info</td>
<td class="right">4</td>
<td class="left">浮点型字面量</td>
</tr>

<tr>
<td class="left">CONSTANT_Long_info</td>
<td class="right">5</td>
<td class="left">长整形字面量</td>
</tr>

<tr>
<td class="left">CONSTANT_Double_info</td>
<td class="right">6</td>
<td class="left">双精度浮点型字面量</td>
</tr>

<tr>
<td class="left">CONSTANT_Class_info</td>
<td class="right">7</td>
<td class="left">类或接口的符号引用</td>
</tr>

<tr>
<td class="left">CONSTANT_String_info</td>
<td class="right">8</td>
<td class="left">字符串类型字面量</td>
</tr>

<tr>
<td class="left">CONSTANT_Fieldref_info</td>
<td class="right">9</td>
<td class="left">字段的符号引用</td>
</tr>

<tr>
<td class="left">CONSTANT_Methodref_info</td>
<td class="right">10</td>
<td class="left">类中方法的符号引用</td>
</tr>

<tr>
<td class="left">CONSTANT_InterfaceMethod_info</td>
<td class="right">11</td>
<td class="left">接口中方法的符号引用</td>
</tr>

<tr>
<td class="left">CONSTANT_NameAndType_info</td>
<td class="right">12</td>
<td class="left">字段或方法的部分符号引用</td>
</tr>

<tr>
<td class="left">CONSTANT_MethodHandle_info</td>
<td class="right">15</td>
<td class="left">表示方法句柄</td>
</tr>

<tr>
<td class="left">CONSTANT_MethodType_info</td>
<td class="right">16</td>
<td class="left">标识方法类型</td>
</tr>

<tr>
<td class="left">CONSTANT_InvokeDynamic_info</td>
<td class="right">18</td>
<td class="left">表示一个动态方法调用点</td>
</tr>
</tbody>
</table>

<p>
例子中的常量池结构：
</p>

<div class="figure">
<p><img src="pic/constant-pool.jpg" alt="constant-pool.jpg" width="70%" />
</p>
</div>

<p>
之所以说常量池是最烦琐的数据，是因为这14种常量类型各自均有自己的结构。回头看看常量池的第一项常量，它的标志位(偏移地址:0x0000000A)是0x07，查表6-3的标志列发现这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的符号引用
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">CONSTANT_Class_info</h4>
<div class="outline-text-4" id="text-2-2-1">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> CONSTANT_Class_info型常量的结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u1</td>
<td class="left">tag</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">name_index</td>
<td class="right">1</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>tag是标志位，它用于区分常量类型
</li>
<li>name_index是一个索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类(或者接口)的全限定名，这里name_index值(偏移地址:0x0000000B)为 <span class="underline">0x0002</span> ，也即是指向了常量池中的第二项常量。继续从图6-3中查找第二项常量，它的标志位(地址:0x0000000D)是 <span class="underline">0x01</span> ，查表6-3可知确实是一个CONSTANT_Utf8_info类型的常量
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">CONSTANT_Utf8_info</h4>
<div class="outline-text-4" id="text-2-2-2">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> CONSTANT_Utf8_info型常量的结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u1</td>
<td class="left">tag</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u1</td>
<td class="left">bytes</td>
<td class="right">length</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>length值: 这个UTF-8编码的字符串长度是多少字节
</li>
<li>byte: 长度为length字节的连续数据是一个使用 <span class="underline">UTF-8缩略编码</span> 表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是:
<ul class="org-ul">
<li>从 <span class="underline">\u0001</span> 到 <span class="underline">\u007f</span> 之间的字符(相当于1〜127的ASCII码)的缩略编码使用 <b>一个字节</b> 表示
</li>
<li>从 <span class="underline">\u0080</span> 到 <span class="underline">\u07ff</span> 之间的所有字符的缩略编码用 <b>两个字节</b> 表示
</li>
<li>从 <span class="underline">\u0800</span> 到 <span class="underline">\uffff</span> 之间的所有字符的缩略编码就按照普通UTF-8编码规则使用 <b>三个字节</b> 表示
</li>
</ul>
</li>
</ul>

<p>
由于Class文件中方法、字段等都需要引用 <span class="underline">CONSTANT_Utf8_info</span> 型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中 <span class="underline">如果定义了超过64KB英文字符的变量或方法名，将会无法编译</span> 
</p>

<p>
这个字符串的length值(偏移地址:0x0000000E)为 <span class="underline">0x001D</span> ，也就是长29字节，往后29字节正好命在1〜127的ASCII码范围以内，内容为 <span class="underline">org/fenixsofl/clazz/TestClass</span> ，换算结果如下图选中的部分所示：
</p>


<div class="figure">
<p><img src="pic/constant-pool-utf8.jpg" alt="constant-pool-utf8.jpg" width="70%" />
</p>
</div>

<p>
到此为止，分析了TestClass.class常量池中21个常量中的两个，其余的19个常量都可以通过类似的方法计算出来。为了避免计算过程占用过多的版面，后续的19个常量的计算过程可以借助计算机来帮我们完成。在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具: <span class="underline">javap</span> ，下面中列出了使用javap工具的 <span class="underline">-verbose</span> 参数输出的TestClass.class文件字节码内容(此清单中省略了常量池以外的信息)
</p>

<div class="org-src-container">

<pre class="src src-sh">klose@gentoo ~/tmp/org/fenixsoft/clazz $ javap -verbose TestClass.class  
Classfile /home/klose/tmp/org/fenixsoft/clazz/TestClass.class
  Last modified 2018-7-7; size 295 bytes
  MD5 checksum 81f2ab948a7a3068839b61a8f91f634b
  Compiled from <span style="color: #ffa07a;">"TestClass.java"</span>
public class org.fenixsoft.clazz.TestClass
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">1 = Methodref          #4.#15         // java/lang/Object."&lt;init&gt;":()V</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">2 = Fieldref           #3.#16         // org/fenixsoft/clazz/TestClass.m:I</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">3 = Class              #17            // org/fenixsoft/clazz/TestClass</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">4 = Class              #18            // java/lang/Object</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">5 = Utf8               m</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">6 = Utf8               I</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">7 = Utf8               &lt;init&gt;</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">8 = Utf8               ()V</span>
   <span style="color: #ff4500;">#</span><span style="color: #ff4500;">9 = Utf8               Code</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">10 = Utf8               LineNumberTable</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">11 = Utf8               inc</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">12 = Utf8               ()I</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">13 = Utf8               SourceFile</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">14 = Utf8               TestClass.java</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">15 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">16 = NameAndType        #5:#6          // m:I</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">17 = Utf8               org/fenixsoft/clazz/TestClass</span>
  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">18 = Utf8               java/lang/Object</span>
</pre>
</div>

<pre class="example">
注意：因为测试使用的是jdk1.8，实际结果和作者描述有出入
</pre>
<p>
某些自动生成的常量没有在Java代码里面直接出现过，但它们会被后面即将讲到的字段表(field_info)、方法表(method_info)、属性表(attribute_info)引用到，它们会用来描述一些不方便使用 <span class="underline">固定字节</span> 进行表达的内容。譬如描述方法的返回值是什么?有几个参数?每个参数的类型是什么? 因为Java中的 <span class="underline">类</span> 是无穷无尽的， <b>无法通过简单的无符号字节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达</b> 
</p>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">常量池总结</h4>
<div class="outline-text-4" id="text-2-2-3">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 5:</span> 常量池14种常量类型的结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">常量</td>
<td class="left">项目</td>
<td class="left">类型</td>
<td class="left">含义</td>
</tr>

<tr>
<td class="left">CONSTANT_Utf8_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">1</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">length</td>
<td class="left">u2</td>
<td class="left">UTF-8编码的字符串的长度</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">bytes</td>
<td class="left">u1</td>
<td class="left">长度为length的UTF-8编码的字符串</td>
</tr>

<tr>
<td class="left">CONSTANT_Integer_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">3</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">bytes</td>
<td class="left">u4</td>
<td class="left">按照高位在前的int值</td>
</tr>

<tr>
<td class="left">CONSTANT_Float_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">4</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">bytes</td>
<td class="left">u4</td>
<td class="left">按照高位在前的float值</td>
</tr>

<tr>
<td class="left">CONSTANT_Long_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">5</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">bytes</td>
<td class="left">u8</td>
<td class="left">按照高位在前的long值</td>
</tr>

<tr>
<td class="left">CONSTANT_Double_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">6</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">bytes</td>
<td class="left">u8</td>
<td class="left">按照高位在前的double值</td>
</tr>

<tr>
<td class="left">CONSTANT_Class_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">7</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向全限定名常量项的索引</td>
</tr>

<tr>
<td class="left">CONSTANT_String_info</td>
<td class="left">Tag</td>
<td class="left">u1</td>
<td class="left">8</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向字符串字面量的索引</td>
</tr>

<tr>
<td class="left">CONSTANT_Fieldref_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">9</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向字段描述符CONSTANT_NameAndType_info的索引项</td>
</tr>

<tr>
<td class="left">CONSTANT_Methodref_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">10</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向声明方法的类描述符CONSTANT_Class_info的索引项</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向名称及类描述符CONSTANT_NameAndType_info的索引项</td>
</tr>

<tr>
<td class="left">CONSTANT_InterfaceMethod_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">11</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向声明方法的接口描述符COSNTANT_Class_info的索引项</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向名称及类描述符CONSTANT_NameAndType_info的索引项</td>
</tr>

<tr>
<td class="left">CONSTANT_NameAndType_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">12</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向该字段或方法名称常量池的索引</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">index</td>
<td class="left">u2</td>
<td class="left">指向该字段或方法描述符常量池的索引</td>
</tr>

<tr>
<td class="left">CONSTANT_MethodHandle_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">15</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">reference_kind</td>
<td class="left">u2</td>
<td class="left">值必须在1-9之间，决定了方法句柄的类型，方法句柄累心的值表示方法句柄的字节码行为</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">reference_index</td>
<td class="left">u2</td>
<td class="left">值必须是对常量池的有效索引</td>
</tr>

<tr>
<td class="left">CONSTANT_MethodType_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">16</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">descriptor_index</td>
<td class="left">u2</td>
<td class="left">值必须是对常量池的有效索引，常量池在改索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符</td>
</tr>

<tr>
<td class="left">CONSTANT_InvokeDynamic_info</td>
<td class="left">tag</td>
<td class="left">u1</td>
<td class="left">18</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">bootstrap_method_attrindex</td>
<td class="left">u2</td>
<td class="left">值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">name_and_type_index</td>
<td class="left">u2</td>
<td class="left">值必须是对当前常量池的有效索引，常量池在该索引处的项必须是COSTANT_NameAndType_info结构，表示方法名和方法描述符</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">访问标志</h3>
<div class="outline-text-3" id="text-2-3">
<p>
常量池结束后紧接着的两个字节代表访问标志，用来标识一些类或接口的访问信息，包括：
</p>
<ul class="org-ul">
<li>这个Class是类还是接口
</li>
<li>是否定义为public
</li>
<li>是否定义为abstract
</li>
<li>如果是类的话，是否被声明为final等
</li>
</ul>

<p>
具体的标志位以及含义如下表：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 6:</span> 访问标志</caption>

<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">标志名称</td>
<td class="right">标志值</td>
<td class="left">含义</td>
</tr>

<tr>
<td class="left">ACC_PUBLIC</td>
<td class="right">0x0001</td>
<td class="left">是否是public</td>
</tr>

<tr>
<td class="left">ACC_FINAL</td>
<td class="right">0x0010</td>
<td class="left">是否被声明为final，只有类可以设置</td>
</tr>

<tr>
<td class="left">ACC_SUPER</td>
<td class="right">0x0020</td>
<td class="left">是否允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真</td>
</tr>

<tr>
<td class="left">ACC_INTERFACE</td>
<td class="right">0x0200</td>
<td class="left">标识是一个接口</td>
</tr>

<tr>
<td class="left">ACC_ABSTRACT</td>
<td class="right">0x0400</td>
<td class="left">是否是abstract，对于接口和抽象类来说为真，其他类都为假</td>
</tr>

<tr>
<td class="left">ACC_SYNITHETIC</td>
<td class="right">0x1000</td>
<td class="left">标识这个类并非由用户代码产生</td>
</tr>

<tr>
<td class="left">ACC_ANNOTATION</td>
<td class="right">0x2000</td>
<td class="left">标识这是一个注解</td>
</tr>

<tr>
<td class="left">ACC_ENUM</td>
<td class="right">0x4000</td>
<td class="left">标识这是一个枚举类</td>
</tr>
</tbody>
</table>

<p>
access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求为0
</p>
<pre class="example">
例子中的TestClass是一个普通Java类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK1.2之后的编译器进行编译

因此它的ACC_PUBLIC、ACC_SUPER标志应当为真

而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM这6个标志应S为假

因此它的access_flags的值为: 0x0001 | 0x0020 = 0x0021
</pre>

<p>
下图可以看出：access_flags标志(偏移地址:0x000000EF)的确为 <span class="underline">0x0021</span> 
</p>


<div class="figure">
<p><img src="pic/access-flags.jpg" alt="access-flags.jpg" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">类索引、父类索引与接口索引集合</h3>
<div class="outline-text-3" id="text-2-4">
<p>
在访问标志 <span class="underline">access_flags</span> 后接下来就是类索引（ <span class="underline">this_class</span> ）和父类索引（ <span class="underline">super_class</span> ），这两个数据都是 <b>u2</b> 类型的，而接下来的接口索引集合是一个 <b>u2类型的集合</b> ，class文件由这三个数据项来 <b>确定类的继承关系</b> 。由于Java中是单继承，所以 <span class="underline">父类索引只有一个</span> ；但Java类可以实现多个接口，所以 <span class="underline">接口索引是一个集合</span> 
</p>

<ul class="org-ul">
<li>类索引：确定这个类的全限定名，这个全限定名就是说一个类的 <span class="underline">类名包含所有的包名</span> ，然后使用 <b>/</b> 代替 <b>.</b> 。比如Object的全限定名是java.lang.Object
</li>
<li>父类索引：确定这个类的父类的全限定名，除了Object之外，所有的类都有父类，所以 <b>除了Object之外所有类的父类索引都不为0</b> 
</li>
<li>接口索引：集合存储了implements语句后面按照从 <span class="underline">左到右</span> 的顺序的接口
</li>
</ul>

<p>
类索引和父类索引都是一个索引，这个索引指向常量池中的 <b>CONSTANT_Class_info</b> 类型的常量。然后再CONSTANT_Class_info常量中的索引就可以找到常量池中类型为 <b>CONSTANT_Utf8_info</b> 的常量，而这个常量保存着类的全限定名：
</p>


<div class="figure">
<p><img src="pic/this-class-index.jpg" alt="this-class-index.jpg" width="70%" />
</p>
</div>

<p>
从偏移地址 <span class="underline">0x000000F1</span> 开始的3个U2类型的值分别为 <span class="underline">0x0001</span> 、 <span class="underline">0x0003</span> 、 <span class="underline">0x0000</span> ，也就是类索引为1，父类索引为3，接口索引集合大小为0，查询前面中javap命令计算出来的常量池，找出对应的类和父类的常量：
</p>


<div class="figure">
<p><img src="pic/this-class-constant-pool.jpg" alt="this-class-constant-pool.jpg" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">字段表集合</h3>
<div class="outline-text-3" id="text-2-5">
<p>
字段表用来 <b>描述接口或类中声明的变量</b> 。字段包括类级变量和实例级变量，但不包括方法内变量：
</p>
<ul class="org-ul">
<li>类级变量就是 <span class="underline">静态变量</span> ，这个变量不属于这个类的任何实例，可以不用定义类实例就可以使用
</li>
<li>实例级变量不是静态变量，是和类实例相关联的，需要定义类实例才能使用
</li>
</ul>

<p>
声明一个变量需要信息：
</p>
<ul class="org-ul">
<li>字段的作用域： <b>public</b> 、 <b>private</b> 和 <b>protected</b> 修饰符
</li>
<li>实例变量还是类变量： <b>static</b> 修饰符
</li>
<li>可变性： <b>final</b> 修饰符
</li>
<li>并发可见性： <b>volatile</b> 修饰符
</li>
<li>是否可被序列化： <b>transient</b> 修饰符
</li>
<li>字段的数据类型：
<ul class="org-ul">
<li>基本类型
</li>
<li>对象
</li>
<li>数组
</li>
</ul>
</li>
<li>字段名称
</li>
</ul>

<p>
包含的信息有点多，不过不需要的可以不写。这些信息中，各个修饰符可以用布尔值表示。而字段叫什么名字、字段被定义为什么类型数据都是无法固定的，只能用常量池中的常量来表示。下面是字段表的格式：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 7:</span> 字段表结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">access_flags</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">name_index</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">descriptor_index</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attributes_count</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">attribute_info</td>
<td class="left">attributes</td>
<td class="right">attributes_count</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">access_flags</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
和类中的access_flags类似，对于字段来说可以设置的标志位及含义如下：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 8:</span> 字段访问标志</caption>

<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">标志名称</td>
<td class="right">标志值</td>
<td class="left">含义</td>
</tr>

<tr>
<td class="left">ACC_PUBLIC</td>
<td class="right">0x0001</td>
<td class="left">字段是否是public</td>
</tr>

<tr>
<td class="left">ACC_PRIVATE</td>
<td class="right">0x0002</td>
<td class="left">字段是否是private</td>
</tr>

<tr>
<td class="left">ACC_PROTECTED</td>
<td class="right">0x0004</td>
<td class="left">字段是否是protected</td>
</tr>

<tr>
<td class="left">ACC_STATIC</td>
<td class="right">0x0008</td>
<td class="left">字段是否是static</td>
</tr>

<tr>
<td class="left">ACC_FINAL</td>
<td class="right">0x0010</td>
<td class="left">字段是否是final</td>
</tr>

<tr>
<td class="left">ACC_VOLATILE</td>
<td class="right">0x0040</td>
<td class="left">字段是否是volatile</td>
</tr>

<tr>
<td class="left">ACC_TRANSIENT</td>
<td class="right">0x0080</td>
<td class="left">字段是否是transient</td>
</tr>

<tr>
<td class="left">ACC_SYNTHETIC</td>
<td class="right">0x1000</td>
<td class="left">字段是否是由编译器自动产生的</td>
</tr>

<tr>
<td class="left">ACC_ENUM</td>
<td class="right">0x4000</td>
<td class="left">字段是否是enum</td>
</tr>
</tbody>
</table>

<p>
Java语言本身的规则决定：
</p>
<ol class="org-ol">
<li><span class="underline">ACC_PUBLIC_、 _ACC_PRIVATE</span> 和 <span class="underline">ACC_PROTECTED</span> 只能选择一个
</li>
<li><span class="underline">ACC_FINAL</span> 和 <span class="underline">ACC_VOLATILE</span> 不能同时选择
</li>
<li>接口中的字段必须有 <span class="underline">ACC_PUBLIC</span> 、 <span class="underline">ACC_STATIC</span> 和 <span class="underline">ACC_FINAL</span> 标志
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2">name_index</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
字段名的常量池索引，注意：这是简单名而不是全限定名
</p>
</div>
</div>

<div id="outline-container-sec-2-5-3" class="outline-4">
<h4 id="sec-2-5-3">descriptor_index</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
字段描述符的常量池索引
</p>

<p>
描述符是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值：
</p>
<ul class="org-ul">
<li>基本数据类型以及代表无返回值的void类型都用一个大写字符来表示
</li>
<li>对象类型则用字符L加对象的全限定名来表示
</li>
</ul>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 9:</span> 描述符标识字符含义</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">标识字符</td>
<td class="left">含义</td>
</tr>

<tr>
<td class="left">B</td>
<td class="left">byte</td>
</tr>

<tr>
<td class="left">C</td>
<td class="left">char</td>
</tr>

<tr>
<td class="left">D</td>
<td class="left">double</td>
</tr>

<tr>
<td class="left">F</td>
<td class="left">float</td>
</tr>

<tr>
<td class="left">I</td>
<td class="left">int</td>
</tr>

<tr>
<td class="left">J</td>
<td class="left">long</td>
</tr>

<tr>
<td class="left">S</td>
<td class="left">short</td>
</tr>

<tr>
<td class="left">Z</td>
<td class="left">boolean</td>
</tr>

<tr>
<td class="left">V</td>
<td class="left">void</td>
</tr>

<tr>
<td class="left">L</td>
<td class="left">对象类型，如Ljava/lang/Object</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>数组类型：每一个维度将使用一个前置的 <span class="underline">[</span> 字符来描述：
<ul class="org-ul">
<li>java.lang.String[][]: <span class="underline">[[Ljava/lang/String</span>
</li>
<li>double[]: <span class="underline">[D</span>
</li>
</ul>
</li>
<li>方法的描述符相对来说要复杂一些，因为一个方法除了返回值类型，还有参数类型，而且参数的个数还不确定。按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号 <span class="underline">()</span> 内：
<ul class="org-ul">
<li>void inc()： <span class="underline">()V</span> 
</li>
<li>java.lang.String toString()： <span class="underline">()Ljava/lang/String</span>
</li>
<li>int indexOf(char[], int, int, char[], int, int, int)： <span class="underline">([CII[CIII)I</span>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-5-4" class="outline-4">
<h4 id="sec-2-5-4">attributes</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
属性信息，下面会介绍
</p>
</div>
</div>

<div id="outline-container-sec-2-5-5" class="outline-4">
<h4 id="sec-2-5-5">实例</h4>
<div class="outline-text-4" id="text-2-5-5">

<div class="figure">
<p><img src="pic/fields-info.jpg" alt="fields-info.jpg" width="70%" />
</p>
</div>

<ul class="org-ul">
<li>字段表集合中 <b>不会列出从超类或者父接口中继承而来的字段</b> ，但有可能列出原本Java代码之中不存在的字段，譬如在 <span class="underline">内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段</span>
</li>
<li>字段是 <b>无法重载</b> 的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于 <b>字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的</b>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">方法表集合</h3>
<div class="outline-text-3" id="text-2-6">
<p>
class文件存储格式中对方法的描述和对字段的描述几乎相同，方法表的结构也和字段表相同，这里就不再列出。不过，方法表的访问标志和字段的不同，列出如下：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 10:</span> 方法访问标志</caption>

<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">标识名称</td>
<td class="right">标志值</td>
<td class="left">含义</td>
</tr>

<tr>
<td class="left">ACC_PUBLIC</td>
<td class="right">0x0001</td>
<td class="left">方法是否是public</td>
</tr>

<tr>
<td class="left">ACC_PRIVATE</td>
<td class="right">0x0002</td>
<td class="left">方法是否是private</td>
</tr>

<tr>
<td class="left">ACC_PROTECTED</td>
<td class="right">0x0004</td>
<td class="left">方法是否是protected</td>
</tr>

<tr>
<td class="left">ACC_STATIC</td>
<td class="right">0x0008</td>
<td class="left">方法是否是static</td>
</tr>

<tr>
<td class="left">ACC_FINAL</td>
<td class="right">0x0010</td>
<td class="left">方法是否是final</td>
</tr>

<tr>
<td class="left">ACC_SYNCHRONIZED</td>
<td class="right">0x0020</td>
<td class="left">方法是否是synchronized</td>
</tr>

<tr>
<td class="left">ACC_BRIDGE</td>
<td class="right">0x0040</td>
<td class="left">方法是否是由编译器产生的桥接方法</td>
</tr>

<tr>
<td class="left">ACC_VARARGS</td>
<td class="right">0x0080</td>
<td class="left">方法是否接受不定参数</td>
</tr>

<tr>
<td class="left">ACC_NATIVE</td>
<td class="right">0x0100</td>
<td class="left">方法是否是native</td>
</tr>

<tr>
<td class="left">ACC_ABSTRACT</td>
<td class="right">0x0400</td>
<td class="left">方法是否是abstract</td>
</tr>

<tr>
<td class="left">ACC_STRICTFP</td>
<td class="right">0x0800</td>
<td class="left">方法是否是strictfp</td>
</tr>

<tr>
<td class="left">ACC_SYNTHETIC</td>
<td class="right">0x1000</td>
<td class="left">方法是否是由编译器自动产生的</td>
</tr>
</tbody>
</table>

<p>
方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 <b>Code</b> 的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目
</p>
</div>

<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">实例</h4>
<div class="outline-text-4" id="text-2-6-1">

<div class="figure">
<p><img src="pic/methods-info.jpg" alt="methods-info.jpg" width="70%" />
</p>
</div>

<p>
方法表集合入口地址为: <span class="underline">0x00000101</span> :
</p>
<ul class="org-ul">
<li>第一个u2类型的数据(即是计数器容量)的值为 <span class="underline">0x0002</span> 代表集合中有两个方法: 
<ul class="org-ul">
<li>编译器添加的实例构造器&lt;init&gt;
<ul class="org-ul">
<li>访问标志值为 <span class="underline">0x001</span> ，也就是只有 <span class="underline">ACC_PUBLIC</span> 标志为真
</li>
<li>名称索引值为 <span class="underline">0x0007</span> ，常量池得方法名为 <span class="underline">&lt;init&gt;</span>
</li>
<li>描述符索引值为0x0008，对应常量为 <span class="underline">()V</span>
</li>
<li>属性表计数器attributes_count的值为 <span class="underline">0x0001</span> 就表示此方法的属性表集合有一项属性
</li>
<li>属性名称索引为 <span class="underline">0x0009</span> ，对应常量为 <span class="underline">Code</span> ，说明此属性是方法的字节码描述
</li>
</ul>
</li>
<li>源码中的方法inc()
</li>
</ul>
</li>
</ul>

<p>
与字段表集合相对应的，如果父类方法在子类中没有被 <b>重写</b> ，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器 <span class="underline">&lt;clinit&gt;</span> 方法和实例构造器 <span class="underline">&lt;init&gt;</span> 方法
</p>

<p>
要 <b>重载</b> 一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个 <b>与原方法不同的特征签名</b> ，特征签名就是一个方法中 <span class="underline">各个参数在常量池中的字段符号引用的集合</span> ，也就是因为 <b>返回值不会包含在特征签名中</b> ，因此Java无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说， <b>如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</b> 
</p>

<p>
Java代码的方法特征签名只包括了方法名称、参数顺序及参数类型,而字节码的特征签名还包括 <b>方法返回值以及受查异常表</b>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">属性表集合</h3>
<div class="outline-text-3" id="text-2-7">
<p>
属性表(attribute_info)在前面的讲解之中已经出现过数次，在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息
</p>

<p>
与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些， <b>不再要求各个属性表具有严格顺序</b> ，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息， <span class="underline">Java虚拟机运行时会忽略掉它不认识的属性</span> 。为了能正确解析Class文件，《Java虚拟机规范(第2版)》中预定义了9项虚拟机实现应当能识别的属性，而在最新的《Java虚拟机规范(Java SE7)》版中，预定义属性已经增加到21项，具体内容见表6-13。后面将对其中一些属性中的关键常用的部分进行讲解
</p>


<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 11:</span> 虚拟机中预定义的属性</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">属性名称</td>
<td class="left">使用位置</td>
<td class="left">含义</td>
</tr>

<tr>
<td class="left">code</td>
<td class="left">方法表</td>
<td class="left">Java代码编译成的字节码指令</td>
</tr>

<tr>
<td class="left">constantvalue</td>
<td class="left">字段表</td>
<td class="left">final关键字定义的常量池</td>
</tr>

<tr>
<td class="left">deprecated</td>
<td class="left">类，方法，字段表</td>
<td class="left">被声明为deprecated的方法和字段</td>
</tr>

<tr>
<td class="left">exceptions</td>
<td class="left">方法表</td>
<td class="left">方法抛出的异常</td>
</tr>

<tr>
<td class="left">enclosingmethod</td>
<td class="left">类文件</td>
<td class="left">仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>

<tr>
<td class="left">innerclass</td>
<td class="left">类文件</td>
<td class="left">内部类列表</td>
</tr>

<tr>
<td class="left">linenumbertable</td>
<td class="left">code属性</td>
<td class="left">Java源码的行号与字节码指令的对应关系</td>
</tr>

<tr>
<td class="left">localvariabletable</td>
<td class="left">code属性</td>
<td class="left">方法的局部变量描述</td>
</tr>

<tr>
<td class="left">stackmaptable</td>
<td class="left">code属性</td>
<td class="left">JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">signature</td>
<td class="left">类，方法表，字段表</td>
<td class="left">用于支持泛型情况下的方法签名</td>
</tr>

<tr>
<td class="left">sourcefile</td>
<td class="left">类文件</td>
<td class="left">记录源文件名称</td>
</tr>

<tr>
<td class="left">sourcedebugextension</td>
<td class="left">类文件</td>
<td class="left">用于存储额外的调试信息</td>
</tr>

<tr>
<td class="left">synthetic</td>
<td class="left">类，方法表，字段表</td>
<td class="left">标志方法或字段为编译器自动生成的</td>
</tr>

<tr>
<td class="left">localvariabletypetable</td>
<td class="left">类</td>
<td class="left">使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>

<tr>
<td class="left">runtimevisibleannotations</td>
<td class="left">类，方法表，字段表</td>
<td class="left">为动态注解提供支持</td>
</tr>

<tr>
<td class="left">runtimeinvisibleannotations</td>
<td class="left">表，方法表，字段表</td>
<td class="left">用于指明哪些注解是运行时不可见的</td>
</tr>

<tr>
<td class="left">runtimevisibleparameterannotation</td>
<td class="left">方法表</td>
<td class="left">作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法</td>
</tr>

<tr>
<td class="left">runtimeinvisibleparameterannotation</td>
<td class="left">方法表</td>
<td class="left">作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数</td>
</tr>

<tr>
<td class="left">annotationdefault</td>
<td class="left">方法表</td>
<td class="left">用于记录注解类元素的默认值</td>
</tr>

<tr>
<td class="left">bootstrapmethods</td>
<td class="left">类文件</td>
<td class="left">用于保存invokeddynamic指令引用的引导方式限定符</td>
</tr>
</tbody>
</table>

<p>
对于每个属性，它的名称需要从常量池中引用一个 CONSTANT_utf8_info 类型的常量类表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性区说明属性值所占用的位数即可
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 12:</span> 属性表定义的结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attribute_name_index</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attribute_length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u1</td>
<td class="left">info</td>
<td class="right">attribute_length</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-2-7-1" class="outline-4">
<h4 id="sec-2-7-1">Code 属性</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
Java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在 <b>Code属性</b> 内。Code属性出现在 <span class="underline">方法表的属性集合</span> 之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表所示：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 13:</span> Code属性表的结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attribute_name_index</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u4</td>
<td class="left">attribute_length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">max_stack</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">max_locals</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u4</td>
<td class="left">code_length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u1</td>
<td class="left">code</td>
<td class="right">code_length</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">exception_table_length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">exception_info</td>
<td class="left">exception_table</td>
<td class="right">exception_length</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attributes_count</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">attribute_info</td>
<td class="left">attributes</td>
<td class="right">attributes_count</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><b>attribute_name_index</b> : 指向CONSTANT_Utf8_info型常量的索引，常量值固定为 <span class="underline">Code</span> ，它代表了该属性的属性名称
</li>
<li><b>attribute_length</b> : 指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为 <span class="underline">整个属性表长度减去6个字节</span> 
</li>
<li><b>max_stack</b> : 操作数栈( <span class="underline">Operand Stacks</span> )深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度
</li>
<li><b>max_locals</b> :  <span class="underline">局部变量表所需的存储空间</span> 。这里的单位是 <span class="underline">Slot</span> ，Slot是虚拟机为局部变量分配内存所使用的最小单位
<ul class="org-ul">
<li>对于byte、char、float、int、short、boolean和return address等长度不超过32位的数据类型，每个局部变量占用1个Slot
</li>
<li>double和long这两种64位的数据类型则需要两个Slot来存放
</li>
<li>需要使用局部变量表来存放：
<ul class="org-ul">
<li>方法参数：包含实例方法中的隐藏参数this
</li>
<li>显式异常处理器的参数：try-catch语句中catch块所定义的异常
</li>
<li>方法体中定义的局部变量
</li>
</ul>
</li>
</ul>
</li>
</ul>

<pre class="example">
并不是在方法中用到了參少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值

原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用

Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小
</pre>

<ul class="org-ul">
<li><b>code_length</b> : 字节码长度
<pre class="example">
    虽然它是一个u4类型的长度值，理论上最大值可以达到2^32-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度
  
    如果超过这个限制，Javac编译器也会拒绝编译
  
    一般来讲，编写Java代码时只要不是刻意去编写一个超长的方法来为难编译器，是不太可能超过这个最大值的限制
  
    但是某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就可能因为方法生成字节码超长的原因而导致编译失败
</pre>
</li>

<li><b>code</b> : 存储字节码指令的一系列字节流。也叫 <span class="underline">字节码指令</span> ，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解
</li>
</ul>
<pre class="example">
  一个u1数据类型的取值范围为0x00〜OxFF，对应十进制的0〜255，也就是一共可以表达256条指令

  目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令
</pre>
</div>


<div id="outline-container-sec-2-7-1-1" class="outline-5">
<h5 id="sec-2-7-1-1">Code属性实例</h5>
<div class="outline-text-5" id="text-2-7-1-1">
<p>
Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为：
</p>
<ul class="org-ul">
<li><b>代码</b> ：方法体里面的Java代码
</li>
<li><b>元数据</b> ：包括类、字段、方法定义及其他信息
</li>
</ul>

<p>
在整个Class文件中，Code属性用于描述 <span class="underline">代码</span> ，所有的其他数据项目都用于描述 <span class="underline">元数据</span> 。上一节分析过的实例构造器 <span class="underline">&lt;init&gt;</span> 方法的Code属性如下图所示：
</p>


<div class="figure">
<p><img src="pic/code-attribute.jpg" alt="code-attribute.jpg" width="70%" />
</p>
</div>

<p>
它的操作数栈的最大深度和本地变量表的容量都为 <span class="underline">0x0001</span> ，字节码区域所占空间的长度为 <span class="underline">0x0005</span> 。虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译 <span class="underline">2AB7000AB1</span> 的过程为:
</p>
<ol class="org-ol">
<li>读入 <span class="underline">2A</span> ，查表得0x2A对应的指令为 <b>aload_0</b> ，这个指令的含义是 <span class="underline">将第0个Slot中为reference类型的本地变量推送到操作数栈顶</span>
</li>
<li>读入 <span class="underline">B7</span> ，查表得0xB7对应的指令为 <b>invokespecial</b> ，这条指令的作用是 <span class="underline">以栈顶的reference类型的数据所指向的对象作为方法接收者</span> ，调用此对象的实例构造器方法、private方法或者它的父类的方法
<ul class="org-ul">
<li>这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用
</li>
</ul>
</li>
<li>读入 <span class="underline">000A</span> ，这是 <span class="underline">invokespecial</span> 的参数，查常量池得0x000A对应的常量为实例构造器 <span class="underline">&lt;init&gt;</span> 方法的符号引用
</li>
<li>读入 <span class="underline">B1</span> ，查表得0xB1对应的指令为 <span class="underline">return</span> ，含义是返回此方法，并且返回值为 <span class="underline">void</span> 。这条指令执行后，当前方法结束
</li>
</ol>

<p>
再次使用javap命令把此Class文件中的另外一个方法的字节码指令也计算出来，结果如下图所示：
</p>


<div class="figure">
<p><img src="pic/javap-sample.jpg" alt="javap-sample.jpg" width="70%" />
</p>
</div>

<pre class="example">
  没有任何参数，没有定义任何局部变量，但是 Locals 和 Args_size 值为1：

  在任何实例方法里面，都可以通过 this 关键字访问到此方法所属的对象

  实现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已

  因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算

  这个处理只对实例方法有效，如果把inc()方法声明为static，那Args_size就不会等于1而是等于0了
</pre>

<p>
在字节码指令之后的是这个方法的 <b>显式异常处理表集合</b> ，异常表对于Code属性来说并不是 <span class="underline">必须存在的</span> 
</p>
</div>
</div>


<div id="outline-container-sec-2-7-1-2" class="outline-5">
<h5 id="sec-2-7-1-2">异常处理表集合</h5>
<div class="outline-text-5" id="text-2-7-1-2">
<p>
异常表的格式如下表所示：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 14:</span> 异常处理表集合</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">start_pc</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">end_pc</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">handler_pc</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">catch_type</td>
<td class="right">1</td>
</tr>
</tbody>
</table>

<p>
它包含4个字段：如果当字节码在第 <span class="underline">start_pc</span> 行到第 <span class="underline">end_pc</span> 行之间(不含第end_pc行)出现了类型为 <span class="underline">catch_type</span> 或者其子类的异常(catch_type为指向一个CONSTANT_Class_info型常量的索引)，则转到第 <span class="underline">handler_pc</span> 行继续处理。当catch_type的值为0时，代表 <b>任意异常情况都需要转向到handler_pc处进行处理</b> 
</p>

<p>
异常表实际上是Java代码的一部分，编译器使用 <b>异常表而不是简单的跳转命令</b> 来实现Java异常及finally处理机制
</p>

<p>
下面代码主要演示了在字节码层面中try-catch-finally是如何实现的：
</p>


<div class="figure">
<p><img src="pic/javap-try-catch.jpg" alt="javap-try-catch.jpg" width="70%" />
</p>
</div>

<p>
编译器为这段Java源码生成了3条异常表记录，对应3条可能出现的代码执行路径。从Java代码的语义上讲,这3条执行路径分别为:
</p>
<ol class="org-ol">
<li>如果try语句块中出现属于Exception或其子类的异常,则转到catch语句块处理
</li>
<li>如果try语句块中出现不属于Exception或其子类的异常,则转到finally语句块处理
</li>
<li>如果catch语句块中出现任何异常,则转到finally语句块处理
</li>
</ol>

<pre class="example">
  如果没有出现异常,返回值是1

  如果出现了Exception异常,返回值是2

  如果出现了Exception以外的异常,方法非正常退出,没有返回值
</pre>

<ul class="org-ul">
<li>字节码中第0〜4行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到最后一个本地变量表的Slot中 
</li>
</ul>
<pre class="example">
  这个Slot里面的值在ireturn指令执行前将会被重新读到操作栈顶,作为方法返回值使用

  为了讲解方便,给这个Slot起了个名字: returnValue
</pre>
<ul class="org-ul">
<li>如果这时没有出现异常
<ul class="org-ul">
<li>则会继续走到第5〜9行，将变量x赋值为3，然后将之前保存在 <span class="underline">returnValue</span> 中的整数1读入到操作栈顶
</li>
<li>最后ireturn指令会以int形式返回操作栈顶中的值，方法结束
</li>
</ul>
</li>
<li>如果出现了异常
<ul class="org-ul">
<li>PC寄存器指针转到第10行，第10〜20行所做的事情是将2赋值给变量x，然后将变量x此时的值赋给 <span class="underline">returnValue</span> ，最后再将变量x的值改为3
</li>
<li>方法返回前同样将 <span class="underline">returnValue</span> 中保留的整数2读到了操作栈顶
</li>
<li>从第21行开始的代码，作用是变量x的值賦为3，并将栈顶的异常拋出，方法结束
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-7-2" class="outline-4">
<h4 id="sec-2-7-2">Exception 属性</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
<span class="underline">Exceptions属性</span> 是在方法表中与Code属性平级的一项属性，不要与前面刚刚讲解完的异常表产生混淆。Exceptions属性的作用是 <b>列举出方法中可能拋出的受查异常</b> (Checked Excepitons)，也就是方法描述时在throws关键字后面列举的异常：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 15:</span> 异常属性结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attribute_name_index</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attribute_length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attribute_of_exception</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">exception_index_table</td>
<td class="right">number_of_exceptions</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><b>number_of_exceptions</b> :方法可能拋出的受查异常数量
</li>
<li><b>exception_index_table</b> : 是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-7-3" class="outline-4">
<h4 id="sec-2-7-3">LineNumberTable属性</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
<span class="underline">LineNumberTable</span> 属性用于描述 <b>Java源码行号与字节码行号(字节码的偏移量)之间的对应关系</b> 。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用 <span class="underline">-g:none</span> 或 <span class="underline">-g:lines</span> 选项来取消或要求生成这项信息
</p>

<pre class="example">
  如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当拋出异常时，堆栈中将不会显示出错的行号

  并且在调试程序的时候，也无法按照源码行来设置断点
</pre>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 16:</span> LineNumberTable属性结构</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">类型</td>
<td class="left">名称</td>
<td class="right">数量</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">attribute_name_index</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u4</td>
<td class="left">attribute_length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">u2</td>
<td class="left">line_number_table_length</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">line_number_info</td>
<td class="left">line_number_table</td>
<td class="right">line_number_table_length</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>line_number_table是一个数量为line_number_table_length，类型为line_number_info的集合
<ul class="org-ul">
<li>line_number_info表：
<ul class="org-ul">
<li>start_pc: 字节码行号
</li>
<li>line_number: Java源代码行号
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-7-4" class="outline-4">
<h4 id="sec-2-7-4">LocalVariableTable属性</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
