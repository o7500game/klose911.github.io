<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>内存模型</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="jvm_example.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">内存模型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3a66ffb">硬件的效率与一致性</a></li>
<li><a href="#orgfbe8f2d">JVM内存模型</a>
<ul>
<li><a href="#org6a3923d">主内存与工作内存</a></li>
<li><a href="#orgd5c32f5">内存间交互操作</a>
<ul>
<li><a href="#orgeefc6d9">执行顺序</a></li>
</ul>
</li>
<li><a href="#org2953955">volatile型变量的特殊规则</a></li>
</ul>
</li>
<li><a href="#org74dec75">JVM线程实现</a></li>
</ul>
</div>
</div>
<p>
<b>多任务处理</b> 在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是 <b>计算机的 <span class="underline">运算</span> 速度与它的 <span class="underline">存储</span> 和 <span class="underline">通信</span> 子系统速度的差距太大</b> ，大量的时间都花费在 <span class="underline">磁盘I/O</span> 、 <span class="underline">网络通信</span> 或者 <span class="underline">数据库</span> 访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的浪费，而让计算机同时处理几项任务则是最容易想到、也被证明是非常有效的“压榨”手段
</p>

<p>
除了充分利用计算机处理器的能力外， <b>一个服务端同时对多个客户端</b> 提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏， <b>每秒事务处理数</b> ( <span class="underline">TPS</span> )是最重要的指标之一，它代表着 <b>一秒内服务端平均能响应的请求总数</b> ，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间 <span class="underline">频繁阻塞</span> 甚至 <span class="underline">死锁</span> ，将会 <b>大大降低程序的并发能力</b> 
</p>


<p>
服务端是Java语言最擅长的领域之一，这个领域的应用占了Java应用中最大的一块份额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持。幸好Java语言和虚拟机提供了许多工具，把并发编程的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线程并发细节，使得程序员在编码时能更关注业务逻辑，而不是花费大部分时间去关注此服务会同时被多少人调用、如何协调硬件资源
</p>

<p>
但是无论语言、中间件和框架如何先进，开发人员都不能期望它们能独立完成所有并发处理的事情，了解并发的内幕也是成为一个高级程序员不可缺少的课程
</p>

<pre class="example">
Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力

摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系

这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程
</pre>
<div id="outline-container-org3a66ffb" class="outline-2">
<h2 id="org3a66ffb">硬件的效率与一致性</h2>
<div class="outline-text-2" id="text-org3a66ffb">
<p>
先花费一点时间去了解一下物理计算机中的 <b>并发</b> 问题
</p>
<pre class="example">
    物理机遇到的并发问题与虚拟机中的情况有不少相似之处

    物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义
</pre>

<p>
<span class="underline">让计算机并发执行若干个运算任务</span> 与 <span class="underline">更充分地利用计算机处理器的效能</span> 之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是 <b>绝大多数的运算任务都不可能只靠处理器 <span class="underline">计算</span> 就能完成</b> ，处理器至少要与 <b>内存交互</b> ，如 <span class="underline">读取运算数据</span> 、 <span class="underline">存储运算结果</span> 等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层 <b>读写速度尽可能接近处理器运算速度的高速缓存</b> 来作为内存与处理器之间的缓冲：
</p>
<ul class="org-ul">
<li>将运算 <b>需要使用到的数据复制到缓存</b> 中，让运算能快速进行</li>
<li>当运算结束后再从 <b>缓存同步计算结果回内存</b> 之中，这样处理器就无须等待缓慢的内存读写了</li>
</ul>

<p>
基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题： <b>缓存一致性</b> 。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如下图所示：
</p>


<div class="figure">
<p><img src="pic/cache_coherence.png" alt="cache_coherence.png" width="50%" /> 
</p>
</div>

<pre class="example">
    当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致

    如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？

    为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作

    这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等
</pre>
<p>
以后将会多次提到的 <span class="underline">内存模型</span> 一词，可以理解为 <b>在 <span class="underline">特定的操作协议</span> 下，对 <span class="underline">特定的内存</span> 或 <span class="underline">高速缓存</span> 进行读写访问的过程抽象</b> 
</p>
<pre class="example">
    不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型

    这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性
</pre>

<p>
除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行 <span class="underline">乱序执行</span> 优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其 <b>顺序性并不能靠代码的先后顺序来保证</b> 。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的 <span class="underline">指令重排序</span> 优化
</p>
</div>
</div>
<div id="outline-container-orgfbe8f2d" class="outline-2">
<h2 id="orgfbe8f2d">JVM内存模型</h2>
<div class="outline-text-2" id="text-orgfbe8f2d">
<p>
Java虚拟机规范中试图定义一种 <span class="underline">Java内存模型</span> (JMM)来 <b>屏蔽掉各种硬件和操作系统的内存访问差异</b> ，以实现让Java程序在各种平台下都能达到一致的内存访问效果
</p>
<pre class="example">
    在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型

    由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错

    因此在某些场景就必须针对不同的平台来编写程序
</pre>

<p>
定义Java内存模型并非一件容易的事情：
</p>
<ul class="org-ul">
<li>这个模型必须定义得 <b>足够严谨</b> ，才能让Java的并发内存访问操作不会产生歧义</li>
<li>也必须定义得 <b>足够宽松</b> ，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度</li>
</ul>

<p>
经过长时间的验证和修补，在 JDK 1.5（实现了 <span class="underline">JSR-133[2]</span> ）发布后，Java内存模型已经成熟和完善起来了
</p>
</div>
<div id="outline-container-org6a3923d" class="outline-3">
<h3 id="org6a3923d">主内存与工作内存</h3>
<div class="outline-text-3" id="text-org6a3923d">
<p>
Java内存模型的主要目标是 <b>定义程序中各个变量的访问规则</b> ，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的 <span class="underline">变量</span> 与 <span class="underline">Java编程中所说的变量</span> 有所区别，它包括了 <span class="underline">实例字段</span> 、 <span class="underline">静态字段</span> 和 <span class="underline">构成数组对象的元素</span> ，但不包括 <b>局部变量</b> 与 <b>方法参数</b> ，因为后者是 <b>线程私有的</b> ，不会被共享，自然就不会存在竞争问题
</p>
<pre class="example">
为了获得较好的执行效能

Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互

也没有限制即时编译器进行调整代码执行顺序这类优化措施
</pre>

<p>
Java内存模型规定了 <b>所有的变量都存储在主内存</b> 中
</p>
<pre class="example">
     此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分
</pre>

<p>
每条 <b>线程</b> 还有自己的 <b>工作内存</b> ：
</p>
<ul class="org-ul">
<li>线程的工作内存中保存了被该线程使用到的 <b>变量的主内存副本拷贝</b></li>
<li>线程对变量的所有操作（ <span class="underline">读取</span> 、 <span class="underline">赋值</span> 等）都必须在 <b>工作内存</b> 中进行，而不能 <b>直接读写主内存中的变量</b></li>
<li><b>不同的线程</b> 之间也 <b>无法直接访问对方工作内存中的变量</b> ，线程间变量值的 <b>传递</b> 均需要通过 <span class="underline">主内存</span> 来完成</li>
</ul>
<pre class="example">
     可与前面讲的处理器高速缓存类比
</pre>

<p>
线程、主内存、工作内存三者的交互关系如下图所示：
</p>

<div class="figure">
<p><img src="pic/working_memory.png" alt="working_memory.png" width="50%" /> 
</p>
</div>


<p>
注意：
</p>
<ul class="org-ul">
<li>如果局部变量是一个 <span class="underline">reference</span> 类型，它引用的对象在 <b>Java堆中可被各个线程共享</b> ，但是reference本身在 <b>Java栈的局部变量表</b> 中，它是 <b>线程私有的</b></li>
<li>拷贝副本，假设线程中访问一个10MB的对象，也会把这10MB的内存复制一份拷贝出来吗？ 事实上并不会如此， 这个 <span class="underline">对象的引用</span> 、对象中 <span class="underline">某个在线程访问到的字段</span> 是 <b>有可能存在拷贝</b> 的，但不会有虚拟机实现成把整个对象拷贝一次</li>
<li><b>volatile</b> 变量依然有 <b>工作内存的拷贝</b> ，但是由于它 <b>特殊的操作顺序性</b> 规定，所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于volatile也并不存在例外</li>
<li>除了实例数据，Java堆还保存了对象的其他信息，对于HotSpot虚拟机来讲 
<ul class="org-ul">
<li>有Mark Word
<ul class="org-ul">
<li>存储对象哈希码</li>
<li>GC标志</li>
<li>GC年龄</li>
<li>同步锁等信息）</li>
</ul></li>
<li>Klass Point : 指向存储类型元数据的指针</li>
<li>字节对齐补白的填充数据 ： 如果实例数据刚好满足8字节对齐的话，则可以不存在补白</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd5c32f5" class="outline-3">
<h3 id="orgd5c32f5">内存间交互操作</h3>
<div class="outline-text-3" id="text-orgd5c32f5">
<p>
关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下 <b>8种操作</b> 来完成，虚拟机实现时必须保证下面提及的 <b>每一种操作都是原子的、不可再分的</b> 
</p>
<pre class="example">
     对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外
</pre>
<ul class="org-ul">
<li><b>lock</b> （锁定）：作用于 <span class="underline">主内存</span> 的变量，它把一个变量 <b>标识为一条线程独占</b> 的状态</li>
<li><b>unlock</b> （解锁）：作用于 <span class="underline">主内存</span> 的变量，它把一个处于 <b>锁定状态的变量释放</b> 出来，释放后的变量才可以被 <span class="underline">其他线程</span> 锁定</li>
<li><b>read</b> （读取）：作用于 <span class="underline">主内存</span> 的变量，它把一个变量的值从 <b>主内存传输到线程的工作内存</b> 中，以便随后的 <span class="underline">load</span> 动作使用</li>
<li><b>load</b> （载入）：作用于 <span class="underline">工作内存</span> 的变量，它把 <span class="underline">read</span> 操作从主内存中得到的 <b>变量值放入工作内存的变量副本</b> 中</li>
<li><b>use*（使用）：作用于 <span class="underline">工作内存</span> 的变量，它把工作内存中一个 *变量的值传递给执行引擎</b> ，每当虚拟机遇到一个 <span class="underline">需要使用到变量的值</span> 的字节码指令时将会执行这个操作</li>
<li><b>assign*（赋值）：作用于 <span class="underline">工作内存</span> 的变量，它把一个 *从执行引擎接收到的值赋给工作内存的变量</b> ，每当虚拟机遇到一个给 <span class="underline">变量赋值</span> 的字节码指令时执行这个操作</li>
<li><b>store*（存储）：作用于 <span class="underline">工作内存</span> 的变量，它把工作内存中一个 *变量的值传送到主内存</b> 中，以便随后的 <span class="underline">write</span> 操作使用</li>
<li><b>write*（写入）：作用于 <span class="underline">主内存</span> 的变量，它把 <span class="underline">store</span> 操作从 *工作内存中得到的变量的值放入主内存的变量</b> 中</li>
</ul>
</div>

<div id="outline-container-orgeefc6d9" class="outline-4">
<h4 id="orgeefc6d9">执行顺序</h4>
<div class="outline-text-4" id="text-orgeefc6d9">
<ul class="org-ul">
<li>如果要把一个变量从 <b>主内存复制到工作内存</b> ，那就要 <b>顺序地执行 <span class="underline">read</span> 和 <span class="underline">load</span> 操作</b></li>
<li>如果要把变量从 <b>工作内存同步回主内存</b> ，就要 <b>顺序地执行 <span class="underline">store</span> 和 <span class="underline">write</span> 操作</b></li>
</ul>

<pre class="example">
      注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行

      也就是说，read与load之间、store与write之间是可插入其他指令的

      如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a
</pre>

<p>
除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
</p>
<ul class="org-ul">
<li>不允许 <span class="underline">read</span> 和 <span class="underline">load</span> 、 <span class="underline">store</span> 和 <span class="underline">write</span> 操作之一 <b>单独出现</b> ，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在 <b>工作内存中改变了之后必须把该变化同步回主内存</b></li>
<li>不允许一个线程无原因地， <b>没有发生过任何 <span class="underline">assign</span> 操作</b> ，把数据从线程的 <b>工作内存同步回主内存中</b></li>
<li>一个 <b>新的变量只能在主内存中诞生</b> ，不允许在工作内存中直接使用一个 <b>未被初始化</b> （ <span class="underline">load</span> 或 <span class="underline">assign</span> ）的变量，换句话说，就是 <b>对一个变量实施 <span class="underline">use</span> 、 <span class="underline">store</span> 操作之前，必须先执行过了 <span class="underline">assign</span> 和 <span class="underline">load</span> 操作</b></li>
<li>一个变量在 <b>同一个时刻只允许 <span class="underline">一条线程</span> 对其进行 <span class="underline">lock</span> 操作</b> 
<ul class="org-ul">
<li>但 <span class="underline">lock</span> 操作可以被 <span class="underline">同一条线程</span>  <b>重复执行多次</b> ，多次执行 lock 后，只有 <b>执行相同次数的 <span class="underline">unlock</span> 操作</b> ，变量才会被解锁</li>
<li>如果对一个变量执行 <span class="underline">lock</span> 操作，那将会 <b>清空工作内存中此变量的值</b> ，在 <span class="underline">执行引擎</span> 使用这个变量前，需要 <b>重新执行 <span class="underline">load</span> 或 <span class="underline">assign</span> 操作</b> 初始化变量的值</li>
</ul></li>
<li>如果一个变量 <b>事先没有被 <span class="underline">lock</span> 操作锁定</b> ，那就 <b>不允许对它执行 <span class="underline">unlock</span> 操作</b> ，也 <b>不允许去 unlock 一个 <span class="underline">被其他线程</span> 锁定</b> 住的变量
<ul class="org-ul">
<li>对一个变量执行 <span class="underline">unlock</span> 操作之前，必须 <b>先把此变量同步回主内存中</b> ，也就是执行 <span class="underline">store</span> 、 <span class="underline">write</span> 操作</li>
</ul></li>
</ul>

<pre class="example">
       基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这8种操作去定义Java内存模型的访问协议了

      仅是描述方式改变了，Java内存模型并没有改变
</pre>
</div>
</div>
</div>

<div id="outline-container-org2953955" class="outline-3">
<h3 id="org2953955">volatile型变量的特殊规则</h3>
</div>
</div>
<div id="outline-container-org74dec75" class="outline-2">
<h2 id="org74dec75">JVM线程实现</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
