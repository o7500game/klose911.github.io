<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>内存模型</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="jvm_example.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">内存模型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3a66ffb">硬件的效率与一致性</a></li>
<li><a href="#orgfbe8f2d">JVM内存模型</a>
<ul>
<li><a href="#org6a3923d">主内存与工作内存</a></li>
<li><a href="#orgd5c32f5">内存间交互操作</a>
<ul>
<li><a href="#orgeefc6d9">执行顺序</a></li>
</ul>
</li>
<li><a href="#org2953955">volatile型变量的特殊规则</a>
<ul>
<li><a href="#org541f4af">可见性</a></li>
<li><a href="#org498d707">指令重排</a></li>
<li><a href="#org74bf303">总结</a></li>
<li><a href="#org41e78d7">对于long和double型变量的特殊规则</a></li>
</ul>
</li>
<li><a href="#org2506188">原子性、可见性与有序性</a></li>
</ul>
</li>
<li><a href="#org74dec75">JVM线程实现</a></li>
</ul>
</div>
</div>
<p>
<b>多任务处理</b> 在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是 <b>计算机的 <span class="underline">运算</span> 速度与它的 <span class="underline">存储</span> 和 <span class="underline">通信</span> 子系统速度的差距太大</b> ，大量的时间都花费在 <span class="underline">磁盘I/O</span> 、 <span class="underline">网络通信</span> 或者 <span class="underline">数据库</span> 访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力“压榨”出来，否则就会造成很大的浪费，而让计算机同时处理几项任务则是最容易想到、也被证明是非常有效的“压榨”手段
</p>

<p>
除了充分利用计算机处理器的能力外， <b>一个服务端同时对多个客户端</b> 提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏， <b>每秒事务处理数</b> ( <span class="underline">TPS</span> )是最重要的指标之一，它代表着 <b>一秒内服务端平均能响应的请求总数</b> ，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间 <span class="underline">频繁阻塞</span> 甚至 <span class="underline">死锁</span> ，将会 <b>大大降低程序的并发能力</b> 
</p>


<p>
服务端是Java语言最擅长的领域之一，这个领域的应用占了Java应用中最大的一块份额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持。幸好Java语言和虚拟机提供了许多工具，把并发编程的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线程并发细节，使得程序员在编码时能更关注业务逻辑，而不是花费大部分时间去关注此服务会同时被多少人调用、如何协调硬件资源
</p>

<p>
但是无论语言、中间件和框架如何先进，开发人员都不能期望它们能独立完成所有并发处理的事情，了解并发的内幕也是成为一个高级程序员不可缺少的课程
</p>

<pre class="example">
Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力

摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系

这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程
</pre>
<div id="outline-container-org3a66ffb" class="outline-2">
<h2 id="org3a66ffb">硬件的效率与一致性</h2>
<div class="outline-text-2" id="text-org3a66ffb">
<p>
先花费一点时间去了解一下物理计算机中的 <b>并发</b> 问题
</p>
<pre class="example">
    物理机遇到的并发问题与虚拟机中的情况有不少相似之处

    物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义
</pre>

<p>
<span class="underline">让计算机并发执行若干个运算任务</span> 与 <span class="underline">更充分地利用计算机处理器的效能</span> 之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是 <b>绝大多数的运算任务都不可能只靠处理器 <span class="underline">计算</span> 就能完成</b> ，处理器至少要与 <b>内存交互</b> ，如 <span class="underline">读取运算数据</span> 、 <span class="underline">存储运算结果</span> 等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层 <b>读写速度尽可能接近处理器运算速度的高速缓存</b> 来作为内存与处理器之间的缓冲：
</p>
<ul class="org-ul">
<li>将运算 <b>需要使用到的数据复制到缓存</b> 中，让运算能快速进行</li>
<li>当运算结束后再从 <b>缓存同步计算结果回内存</b> 之中，这样处理器就无须等待缓慢的内存读写了</li>
</ul>

<p>
基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题： <b>缓存一致性</b> 。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如下图所示：
</p>


<div class="figure">
<p><img src="pic/cache_coherence.png" alt="cache_coherence.png" width="50%" /> 
</p>
</div>

<pre class="example">
    当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致

    如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？

    为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作

    这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等
</pre>
<p>
以后将会多次提到的 <span class="underline">内存模型</span> 一词，可以理解为 <b>在 <span class="underline">特定的操作协议</span> 下，对 <span class="underline">特定的内存</span> 或 <span class="underline">高速缓存</span> 进行读写访问的过程抽象</b> 
</p>
<pre class="example">
    不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型

    这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性
</pre>

<p>
除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行 <span class="underline">乱序执行</span> 优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其 <b>顺序性并不能靠代码的先后顺序来保证</b> 。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的 <span class="underline">指令重排序</span> 优化
</p>
</div>
</div>
<div id="outline-container-orgfbe8f2d" class="outline-2">
<h2 id="orgfbe8f2d">JVM内存模型</h2>
<div class="outline-text-2" id="text-orgfbe8f2d">
<p>
Java虚拟机规范中试图定义一种 <span class="underline">Java内存模型</span> (JMM)来 <b>屏蔽掉各种硬件和操作系统的内存访问差异</b> ，以实现让Java程序在各种平台下都能达到一致的内存访问效果
</p>
<pre class="example">
    在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型

    由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错

    因此在某些场景就必须针对不同的平台来编写程序
</pre>

<p>
定义Java内存模型并非一件容易的事情：
</p>
<ul class="org-ul">
<li>这个模型必须定义得 <b>足够严谨</b> ，才能让Java的并发内存访问操作不会产生歧义</li>
<li>也必须定义得 <b>足够宽松</b> ，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度</li>
</ul>

<p>
经过长时间的验证和修补，在 JDK 1.5（实现了 <span class="underline">JSR-133[2]</span> ）发布后，Java内存模型已经成熟和完善起来了
</p>
</div>
<div id="outline-container-org6a3923d" class="outline-3">
<h3 id="org6a3923d">主内存与工作内存</h3>
<div class="outline-text-3" id="text-org6a3923d">
<p>
Java内存模型的主要目标是 <b>定义程序中各个变量的访问规则</b> ，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的 <span class="underline">变量</span> 与 <span class="underline">Java编程中所说的变量</span> 有所区别，它包括了 <span class="underline">实例字段</span> 、 <span class="underline">静态字段</span> 和 <span class="underline">构成数组对象的元素</span> ，但不包括 <b>局部变量</b> 与 <b>方法参数</b> ，因为后者是 <b>线程私有的</b> ，不会被共享，自然就不会存在竞争问题
</p>
<pre class="example">
为了获得较好的执行效能

Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互

也没有限制即时编译器进行调整代码执行顺序这类优化措施
</pre>

<p>
Java内存模型规定了 <b>所有的变量都存储在主内存</b> 中
</p>
<pre class="example">
     此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分
</pre>

<p>
每条 <b>线程</b> 还有自己的 <b>工作内存</b> ：
</p>
<ul class="org-ul">
<li>线程的工作内存中保存了被该线程使用到的 <b>变量的主内存副本拷贝</b></li>
<li>线程对变量的所有操作（ <span class="underline">读取</span> 、 <span class="underline">赋值</span> 等）都必须在 <b>工作内存</b> 中进行，而不能 <b>直接读写主内存中的变量</b></li>
<li><b>不同的线程</b> 之间也 <b>无法直接访问对方工作内存中的变量</b> ，线程间变量值的 <b>传递</b> 均需要通过 <span class="underline">主内存</span> 来完成</li>
</ul>
<pre class="example">
     可与前面讲的处理器高速缓存类比
</pre>

<p>
线程、主内存、工作内存三者的交互关系如下图所示：
</p>

<div class="figure">
<p><img src="pic/working_memory.png" alt="working_memory.png" width="50%" /> 
</p>
</div>


<p>
注意：
</p>
<ul class="org-ul">
<li>如果局部变量是一个 <span class="underline">reference</span> 类型，它引用的对象在 <b>Java堆中可被各个线程共享</b> ，但是reference本身在 <b>Java栈的局部变量表</b> 中，它是 <b>线程私有的</b></li>
<li>拷贝副本，假设线程中访问一个10MB的对象，也会把这10MB的内存复制一份拷贝出来吗？ 事实上并不会如此， 这个 <span class="underline">对象的引用</span> 、对象中 <span class="underline">某个在线程访问到的字段</span> 是 <b>有可能存在拷贝</b> 的，但不会有虚拟机实现成把整个对象拷贝一次</li>
<li><b>volatile</b> 变量依然有 <b>工作内存的拷贝</b> ，但是由于它 <b>特殊的操作顺序性</b> 规定，所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于volatile也并不存在例外</li>
<li>除了实例数据，Java堆还保存了对象的其他信息，对于HotSpot虚拟机来讲 
<ul class="org-ul">
<li>Mark Word
<ul class="org-ul">
<li>存储对象哈希码</li>
<li>GC标志</li>
<li>GC年龄</li>
<li>同步锁等信息</li>
</ul></li>
<li>Klass Point : 指向存储类型元数据的指针</li>
<li>字节对齐补白的填充数据 ： 如果实例数据刚好满足8字节对齐的话，则可以不存在补白</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd5c32f5" class="outline-3">
<h3 id="orgd5c32f5">内存间交互操作</h3>
<div class="outline-text-3" id="text-orgd5c32f5">
<p>
关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下 <b>8种操作</b> 来完成，虚拟机实现时必须保证下面提及的 <b>每一种操作都是原子的、不可再分的</b> 
</p>
<pre class="example">
     对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外
</pre>
<ul class="org-ul">
<li><b>lock</b> （锁定）：作用于 <span class="underline">主内存</span> 的变量，它把一个变量 <b>标识为一条线程独占</b> 的状态</li>
<li><b>unlock</b> （解锁）：作用于 <span class="underline">主内存</span> 的变量，它把一个处于 <b>锁定状态的变量释放</b> 出来，释放后的变量才可以被 <span class="underline">其他线程</span> 锁定</li>
<li><b>read</b> （读取）：作用于 <span class="underline">主内存</span> 的变量，它把一个变量的值从 <b>主内存传输到线程的工作内存</b> 中，以便随后的 <span class="underline">load</span> 动作使用</li>
<li><b>load</b> （载入）：作用于 <span class="underline">工作内存</span> 的变量，它把 <span class="underline">read</span> 操作从主内存中得到的 <b>变量值放入工作内存的变量副本</b> 中</li>
<li><b>use</b> （使用）：作用于 <span class="underline">工作内存</span> 的变量，它把工作内存中一个 <b>变量的值传递给执行引擎</b> ，每当虚拟机遇到一个 <span class="underline">需要使用到变量的值</span> 的字节码指令时将会执行这个操作</li>
<li><b>assign</b> （赋值）：作用于 <span class="underline">工作内存</span> 的变量，它把一个 <b>从执行引擎接收到的值赋给工作内存的变量</b> ，每当虚拟机遇到一个给 <span class="underline">变量赋值</span> 的字节码指令时执行这个操作</li>
<li><b>store</b> （存储）：作用于 <span class="underline">工作内存</span> 的变量，它把工作内存中一个 <b>变量的值传送到主内存</b> 中，以便随后的 <span class="underline">write</span> 操作使用</li>
<li><b>write</b> （写入）：作用于 <span class="underline">主内存</span> 的变量，它把 <span class="underline">store</span> 操作从 <b>工作内存中得到的变量的值放入主内存的变量</b> 中</li>
</ul>
</div>

<div id="outline-container-orgeefc6d9" class="outline-4">
<h4 id="orgeefc6d9">执行顺序</h4>
<div class="outline-text-4" id="text-orgeefc6d9">
<ul class="org-ul">
<li>如果要把一个变量从 <b>主内存复制到工作内存</b> ，那就要 <b>顺序地执行 <span class="underline">read</span> 和 <span class="underline">load</span> 操作</b></li>
<li>如果要把变量从 <b>工作内存同步回主内存</b> ，就要 <b>顺序地执行 <span class="underline">store</span> 和 <span class="underline">write</span> 操作</b></li>
</ul>

<pre class="example">
      注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行

      也就是说，read与load之间、store与write之间是可插入其他指令的

      如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a
</pre>

<p>
除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
</p>
<ul class="org-ul">
<li>不允许 <span class="underline">read</span> 和 <span class="underline">load</span> 、 <span class="underline">store</span> 和 <span class="underline">write</span> 操作之一 <b>单独出现</b> ，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在 <b>工作内存中改变了之后必须把该变化同步回主内存</b></li>
<li>不允许一个线程无原因地， <b>没有发生过任何 <span class="underline">assign</span> 操作</b> ，把数据从线程的 <b>工作内存同步回主内存中</b></li>
<li>一个 <b>新的变量只能在主内存中诞生</b> ，不允许在工作内存中直接使用一个 <b>未被初始化</b> （ <span class="underline">load</span> 或 <span class="underline">assign</span> ）的变量，换句话说，就是 <b>对一个变量实施 <span class="underline">use</span> 、 <span class="underline">store</span> 操作之前，必须先执行过了 <span class="underline">assign</span> 和 <span class="underline">load</span> 操作</b></li>
<li>一个变量在 <b>同一个时刻只允许 <span class="underline">一条线程</span> 对其进行 <span class="underline">lock</span> 操作</b> 
<ul class="org-ul">
<li>但 <span class="underline">lock</span> 操作可以被 <span class="underline">同一条线程</span>  <b>重复执行多次</b> ，多次执行 lock 后，只有 <b>执行相同次数的 <span class="underline">unlock</span> 操作</b> ，变量才会被解锁</li>
<li>如果对一个变量执行 <span class="underline">lock</span> 操作，那将会 <b>清空工作内存中此变量的值</b> ，在 <span class="underline">执行引擎</span> 使用这个变量前，需要 <b>重新执行 <span class="underline">load</span> 或 <span class="underline">assign</span> 操作</b> 初始化变量的值</li>
</ul></li>
<li>如果一个变量 <b>事先没有被 <span class="underline">lock</span> 操作锁定</b> ，那就 <b>不允许对它执行 <span class="underline">unlock</span> 操作</b> ，也 <b>不允许去 unlock 一个 <span class="underline">被其他线程</span> 锁定</b> 住的变量
<ul class="org-ul">
<li>对一个变量执行 <span class="underline">unlock</span> 操作之前，必须 <b>先把此变量同步回主内存中</b> ，也就是执行 <span class="underline">store</span> 、 <span class="underline">write</span> 操作</li>
</ul></li>
</ul>

<pre class="example">
       基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这8种操作去定义Java内存模型的访问协议了

      仅是描述方式改变了，Java内存模型并没有改变
</pre>
</div>
</div>
</div>

<div id="outline-container-org2953955" class="outline-3">
<h3 id="org2953955">volatile型变量的特殊规则</h3>
<div class="outline-text-3" id="text-org2953955">
<p>
关键字 <b>volatile</b> 可以说是Java虚拟机提供的 <b>最轻量级的同步机制</b> 
</p>

<pre class="example">
volatile 并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用 synchronized 来进行同步

了解volatile变量的语义对后面了解多线程操作的其他特性很有意义

Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用
</pre>
</div>

<div id="outline-container-org541f4af" class="outline-4">
<h4 id="org541f4af">可见性</h4>
<div class="outline-text-4" id="text-org541f4af">
<p>
当一个变量定义为 <b>volatile</b> 之后，它将保证此变量对所有线程的 <b>可见性</b> ，这里的 <span class="underline">可见性</span> 是指 <b>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</b> 。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成
</p>

<pre class="example">
      例如，线程A修改一个普通变量的值，然后向主内存进行回写

      另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见
</pre>

<p>
关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出 <b>基于volatile变量的运算在并发下是安全的</b> 这个结论。volatile变量在 <span class="underline">各个线程的工作内存中不存在一致性问题</span> （在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的 <b>运算并非原子操作</b> ，导致 <b>volatile变量的运算在并发下一样是不安全的</b> ，可以通过一段简单的演示来说明原因，请看下面代码：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">VolatileTest</span> {

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">race</span> = 0;

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">increase</span>() {
        race++;
    }

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #00bfff; font-weight: bold;">final</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">THREADS_COUNT</span> = 20;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        <span style="color: #98f5ff;">Thread</span>[] <span style="color: #4eee94;">threads</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>[THREADS_COUNT];
        <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span> = 0; i &lt; <span style="color: #98f5ff;">THREADS_COUNT</span>; i++) {
            threads[i] = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Thread</span>(() -&gt; {
                    <span style="color: #00bfff; font-weight: bold;">for</span> (<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i1</span> = 0; i1 &lt; 10000; i1++) {
                        increase();
                    }
            });
            threads[i].start();
        }

        <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#25152;&#26377;&#32047;&#21152;&#32447;&#31243;&#37117;&#32467;&#26463;</span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (Thread.activeCount() &gt; 1)
            Thread.yield();

        System.out.println(race);
    }
}
</pre>
</div>

<pre class="example">
      这段代码发起了20个线程，每个线程对race变量进行10000次自增操作

      如果这段代码能够正确并发的话，最后输出的结果应该是200000

      然而运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字
</pre>

<p>
问题就出现在自增运算 <span class="underline">race++</span> 之中，用Javap反编译这段代码后会得到下面代码，发现只有一行代码的 <span class="underline">increase()</span>  方法在Class文件中是由 <b>4条字节码指令构成的</b> （return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：
</p>
<ul class="org-ul">
<li>当 <span class="underline">getstatic</span> 指令把 <span class="underline">race的值</span> 取到 <span class="underline">操作栈顶</span> 时， <b>volatile关键字保证了race的值在此时是正确的</b></li>
<li>但是在执行 <span class="underline">iconst_1</span> 、 <span class="underline">iadd</span> 这些指令的时候， <b>其他线程可能已经把race的值加大了</b> ，而 <b>在操作栈顶的值就变成了过期的数据</b> ，所以 <span class="underline">putstatic</span> 指令执行后就可能 <b>把较小的race值同步回主内存</b> 之中</li>
</ul>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">increase</span>();
  <span style="color: #ffd700;">descriptor</span>: ()V
  flags: ACC_PUBLIC, <span style="color: #98f5ff;">ACC_STATIC</span>
  <span style="color: #4eee94;">Code</span>:
    stack=2, locals=0, args_size=0
       0: getstatic     #2                  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Field race:I</span>
       3: iconst_1
       4: iadd
       5: putstatic     #2                  <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">Field race:I</span>
       8: <span style="color: #00bfff; font-weight: bold;">return</span>
    LineNumberTable:
      line 11: 0
      line 12: 8
</pre>
</div>

<pre class="example">
      客观地说，在此使用字节码来分析并发问题，仍然是不严谨的

      因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作

      一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义

      如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令

      此处使用-XX：+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析
</pre>

<p>
由于 <span class="underline">volatile</span> 变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过 <span class="underline">加锁</span> 来 <b>保证原子性</b> ：
</p>
<ul class="org-ul">
<li>运算结果并 <b>不依赖变量的当前值</b> ，或者能够确保只有 <b>单一的线程</b> 修改变量的值</li>
<li>变量 <b>不需要与其他的状态变量</b> 共同参与不变约束</li>
</ul>

<p>
如下的代码所示的这类场景就很适合使用 <span class="underline">volatile</span> 变量来控制并发，当 <span class="underline">shutdown()</span> 方法被调用时，能保证所有线程中执行的 <span class="underline">doWork()</span> 方法都立即停下来：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> <span style="color: #4eee94;">shutdownRequested</span>&#65307;

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> shutdown&#65288;&#65289;{
    shutdownRequested=<span style="color: #ffd700;">true</span>&#65307;
        }

<span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">void</span> <span style="color: #4eee94;">doWork</span>&#65288;&#65289;{
    <span style="color: #00bfff; font-weight: bold;">while</span>&#65288;&#65281;shutdownRequested&#65289;{
            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">do stuff</span>
        }
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org498d707" class="outline-4">
<h4 id="org498d707">指令重排</h4>
<div class="outline-text-4" id="text-org498d707">
<p>
使用volatile变量的第二个语义是 <b>禁止指令重排序优化</b> ，普通的变量仅仅会保证在 <b>该方法的执行过程中所有 <span class="underline">依赖赋值结果</span> 的地方都能获取到正确的结果</b> ，而 <b>不能保证 <span class="underline">变量赋值操作</span> 的顺序与 <span class="underline">程序代码中的执行顺序</span> 一致</b> 。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的 <span class="underline">线程内表现为串行的语义</span> 
</p>

<p>
继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码所示：
</p>
<div class="org-src-container">
<pre class="src src-java"> <span style="color: #98f5ff;">Map</span> <span style="color: #4eee94;">configOptions</span>&#65307;
 <span style="color: #98f5ff;">char</span>[] configText&#65307;

 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27492;&#21464;&#37327;&#24517;&#39035;&#23450;&#20041;&#20026;volatile</span>
 <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">boolean</span> initialized=<span style="color: #ffd700;">false</span>&#65307;
 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35774;&#20197;&#19979;&#20195;&#30721;&#22312;&#32447;&#31243;A&#20013;&#25191;&#34892;</span>

 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#27169;&#25311;&#35835;&#21462;&#37197;&#32622;&#20449;&#24687;&#65292;&#24403;&#35835;&#21462;&#23436;&#25104;&#21518;&#23558;initialized&#35774;&#32622;&#20026;true&#20197;&#36890;&#30693;&#20854;&#20182;&#32447;&#31243;&#37197;&#32622;&#21487;&#29992;</span>
     configOptions = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">HashMap</span>()&#65307;
     configText = readConfigFile(fileName)&#65307;
     processConfigOptions(configText, configOptions)&#65307;
     initialized = <span style="color: #ffd700;">true</span>&#65307;

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20551;&#35774;&#20197;&#19979;&#20195;&#30721;&#22312;&#32447;&#31243;B&#20013;&#25191;&#34892;</span>
 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;initialized&#20026;true&#65292;&#20195;&#34920;&#32447;&#31243;A&#24050;&#32463;&#25226;&#37197;&#32622;&#20449;&#24687;&#21021;&#22987;&#21270;&#23436;&#25104;</span>
     <span style="color: #00bfff; font-weight: bold;">while</span>(&#65281;initialized){
         sleep()&#65307;
     }
 <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#32447;&#31243;A&#20013;&#21021;&#22987;&#21270;&#22909;&#30340;&#37197;&#32622;&#20449;&#24687;</span>
     doSomethingWithConfig()&#65307;
</pre>
</div>

<p>
上面的程序是一段伪代码，其中描述的场景十分常见，只是在处理配置文件时一般不会出现并发而已。如果定义 initialized 变量时没有使用volatile修饰，就可能会由于 <span class="underline">指令重排序的优化</span> ，导致 <b>位于线程A中最后一句的代码 <span class="underline">initialized=true</span> 被提前执行</b> ，这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生
</p>

<pre class="example">
  这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行
</pre>

<p>
指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。下面代码是一段标准的DCL单例代码，可以观察加入 volatile 和 未加入volatile关键字时所生成汇编代码的差别：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">class</span> <span style="color: #98f5ff;">Singleton</span> {

    <span style="color: #00bfff; font-weight: bold;">private</span> <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">Singleton</span> <span style="color: #4eee94;">instance</span>;

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">Singleton</span> <span style="color: #daa520; font-weight: bold;">getInstance</span>() {
        <span style="color: #00bfff; font-weight: bold;">if</span> (instance == <span style="color: #ffd700;">null</span>) {
            <span style="color: #00bfff; font-weight: bold;">synchronized</span> (Singleton.<span style="color: #00bfff; font-weight: bold;">class</span>) {
                <span style="color: #00bfff; font-weight: bold;">if</span> (instance == <span style="color: #ffd700;">null</span>) {
                    instance = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">Singleton</span>();
                }
            }
        }
        <span style="color: #00bfff; font-weight: bold;">return</span> instance;
    }

    <span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">String</span>[] <span style="color: #4eee94;">args</span>) {
        Singleton.getInstance();
    }
}
</pre>
</div>

<p>
编译后，这段代码对instance变量赋值部分如下所示： 
</p>

<div class="org-src-container">
<pre class="src src-sh">0x01a3de0f&#65306;mov$<span style="color: #4eee94;">0</span>x3375cdb0&#65292;%esi         &#65307;&#8230;&#8230;beb0cd75 33
                                        &#65307;{oop&#65288;<span style="color: #deb887;">'Singleton'</span>&#65289;}
0x01a3de14&#65306;mov%eax&#65292;0x150&#65288;%esi&#65289;      &#65307;&#8230;&#8230;89865001 0000
0x01a3de1a&#65306;shr$<span style="color: #4eee94;">0</span>x9&#65292;%esi                &#65307;&#8230;&#8230;c1ee09
0x01a3de1d&#65306;movb$<span style="color: #4eee94;">0</span>x0&#65292;0x1104800&#65288;%esi&#65289;    &#65307;&#8230;&#8230;c6860048 100100
0x01a3de24&#65306;lock addl$<span style="color: #4eee94;">0</span>x0&#65292;&#65288;%esp&#65289;        &#65307;&#8230;&#8230;f0830424 00
                                        &#65307;*putstatic instance
                                        &#65307;-
Singleton&#65306;getInstance@24
</pre>
</div>


<p>
通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后（前面 <span class="underline">mov%eax，0x150(%esi)</span> 这句便是赋值操作）多执行了一个 <b>lock addl ＄0x0，(%esp)</b> 操作，这个操作相当于一个 <span class="underline">内存屏障</span> （指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。关键在于lock前缀，它的作用是使得 <b>本CPU的Cache写入了内存</b> ，该写入动作也会 <b>引起别的CPU或者别的内核无效化其Cache</b> ，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的 <span class="underline">store和write</span> 操作。所以通过这样一个空操作，可让前面volatile变量的 <b>修改对其他CPU立即可见</b> 
</p>

<pre class="example">
lock 指令中的 addl ＄0x0，(%esp) （把ESP寄存器的值加0）显然是一个 空操作

采用这个空操作而不是空操作指令nop是因为IA32手册规定 lock前缀不允许配合nop指令使用 
</pre>

<p>
从硬件架构上讲，指令重排序是指 CPU采用了允许将 <span class="underline">多条指令不按程序规定的顺序分开发送给各相应电路单元处理</span> 。但并不是说指令任意重排，CPU需要能 <b>正确处理指令依赖情况以保障程序能得出正确的执行结果</b> 
</p>
<pre class="example">
  譬如 指令1 把地址 A 中的值加10，指令2把地址 A 中的值乘以2，指令3把地址 B 中的值减去3

  这时指令1和指令2是有依赖的，它们之间的顺序不能重排，因为 (A+10) * 2 与 A * 2 +10 显然不相等

  但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可

  所以在本内CPU中，重排序看起来依然是有序的
</pre>
<p>
实际上， <span class="underline">lock addl＄0x0, (%esp)</span> 指令把 <span class="underline">修改同步到内存</span> 时，意味着 <b>所有之前的操作都已经执行完成</b> ，这样便形成了 <span class="underline">指令重排序无法越过内存屏障</span> 的效果
</p>
</div>
</div>


<div id="outline-container-org74bf303" class="outline-4">
<h4 id="org74bf303">总结</h4>
<div class="outline-text-4" id="text-org74bf303">
<p>
volatile 能让代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁，但是由于虚拟机对锁实行的许多消除和优化，使得很难量化地认为volatile就会比synchronized快多少。如果让volatile自己与自己比较，那可以确定一个原则:  volatile变量 <span class="underline">读操作的性能消耗与普通变量几乎没有什么差别</span> ，但是 <span class="underline">写操作则可能会慢一些</span> ，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，在volatile与锁之中选择的唯一依据仅仅是 <b>volatile的语义能否满足使用场景的需求</b> 
</p>

<p>
最后，回头看一下Java内存模型中对volatile变量定义的特殊规则。假定 <span class="underline">T</span> 表示一个 <span class="underline">线程</span> ， <span class="underline">V</span> 和 <span class="underline">W</span> 分别表示两个 <span class="underline">volatile型变量</span> ，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：
</p>
<ol class="org-ol">
<li>只有当线程 T 对变量 V 执行的前一个动作是 <span class="underline">load</span>  的时候，线程 T 才能对变量 V 执行 <span class="underline">use</span> 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 <span class="underline">use</span> 的时候，线程 T 才能对变量 V 执行 <span class="underline">load</span> 动作。线程T对变量V的use动作可以认为是和 线程 T 对变量 V 的 load、read动作相关联，必须连续一起出现。这条规则要求在 <span class="underline">工作内存</span> 中， <b>每次使用 V 前都必须先从主内存刷新最新的值</b> ，用于保证能看见其他线程对变量 V 所做的修改后的值</li>
<li>只有当线程 T 对变量 V 执行的前一个动作是 <span class="underline">assign</span> 的时候，线程 T 才能对变量 V 执行 <span class="underline">store</span> 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 <span class="underline">store</span> 的时候，线程 T 才能对变量 V 执行 <span class="underline">assign</span> 动作。线程 T 对变量 V 的 assign动作可以认为是和线程T对变量V的 <span class="underline">store、write</span> 动作相关联，必须连续一起出现。这条规则要求在工作内存中， <b>每次修改 V 后都必须立刻同步回主内存中</b> ，用于保证其他线程可以看到自己对变量V所做的修改</li>
</ol>

<pre class="example">
volatile屏蔽指令重排序的语义在JDK 1.5中才被完全修复

此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题）

这点也是在JDK 1.5之前的Java中无法安全地使用DCL（双锁检测）来实现单例模式的原因 
</pre>
</div>
</div>


<div id="outline-container-org41e78d7" class="outline-4">
<h4 id="org41e78d7">对于long和double型变量的特殊规则</h4>
<div class="outline-text-4" id="text-org41e78d7">
<p>
Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型 ( <span class="underline">long</span> 和 <span class="underline">double</span> )，在模型中特别定义了一条相对宽松的规定： <b>允许虚拟机将没有被 <span class="underline">volatile</span> 修饰的64位数据的读写操作划分为 <span class="underline">两次32位的操作</span> 来进行</b> ，即允许虚拟机实现选择可以不保证64位数据类型的 <span class="underline">load</span> 、_store_ 、 <span class="underline">read</span> 和 <span class="underline">write</span> 这4个操作的原子性，这点就是所谓的 <span class="underline">long和double的非原子性协定</span> 
</p>

<p>
如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了  <span class="underline">半个变量</span> 的数值
</p>

<pre class="example">
  不过这种读取到“半个变量”的情况非常罕见，在目前商用Java虚拟机中不会出现

  因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作

  但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现
</pre>
<p>
在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此在编写代码时 <b>一般不需要把用到的long和double变量专门声明为volatile</b> 
</p>
</div>
</div>
</div>

<div id="outline-container-org2506188" class="outline-3">
<h3 id="org2506188">原子性、可见性与有序性</h3>
</div>
</div>
<div id="outline-container-org74dec75" class="outline-2">
<h2 id="org74dec75">JVM线程实现</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
