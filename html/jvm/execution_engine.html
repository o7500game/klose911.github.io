<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>执行引擎</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="class_loader.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">执行引擎</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">运行时栈帧结构</a>
<ul>
<li><a href="#sec-1-1">局部变量表</a></li>
<li><a href="#sec-1-2">操作数栈</a></li>
<li><a href="#sec-1-3">动态连接</a></li>
<li><a href="#sec-1-4">方法返回地址</a></li>
<li><a href="#sec-1-5">附加信息</a></li>
</ul>
</li>
<li><a href="#sec-2">方法调用</a>
<ul>
<li><a href="#sec-2-1">解析</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<b>执行引擎</b> 是Java虚拟机最核心的组成部分之一。 <span class="underline">虚拟机</span> 是一个相对于 <span class="underline">物理机</span> 的概念，这两种机器都有代码执行能力，其区别：
</p>
<ul class="org-ul">
<li>物理机的执行引擎是 <b>直接建立在处理器、硬件、指令集和操作系统</b> 层面上的
</li>
<li>虚拟机的执行引擎则是由 <b>自己实现的</b> ，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式 
</li>
</ul>

<p>
在Java虚拟机规范中制定了 <span class="underline">虚拟机字节码执行引擎</span> 的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有 <span class="underline">解释执行</span> (通过解释器执行)和 <span class="underline">编译执行</span> (通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的:
</p>
<ul class="org-ul">
<li>输入：字节码文件
</li>
<li>处理：字节码解析的等效过程
</li>
<li>输出：执行结果
</li>
</ul>

<pre class="example">
  有一些虚拟机(如Sun Classic VM)的内部只存在解释器，只能解释执行

  另外一些虚拟机(如BEA JRockit)的内部只存在即时编译器，只能编译执行
</pre>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">运行时栈帧结构</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>栈帧</b> ( <span class="underline">Stack Frame</span> )是用于支持虚拟机进行 <b>方法调用和方法执行的数据结构</b> ，它是虚拟机运行时数据区中的 <b>虚拟机栈</b> ( <span class="underline">Virtual Machine Stack</span> )的栈元素。栈帧存储了方法的 
</p>
<ul class="org-ul">
<li><b>局部变量表</b>
</li>
<li><b>操作数栈</b> 
</li>
<li><b>动态连接</b>
</li>
<li><b>方法返回地址</b> 
</li>
<li>&#x2026;..
</li>
</ul>

<p>
每一个方法从调用开始至执行完成的过程，都对应着 <b>一个栈帧在虚拟机栈里面从入栈到出栈的过程</b> 
</p>

<pre class="example">
    在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中

    一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现
</pre>

<p>
一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中， <b>只有位于栈顶的栈帧才是有效的</b> ，称为 <span class="underline">当前栈帧</span> ( <span class="underline">Current Stack Frame</span> )，与这个栈帧相关联的方法称为 <span class="underline">当前方法</span> 。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示：
</p>


<div class="figure">
<p><img src="pic/jvm-stack-frame.png" alt="jvm-stack-frame.png" width="50%" /> 
</p>
</div>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">局部变量表</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>局部变量表</b> 是一组变量值存储空间，用于存放 <b>方法参数和方法内部定义的局部查量</b> 。在Java程序编译为Class文件时，就在 <span class="underline">方法的Code属性</span> 的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量
</p>

<p>
局部变量表的容量以 <b>变量槽</b> ( <span class="underline">Slot</span> )为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出 <span class="underline">每个Slot占用32位长度的内存空间</span> 是有一些差别的，它允许Slot的长度可以 <b>随着处理器、操作系统或虚拟机的不同而发生变化</b> 。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致
</p>

<pre class="example">
一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress8种类型

reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构
但一般来说，虚拟机实现至少都应当能通过这个引用做到两点
  1. 从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引
  2. 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息


returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址
很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替
</pre>
<p>
对于64位的数据类型，虚拟机会以 <span class="underline">高位对齐</span> 的方式为其 <span class="underline">分配两个连续的Slot空间</span> 。Java语言中明确的(reference类型则可能是32位也可能是64位)64位的数据类型只有long和double两种
</p>
<pre class="example">
     把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类似

     不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题
</pre>

<p>
虚拟机通过 <span class="underline">索引定位</span> 的方式使用局部变量表，索引值的范围是从 <span class="underline">0开始至局部变量表最大的Slot数量</span> 
</p>
<ul class="org-ul">
<li>如果访问的是 <span class="underline">32位</span> 数据类型的变量，索引 <span class="underline">n</span> 就代表了使用第 <span class="underline">n个Slot</span>
</li>
<li>如果是 <span class="underline">64位</span> 数据类型的变量，则说明会同时使用 <span class="underline">n</span> 和 <span class="underline">n+1</span> 两个Slot
<ul class="org-ul">
<li>对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在 <span class="underline">类加载的校验阶段拋出异常</span> 
</li>
</ul>
</li>
</ul>

<p>
在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法(非static的方法)，那 <b>局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用</b> ，在方法中可以通过关键字 <span class="underline">this</span> 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot
</p>

<p>
为了尽可能节省栈帧空间，局部变量表中的Slot是可以 <b>重用</b> 的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体， <b>如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用</b> 。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接 <span class="underline">影响到系统的垃圾收集行为</span> 
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)() {
    <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">placeholder</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[64 * 1024 * 1024];
    System.gc();
}
</pre>
</div>
<p>
首先向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。在虚拟机运行参数中加上 <span class="underline">-verbose:gc</span> 来看看垃圾收集的过程，发现在 <span class="underline">System.gc()</span> 运行后并没有回收这64MB的内存，运行结果:
</p>

<pre class="example">
[GC 66846K-&gt;65824K (125632K ) ,0.0032678 secs] [Full GC 65824K-&gt; 65746K (125632K) ,0.0064131 secs] 
</pre>

<p>
因为在执行 <span class="underline">Systemgc()</span> 时，变量 placeholder 还处于作用域之内,虚拟机自然不敢回收 placeholder 的内存。那把代码修改一下
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)() {
    {
        <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">placeholder</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[64 * 1024 * 1024];
    }
    System.gc();
}
</pre>
</div>

<p>
加入了花括号之后， placeholder 的作用域被限制在花括号之内，从代码逻辑上讲，在执行 <span class="underline">System.gc()</span> 的时候，placeholder 已经不可能再被访问了,但执行一下这段程序,会发现运行结果如下,还是有64MB的内存没有被回收
</p>

<p>
在调用System.gc() 之前加入—行 <span class="underline">int a=0;</span> 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)() {
    {
        <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">placeholder</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[64 * 1024 * 1024];
    }
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 0;
    System.gc();
}
</pre>
</div>

<pre class="example">
[GC 66401K-&gt; 65778K (125632K ) ,0.0035471 secs] [Full GC 65778K-&gt;218K (125632K) ,0.0140596 secs]
</pre>

<p>
placeholder能否被回收的根本原因是:局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了 placeholder 的作用域，但在此之后，没有任何对局部变量表的读写操作， <b>placeholder原本所占用的Slot还没有被其他变量所复用</b> ，所以作为GC Roots—部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微 
</p>

<pre class="example">
     如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值(把变量对应的局部变量表Slot清空)便不见得是一个绝对无意义的操作

     这种操作可以作为一种在极特殊情形(对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件)下的“奇技”来使用

     一本非常著名的书籍《Practical Java》中把“不使用的对象应手动赋值为null”作为一条推荐的编码规则，但是并没有解释具体的原因，很长时间之内都有读者对这条规则感到疑惑
</pre>

<p>
虽然代码示例说明了 <span class="underline">赋null值的操作</span> 在某些情况下确实是有用的，但不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因：
</p>
<ol class="org-ol">
<li>从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法
</li>
<li>从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GC Roots的枚举也与解释执行时期有巨大差别，以前面例子来看，第二种代码方式在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须写成手动操作
</li>
</ol>

<p>
局部变量不像前面介绍的类变量那样存在 <span class="underline">准备阶段</span> 。即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样， <b>如果一个局部变量定义了但没有赋初始值是不能使用的</b> ，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>;
    System.out.println(a);
}
</pre>
</div>

<pre class="example">
Test.java:4: error: variable a might not have been initialized
                System.out.println(a);
                                   ^
1 error
</pre>

<p>
编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虛拟机发现而导致类加载失败
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">操作数栈</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<b>操作数栈</b> ( <span class="underline">Operand Stack</span> )也常称为操作栈，它是一个 <span class="underline">后入先出</span> (LIFO)栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_Stacks数据项中
</p>

<p>
操作数栈的每一个元素可以是任意的Java数据类型，包括 <span class="underline">long</span> 和 <span class="underline">double</span> 。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的 <b>深度都不会超过在max_Stacks数据项中设定的最大值</b> 
</p>

<p>
当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作
</p>
<ul class="org-ul">
<li>做算术运算的时候是通过操作数栈来进行的
</li>
<li>调用其他方法的时候是通过操作数栈来进行参数传递
</li>
</ul>

<pre class="example">
     比如，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值

     当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈
</pre>


<p>
操作数栈中 <b>元素的数据类型必须与字节码指令的序列严格匹配</b> ，在编译程序代码的时候， <span class="underline">编译器要严格保证这一点</span> ，在 <span class="underline">类校验阶段的数据流分析</span> 中还要再次验证这一点
</p>

<pre class="example">
     以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况
</pre>


<p>
在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。 <b>让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据</b> ，无须进行额外的参数复制传递，重叠的过程如图所示：
</p>


<div class="figure">
<p><img src="pic/stack-frame-share.png" alt="stack-frame-share.png" width="50%" /> 
</p>
</div>

<p>
Java虚拟机的解释执行引擎称为 <span class="underline">基于栈的执行引擎</span> ,其中所指的 <span class="underline">栈</span> 就是 <b>操作数栈</b> 
</p>
</div>
</div>


<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">动态连接</h3>
<div class="outline-text-3" id="text-1-3">
<p>
每个栈帧都包含一个 <b>指向运行时常量池中该栈帧所属方法的引用</b> ，持有这个引用是为了 <b>支持方法调用过程中的动态连接</b> ( <span class="underline">Dynamic Linking</span> )
</p>

<p>
Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以 <b>常量池中指向方法的符号引用作为参数</b> 。这些符号引用可以被：
</p>
<ul class="org-ul">
<li>静态解析：类加载阶段或者第一次使用的时候就转化为直接引用
</li>
<li>动态链接：在每一次运行期间转化为直接引用
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">方法返回地址</h3>
<div class="outline-text-3" id="text-1-4">
<p>
当一个方法开始执行后，只有两种方式可以退出这个方法:
</p>
<ul class="org-ul">
<li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为 <span class="underline">正常完成出口</span> (Normal Method Invocation Completion)
</li>
<li>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用 <b>athrow</b> 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为 <span class="underline">异常完成出口</span> (Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是 <b>不会给它的上层调用者产生任何返回值</b> 
</li>
</ul>

<p>
无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说
</p>
<ol class="org-ol">
<li>方法正常退出时， <span class="underline">调用者的PC计数器的值</span> 可以作为返回地址，栈帧中 <b>很可能会保存这个计数器值</b> 
</li>
<li>而方法异常退出时，返回地址是要通过 <span class="underline">异常处理器表</span> 来确定的，栈帧中 <b>一般不会保存这部分信息</b>
</li>
</ol>

<p>
方法退出的过程实际上就等同于把 <b>当前栈帧出栈</b> ，因此退出时可能执行的操作有:
</p>
<ul class="org-ul">
<li>恢复上层方法的局部变量表和操作数栈
</li>
<li>把返回值(如果有的话)压入调用者栈帧的操作数栈中
</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令等
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">附加信息</h3>
<div class="outline-text-3" id="text-1-5">
<p>
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现
</p>

<pre class="example">
     在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">方法调用</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>方法调用</b> 阶段唯一的任务就是 <b>确定被调用方法的版本(即调用哪一个方法)</b> ，暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的链接步骤，一切方法调用在Class文件里面存储的都只是 <span class="underline">符号引用</span> ，而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用
</p>

<p>
在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。
</p>
<ul class="org-ul">
<li><b>invokestatic</b> : 调用 <b>静态</b> 方法
</li>
<li><b>invokespecial</b> : 调用实例构造器 <span class="underline">&lt;init&gt;</span> 方法、私有方法和父类方法
</li>
<li><b>invokevirtual</b> : 调用所有的 <b>虚</b> 方法
</li>
<li><b>invokeinterface</b> : 调用 <b>接口</b> 方法，会在运行时再确定一个实现此接口的对象
</li>
<li><b>invokedynamic</b> : 先在运行时 <b>动态解析出调用点限定符所引用的方法</b> ，然后再执行该方法
</li>
</ul>

<p>
在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">解析</h3>
<div class="outline-text-3" id="text-2-1">
<p>
所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是： <b>方法在程序真正运行之前就有一个确定的调用版本，并且这个方法的调用版本在运行期是不可改变的</b> 。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析
</p>

<p>
在Java语言中符合 <span class="underline">编译器可知，运行期不可变</span> 这个要求的方法，主要包括 <b>静态</b> 方法和 <b>私有</b> 方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各个的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析
</p>

<p>
只要能被 <span class="underline">invokestatic</span> 和 <span class="underline">invokespecial</span> 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有 <b>静态方法</b> 、 <b>私有方法</b> 、 <b>实例构造器</b> 、 <b>父类方法</b> 4类，它们在 <b>类加载的时候就会把符号引用解析为该方法的直接引用</b> 。这些方法可以称为 <span class="underline">非虚方法</span> ，与之相反，其他方法称为虚方法(除去 <b>final</b> 方法，后文会提到)。下面代码中静态方法 <span class="underline">sayHello()</span> 只可能属于类型 <span class="underline">StaticResolution</span> ，没有任何手段可以覆盖或隐藏这个方法
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#26041;&#27861;&#38745;&#24577;&#35299;&#26512;&#28436;&#31034;</span>
<span style="color: #ffa07a;"> * </span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@author</span><span style="color: #ffa07a;"> zzm</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StaticResolution</span> {
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>() {
        System.out.println(<span style="color: #ffa07a;">"hello world"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        StaticResolution.sayHello();
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
