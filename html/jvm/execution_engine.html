<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>执行引擎</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="class_loader.html"> UP </a>
 |
 <a accesskey="H" href="jvm.html"> HOME </a>
</div><div id="content">
<h1 class="title">执行引擎</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">运行时栈帧结构</a>
<ul>
<li><a href="#sec-1-1">局部变量表</a></li>
<li><a href="#sec-1-2">操作数栈</a></li>
<li><a href="#sec-1-3">动态连接</a></li>
<li><a href="#sec-1-4">方法返回地址</a></li>
<li><a href="#sec-1-5">附加信息</a></li>
</ul>
</li>
<li><a href="#sec-2">方法调用</a>
<ul>
<li><a href="#sec-2-1">解析</a></li>
<li><a href="#sec-2-2">分派</a>
<ul>
<li><a href="#sec-2-2-1">静态分派</a></li>
<li><a href="#sec-2-2-2">动态分派</a></li>
<li><a href="#sec-2-2-3">单分派与多分派</a></li>
<li><a href="#sec-2-2-4">动态分派的实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<b>执行引擎</b> 是Java虚拟机最核心的组成部分之一。 <span class="underline">虚拟机</span> 是一个相对于 <span class="underline">物理机</span> 的概念，这两种机器都有代码执行能力，其区别：
</p>
<ul class="org-ul">
<li>物理机的执行引擎是 <b>直接建立在处理器、硬件、指令集和操作系统</b> 层面上的
</li>
<li>虚拟机的执行引擎则是由 <b>自己实现的</b> ，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式 
</li>
</ul>

<p>
在Java虚拟机规范中制定了 <span class="underline">虚拟机字节码执行引擎</span> 的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有 <span class="underline">解释执行</span> (通过解释器执行)和 <span class="underline">编译执行</span> (通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的:
</p>
<ul class="org-ul">
<li>输入：字节码文件
</li>
<li>处理：字节码解析的等效过程
</li>
<li>输出：执行结果
</li>
</ul>

<pre class="example">
  有一些虚拟机(如Sun Classic VM)的内部只存在解释器，只能解释执行

  另外一些虚拟机(如BEA JRockit)的内部只存在即时编译器，只能编译执行
</pre>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">运行时栈帧结构</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>栈帧</b> ( <span class="underline">Stack Frame</span> )是用于支持虚拟机进行 <b>方法调用和方法执行的数据结构</b> ，它是虚拟机运行时数据区中的 <b>虚拟机栈</b> ( <span class="underline">Virtual Machine Stack</span> )的栈元素。栈帧存储了方法的 
</p>
<ul class="org-ul">
<li><b>局部变量表</b>
</li>
<li><b>操作数栈</b> 
</li>
<li><b>动态连接</b>
</li>
<li><b>方法返回地址</b> 
</li>
<li>&#x2026;..
</li>
</ul>

<p>
每一个方法从调用开始至执行完成的过程，都对应着 <b>一个栈帧在虚拟机栈里面从入栈到出栈的过程</b> 
</p>

<pre class="example">
    在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中

    一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现
</pre>

<p>
一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中， <b>只有位于栈顶的栈帧才是有效的</b> ，称为 <span class="underline">当前栈帧</span> ( <span class="underline">Current Stack Frame</span> )，与这个栈帧相关联的方法称为 <span class="underline">当前方法</span> 。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示：
</p>


<div class="figure">
<p><img src="pic/jvm-stack-frame.png" alt="jvm-stack-frame.png" width="50%" /> 
</p>
</div>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">局部变量表</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>局部变量表</b> 是一组变量值存储空间，用于存放 <b>方法参数和方法内部定义的局部查量</b> 。在Java程序编译为Class文件时，就在 <span class="underline">方法的Code属性</span> 的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量
</p>

<p>
局部变量表的容量以 <b>变量槽</b> ( <span class="underline">Slot</span> )为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出 <span class="underline">每个Slot占用32位长度的内存空间</span> 是有一些差别的，它允许Slot的长度可以 <b>随着处理器、操作系统或虚拟机的不同而发生变化</b> 。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致
</p>

<pre class="example">
一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress8种类型

reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构
但一般来说，虚拟机实现至少都应当能通过这个引用做到两点
  1. 从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引
  2. 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息


returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址
很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替
</pre>
<p>
对于64位的数据类型，虚拟机会以 <span class="underline">高位对齐</span> 的方式为其 <span class="underline">分配两个连续的Slot空间</span> 。Java语言中明确的(reference类型则可能是32位也可能是64位)64位的数据类型只有long和double两种
</p>
<pre class="example">
     把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类似

     不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题
</pre>

<p>
虚拟机通过 <span class="underline">索引定位</span> 的方式使用局部变量表，索引值的范围是从 <span class="underline">0开始至局部变量表最大的Slot数量</span> 
</p>
<ul class="org-ul">
<li>如果访问的是 <span class="underline">32位</span> 数据类型的变量，索引 <span class="underline">n</span> 就代表了使用第 <span class="underline">n个Slot</span>
</li>
<li>如果是 <span class="underline">64位</span> 数据类型的变量，则说明会同时使用 <span class="underline">n</span> 和 <span class="underline">n+1</span> 两个Slot
<ul class="org-ul">
<li>对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在 <span class="underline">类加载的校验阶段拋出异常</span> 
</li>
</ul>
</li>
</ul>

<p>
在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法(非static的方法)，那 <b>局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用</b> ，在方法中可以通过关键字 <span class="underline">this</span> 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot
</p>

<p>
为了尽可能节省栈帧空间，局部变量表中的Slot是可以 <b>重用</b> 的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体， <b>如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用</b> 。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接 <span class="underline">影响到系统的垃圾收集行为</span> 
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)() {
    <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">placeholder</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[64 * 1024 * 1024];
    System.gc();
}
</pre>
</div>
<p>
首先向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。在虚拟机运行参数中加上 <span class="underline">-verbose:gc</span> 来看看垃圾收集的过程，发现在 <span class="underline">System.gc()</span> 运行后并没有回收这64MB的内存，运行结果:
</p>

<pre class="example">
[GC 66846K-&gt;65824K (125632K ) ,0.0032678 secs] [Full GC 65824K-&gt; 65746K (125632K) ,0.0064131 secs] 
</pre>

<p>
因为在执行 <span class="underline">Systemgc()</span> 时，变量 placeholder 还处于作用域之内,虚拟机自然不敢回收 placeholder 的内存。那把代码修改一下
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)() {
    {
        <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">placeholder</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[64 * 1024 * 1024];
    }
    System.gc();
}
</pre>
</div>

<p>
加入了花括号之后， placeholder 的作用域被限制在花括号之内，从代码逻辑上讲，在执行 <span class="underline">System.gc()</span> 的时候，placeholder 已经不可能再被访问了,但执行一下这段程序,会发现运行结果如下,还是有64MB的内存没有被回收
</p>

<p>
在调用System.gc() 之前加入—行 <span class="underline">int a=0;</span> 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>)() {
    {
        <span style="color: #98fb98;">byte</span>[] <span style="color: #eedd82;">placeholder</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">byte</span>[64 * 1024 * 1024];
    }
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 0;
    System.gc();
}
</pre>
</div>

<pre class="example">
[GC 66401K-&gt; 65778K (125632K ) ,0.0035471 secs] [Full GC 65778K-&gt;218K (125632K) ,0.0140596 secs]
</pre>

<p>
placeholder能否被回收的根本原因是:局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了 placeholder 的作用域，但在此之后，没有任何对局部变量表的读写操作， <b>placeholder原本所占用的Slot还没有被其他变量所复用</b> ，所以作为GC Roots—部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微 
</p>

<pre class="example">
     如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值(把变量对应的局部变量表Slot清空)便不见得是一个绝对无意义的操作

     这种操作可以作为一种在极特殊情形(对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件)下的“奇技”来使用

     一本非常著名的书籍《Practical Java》中把“不使用的对象应手动赋值为null”作为一条推荐的编码规则，但是并没有解释具体的原因，很长时间之内都有读者对这条规则感到疑惑
</pre>

<p>
虽然代码示例说明了 <span class="underline">赋null值的操作</span> 在某些情况下确实是有用的，但不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因：
</p>
<ol class="org-ol">
<li>从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法
</li>
<li>从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GC Roots的枚举也与解释执行时期有巨大差别，以前面例子来看，第二种代码方式在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须写成手动操作
</li>
</ol>

<p>
局部变量不像前面介绍的类变量那样存在 <span class="underline">准备阶段</span> 。即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样， <b>如果一个局部变量定义了但没有赋初始值是不能使用的</b> ，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值：
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>;
    System.out.println(a);
}
</pre>
</div>

<pre class="example">
Test.java:4: error: variable a might not have been initialized
                System.out.println(a);
                                   ^
1 error
</pre>

<p>
编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虛拟机发现而导致类加载失败
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">操作数栈</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<b>操作数栈</b> ( <span class="underline">Operand Stack</span> )也常称为操作栈，它是一个 <span class="underline">后入先出</span> (LIFO)栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_Stacks数据项中
</p>

<p>
操作数栈的每一个元素可以是任意的Java数据类型，包括 <span class="underline">long</span> 和 <span class="underline">double</span> 。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的 <b>深度都不会超过在max_Stacks数据项中设定的最大值</b> 
</p>

<p>
当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作
</p>
<ul class="org-ul">
<li>做算术运算的时候是通过操作数栈来进行的
</li>
<li>调用其他方法的时候是通过操作数栈来进行参数传递
</li>
</ul>

<pre class="example">
     比如，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值

     当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈
</pre>


<p>
操作数栈中 <b>元素的数据类型必须与字节码指令的序列严格匹配</b> ，在编译程序代码的时候， <span class="underline">编译器要严格保证这一点</span> ，在 <span class="underline">类校验阶段的数据流分析</span> 中还要再次验证这一点
</p>

<pre class="example">
     以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况
</pre>


<p>
在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。 <b>让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据</b> ，无须进行额外的参数复制传递，重叠的过程如图所示：
</p>


<div class="figure">
<p><img src="pic/stack-frame-share.png" alt="stack-frame-share.png" width="50%" /> 
</p>
</div>

<p>
Java虚拟机的解释执行引擎称为 <span class="underline">基于栈的执行引擎</span> ,其中所指的 <span class="underline">栈</span> 就是 <b>操作数栈</b> 
</p>
</div>
</div>


<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">动态连接</h3>
<div class="outline-text-3" id="text-1-3">
<p>
每个栈帧都包含一个 <b>指向运行时常量池中该栈帧所属方法的引用</b> ，持有这个引用是为了 <b>支持方法调用过程中的动态连接</b> ( <span class="underline">Dynamic Linking</span> )
</p>

<p>
Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以 <b>常量池中指向方法的符号引用作为参数</b> 。这些符号引用可以被：
</p>
<ul class="org-ul">
<li>静态解析：类加载阶段或者第一次使用的时候就转化为直接引用
</li>
<li>动态链接：在每一次运行期间转化为直接引用
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">方法返回地址</h3>
<div class="outline-text-3" id="text-1-4">
<p>
当一个方法开始执行后，只有两种方式可以退出这个方法:
</p>
<ul class="org-ul">
<li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为 <span class="underline">正常完成出口</span> (Normal Method Invocation Completion)
</li>
<li>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用 <b>athrow</b> 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为 <span class="underline">异常完成出口</span> (Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是 <b>不会给它的上层调用者产生任何返回值</b> 
</li>
</ul>

<p>
无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说
</p>
<ol class="org-ol">
<li>方法正常退出时， <span class="underline">调用者的PC计数器的值</span> 可以作为返回地址，栈帧中 <b>很可能会保存这个计数器值</b> 
</li>
<li>而方法异常退出时，返回地址是要通过 <span class="underline">异常处理器表</span> 来确定的，栈帧中 <b>一般不会保存这部分信息</b>
</li>
</ol>

<p>
方法退出的过程实际上就等同于把 <b>当前栈帧出栈</b> ，因此退出时可能执行的操作有:
</p>
<ul class="org-ul">
<li>恢复上层方法的局部变量表和操作数栈
</li>
<li>把返回值(如果有的话)压入调用者栈帧的操作数栈中
</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令等
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">附加信息</h3>
<div class="outline-text-3" id="text-1-5">
<p>
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现
</p>

<pre class="example">
     在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">方法调用</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>方法调用</b> 阶段唯一的任务就是 <b>确定被调用方法的版本(即调用哪一个方法)</b> ，暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的链接步骤，一切方法调用在Class文件里面存储的都只是 <span class="underline">符号引用</span> ，而不是方法在实际运行时内存布局中的入口地址(相当于之前说的直接引用)。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用
</p>

<p>
在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。
</p>
<ul class="org-ul">
<li><b>invokestatic</b> : 调用 <b>静态</b> 方法
</li>
<li><b>invokespecial</b> : 调用实例构造器 <span class="underline">&lt;init&gt;</span> 方法、私有方法和父类方法
</li>
<li><b>invokevirtual</b> : 调用所有的 <b>虚</b> 方法
</li>
<li><b>invokeinterface</b> : 调用 <b>接口</b> 方法，会在运行时再确定一个实现此接口的对象
</li>
<li><b>invokedynamic</b> : 先在运行时 <b>动态解析出调用点限定符所引用的方法</b> ，然后再执行该方法
</li>
</ul>

<p>
在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">解析</h3>
<div class="outline-text-3" id="text-2-1">
<p>
所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是： <b>方法在程序真正运行之前就有一个确定的调用版本，并且这个方法的调用版本在运行期是不可改变的</b> 。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析
</p>

<p>
在Java语言中符合 <span class="underline">编译器可知，运行期不可变</span> 这个要求的方法，主要包括 <b>静态</b> 方法和 <b>私有</b> 方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各个的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析
</p>

<p>
只要能被 <span class="underline">invokestatic</span> 和 <span class="underline">invokespecial</span> 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有 <b>静态方法</b> 、 <b>私有方法</b> 、 <b>实例构造器</b> 、 <b>父类方法</b> 4类，它们在 <b>类加载的时候就会把符号引用解析为该方法的直接引用</b> 。这些方法可以称为 <span class="underline">非虚方法</span> ，与之相反，其他方法称为 <span class="underline">虚方法</span> (除去 <b>final</b> 方法，后文会提到)。下面代码中静态方法 <span class="underline">sayHello()</span> 只可能属于类型 <span class="underline">StaticResolution</span> ，没有任何手段可以覆盖或隐藏这个方法
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#26041;&#27861;&#38745;&#24577;&#35299;&#26512;&#28436;&#31034;</span>
<span style="color: #ffa07a;"> * </span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@author</span><span style="color: #ffa07a;"> zzm</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StaticResolution</span> {
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>() {
        System.out.println(<span style="color: #ffa07a;">"hello world"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        StaticResolution.sayHello();
    }
}
</pre>
</div>

<p>
使用 <span class="underline">javap</span> 命令查看这段程序的字节码，会发现的确是通过 <span class="underline">invokestatic</span> 命令来调用 <span class="underline">sayHello()</span> 方法的
</p>

<div class="org-src-container">

<pre class="src src-sh">$ javap -verbose StaticResolution.class

.....
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      <span style="color: #eedd82;">stack</span>=0, <span style="color: #eedd82;">locals</span>=1, <span style="color: #eedd82;">args_size</span>=1
         0: invokestatic  <span style="color: #ff4500;">#</span><span style="color: #ff4500;">5                  // Method sayHello:()V</span>
         3: return
      LineNumberTable:
        line 13: 0
        line 14: 3
}
</pre>
</div>

<pre class="example">
Java中的非虚方法还有一种，就是被final修饰的方法

虽然final方法是使用 invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的

在Java语言规范中明确说明了final方法是一种非虚方法
</pre>

<p>
解析调用一定是个 <b>静态</b> 的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">分派</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<b>分派</b> 调用则可能是
</p>
<ul class="org-ul">
<li>静态的
</li>
<li>动态的
</li>
</ul>

<p>
根据分派依据的宗量数可分为 
</p>
<ul class="org-ul">
<li><span class="underline">单分派</span>
</li>
<li><span class="underline">多分派</span> 
</li>
</ul>

<p>
这两类分派方式的两两组合就构成了 
</p>
<ul class="org-ul">
<li><span class="underline">静态单分派</span>
</li>
<li><span class="underline">静态多分派</span>
</li>
<li><span class="underline">动态单分派</span>
</li>
<li><span class="underline">动态多分派</span>
</li>
</ul>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">静态分派</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#26041;&#27861;&#38745;&#24577;&#20998;&#27966;&#28436;&#31034;</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">StaticDispatch</span> {

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">abstract</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Human</span> {
    }

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Man</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Human</span> {
    }

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Woman</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Human</span> {
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">guy</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello,guy!"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">Man</span> <span style="color: #eedd82;">guy</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello,gentleman!"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">Woman</span> <span style="color: #eedd82;">guy</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello,lady!"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        <span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">man</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Man</span>();
        <span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">woman</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Woman</span>();
        <span style="color: #98fb98;">StaticDispatch</span> <span style="color: #eedd82;">sr</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">StaticDispatch</span>();
        sr.sayHello(man);
        sr.sayHello(woman);
    }
}
</pre>
</div>

<p>
运行结果：
</p>
<pre class="example">
hello,guy!
hello,guy!
</pre>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">man</span>=<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Man</span>();
</pre>
</div>

<p>
上面代码中的 <span class="underline">Human</span> 称为变量的 <b>静态类型</b> ，后面的 <span class="underline">Man</span> 则称为变量的 <b>实际类型</b> ，区别:
</p>
<ul class="org-ul">
<li>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的
</li>
<li>而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么
</li>
</ul>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#23454;&#38469;&#31867;&#22411;&#21464;&#21270;</span>
<span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">man</span>=<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Man</span>(); 
man=<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Woman</span>();

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38745;&#24577;&#31867;&#22411;&#21464;&#21270;</span>
sr.sayHello((<span style="color: #98fb98;">Man</span>)man);
sr.sayHello((<span style="color: #98fb98;">Woman</span>)man);
</pre>
</div>

<p>
回到最开始的代码， <span class="underline">main()</span> 里面的两次 <span class="underline">sayHello()</span> 方法调用，在方法接收者已经确定是对象 <span class="underline">sr</span> 的前提下，使用哪个重载版本，就完全取决于 <b>传入参数的数量</b> 和 <b>数据类型</b> 。刻意地定义了两个静态类型相同但实际类型不同的变量，但虚拟机(准确地说是编译器)在 <b>重载时是通过参数的静态类型而不是实际类型</b> 作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了 <span class="underline">sayHello(Human)</span> 作为调用目标，并把这个方法的符号引用写到 <span class="underline">main()</span> 方法里的两条 <b>invokevirtual</b> 指令中
</p>

<p>
<b>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派</b> 。静态分派的典型应用是 <b>方法重载</b> 。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是  <span class="underline">唯一的</span> ，往往只能确定一个 <span class="underline">更加合适的</span> 版本
</p>

<pre class="example">
  产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断
</pre>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Overload</span> {

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">Object</span> <span style="color: #eedd82;">arg</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello Object"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arg</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello int"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">arg</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello long"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">Character</span> <span style="color: #eedd82;">arg</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello Character"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">arg</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello char"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">char</span>... <span style="color: #eedd82;">arg</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello char ..."</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>(<span style="color: #98fb98;">Serializable</span> <span style="color: #eedd82;">arg</span>) {
        System.out.println(<span style="color: #ffa07a;">"hello Serializable"</span>);
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        sayHello(<span style="color: #ffa07a;">'a'</span>);
    }
}
</pre>
</div>

<p>
运行结果：
</p>
<pre class="example">
hello char
</pre>

<p>
这很好理解， 'a'  是一个 <span class="underline">char</span> 类型的数据，自然会寻找参数类型为char的重载方法,如果注释掉 <span class="underline">sayHello(char arg)</span> 方法，那输出会变为:
</p>

<pre class="example">
hello int
</pre>

<p>
这时发生了一次自动类型转换， 'a' 除了可以代表一个字符串，还可以代表数字97(字符a的Unicode数值为十进制数字97)，因此参数类型为 <span class="underline">int</span> 的重载也是合适的。继续注释掉 <span class="underline">sayHello(int arg)</span> 方法，那输出会变为:
</p>

<pre class="example">
hello long
</pre>

<p>
这时发生了两次自动类型转换， 'a' 转型为整数97之后，进一步转型为长整数 <span class="underline">97L</span> ，匹配了参数类型为 <span class="underline">long</span> 的重载。实际上自动转型还能继续发生多次，按照 <b>char-&gt;int-&gt;long-&gt;float-&gt;double</b> 的顺序转型进行匹配。但不会匹配到 <b>byte</b> 和 <b>short</b> 类型的重载，因为 <span class="underline">char</span> 到 <span class="underline">byte</span> 或 <span class="underline">short</span> 的转型是不安全的。继续注释掉 <span class="underline">sayHello(long arg)</span> 方法，那输会变为:
</p>

<pre class="example">
hello Character
</pre>

<p>
这时发生了一次自动装箱， 'a' 被包装为它的封装类型 <span class="underline">java.lang.Character</span> ，所以匹配到了参数类型为 <span class="underline">Character</span> 的重载，继续注释掉 <span class="underline">sayHello(Character arg)</span> 方法，那输出会变为:
</p>

<pre class="example">
hello Serializable
</pre>

<p>
出现hello Serializable，是因为 <span class="underline">java.lang.Serializable</span> 是 <span class="underline">java.lang.Character</span> 类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次自动转型
</p>
<pre class="example">
char可以转型成int，但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类

Character还实现了另外一个接口java.lang.Comparable&lt;Character&gt;

如果同时出现两个参数分别为Serializable和Comparable&lt;Character&gt;的重载方法，那它们在此时的优先级是一样的

编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译

程序必须在调用时显式地指定字面量的静态类型，如:sayHello((Comparable&lt;Character&gt;) 'a' )，才能编译通过
</pre>

<p>
下面继续注释掉 <span class="underline">sayHello(Serializable arg)</span> 方法，输出会变为:
</p>

<pre class="example">
hello Object
</pre>

<p>
这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。把 <span class="underline">sayHello(Object arg)</span> 也注释掉，输出将会变为:
</p>

<pre class="example">
hello char...
</pre>

<p>
7个重载方法已经被注释得只剩一个了，可见 <b>变长参数的重载优先级是最低的</b> ，这时候字符 'a' 被当做了一个 <b>数组元素</b> 
</p>
<pre class="example">
  这里使用的是char类型的变长参数，还可以选择int类型、Character类型、Object类型等的变长参数重载来演示一遍

  但要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的
</pre>

<p>
解析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。例如，静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的
</p>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">动态分派</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
动态分派和多态性的另外一个重要体现： <b>重写</b> ( <span class="underline">Override</span> )有着很密切的关联
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#26041;&#27861;&#21160;&#24577;&#20998;&#27966;&#28436;&#31034;</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@author</span><span style="color: #ffa07a;"> zzm</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">DynamicDispatch</span> {

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">abstract</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Human</span> {
        <span style="color: #00ffff;">protected</span> <span style="color: #00ffff;">abstract</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>();
    }

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Man</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Human</span> {
        <span style="color: #7fffd4;">@Override</span>
        <span style="color: #00ffff;">protected</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>() {
            System.out.println(<span style="color: #ffa07a;">"man say hello"</span>);
        }
    }

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Woman</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Human</span> {
        <span style="color: #7fffd4;">@Override</span>
        <span style="color: #00ffff;">protected</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sayHello</span>() {
            System.out.println(<span style="color: #ffa07a;">"woman say hello"</span>);
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        <span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">man</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Man</span>();
        <span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">woman</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Woman</span>();
        man.sayHello();
        woman.sayHello();
        man = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Woman</span>();
        man.sayHello();
    }
}
</pre>
</div>

<p>
运行结果：
</p>
<pre class="example">
man say hello
woman say hello
woman say hello
</pre>

<p>
显然这里不可能再根据静态类型来决定，因为静态类型同样都是 <span class="underline">Human</span> 的两个变量 <span class="underline">man</span> 和 <span class="underline">woman</span> 在调用 <span class="underline">sayHello()</span> 方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的 <b>实际类型</b> 不同。使用 <span class="underline">javap</span> 命令输出这段代码的字节码，输出结果如下所示：
</p>

<div class="org-src-container">

<pre class="src src-sh">  $ javap -verbose DynamicDispatch.class

  ......
    public static void main(java.lang.String[]);
      descriptor: ([Ljava/lang/String;)V
      flags: ACC_PUBLIC, ACC_STATIC
      Code:
        <span style="color: #eedd82;">stack</span>=2, <span style="color: #eedd82;">locals</span>=3, <span style="color: #eedd82;">args_size</span>=1
           0: new           <span style="color: #ff4500;">#</span><span style="color: #ff4500;">2                  // class DynamicDispatch$Man</span>
           3: dup
           4: invokespecial <span style="color: #ff4500;">#</span><span style="color: #ff4500;">3                  // Method DynamicDispatch$Man."&lt;init&gt;":()V</span>
           7: astore_1
           8: new           <span style="color: #ff4500;">#</span><span style="color: #ff4500;">4                  // class DynamicDispatch$Woman</span>
          11: dup
          12: invokespecial <span style="color: #ff4500;">#</span><span style="color: #ff4500;">5                  // Method DynamicDispatch$Woman."&lt;init&gt;":()V</span>
          15: astore_2
          16: aload_1
          17: invokevirtual <span style="color: #ff4500;">#</span><span style="color: #ff4500;">6                  // Method DynamicDispatch$Human.sayHello:()V</span>
          20: aload_2
          21: invokevirtual <span style="color: #ff4500;">#</span><span style="color: #ff4500;">6                  // Method DynamicDispatch$Human.sayHello:()V</span>
          24: new           <span style="color: #ff4500;">#</span><span style="color: #ff4500;">4                  // class DynamicDispatch$Woman</span>
          27: dup
          28: invokespecial <span style="color: #ff4500;">#</span><span style="color: #ff4500;">5                  // Method DynamicDispatch$Woman."&lt;init&gt;":()V</span>
          31: astore_1
          32: aload_1
          33: invokevirtual <span style="color: #ff4500;">#</span><span style="color: #ff4500;">6                  // Method DynamicDispatch$Human.sayHello:()V</span>
          36: return
......
  }
</pre>
</div>

<p>
0~15行的字节码是准备动作：
</p>
<ul class="org-ul">
<li>建立man和woman的内存空间
</li>
<li>调用Man和Woman类型的实例构造器
</li>
<li>将这两个实例的引用存放在第1、2个局部变量表Slot之中
</li>
</ul>

<p>
这个动作也就对应了代码中的这两句:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">man</span>=<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Man</span>(); 
<span style="color: #98fb98;">Human</span> <span style="color: #eedd82;">woman</span>=<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Woman</span>();
</pre>
</div>

<ul class="org-ul">
<li>16、20两句分别把 <b>刚刚创建的两个对象的引用压到栈顶</b> ，这两个对象是将要执行的 <span class="underline">sayHello()</span> 方法的所有者，称为接收者(Receiver)
</li>
<li>17和21句是方法调用指令
</li>
</ul>

<p>
这两条调用指令单从字节码角度来看，无论是指令(都是 <span class="underline">invokevirtual</span> )还是参数(都是常量池中第22项的常量，注释显示了这个常量是 <span class="underline">Human.sayHello()</span> 的符号引用)完全一样的，但是这两句指令最终执行的目标方法并不相同。原因就在于invokevirtual指令的 <b>多态查找</b> 过程。invokevirtual指令的运行时解析过程大致分为以下几个步骤:
</p>
<ol class="org-ol">
<li>找到 <b>操作数栈顶的第一个元素所指向的对象的实际类型</b> ，记作 <span class="underline">C</span>
</li>
<li>如果 <b>在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验</b> 
<ul class="org-ul">
<li>如果通过则返回这个方法的直接引用，查找过程结束
</li>
<li>如果不通过，则返回 <span class="underline">java.lang.IllegalAccessError</span> 异常
</li>
</ul>
</li>
<li>否则， <b>按照继承关系从下往上依次对C的各个父类</b> 进行第2步的搜索和验证过程
</li>
<li>如果始终没有找到合适的方法，则抛出 <span class="underline">java.lang.AbstractMethodError</span> 异常
</li>
</ol>

<p>
由于 <span class="underline">invokevirtual</span> 指令执行的第一步就是在 <b>运行期确定接收者的实际类型</b> ，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法 <span class="underline">重写</span> 的本质。把这种 <b>在运行期根据实际类型确定方法执行版本的分派</b> 过程称为 <b>动态分派</b>
</p>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">单分派与多分派</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
<b>方法的接收者与方法的参数</b> 统称为方法的 <span class="underline">宗量</span> 。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种
</p>
<ul class="org-ul">
<li>单分派是根据 <b>一个宗量</b> 对目标方法进行选择
</li>
<li>多分派则是根据 <b>多于一个宗量</b> 对目标方法进行选择
</li>
</ul>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * &#21333;&#20998;&#27966;&#12289;&#22810;&#20998;&#27966;&#28436;&#31034;</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Dispatch</span> {

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">QQ</span> {}

    <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">_360</span> {}

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Father</span> {
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hardChoice</span>(<span style="color: #98fb98;">QQ</span> <span style="color: #eedd82;">arg</span>) {
            System.out.println(<span style="color: #ffa07a;">"father choose qq"</span>);
        }

        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hardChoice</span>(<span style="color: #98fb98;">_360</span> <span style="color: #eedd82;">arg</span>) {
            System.out.println(<span style="color: #ffa07a;">"father choose 360"</span>);
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Son</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Father</span> {
        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hardChoice</span>(<span style="color: #98fb98;">QQ</span> <span style="color: #eedd82;">arg</span>) {
            System.out.println(<span style="color: #ffa07a;">"son choose qq"</span>);
        }

        <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">hardChoice</span>(<span style="color: #98fb98;">_360</span> <span style="color: #eedd82;">arg</span>) {
            System.out.println(<span style="color: #ffa07a;">"son choose 360"</span>);
        }
    }

    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) {
        <span style="color: #98fb98;">Father</span> <span style="color: #eedd82;">father</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Father</span>();
        <span style="color: #98fb98;">Father</span> <span style="color: #eedd82;">son</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Son</span>();
        father.hardChoice(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">_360</span>());
        son.hardChoice(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">QQ</span>());
    }
}
</pre>
</div>

<p>
运行结果：
</p>

<pre class="example">
father choose 360
son choose qq
</pre>

<p>
在 <span class="underline">main</span> 函数中调用了两次 <span class="underline">hardChoice()</span> 方法，这两次 <span class="underline">hardChoice()</span> 方法的选择结果在程序输出中已经显示得很清楚了
</p>

<div class="org-src-container">

<pre class="src src-sh">$ javap -verbose Dispatch.class

.......
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      <span style="color: #eedd82;">stack</span>=3, <span style="color: #eedd82;">locals</span>=3, <span style="color: #eedd82;">args_size</span>=1
         0: new           <span style="color: #ff4500;">#</span><span style="color: #ff4500;">2                  // class Dispatch$Father</span>
         3: dup
         4: invokespecial <span style="color: #ff4500;">#</span><span style="color: #ff4500;">3                  // Method Dispatch$Father."&lt;init&gt;":()V</span>
         7: astore_1
         8: new           <span style="color: #ff4500;">#</span><span style="color: #ff4500;">4                  // class Dispatch$Son</span>
        11: dup
        12: invokespecial <span style="color: #ff4500;">#</span><span style="color: #ff4500;">5                  // Method Dispatch$Son."&lt;init&gt;":()V</span>
        15: astore_2
        16: aload_1
        17: new           <span style="color: #ff4500;">#</span><span style="color: #ff4500;">6                  // class Dispatch$_360</span>
        20: dup
        21: invokespecial <span style="color: #ff4500;">#</span><span style="color: #ff4500;">7                  // Method Dispatch$_360."&lt;init&gt;":()V</span>
        24: invokevirtual <span style="color: #ff4500;">#</span><span style="color: #ff4500;">8                  // Method Dispatch$Father.hardChoice:(LDispatch$_360;)V</span>
        27: aload_2
        28: new           <span style="color: #ff4500;">#</span><span style="color: #ff4500;">9                  // class Dispatch$QQ</span>
        31: dup
        32: invokespecial <span style="color: #ff4500;">#</span><span style="color: #ff4500;">10                 // Method Dispatch$QQ."&lt;init&gt;":()V</span>
        35: invokevirtual <span style="color: #ff4500;">#</span><span style="color: #ff4500;">11                 // Method Dispatch$Father.hardChoice:(LDispatch$QQ;)V</span>
        38: return
</pre>
</div>

<p>
来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点:
</p>
<ol class="org-ol">
<li>静态类型是 <span class="underline">Father</span> 还是 <span class="underline">Son</span>
</li>
<li>方法参数是 <span class="underline">QQ</span> 还是 <span class="underline">360</span> 
</li>
</ol>

<p>
这次选择结果的最终产物是产生了两条 <b>invokevirtual</b> 指令，两条指令的参数分别为常量池中指向 <span class="underline">Father.hardChoice(360)</span> 及 <span class="underline">Father.hardChoice(QQ)</span> 方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的 <b>静态分派属于多分派类型</b> 
</p>

<p>
运行阶段虚拟机的选择，也就是动态分派的过程。在执行 <span class="underline">son.hardChoice(newQQ())</span> 这句代码时，更准确地说，是在执行这句代码所对应的
<b>invokevirtual</b> 指令时，由于编译期已经决定目标方法的签名必须为 <span class="underline">hardChoice(QQ)</span> ，虚拟机此时不会关心传递过来的参数 <span class="underline">QQ</span> 到底是 <span class="underline">腾讯QQ</span> 还是 <span class="underline">奇瑞QQ</span> ，因为这时 <b>参数的静态类型、实际类型都对方法的选择</b> 不会构成任何影响，唯一可以影响虚拟机选择的因素只有此 <b>方法的接受者的实际类型</b> 是 <span class="underline">Father</span> 还是 <span class="underline">Son</span> 。因为 <b>只有一个宗量作为选择依据</b> ，所以Java语言的 <b>动态分派属于单分派类型</b> 
</p>

<p>
总之：1.8之前的Java语言是一门 <b>静态多分派、动态单分派</b> 的语言
</p>

<pre class="example">
JDK1.8之前而是通过内置动态语言(如JavaScript)执行引擎的方式来满足动态性的需求

但是Java虚拟机层面上则不是如此，在JDK 1.7中实现的JSR-292里面就已经开始提供对动态语言的支持了

JDK 1.7中新增的invokedymmic指令也成为了最复杂的一条方法调用的字节码指令
</pre>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">动态分派的实现</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。面对这种情况，最常用的 <span class="underline">稳定优化</span> 手段就是为 <b>类在方法区中建立一个虚方法表</b> (Vritual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表 Inteface Method Table，简称itable)，使用 <b>虚方法表索引</b> 来代替元数据查找以提高性能。虚方法表结构示例，如图所示：
</p>


<div class="figure">
<p><img src="pic/virtual-method-table.jpg" alt="virtual-method-table.jpg" width="70%" /> 
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
