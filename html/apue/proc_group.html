<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>进程关系</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="process.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程关系</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">登录</a>
<ul>
<li><a href="#sec-1-1">终端登录</a>
<ul>
<li><a href="#sec-1-1-1">4.3+BSD</a></li>
<li><a href="#sec-1-1-2">SVR4终端登录</a></li>
</ul>
</li>
<li><a href="#sec-1-2">网络登录</a>
<ul>
<li><a href="#sec-1-2-1">4.3+BSD</a></li>
<li><a href="#sec-1-2-2">SVR4</a></li>
</ul>
</li>
<li><a href="#sec-1-3">登录总结</a></li>
</ul>
</li>
<li><a href="#sec-2">进程组</a></li>
</ul>
</div>
</div>
<p>
本章将详细地说明进程组以及POSIX.1引进的对话期新概念，还将介绍登录shell(登录时所调用的)和所有从登录shell起动的进程之间的关系 
</p>

<p>
在说明这些关系时不可能不谈及信号，而谈论信号又需要很多本章介绍的概念
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">登录</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">终端登录</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在早期的UNIX系统中，例如V7，用户用哑终端(通过RS-232连到主机)进行登录。终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)。在这两种情况下登录都经由内核中的终端设备驱动程序，例如在PDP-11上常用的设备是DH-11和DZ-11。因为连到主机上的终端设备数已经确定，所以同时的登录数也就有了已知的上限。下面说明的登录过程适用于使用一个RS-232终端登录到UNIX系统中
</p>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">4.3+BSD</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
登录过程在历史上并没有多少改变。系统管理者创建一个通常名为/etc/ttys的文件，其中每个终端设备有一行，每一行说明设备名和传到getty程序的参数，这些参数说明了终端的波特率等。当系统启动时，内核创建进程ID1，也就是init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则执行程序getty。这种情况示于图9-1中：
</p>

<div class="figure">
<p><img src="pic/console-login.png" alt="console-login.png" width="50%" />
</p>
</div>

<p>
图9-1中各个进程的实际用户ID和有效用户ID都是0(也就是它们都具有超级用户特权)。init以空环境执行getty程序。
</p>

<p>
getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login:”之类的信息，并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度(波特率)
</p>

<p>
当用户键入了用户名后getty就完成了，然后它以类似于下列的方式调用login程序：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22312;gettytab&#25991;&#20214;&#20013;&#21487;&#33021;&#20250;&#26377;&#19968;&#20123;&#36873;&#25321;&#39033;&#20351;&#20854;&#35843;&#29992;&#20854;&#20182;&#31243;&#24207;&#65292;&#20294;&#31995;&#32479;&#40664;&#35748;&#26159;login&#31243;&#24207;</span>
execle(<span style="color: #ffa07a;">"/usr/bin/login"</span>, <span style="color: #ffa07a;">"login"</span>, <span style="color: #ffa07a;">"-p"</span>, username, (<span style="color: #98fb98;">char</span>*)0, envp);
</pre>
</div>
<p>
getty以终端名(例如TERM=foo，其中终端foo的类型取自gettytab文件)和在gettytab中的环境字符串为login创建一个环境(envp参数)。-p标志通知login保留传给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。图9-2显示了login刚被调用后这些进程的状态：
</p>

<div class="figure">
<p><img src="pic/login-begin.png" alt="login-begin.png" width="50%" />
</p>
</div>

<p>
因为最初的init进程具有超级用户优先权，所以图9-2中的所有进程都有超级用户优先权。图9-2中底部三个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且除了最初的init进程，所有的进程均有一个父进程ID
</p>

<p>
login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass(3)以显示提示“Password:”接着读用户键入的口令 (自然，禁止回送用户键入的口令)。它调用crypt(3)将用户键入的口令加密，并与该用户口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数 1 调用exit表示登录过程失败。父进程(init)了解到子进程的终止情况后，将再次调用fork，其后又跟随着执行getty，对此终端重复上述过程
</p>

<p>
如果用户正确登录，login就将当前工作目录更改为该用户的起始目录(chdir)。它也调用chown改变该终端的所有权，使该用户成为所有者和组所有者。将对该终端设备的存取许可权改变成：用户读、写和组写。调用setgid及initgroups设置进程的组ID。然后用login所得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)，以及一个系统默认路径(PATH)。最后login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell，其方式类似于:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #ff4500;">//</span><span style="color: #ff4500;">argv[0]&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;-&#26159;&#19968;&#20010;&#26631;&#24535;&#65292;&#34920;&#31034;&#35813;shell&#34987;&#35843;&#29992;&#20026;&#30331;&#24405;shell&#12290;shell&#21487;&#20197;&#26597;&#30475;&#27492;&#23383;&#31526;&#65292;&#24182;&#30456;&#24212;&#22320;&#20462;&#25913;&#20854;&#36215;&#21160;&#36807;&#31243;</span>
execl(<span style="color: #ffa07a;">"/bin/sh"</span>, <span style="color: #ffa07a;">"-sh"</span>, (<span style="color: #98fb98;">char</span> *) 0);
</pre>
</div>
<p>
login所做的比上面说的要多。它可选地打印message-of-the-day文件，检查新邮件以及其他一些功能
</p>

<p>
因为setuid是由超级用户调用的，它更改所有三个用户ID:实际、有效和保存的用户ID。login在较早时间调用的setgid对所有三个组ID也有同样效果
</p>

<p>
到此为止登录用户的登录shell开始运行。其父进程ID是init进程ID(进程ID 1)，所以当此登录shell终止时，init会得到通知(接到SIGCHLD信号)，它会对该终端重复全部上述过程。登录shell的文件描述符0，1和2设置为终端设备。图9-3显示了这种安排：
</p>

<div class="figure">
<p><img src="pic/finish-login.png" alt="finish-login.png" width="50%" />
</p>
</div>

<p>
现在登录shell读对应的启动文件(Bourneshell和KornShell是.profile，Cshell是.cshrc和.login)。这些配置文件通常改变某些环境变量，加上一些环境变量。例如很多用户设置他们自己的PATH，常常提示实际终端类型(TERM)。当执行完启动文件后，用户最后得到shell的提示符，并能键入命令
</p>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">SVR4终端登录</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
SVR4支持两种形式的终端登录：
</p>
<ul class="org-ul">
<li>getty：这与上面所说明的一样，通常用于控制台
</li>
<li>ttymon：用于其他终端的登录
</li>
</ul>

<p>
ttymon是名为服务存取设施(ServiceAccessFacility，SAF)的一部分。只简单说明从init到登录shell之间工作过程，最后结果与图9-3中所示相似。init是sac(服务存取控制器)的父进程，sac调用fork，然后其子进程执行ttymon程序，此时系统进入多用户状态。ttymon监视列于配置文件中的所有终端端口，当用户键入登录名时，它调用一次fork。在此之后该子进程又执行登录用户的登录shell，于是到达了图9-3中所示的位置。一个区别是登录shell的父进程现在是ttymon，而在getty登录中，登录shell的父进程是init
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">网络登录</h3>
<div class="outline-text-3" id="text-1-2">
<p>
终端登录中init知道哪些终端设备可用来进行登录，并为每个设备生成一个getty进程。但是对网络登录则情况有所不同，所有登录都经由内核的网络界面驱动程序(例如以太网驱动程序)，事先并不知道将会有多少这样的登录。不是使一个进程等待每一个可能的登录，而是必须等待一个网络连接请求的到达。在4.3+BSD中，有一个称为inetd的进程，它等待大多数网络连接。本书将说明4.3+BSD的网络登录中所涉及的进程序列
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">4.3+BSD</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
作为系统起动的一部分init调用一个shell，使其执行shell脚本etc/rc。由此shell脚本起动一个精灵进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后该子进程执行适当的程序
</p>

<p>
假定到达了一个对于TELNET服务器的TCP连接请求。TELNET是使用TCP协议的远程登录应用程序。在另一个主机(它通过某种形式的网络，连接到服务器主机上)上的用户，或在同一个主机上的一个用户籍起动TELNET客户进程(client)起动登录过程：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ telnet hostname
</pre>
</div>
<p>
该客户进程打开一个到名为hostname的主机的TCP连接，在hostname主机上起动的程序被称为TELNET服务器。然后客户进程和服务器进程之间使用TELNET应用协议通过TCP连接交换数据。所发生的是起动客户进程的用户现在登录到了服务器进程所在的主机。(自然用户需要在服务器进程主机上有一个有效的账号)。图9-4显示了在执行TELNET服务器进程(称为telnetd)中所涉及的进程序列
</p>

<div class="figure">
<p><img src="pic/telnetd.png" alt="telnetd.png" width="50%" />
</p>
</div>

<p>
然后telnetd进程打开一个伪终端设备，并用fork生成一个子进程。父进程处理通过网络连接的通信，子进程则执行login程序。父、子进程通过伪终端相连接。在调用exec之前，子进程使其文件描述符0，1，2与伪终端相连。如果登录正确，login就执行9.2节中所述的同样步骤—更改当前工作目录为起始目录，设置登录用户的组ID和用户ID，以及登录用户的初始环境。然后login用exec将其自身替换为登录用户的登录shell。图9-5显示了到达这一点时的进程安排：
</p>

<div class="figure">
<p><img src="pic/network-login.png" alt="network-login.png" width="50%" />
</p>
</div>

<p>
很明显在伪终端设备驱动程序和终端实际用户之间有很多事情在进行着，以后说明伪终端时，再介绍与这种安排相关的所有进程
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">SVR4</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
SVR4中网络登录的情况与4.3+BSD中的几乎一样。同样使用了inetd服务器进程，但是在SVR4中inetd是作为一种服务由服务存取控制器sac调用的，其父进程不是init。最后得到的结果与图9-5中一样
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">登录总结</h3>
<div class="outline-text-3" id="text-1-3">
<p>
登录需要理解的重点是：当通过终端或网络登录时得到一个登录shell，其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上。接着会了解到这一登录shell是一个POSIX.1对话期的开始，而此终端或伪终端则是会话期的控制终端
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">进程组</h2>
</div>
</div>
<div id="postamble" class="status">

     <br/>
    <div class='ds-thread'></div>
<script>
var duoshuoQuery = {short_name:'klose911'};
(function() {
	 var dsThread = document.getElementsByClassName('ds-thread')[0];
         dsThread.setAttribute('data-thread-key', document.title);
         dsThread.setAttribute('data-title', document.title);
         dsThread.setAttribute('data-url', window.location.href);
	 var ds = document.createElement('script');
	 ds.type = 'text/javascript';ds.async = true;
	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	 ds.charset = 'UTF-8';
	 (document.getElementsByTagName('head')[0] 
				       || document.getElementsByTagName('body')[0]).appendChild(ds);
				       })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90850421-1', 'auto');
  ga('send', 'pageview');
</script>
</div>
</body>
</html>
