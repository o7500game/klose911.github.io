<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>进程关系</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="process.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程关系</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">登录</a>
<ul>
<li><a href="#sec-1-1">终端登录</a>
<ul>
<li><a href="#sec-1-1-1">4.3+BSD</a></li>
<li><a href="#sec-1-1-2">SVR4</a></li>
</ul>
</li>
<li><a href="#sec-1-2">网络登录</a>
<ul>
<li><a href="#sec-1-2-1">4.3+BSD</a></li>
<li><a href="#sec-1-2-2">SVR4</a></li>
</ul>
</li>
<li><a href="#sec-1-3">登录总结</a></li>
</ul>
</li>
<li><a href="#sec-2">进程组</a>
<ul>
<li><a href="#sec-2-1">getpgrp</a></li>
<li><a href="#sec-2-2">setgpid</a></li>
</ul>
</li>
<li><a href="#sec-3">会话期</a>
<ul>
<li><a href="#sec-3-1">setsid</a></li>
</ul>
</li>
<li><a href="#sec-4">控制终端</a>
<ul>
<li><a href="#sec-4-1">tcgetpgrp, tcsetpgrp</a></li>
</ul>
</li>
<li><a href="#sec-5">作业控制</a></li>
</ul>
</div>
</div>
<p>
本章将详细地说明进程组以及POSIX.1引进的对话期新概念，还将介绍登录shell(登录时所调用的)和所有从登录shell起动的进程之间的关系 
</p>

<p>
在说明这些关系时不可能不谈及信号，而谈论信号又需要很多本章介绍的概念
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">登录</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">终端登录</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在早期的UNIX系统中，例如V7，用户用哑终端(通过RS-232连到主机)进行登录。终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)。在这两种情况下登录都经由内核中的终端设备驱动程序，例如在PDP-11上常用的设备是DH-11和DZ-11。因为连到主机上的终端设备数已经确定，所以同时的登录数也就有了已知的上限。下面说明的登录过程适用于使用一个RS-232终端登录到UNIX系统中
</p>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">4.3+BSD</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
登录过程在历史上并没有多少改变。系统管理者创建一个通常名为/etc/ttys的文件，其中每个终端设备有一行，每一行说明设备名和传到getty程序的参数，这些参数说明了终端的波特率等。当系统启动时，内核创建进程ID1，也就是init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则执行程序getty。这种情况示于图9-1中：
</p>

<div class="figure">
<p><img src="pic/console-login.png" alt="console-login.png" width="50%" />
</p>
</div>

<p>
图9-1中各个进程的实际用户ID和有效用户ID都是0(也就是它们都具有超级用户特权)。init以空环境执行getty程序。
</p>

<p>
getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login:”之类的信息，并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度(波特率)
</p>

<p>
当用户键入了用户名后getty就完成了，然后它以类似于下列的方式调用login程序：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22312;gettytab&#25991;&#20214;&#20013;&#21487;&#33021;&#20250;&#26377;&#19968;&#20123;&#36873;&#25321;&#39033;&#20351;&#20854;&#35843;&#29992;&#20854;&#20182;&#31243;&#24207;&#65292;&#20294;&#31995;&#32479;&#40664;&#35748;&#26159;login&#31243;&#24207;</span>
execle(<span style="color: #ffa07a;">"/usr/bin/login"</span>, <span style="color: #ffa07a;">"login"</span>, <span style="color: #ffa07a;">"-p"</span>, username, (<span style="color: #98fb98;">char</span>*)0, envp);
</pre>
</div>
<p>
getty以终端名(例如TERM=foo，其中终端foo的类型取自gettytab文件)和在gettytab中的环境字符串为login创建一个环境(envp参数)。-p标志通知login保留传给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。图9-2显示了login刚被调用后这些进程的状态：
</p>

<div class="figure">
<p><img src="pic/login-begin.png" alt="login-begin.png" width="50%" />
</p>
</div>

<p>
因为最初的init进程具有超级用户优先权，所以图9-2中的所有进程都有超级用户优先权。图9-2中底部三个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且除了最初的init进程，所有的进程均有一个父进程ID
</p>

<p>
login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass(3)以显示提示“Password:”接着读用户键入的口令 (自然，禁止回送用户键入的口令)。它调用crypt(3)将用户键入的口令加密，并与该用户口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数 1 调用exit表示登录过程失败。父进程(init)了解到子进程的终止情况后，将再次调用fork，其后又跟随着执行getty，对此终端重复上述过程
</p>

<p>
如果用户正确登录，login就将当前工作目录更改为该用户的起始目录(chdir)。它也调用chown改变该终端的所有权，使该用户成为所有者和组所有者。将对该终端设备的存取许可权改变成：用户读、写和组写。调用setgid及initgroups设置进程的组ID。然后用login所得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)，以及一个系统默认路径(PATH)。最后login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell，其方式类似于:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #ff4500;">//</span><span style="color: #ff4500;">argv[0]&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;-&#26159;&#19968;&#20010;&#26631;&#24535;&#65292;&#34920;&#31034;&#35813;shell&#34987;&#35843;&#29992;&#20026;&#30331;&#24405;shell&#12290;shell&#21487;&#20197;&#26597;&#30475;&#27492;&#23383;&#31526;&#65292;&#24182;&#30456;&#24212;&#22320;&#20462;&#25913;&#20854;&#36215;&#21160;&#36807;&#31243;</span>
execl(<span style="color: #ffa07a;">"/bin/sh"</span>, <span style="color: #ffa07a;">"-sh"</span>, (<span style="color: #98fb98;">char</span> *) 0);
</pre>
</div>
<p>
login所做的比上面说的要多。它可选地打印message-of-the-day文件，检查新邮件以及其他一些功能
</p>

<p>
因为setuid是由超级用户调用的，它更改所有三个用户ID:实际、有效和保存的用户ID。login在较早时间调用的setgid对所有三个组ID也有同样效果
</p>

<p>
到此为止登录用户的登录shell开始运行。其父进程ID是init进程ID(进程ID 1)，所以当此登录shell终止时，init会得到通知(接到SIGCHLD信号)，它会对该终端重复全部上述过程。登录shell的文件描述符0，1和2设置为终端设备。图9-3显示了这种安排：
</p>

<div class="figure">
<p><img src="pic/finish-login.png" alt="finish-login.png" width="50%" />
</p>
</div>

<p>
现在登录shell读对应的启动文件(Bourneshell和KornShell是.profile，Cshell是.cshrc和.login)。这些配置文件通常改变某些环境变量，加上一些环境变量。例如很多用户设置他们自己的PATH，常常提示实际终端类型(TERM)。当执行完启动文件后，用户最后得到shell的提示符，并能键入命令
</p>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">SVR4</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
SVR4支持两种形式的终端登录：
</p>
<ul class="org-ul">
<li>getty：这与上面所说明的一样，通常用于控制台
</li>
<li>ttymon：用于其他终端的登录
</li>
</ul>

<p>
ttymon是名为服务存取设施(ServiceAccessFacility，SAF)的一部分。只简单说明从init到登录shell之间工作过程，最后结果与图9-3中所示相似。init是sac(服务存取控制器)的父进程，sac调用fork，然后其子进程执行ttymon程序，此时系统进入多用户状态。ttymon监视列于配置文件中的所有终端端口，当用户键入登录名时，它调用一次fork。在此之后该子进程又执行登录用户的登录shell，于是到达了图9-3中所示的位置。一个区别是登录shell的父进程现在是ttymon，而在getty登录中，登录shell的父进程是init
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">网络登录</h3>
<div class="outline-text-3" id="text-1-2">
<p>
终端登录中init知道哪些终端设备可用来进行登录，并为每个设备生成一个getty进程。但是对网络登录则情况有所不同，所有登录都经由内核的网络界面驱动程序(例如以太网驱动程序)，事先并不知道将会有多少这样的登录。不是使一个进程等待每一个可能的登录，而是必须等待一个网络连接请求的到达。在4.3+BSD中，有一个称为inetd的进程，它等待大多数网络连接。本书将说明4.3+BSD的网络登录中所涉及的进程序列
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">4.3+BSD</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
作为系统起动的一部分init调用一个shell，使其执行shell脚本etc/rc。由此shell脚本起动一个精灵进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后该子进程执行适当的程序
</p>

<p>
假定到达了一个对于TELNET服务器的TCP连接请求。TELNET是使用TCP协议的远程登录应用程序。在另一个主机(它通过某种形式的网络，连接到服务器主机上)上的用户，或在同一个主机上的一个用户籍起动TELNET客户进程(client)起动登录过程：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ telnet hostname
</pre>
</div>
<p>
该客户进程打开一个到名为hostname的主机的TCP连接，在hostname主机上起动的程序被称为TELNET服务器。然后客户进程和服务器进程之间使用TELNET应用协议通过TCP连接交换数据。所发生的是起动客户进程的用户现在登录到了服务器进程所在的主机。(自然用户需要在服务器进程主机上有一个有效的账号)。图9-4显示了在执行TELNET服务器进程(称为telnetd)中所涉及的进程序列
</p>

<div class="figure">
<p><img src="pic/telnetd.png" alt="telnetd.png" width="50%" />
</p>
</div>

<p>
然后telnetd进程打开一个伪终端设备，并用fork生成一个子进程。父进程处理通过网络连接的通信，子进程则执行login程序。父、子进程通过伪终端相连接。在调用exec之前，子进程使其文件描述符0，1，2与伪终端相连。如果登录正确，login就执行9.2节中所述的同样步骤—更改当前工作目录为起始目录，设置登录用户的组ID和用户ID，以及登录用户的初始环境。然后login用exec将其自身替换为登录用户的登录shell。图9-5显示了到达这一点时的进程安排：
</p>

<div class="figure">
<p><img src="pic/network-login.png" alt="network-login.png" width="50%" />
</p>
</div>

<p>
很明显在伪终端设备驱动程序和终端实际用户之间有很多事情在进行着，以后说明伪终端时，再介绍与这种安排相关的所有进程
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">SVR4</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
SVR4中网络登录的情况与4.3+BSD中的几乎一样。同样使用了inetd服务器进程，但是在SVR4中inetd是作为一种服务由服务存取控制器sac调用的，其父进程不是init。最后得到的结果与图9-5中一样
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">登录总结</h3>
<div class="outline-text-3" id="text-1-3">
<p>
登录需要理解的重点是：当通过终端或网络登录时得到一个登录shell，其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上。接着会了解到这一登录shell是一个POSIX.1对话期的开始，而此终端或伪终端则是会话期的控制终端
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">进程组</h2>
<div class="outline-text-2" id="text-2">
<p>
每个进程除了有一进程ID之外还属于一个进程组。进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID：它是一个正整数，并可存放在pid_t数据类型中
</p>

<p>
每个进程组有一个组长进程。组长进程的标识是，其进程组ID等于其进程ID
</p>

<p>
在讨论信号时，将说明如何将一个信号送给一个进程(由其进程ID标识)或送给一个进程组(由进程组ID标识)。同样waitpid则可被用来等待一个进程或者指定进程组中的一个进程
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">getpgrp</h3>
<div class="outline-text-3" id="text-2-1">
<p>
getpgrp：返回调用进程的进程组ID
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#36820;&#22238;&#35843;&#29992;&#36827;&#31243;&#30340;&#36827;&#31243;&#32452;ID</span>

<span style="color: #ffa07a;">   pid&#65306;&#36827;&#31243;ID</span>

<span style="color: #ffa07a;">   return&#65306;pid&#25152;&#23646;&#36827;&#31243;&#32452;&#30340;&#32452;ID</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">getpgid</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>);
</pre>
</div>
<p>
进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以参加另一个进程组
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">setgpid</h3>
<div class="outline-text-3" id="text-2-2">
<p>
setgpid：参加一个现存的进程组或者创建一个新进程组
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#35774;&#32622;pid&#36827;&#31243;&#30340;&#36827;&#31243;&#32452;ID&#20026;pgid</span>

<span style="color: #ffa07a;">   pid&#65306;&#36827;&#31243;ID</span>
<span style="color: #ffa07a;">   pgid&#65306;&#36827;&#31243;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#20986;&#38169;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setpgid</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pgid</span>);
</pre>
</div>
<p>
将pid进程的进程组ID设置为pgid
</p>

<p>
一个进程只能为它自己或它的子进程设置进程组ID：
</p>
<ul class="org-ul">
<li>如果pid是0，则让调用者的进程ID成为进程组ID
</li>
<li>如果pgid是0，则由pid指定的进程ID成为进程组ID
</li>
<li>如果这两个参数相等，则由pid指定的进程变成进程组组长
</li>
<li>在它的子进程调用了exec后，就不能再设置该子进程的进程组ID
</li>
<li>如果系统不支持作业控制，此函数返回出错，errno设置为ENOSYS
</li>
</ul>

<p>
在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，然后使子进程设置其自己的进程组ID。虽然这些调用中有一个是冗余的，但这样做可以保证父、子进程在进一步操作之前，子进程都进入了该进程组。如果不这样做的话，就会产生一个竞态条件，因为它依赖于哪一个进程先执行！
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">会话期</h2>
<div class="outline-text-2" id="text-3">
<p>
对话期是一个或多个进程组的集合
</p>

<p>
图9.6中一个会话期有三个进程组：
</p>

<div class="figure">
<p><img src="pic/session.png" alt="session.png" width="90%" />
</p>
</div>

<p>
通常是由shell的管道线将几个进程编成一组的，例如上图中的安排可能是由下列形式的shell命令形成的：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ proc1 | proc2 &amp; 
$ proc3 | proc4 | proc5
</pre>
</div>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">setsid</h3>
<div class="outline-text-3" id="text-3-1">
<p>
setsid：创建一个新的会话期
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#20250;&#35805;&#26399;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#36827;&#31243;&#32452;ID&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">setsid</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>
<p>
如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新对话期：
</p>
<ol class="org-ol">
<li>此进程变成该新对话期的对话期首进程(创建该对话期的进程)，也是该新对话期中的唯一进程
</li>
<li>此进程成为一个新进程组的组长进程，新进程组ID也是此调用进程的进程ID
</li>
<li>此进程没有控制终端，如果在调用setsid之前此进程有一个控制终端，那么这种关系也被解除
</li>
</ol>

<p>
如果此调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不出错，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，所以这就保证了子进程不是一个进程组的组长
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">控制终端</h2>
<div class="outline-text-2" id="text-4">
<p>
对话期和进程组有一些其他特性:
</p>
<ul class="org-ul">
<li>一个对话期可以有一个单独的控制终端，这通常是在其上登录的终端设备或伪终端设备
</li>
<li>控制进程：建立与控制终端连接的对话期首进程
</li>
<li>一个对话期中的几个进程组可被分成一个前台进程组以及一个或几个后台进程组
</li>
<li>无论何时键入中断键(常常是Ctrl-C)或退出键(常常是Ctrl-\)，就会造成将中断信号或退出信号送至前台进程组的所有进程
</li>
<li>如果终端界面检测到调制解调器已经脱开连接，则将挂断信号送至控制进程(对话期首进程)
</li>
</ul>

<p>
这些特性示于图9-7中：
</p>

<div class="figure">
<p><img src="pic/terminal.png" alt="terminal.png" width="90%" />
</p>
</div>

<p>
通常不必担心控制终端，登录时将自动建立控制终端
</p>

<p>
有时不管标准输入、标准输出是否重新定向，程序都要与控制终端交互作用。保证程序读写控制终端的方法是打开文件/dev/tty，在内核中，此特殊文件是控制终端的同义语。自然，如果程序没有控制终端，则打开此设备将失败
</p>

<p>
典型的例子是用于读口令的getpass(3)函数(终端回送被关闭)，这一函数由crypt(1)程序调用，而此程序则可用于管道中。例如将文件salaries解密，然后经由管道将输出送至打印程序：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ crypt &lt; salaries | lpr
</pre>
</div>
<p>
因为crypt从其标准输入读取salaries文件，所以标准输入不能用于输入口令。但是crypt的一个设计特征是每次运行此程序时，都会从控制终端/dev/tty读取加密口令，这样也就不需要将口令存放在文件中
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">tcgetpgrp, tcsetpgrp</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>tcgetpgrp：返回拥有控制终端的前台进程组的组ID
</li>
<li>tcsetpgrp：设置控制终端的前台进程组的组ID
</li>
</ul>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#36820;&#22238;&#26576;&#20010;&#25991;&#20214;&#25551;&#36848;&#31526;&#30456;&#20851;&#32852;&#30340;&#25511;&#21046;&#32456;&#31471;&#30340;&#21069;&#21488;&#36827;&#31243;&#32452;&#30340;&#32452;ID</span>

<span style="color: #ffa07a;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#21069;&#21488;&#36827;&#31243;&#32452;ID&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">tcgetpgrp</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">filedes</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#35774;&#32622;filedes&#25152;&#25171;&#24320;&#30340;&#25511;&#21046;&#32456;&#31471;&#30340;&#21069;&#21488;&#36827;&#31243;&#32452;ID&#20026;pgrpid</span>

<span style="color: #ffa07a;">   filedes&#65306;&#19982;&#26576;&#20010;tty&#30456;&#20851;&#32852;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffa07a;">   pgrpid&#65306;&#26576;&#20010;tty&#19979;&#30340;&#19968;&#20010;&#23545;&#35805;&#26399;&#20013;&#30340;&#19968;&#20010;&#36827;&#31243;&#32452;&#30340;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#25104;&#21151;&#36820;&#22238;0&#65292;&#22833;&#36133;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">tcsetpgrp</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">filedes</span>, <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pgrpid</span>);
</pre>
</div>
<p>
这两个函数用来通知内核哪一个进程组是前台进程组，而内核中的终端设备驱动程序也能知道将终端输入和终端产生的信号送到何处
</p>

<p>
只有支持作业控制，这两个函数才被定义，否则直接报错
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">作业控制</h2>
</div>
</div>
<div id="postamble" class="status">

     <br/>
    <div class='ds-thread'></div>
<script>
var duoshuoQuery = {short_name:'klose911'};
(function() {
	 var dsThread = document.getElementsByClassName('ds-thread')[0];
         dsThread.setAttribute('data-thread-key', document.title);
         dsThread.setAttribute('data-title', document.title);
         dsThread.setAttribute('data-url', window.location.href);
	 var ds = document.createElement('script');
	 ds.type = 'text/javascript';ds.async = true;
	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	 ds.charset = 'UTF-8';
	 (document.getElementsByTagName('head')[0] 
				       || document.getElementsByTagName('body')[0]).appendChild(ds);
				       })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90850421-1', 'auto');
  ga('send', 'pageview');
</script>
</div>
</body>
</html>
