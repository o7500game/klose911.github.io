<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>信号</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="proc_group.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">信号</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">基础概念</a>
<ul>
<li><a href="#sec-1-1">信号产生条件</a></li>
<li><a href="#sec-1-2">信号处理</a></li>
<li><a href="#sec-1-3">常见信号</a>
<ul>
<li><a href="#sec-1-3-1">core文件</a></li>
<li><a href="#sec-1-3-2">常用信号说明</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">signal函数</a>
<ul>
<li><a href="#sec-2-1">signal实例</a></li>
<li><a href="#sec-2-2">exec启动程序</a></li>
<li><a href="#sec-2-3">fork创建进程</a></li>
</ul>
</li>
<li><a href="#sec-3">不可靠性</a>
<ul>
<li><a href="#sec-3-1">丢失信号</a></li>
<li><a href="#sec-3-2">无法阻塞信号</a></li>
</ul>
</li>
<li><a href="#sec-4">可中断的系统调用</a></li>
<li><a href="#sec-5">可再入函数</a>
<ul>
<li><a href="#sec-5-1">信号处理函数中调用不可再入函数</a></li>
</ul>
</li>
<li><a href="#sec-6">可靠信号机制</a>
<ul>
<li><a href="#sec-6-1">术语</a>
<ul>
<li><a href="#sec-6-1-1">产生(generation)</a></li>
<li><a href="#sec-6-1-2">递送(delivery)</a>
<ul>
<li><a href="#sec-6-1-2-1">递送顺序(delivery order)</a></li>
</ul>
</li>
<li><a href="#sec-6-1-3">未决(pending)</a></li>
<li><a href="#sec-6-1-4">阻塞(blocking)</a>
<ul>
<li><a href="#sec-6-1-4-1">排队(queue)</a></li>
</ul>
</li>
<li><a href="#sec-6-1-5">信号屏蔽字(signal mask)</a></li>
<li><a href="#sec-6-1-6">信号集(sigset)</a></li>
</ul>
</li>
<li><a href="#sec-6-2">发送信号</a>
<ul>
<li><a href="#sec-6-2-1">kill函数</a>
<ul>
<li><a href="#sec-6-2-1-1">发送权限</a></li>
<li><a href="#sec-6-2-1-2">空信号</a></li>
</ul>
</li>
<li><a href="#sec-6-2-2">raise函数</a></li>
</ul>
</li>
<li><a href="#sec-6-3">alarm和pause函数</a>
<ul>
<li><a href="#sec-6-3-1">alarm</a></li>
<li><a href="#sec-6-3-2">pause</a></li>
<li><a href="#sec-6-3-3">sleep实现</a>
<ul>
<li><a href="#sec-6-3-3-1">sleep1</a></li>
<li><a href="#sec-6-3-3-2">sleep2</a></li>
<li><a href="#sec-6-3-3-3">其他信号处理程序中调用sleep2</a></li>
</ul>
</li>
<li><a href="#sec-6-3-4">超时限制的读操作</a>
<ul>
<li><a href="#sec-6-3-4-1">read2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6-4">信号集</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
信号是软件中断，提供了一种处理异步事件的方法：例如终端用户键入中断键，则会通过信号机制停止一个程序
</p>

<p>
UNIX的早期版本，就已经有信号机制，但是这些系统所提供的信号模型并不可靠。信号可能被丢失，而且在执行临界区代码时，进程很难关闭所选择的信号。4.3BSD和SVR3对信号模型都作了更改，增加了可靠信号机制。但是这两种更改之间并不兼容。幸运的是POSIX.1对可靠信号例程进行了标准化
</p>

<p>
本章先对信号机制进行综述，并说明每种信号的一般用法。然后分析早期实现的问题，最后说明解决这些问题的方法
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">基础概念</h2>
<div class="outline-text-2" id="text-1">
<p>
每个信号都有一个名字，这些名字都以三个字符SIG开头。例如，SIGABRT是异常终止信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，当由alarm函数设置的时间已经超过后产生此信号。SVR4和4.3+BSD均有31种不同的信号
</p>

<p>
在头文件&lt;signal.h&gt;中，这些信号都被定义为正整数(信号编号)。没有一个信号其编号为0，因为信号编号0有特殊的应用，POSIX.1将此种信号编号值称为空信号
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">信号产生条件</h3>
<div class="outline-text-3" id="text-1-1">
<p>
很多条件可以产生一个信号：
</p>
<ul class="org-ul">
<li>当用户按某些特殊键时产生信号，在终端上按DELETE键通常产生中断信号(SIGINT)。这是停止一个已失去控制程序的方法
</li>
<li>硬件异常产生信号：除数为0、无效的存储访问等等。这些条件通常由硬件检测到，并将其通知内核，然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无效存储访问的进程产生一个SIGSEGV
</li>
<li>进程用kill(2)系统调用可将信号发送给另一个进程或进程组。自然有些限制：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户
</li>
<li>用户可用kill(1)命令将信号发送给其他进程，这是是kill系统调用的命令，常用此命令终止一个失控的后台进程
</li>
<li>当检测到某种软件条件已经发生，并将其通知有关进程时也产生信号。这里并不是指硬件产生条件(如被0除)，而是软件条件。例如SIGURG(在网络连接上传来非规定波特率的数据)、SIGPIPE(在管道的读进程已终止后一个进程写此管道)，以及SIGALRM(进程所设置的闹钟时间已经超时)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">信号处理</h3>
<div class="outline-text-3" id="text-1-2">
<p>
信号是异步事件的经典实例，产生信号的事件对进程而言是随机出现的，进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。系统在某个信号出现时按照下列三种方式中的一种进行操作：
</p>
<ol class="org-ol">
<li>忽略此信号：大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略，它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是为了向超级用户提供一种使进程终止或停止的可靠方法。另外如果忽略某些由硬件异常产生的信号(例如非法存储访问或除以0)，则进程的行为是未定义的
</li>
<li>捕捉信号：为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。例如，若编写一个命令解释器，当用户用键盘产生中断信号时，很可能希望返回到程序的主循环，终止系统正在为该用户执行的命令。如果捕捉到SIGCHLD信号，则表示子进程已经终止，所以此信号的捕捉函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。又例如，如果进程创建了临时文件，那么可能要为SIGTERM信号编写一个信号捕捉函数以清除临时文件(kill命令传送的系统默认信号是终止信号)
</li>
<li>执行系统默认动作：表10-1给出了对每一种信号的系统默认动作。注意，对大多数信号的系统默认动作是终止该进程
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">常见信号</h3>
<div class="outline-text-3" id="text-1-3">
<p>
表10-1列出所有信号的名字，说明，以及对于信号的系统默认动作，作业表示这是作业控制信号(仅当支持作业控制时，才要求此种信号)：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> UNIX信号</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">名字</td>
<td class="left">说明</td>
<td class="left">默认</td>
<td class="left">支持系统</td>
</tr>

<tr>
<td class="left">SIGABRT</td>
<td class="left">异常终止(abort)</td>
<td class="left">终止+core</td>
<td class="left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="left">SIGALRM</td>
<td class="left">超时(alarm)</td>
<td class="left">终止</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">SIGBUS</td>
<td class="left">硬件故障</td>
<td class="left">终止+core</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGCHLD</td>
<td class="left">子进程状态改变</td>
<td class="left">忽略</td>
<td class="left">作业</td>
</tr>

<tr>
<td class="left">SIGCONT</td>
<td class="left">使得暂停进程继续</td>
<td class="left">继续/忽略</td>
<td class="left">作业</td>
</tr>

<tr>
<td class="left">SIGEMT</td>
<td class="left">硬件故障</td>
<td class="left">终止+core</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGFPE</td>
<td class="left">算术异常</td>
<td class="left">终止+core</td>
<td class="left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="left">SIGHUP</td>
<td class="left">链接断开</td>
<td class="left">终止</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">SIGILL</td>
<td class="left">非法硬件指令</td>
<td class="left">终止+core</td>
<td class="left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="left">SIGINT</td>
<td class="left">终端中断符</td>
<td class="left">终止</td>
<td class="left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="left">SIGIO</td>
<td class="left">异步IO</td>
<td class="left">忽略/终止</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGIOT</td>
<td class="left">硬件故障</td>
<td class="left">终止+core</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGKILL</td>
<td class="left">终止</td>
<td class="left">终止</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">SIGPIPE</td>
<td class="left">写入无读进程管道</td>
<td class="left">终止</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">SIGPOLL</td>
<td class="left">可轮询事件</td>
<td class="left">终止</td>
<td class="left">SVR4</td>
</tr>

<tr>
<td class="left">SIGPROF</td>
<td class="left">profile时间超时</td>
<td class="left">终止</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGPWR</td>
<td class="left">电源失效/重启</td>
<td class="left">忽略</td>
<td class="left">SVR4</td>
</tr>

<tr>
<td class="left">SIGQUIT</td>
<td class="left">终端退出符</td>
<td class="left">终止+core</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">SIGSEGV</td>
<td class="left">无效内存引用</td>
<td class="left">终止+core</td>
<td class="left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="left">SIGSTOP</td>
<td class="left">停止</td>
<td class="left">暂停</td>
<td class="left">作业</td>
</tr>

<tr>
<td class="left">SIGSYS</td>
<td class="left">无效系统调用</td>
<td class="left">终止+core</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGTERM</td>
<td class="left">终止</td>
<td class="left">终止</td>
<td class="left">ANSIC + POSIX</td>
</tr>

<tr>
<td class="left">SIGTRAP</td>
<td class="left">硬件故障</td>
<td class="left">终止+core</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGTSTP</td>
<td class="left">终端停止符</td>
<td class="left">暂停</td>
<td class="left">作业</td>
</tr>

<tr>
<td class="left">SIGTTIN</td>
<td class="left">后端读取tty</td>
<td class="left">暂停</td>
<td class="left">作业</td>
</tr>

<tr>
<td class="left">SIGTTOUT</td>
<td class="left">后端写tty</td>
<td class="left">暂停</td>
<td class="left">作业</td>
</tr>

<tr>
<td class="left">SIGURG</td>
<td class="left">紧急数据</td>
<td class="left">忽略</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGUSR1</td>
<td class="left">用户自定义1</td>
<td class="left">终止</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">SIGUSR2</td>
<td class="left">用户自定义2</td>
<td class="left">终止</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">SIGVTALRM</td>
<td class="left">虚拟时间闹钟</td>
<td class="left">终止</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGWINCH</td>
<td class="left">终端窗口大小变化</td>
<td class="left">忽略</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGXCPU</td>
<td class="left">超过CPU限制</td>
<td class="left">终止+core/忽略</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SIGXFSZ</td>
<td class="left">超过文件长度限制</td>
<td class="left">终止+core/忽略</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">core文件</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
在系统默认动作列，“终止+core”表示在进程当前工作目录的core文件中复制了该进程的存储图像。大多数UNIX调试程序都使用core文件以检查进程在终止时的状态。在下列条件下不产生core文件: 
</p>
<ul class="org-ul">
<li>进程是设置-用户-ID，而且当前用户并非程序文件的所有者
</li>
<li>进程是设置-组-ID，而且当前用户并非该程序文件的组所有者
</li>
<li>用户没有写当前工作目录的许可权
</li>
<li>文件太大(RLIMIT_CORE)
</li>
</ul>

<p>
core文件的许可权通常是用户读/写，组读和其他读
</p>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">常用信号说明</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>SIGABRT：调用abort函数时产生此信号，进程异常终止
</li>
<li>SIGALRM：超过用alarm函数设置的时间时产生此信号，若由setitimer(2)函数设置的间隔时间已经过时，那么也产生此信号
</li>
<li>SIGBUS：一个实现定义的硬件故障
</li>
<li>SIGCHLD：在一个进程终止或停止时，SIGCHLD信号被送给其父进程。按系统默认，将忽略此信号。如果父进程希望了解其子进程的这种状态改变，则应捕捉此信号。信号捕捉函数中通常要调用wait函数以取得子进程ID和其终止状态
</li>
<li>SIGCONT：作业控制信号，送给需要继续运行的处于停止状态的进程。如果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行，否则默认动作是忽略此信号。例如vi编辑程序在捕捉到此信号后，重新绘制终端屏幕
</li>
<li>SIGEMT：一个实现定义的硬件故障
</li>
<li>SIGFPE：一个算术运算异常，例如除以0，浮点溢出等
</li>
<li>SIGHUP：如果终端界面检测到一个连接断开，则将此信号送给与该终端相关的控制进程。此信号被送给session结构中s_leader字段所指向的进程。仅当终端的CLOCAL标志没有设置时，在上述条件下才产生此信号
  注意：接到此信号的对话期首进程可能在后台，这区别于通常由终端产生的信号(中断、退出和挂起)，这些信号总是传递给前台进程组。如果对话期前进程终止，则也产生此信号。在这种情况，此信号送给前台进程组中的每一个进程

<p>
通常用此信号通知精灵进程以再读它们的配置文件。选用SIGHUP的理由是：因为一个精灵进程不会有一个控制终端，而且通常决不会接收到这种信号
</p>
</li>
<li>SIGILL：进程已执行一条非法硬件指令
</li>
<li>SIGINFO：一种4.3+BSD信号，当用户按状态键(一般采用Ctrl-T)时，终端驱动程序产生此信号并送至前台进程组中的每一个进程(见图9-8)。此信号通常造成在终端上显示前台进程组中各进程的状态信息
</li>
<li>SIGINT：当用户按中断键(一般采用DELETE或Ctrl-C)时，终端驱动程序产生此信号并送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它
</li>
<li>SIGIO：一个异步I/O事件发生
</li>
<li>SIGIOT：一个实现定义的硬件故障
</li>
<li>SIGKILL：两个不能被捕捉或忽略信号中的一个，它向系统管理员提供了一种可以杀死任一进程的可靠方法
</li>
<li>SIGPIPE：如果在读进程已终止时写管道，则产生此信号，当套接口的一端已经终止时，若进程写该套接口也产生此信号
</li>
<li>SIGPOLL：SVR4信号，当在一个可轮询设备上发生一特定事件时产生此信号，它与4.3+BSD的SIGIO和SIGURG信号类似
</li>
<li>SIGPROF：当setitimer(2)函数设置的统计间隔时间已经超过时产生
</li>
<li>SIGPWR：SVR4信号，它依赖于系统。它主要用于具有不间断电源(UPS)的系统上
如果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下，系统依靠蓄电池电源继续运行，所以无须作任何处理。但是如果蓄电池也将不能支持工作，则软件通常会再次接到通知，此时，它在15~30秒内使系统各部分都停止运行。此时应当传递SIGPWR信号。在大多数系统中使接到蓄电池电压过低的进程将信号SIGPWR发送给init进程，然后由init处理停机操作。很多系统init实现在inittab文件中提供了两个记录项用于此种目的：powerfail以及powerwait 
目前已能获得低价格的UPS系统，它用RS-232串行连接能够很容易地将蓄电池电压过低的条件通知系统，于是这种信号也就更加重要了
</li>
<li>SIGQUIT：当用户在终端上按退出键(一般采用Ctrl-\)时，产生此信号，并送至前台进程组中的所有进程。此信号不仅终止前台进程组(如SIGINT所做的那样)，同时产生一个core文件
</li>
<li>SIGSEGV：进程进行了一次无效的内存访问
</li>
<li>SIGSTOP：作业控制信号，它停止一个进程。它类似于交互停止信号(SIGTSTP)，两个不能被捕捉或忽略信号中的一个
</li>
<li>SIGSYS：一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，但其指示系统调用类型的参数却是无效的
</li>
<li>SIGTERM：由kill(1)命令发送的系统默认终止信号
</li>
<li>SIGTRAP：一个实现定义的硬件故障
</li>
<li>SIGTSTP：交互停止信号，当用户在终端上按挂起键(一般采用Ctrl-Z)时，终端驱动程序产生此信号
</li>
<li>SIGTTIN：当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。在下列例外情形下不产生此信号，此时读操作返回出错，errno设置为EIO：
<ol class="org-ol">
<li>读进程忽略或阻塞此信号
</li>
<li>读进程所属的进程组是孤儿进程组 
</li>
</ol>
</li>
<li>SIGTTOU：当一个后台进程组进程试图写其控制终端时产生此信号。与上面所述的SIGTTIN信号不同，一个进程可以选择为允许后台进程写控制终端。如果不允许后台进程写，在这两种情况下不产生此信号，写操作返回出错，errno设置为EIO：
<ol class="org-ol">
<li>写进程忽略或阻塞此信号
</li>
<li>写进程所属进程组是孤儿进程组
</li>
</ol>
</li>
</ul>

<p>
不论是否允许后台进程写，某些除写以外的下列终端操作也能产生此信号：tcsetattr，tcsendbreak，tcdrain，tcflush，tcflow以及tcsetpgrp
</p>
<ul class="org-ul">
<li>SIGURG：通知进程已经发生一个紧急情况。在网络连接上，接到非规定波特率的数据时，此信号可选择地产生
</li>
<li>SIGUSR1：一个用户定义的信号，可用于应用程序
</li>
<li>SIGUSR2：这是一个用户定义的信号，可用于应用程序
</li>
<li>SIGVTALRM：当一个由setitimer(2)函数设置的虚拟间隔时间已经超过时产生此信号
</li>
<li>SIGWINCH：SVR4和4.3+BSD内核保持与每个终端或伪终端相关联的窗口的大小，一个进程可以用ioctl函数得到或设置窗口的大小。如果一个进程用ioctl的设置-窗口-大小命令更改了窗口大小，则内核将SIGWINCH信号送至前台进程组
</li>
<li>SIGXCPUS：如果进程超过了其软CPU时间限制，则产生此信号
</li>
<li>SIGXFSZ：如果进程超过了其软文件长度限制，则产生此信号
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">signal函数</h2>
<div class="outline-text-2" id="text-2">
<p>
signal函数：为某个特定信号设置处理函数
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#22768;&#26126;sighandler_t&#26159;&#19968;&#20010;&#20989;&#25968;&#25351;&#38024;&#31867;&#22411;&#65292;&#20854;&#21442;&#25968;&#26159;&#19968;&#20010;int&#65292;&#27809;&#26377;&#36820;&#22238;&#20540;&#30340;&#20989;&#25968;&#25351;&#38024;</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">void</span> (*<span style="color: #98fb98;">sighandler_t</span>)(<span style="color: #98fb98;">int</span>);
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20026;&#20449;&#21495;signo&#27880;&#20876;&#19968;&#20010;&#29305;&#23450;&#30340;&#22788;&#29702;&#20989;&#25968;handler</span>

<span style="color: #ffa07a;">   signo&#65306;&#20449;&#21495;&#32534;&#21495;</span>
<span style="color: #ffa07a;">   handler&#65306;&#20989;&#25968;&#25351;&#38024;&#65292;&#21442;&#25968;&#26159;&#19968;&#20010;int&#31867;&#22411;&#65292;&#26080;&#36820;&#22238;&#20540;&#12290;SIG_IGN&#65306;&#24573;&#30053;&#25351;&#23450;&#20449;&#21495;&#12289;SIG_DFL&#65306;&#31995;&#32479;&#40664;&#35748;&#22788;&#29702;&#20449;&#21495;&#12289;&#25110;&#32773;&#26159;&#33258;&#23450;&#20041;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#30340;&#22320;&#22336;</span>

<span style="color: #ffa07a;">   return&#65306;&#25104;&#21151;&#21017;&#20026;&#20043;&#21069;&#30340;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;SIG_ERR</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">sighandler_t</span> <span style="color: #87cefa;">signal</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>, <span style="color: #98fb98;">sighandler_t</span> <span style="color: #eedd82;">handler</span>);

<span style="color: #98fb98;">void</span> (*signal(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">handler</span>)(<span style="color: #98fb98;">int</span>))(<span style="color: #98fb98;">int</span>);
</pre>
</div>

<p>
signal函数要求两个参数：
</p>
<ul class="org-ul">
<li>第一个参数signo：一个整型数，表10-1中的信号名
</li>
<li>第二个参数handler：一个函数指针，它指向的函数需要一个整型参数，无返回值，其含义是指向要设置的信号处理函数的指针
<ul class="org-ul">
<li>常数SIG_IGN：内核表示忽略此信号，SIGKILL和SIGSTOP不能忽略
</li>
<li>常数SIG_DFL：系统默认动作
</li>
<li>接到信号后要调用的函数的地址：此函数为信号处理程序或信号捕捉函数，调用此函数为捕捉信号
</li>
</ul>
</li>
</ul>

<p>
signal的返回值也是一个函数指针，指向的函数需要一个整形参数，无返回值，其含义是指向以前的信号处理函数的指针
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Fake signal functions.  </span><span style="color: #ff4500;">*/</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SIG_ERR</span> ((<span style="color: #98fb98;">__sighandler_t</span>) -1)       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Error return.  </span><span style="color: #ff4500;">*/</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SIG_DFL</span> ((<span style="color: #98fb98;">__sighandler_t</span>) 0)        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Default action.  </span><span style="color: #ff4500;">*/</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SIG_IGN</span> ((<span style="color: #98fb98;">__sighandler_t</span>) 1)        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Ignore signal.  </span><span style="color: #ff4500;">*/</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SIG_ERR</span> (<span style="color: #98fb98;">void</span> (*)()) -1
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SIG_DFL</span> (<span style="color: #98fb98;">void</span> (*)()) 0
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">SIG_IGN</span> (<span style="color: #98fb98;">void</span> (*)()) 1
</pre>
</div>
<p>
这些常数可用于表示"指向函数的指针，该函数要一个整型参数，而且无返回值"。signal的第二个参数及其返回值就可用它们表示。这些常数所使用的三个值不一定要是-1，0和1。它们必须是三个值而决不能是任一可说明函数的地址。大多数UNIX系统使用上面所示的值
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">signal实例</h3>
<div class="outline-text-3" id="text-2-1">
<p>
捕捉两个用户定义的信号并打印信号编号：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;&#65292;&#19968;&#20010;&#20989;&#25968;&#23545;&#24212;&#20004;&#20010;&#20449;&#21495;SIGUSR1&#21644;SIGUSR2</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_usr</span>(<span style="color: #98fb98;">int</span>);

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>) 
{
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#27880;&#20876;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>
    <span style="color: #00ffff;">if</span> ( SIG_ERR == signal(SIGUSR1, sig_usr))
        err_sys(<span style="color: #ffa07a;">"can't catch signal SIG_USR1"</span>);
    <span style="color: #00ffff;">if</span>( SIG_ERR == signal(SIGUSR2, sig_usr))
        err_sys(<span style="color: #ffa07a;">"can't catch signal SIG_USR2"</span>);

    <span style="color: #00ffff;">for</span> (; ; )
        pause();

}

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_usr</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    <span style="color: #00ffff;">if</span> (SIGUSR1 == signo)
        printf(<span style="color: #ffa07a;">"received SIGUSR1\n"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (SIGUSR2 == signo)
        printf(<span style="color: #ffa07a;">"received SIGUSR2\n"</span>);
    <span style="color: #00ffff;">else</span>
        err_dump(<span style="color: #ffa07a;">"received signal %d \n"</span>, signo);
    <span style="color: #00ffff;">return</span> ;

}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./src/signal/sigusr1 &amp; <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#21518;&#21488;&#21551;&#21160;&#36827;&#31243;</span>
[1] 10225 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#25903;&#25345;&#20316;&#19994;&#25511;&#21046;shell&#25171;&#21360;&#20316;&#19994;&#21495;&#21644;&#36827;&#31243;&#21495;</span>

$ kill -USR1 10225 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#21521;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;SIGUSR1 </span>
received SIGUSR1

$ kill -USR2 10225 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#21521;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;SIGUSR2</span>
received SIGUSR2

$ kill 10225 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#12288;&#21521;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;SIGTERM</span>
[1]+  Terminated ./src/signal/sigusr1
</pre>
</div>
<p>
当向该进程发送SIGTERM信号后，该进程就终止，因为它不捕捉此信号，而对此信号的系统默认动作是终止
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">exec启动程序</h3>
<div class="outline-text-3" id="text-2-2">
<p>
当执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为系统默认动作，除非调用exec的进程忽略该信号
</p>

<p>
exec函数将原先设置为要捕捉的信号都更改为默认动作，其他信号的状态则不变。一个进程原先要捕捉的信号，当其执行一个新程序后，就自然地不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义
</p>

<p>
对于一个非作业控制shell，当在后台执行一个进程时，例如：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ cc main.c &amp;
</pre>
</div>
<p>
shell自动将后台进程中对中断和退出信号的处理方式设置为忽略，于是当按中断键时就不会影响到后台进程。如果没有这样的处理，那么当按中断键时，它不但终止前台进程，也终止所有后台进程
</p>

<p>
很多捕捉这两个信号的交互程序具有下列形式的代码:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_int</span>(<span style="color: #98fb98;">int</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_quit</span>(<span style="color: #98fb98;">int</span>);

<span style="color: #00ffff;">if</span> (signal(SIGINT, SIG_IGN) != SIG_IGN)
    signal(SIGINT, sig_int);
<span style="color: #00ffff;">if</span> (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
    signal(SIGQUIT, sig_quit);
</pre>
</div>
<p>
这样处理后，仅当SIGINT和SIGQUIT当前并不忽略，进程才捕捉它们
</p>

<p>
从signal的这两个调用中也可以看到这种函数的限制：只有通过改变信号的处理方式就才能获得信号的当前处理方式
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">fork创建进程</h3>
<div class="outline-text-3" id="text-2-3">
<p>
当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程存储图像，所以信号捕捉函数的地址在子进程中是有意义的
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">不可靠性</h2>
<div class="outline-text-2" id="text-3">
<p>
在早期的UNIX版本中(例如V7)，信号是不可靠的。不可靠：一个信号发生了，但进程却可能不知道这个信号
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">丢失信号</h3>
<div class="outline-text-3" id="text-3-1">
<p>
早期版本中的一个问题是在进程每次处理信号时，随即将信号动作复置为默认值，因此早期的信号处理如下：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sig_int</span>();
<span style="color: #ff4500;">//</span><span style="color: #ff4500;">...</span>
signal(SIGINT, sig_int);
<span style="color: #ff4500;">//</span><span style="color: #ff4500;">...</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sig_int</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#27492;&#26102;SIGINT&#20449;&#21495;&#22788;&#29702;&#21160;&#20316;&#24050;&#32463;&#24674;&#22797;&#25104;&#40664;&#35748;&#65292;&#24517;&#39035;&#20877;&#27425;&#27880;&#20876;sig_int&#20989;&#25968;</span>
    signal(SIGINT, sig_int);
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22788;&#29702;SIGINT&#20449;&#21495;</span>
}
</pre>
</div>
<p>
问题在于：在信号发生之后到信号处理程序中调用signal函数之间有一个时间窗口。在此段时间中可能发生另一次同样中断信号，第二个信号会造成执行默认动作，而对中断信号则是终止该进程！
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">无法阻塞信号</h3>
<div class="outline-text-3" id="text-3-2">
<p>
那时进程对信号的控制能力也很低，它能捕捉信号或忽略它，但有些很需要的功能它却并不具备。例如，有时用户希望通知内核阻塞一种信号：不要忽略该信号，在其发生时记住它，然后在进程作好了准备时再通知它。这种阻塞信号的能力当时并不具备。同样内核也无法关闭某种信号，只能忽略它　
</p>

<p>
主函数调用pause函数使自己睡眠，直到捕捉到一个信号。当信号被捕捉到后，信号处理程序将标志sig_int_flag设置为非0。在信号处理程序返回之后，内核将该进程唤醒，它检测到该标志为非0，然后执行它所需做的
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sig_int_flag</span> = 0; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#22914;&#26524;&#25429;&#25417;&#21040;SIGINT&#20449;&#21495;&#65292;&#21017;&#38750;0</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sig_int</span>(<span style="color: #98fb98;">int</span>);  <span style="color: #ff4500;">//</span><span style="color: #ff4500;">SIGINT&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#27880;&#20876;SIGINT&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>
    signal(SIGINT, sig_int);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">...</span>

    <span style="color: #00ffff;">while</span>(sig_int_flag == 0)
        pause();<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#19968;&#30452;&#30561;&#30496;&#30452;&#21040;&#26576;&#20010;&#20449;&#21495;&#21457;&#29983;</span>
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">...</span>
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sig_int</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#20877;&#27425;&#27880;&#20876;&#20449;&#21495;&#22788;&#29702;&#20989;&#25968;</span>
    signal(SIGINT, sig_int);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#35774;&#32622;&#26631;&#24535;&#21464;&#37327;&#65292;&#20351;&#24471;main&#20989;&#25968;&#31163;&#24320;while&#24490;&#29615;</span>
    sig_int_flag = 1;
}
</pre>
</div>
<p>
问题在于：如果在测试sig_int_flag之后，调用pause之前发生信号，此时sig_int_flag已经变为1，但是程序还是会调用pause，如果以后再无此信号发生，则此进程可能会一直睡眠，因此这次发生的信号也就丢失了！
</p>

<p>
这种类型的程序段在大多数情况下会正常工作，使得我们认为它们正确，而实际上却并不是如此
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">可中断的系统调用</h2>
<div class="outline-text-2" id="text-4">
<p>
早期UNIX系统的一个特性是：如果在进程执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为EINTR。这样处理的理由是因为一个信号发生了，进程捕捉到了它，这意味着已经发生了某种事情，所以是个好机会应当唤醒阻塞的系统调用
</p>

<p>
系统调用分成两类：低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的一类系统调用，它们包括:
</p>
<ul class="org-ul">
<li>在读某些类型的文件时，如果数据并不存在则可能会使调用者永远阻塞。例如管道、终端设备以及网络设备
</li>
<li>在写这些类型的文件时，如果不能立即接受这些数据，则也可能会使调用者永远阻塞
</li>
<li>打开文件，在某种条件发生之前也可能会使调用者阻塞。例如，打开终端设备，它要等待直到所连接的调制解调器回答了电话
</li>
<li>pause(调用进程睡眠直至捕捉到一个信号)和wait
</li>
<li>某些ioctl操作
</li>
<li>某些进程间通信函数
</li>
</ul>

<p>
在这些低速系统调用中一个例外是与磁盘I/O有关的系统调用。虽然读、写一个磁盘文件可能暂时阻塞调用者(在磁盘驱动程序将请求排入队列，然后在适当时间执行请求期间)，但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态。
</p>

<p>
使用中断系统调用这种方法来处理的一种情况是：一个进程起动了读终端操作，而使用该终端设备的用户却离开该终端很长时间。在这种情况下进程可能处于阻塞状态几个小时甚至数天，除非系统停机，否则一直如此
</p>

<p>
必须用显式方法处理可中断的系统调用带来的出错返回。典型的代码序列，假定进行一个读操作，它被中断，我们希望重新起动它如下列样式：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">again</span>:
<span style="color: #00ffff;">if</span> ((n = read(fd, buff, BUFFSIZE)) &lt; 0) {
    <span style="color: #00ffff;">if</span> (errno == EINTR)
        <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">again</span>;
<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">just an interrupted system call </span><span style="color: #ff4500;">*/</span>
<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">handle other errors </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>
<p>
为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引进了某些被中断的系统调用的自动再起动。自动再起动的系统调用包括:ioctl、read、readv、write、writev、wait和waitpid。正如前述，其中前五个函数只有对低速设备进行操作时才会被信号中断。而wait和waitpid在捕捉到信号时总是被中断
</p>

<p>
某些应用程序并不希望这些函数被中断后再起动，因为这种自动再起动的处理方式也会带来问题，为此4.3BSD允许进程在每个信号各别处理的基础上不使用此功能
</p>

<p>
4.2BSD引进自动再起动功能的一个理由是：有时用户并不知道所使用的输入、输出设备是否是低速设备。如果编写的程序可以用交互方式运行，则它可能读、写终端低速设备。如果在程序中捕捉信号，而系统却不提供再起动功能，则对每次读、写系统调用就要进行是否出错返回的测试，如果是被中断的，则再进行读、写
</p>

<p>
表10-2列出了几种实现所提供的信号功能及它们的语义
</p>
<!-- This HTML table template is generated by emacs 24.5.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;系统&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;信号处理&nbsp;<br />
      &nbsp;&nbsp;函数是否<br />
      &nbsp;再包装&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;阻塞信号&nbsp;<br />
      &nbsp;&nbsp;&nbsp;的能力&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;被中断系统&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;调用的再<br />
      &nbsp;&nbsp;启动&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;V7,&nbsp;SVR2<br />
      &nbsp;&nbsp;SVR3,&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;决不&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;sigset,&nbsp;sighold,&nbsp;sigrelse,&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigignore,&nbsp;sigpause&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;SVR3,&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;决不&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;signal,&nbsp;sigvec,&nbsp;sigblock,&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;sigsetmask,&nbsp;sigpause&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.2BSD&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;总是&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.3BSD&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;默认&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="3" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;sigaction,&nbsp;sigprocmask,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;sigpending,&nbsp;sigsuspend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;POSIX.1&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;未说明&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;可选&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.3BSD&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;可选&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">可再入函数</h2>
<div class="outline-text-2" id="text-5">
<p>
进程捕捉到信号并继续执行时，它首先执行该信号处理程序中的指令。如果从信号处理程序正常返回(例如没有调用exit或longjmp)，则继续执行在捕捉到信号时进程正在执行的正常指令序列
</p>

<p>
但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。如果进程正在执行malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号插入执行该信号处理程序，其中又调用malloc，这时会发生什么？又比如进程正在执行getpwnam这种将其结果存放在静态存储单元中的函数，而插入执行的信号处理程序中又调用这样的函数，这时又会发生什么呢？在malloc例子中，可能会对进程造成破坏，因为malloc通常为它所分配的存储区保持一个连接表，而插入执行信号处理程序时，进程可能正在更改此连接表。而在getpwnam的例子中，正常返回给调用者的信息可能由返回至信号处理程序的信息覆盖
</p>

<p>
函数是不可再入的原因为：
</p>
<ul class="org-ul">
<li>使用静态数据结构
</li>
<li>调用malloc或free函数
</li>
<li>标准I/O函数，标准I/O库的很多实现都以不可再入方式使用全局数据结构
</li>
</ul>

<p>
信号处理程序中即使调用了POSIX定义的可再入的函数，但因为每个进程只有一个errno变量，所以仍可能修改了其原先的值。一个信号处理程序，它恰好在main刚设置errno之后被调用。如果该信号处理程序调用read，则它可能更改errno的值，从而取代了刚由main设置的值。因此，作为一个通用的规则，应当在信号处理程序前保存，而在其后恢复errno
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">信号处理函数中调用不可再入函数</h3>
<div class="outline-text-3" id="text-5-1">
<p>
信号处理程序my_alarm调用不可再入函数getpwnam，而my_alarm每秒钟被调用一次：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;pwd.h&gt;</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">my_alarm</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">passwd</span> *<span style="color: #eedd82;">rootptr</span>;

    printf(<span style="color: #ffa07a;">"in signal handler\n"</span>);
    <span style="color: #00ffff;">if</span> ((rootptr = getpwnam(<span style="color: #ffa07a;">"root"</span>)) == <span style="color: #7fffd4;">NULL</span>)
        err_sys(<span style="color: #ffa07a;">"getpwnam(root) error"</span>);
    alarm(1);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">passwd</span>   *<span style="color: #eedd82;">ptr</span>;

    signal(SIGALRM, my_alarm);
    alarm(1);
    <span style="color: #00ffff;">for</span> ( ; ; ) {
        <span style="color: #00ffff;">if</span> ((ptr = getpwnam(<span style="color: #ffa07a;">"sar"</span>)) == <span style="color: #7fffd4;">NULL</span>)
            err_sys(<span style="color: #ffa07a;">"getpwnam error"</span>);
        <span style="color: #00ffff;">if</span> (strcmp(ptr-&gt;pw_name, <span style="color: #ffa07a;">"sar"</span>) != 0)
            printf(<span style="color: #ffa07a;">"return value corrupted!, pw_name = %s\n"</span>,
                   ptr-&gt;pw_name);
    }
}
</pre>
</div>
<p>
运行此程序时，其结果具有随意性：通常在信号处理程序第一次返回时，该程序将由SIGSEGV信号终止。检查core文件，从中可以看到main函数已调用getpwnam，而且当信号处理程序调用此同一函数时，某些内部指针出了问题。偶然，此程序会运行若干秒，然后因产生SIGSEGV信号而终止。在捕捉到信号后，若main函数仍正确运行，其返回值却有时错误，有时正确。有时在信号处理程序中调用getpwnam会出错返回，其出错值为EBADF(无效文件描述符)
</p>

<p>
从此实例中可以看出：若在信号处理程序中调用一个不可再入函数，则其结果是不可预见的！
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">可靠信号机制</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">术语</h3>
<div class="outline-text-3" id="text-6-1">
</div><div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1">产生(generation)</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
造成信号的某个事件发生，向某个进程发送一个信号
</p>
<ol class="org-ol">
<li>硬件异常：例如除以0
</li>
<li>软件条件：例如闹钟时间超过
</li>
<li>终端特殊键
</li>
<li>调用kill函数
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2">递送(delivery)</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
内核在进程表中设置某种形式的一个标志，这被称为向一个进程递送信号
</p>
</div>
<div id="outline-container-sec-6-1-2-1" class="outline-5">
<h5 id="sec-6-1-2-1">递送顺序(delivery order)</h5>
<div class="outline-text-5" id="text-6-1-2-1">
<p>
如果有多个信号要递送给一个进程，POSIX.1并没有规定这些信号的递送顺序，但是与进程当前状态有关的信号一般会被优先递送，例如SIGSEGV
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6-1-3" class="outline-4">
<h4 id="sec-6-1-3">未决(pending)</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
信号产生和递送之间的时间间隔
</p>
</div>
</div>

<div id="outline-container-sec-6-1-4" class="outline-4">
<h4 id="sec-6-1-4">阻塞(blocking)</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
进程可以为某个信号设置为阻塞：如果对该信号的动作是系统默认或捕捉该信号，则该进程将对此信号一直保持为未决状态，直到该进程
</p>
<ol class="org-ol">
<li>对此信号解除了阻塞
</li>
<li>对此信号的动作更改为忽略
</li>
</ol>

<p>
注意：内核是在递送信号给进程的时候决定它的处理动作，而不是在信号发生时候，因此进程在信号递送前仍然可以改变对它的处理动作
</p>

<p>
进程调用sigpending函数将指定的信号设置为阻塞和未决
</p>
</div>
<div id="outline-container-sec-6-1-4-1" class="outline-5">
<h5 id="sec-6-1-4-1">排队(queue)</h5>
<div class="outline-text-5" id="text-6-1-4-1">
<p>
如果在进程解除对某个信号的阻塞之前，这种信号发生了多次，POSIX.1允许系统递送该信号一次或多次。如果递送该信号多次，则称这些信号排了队
</p>

<p>
大多数UNIX并不对信号排队，虽然发生多次，但内核最终只递送这种信号一次
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6-1-5" class="outline-4">
<h4 id="sec-6-1-5">信号屏蔽字(signal mask)</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
信号屏蔽字规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应位已设置，则它当前是被阻塞的
</p>

<p>
进程可以调用sigprocmask来检测和更改其当前信号屏蔽字
</p>
</div>
</div>
<div id="outline-container-sec-6-1-6" class="outline-4">
<h4 id="sec-6-1-6">信号集(sigset)</h4>
<div class="outline-text-4" id="text-6-1-6">
<p>
信号数可能会超过一个整型数所包含的二进制位数，因此POSIX.1定义了一个新数据类型sigset_t，它保持一个信号集。例如，信号屏蔽字就保存在这些信号集的一个中
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">发送信号</h3>
<div class="outline-text-3" id="text-6-2">
</div><div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1">kill函数</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
kill：将信号发送给进程或进程组
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#23558;&#20449;&#21495;&#21457;&#36865;&#32473;&#36827;&#31243;&#25110;&#36827;&#31243;&#32452;</span>

<span style="color: #ffa07a;">   pid&#65306;&#36827;&#31243;ID&#25110;&#36827;&#31243;&#32452;ID</span>
<span style="color: #ffa07a;">   signo&#65306;&#20449;&#21495;&#32534;&#21495;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">kill</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>);
</pre>
</div>
<p>
pid参数有四种不同的情况: 
</p>
<ul class="org-ul">
<li>pid&gt;0：将信号发送给进程ID为pid的进程
</li>
<li>pid==0：将信号发送给其进程组ID等于发送进程的进程组ID，而且发送进程有许可权向其发送信号的所有进程，所有进程”并不包括系统进程集中的进程
</li>
<li>pid&lt;0：将信号发送给其进程组ID等于pid绝对值，而且发送进程有许可权向其发送信号 的所有进程。所有进程并不包括系统进程集中的进程
</li>
<li>pid==-1：将信号发送给所有进程
</li>
</ul>

<p>
如果调用kill为调用进程产生信号，而且此信号是不被阻塞的，那么在kill返回之前，signo或者某个其他未决的、非阻塞信号被递送至该进程
</p>
</div>

<div id="outline-container-sec-6-2-1-1" class="outline-5">
<h5 id="sec-6-2-1-1">发送权限</h5>
<div class="outline-text-5" id="text-6-2-1-1">
<p>
进程将信号发送给其他进程需要权限：
</p>
<ul class="org-ul">
<li>超级用户可将信号发送给另一个进程
</li>
<li>对于非超级用户，其基本规则是发送者的实际或有效用户ID必须等于接收者的实际或有效用户ID。如果实现支持_POSIX_SAVED_IDS，则用保存的设置-用户-ID代替有效用户ID
</li>
<li>特例：如果被发送的信号是SIGCONT，则进程可将它发送给属于同一对话期的任一其他进程
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-2-1-2" class="outline-5">
<h5 id="sec-6-2-1-2">空信号</h5>
<div class="outline-text-5" id="text-6-2-1-2">
<p>
POSIX.1将信号编号0定义为空信号。如果signo参数是0，则kill仍执行正常的错误检查，但不发送信号
</p>

<p>
这常被用来确定一个特定进程是否仍旧存在。如果向一个并不存在的进程发送空信号，则kill返回-1，errno则被设置为ESRCH
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2">raise函数</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
raise：向当前进程发送信号
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#21521;&#24403;&#21069;&#36827;&#31243;&#21457;&#36865;&#20449;&#21495;</span>

<span style="color: #ffa07a;">   singo&#65306;&#20449;&#21495;&#32534;&#21495;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#36820;&#22238;0&#65292;&#33509;&#22833;&#36133;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">raise</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
</pre>
</div>

<p>
等价于：
</p>
<div class="org-src-container">

<pre class="src src-C">kill(getpid(), signo);
</pre>
</div>
<p>
raise的用法类似于面向对象中的"throw Exception"
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">alarm和pause函数</h3>
<div class="outline-text-3" id="text-6-3">
</div><div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1">alarm</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
alarm：设置一个时间值，在将来的某个时刻该时间值会被超过，产生SIGALRM信号，默认动作是终止该进程
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20197;&#31186;&#20026;&#21333;&#20301;&#35774;&#32622;&#36827;&#31243;&#30340;&#38393;&#38047;&#23450;&#26102;&#22120;&#65292;</span>
<span style="color: #ffa07a;">   &#36229;&#36807;&#26102;&#20869;&#26680;&#23558;&#20135;&#29983;SIGALARM&#20449;&#21495;&#24182;&#21457;&#36865;&#21040;&#35843;&#29992;&#36827;&#31243;&#65292;&#35813;&#20449;&#21495;&#30340;&#40664;&#35748;&#21160;&#20316;&#26159;&#32456;&#27490;&#36827;&#31243;</span>

<span style="color: #ffa07a;">   seconds: &#31186;&#25968;</span>

<span style="color: #ffa07a;">   return&#65306;0&#25110;&#20197;&#21069;&#35774;&#32622;&#30340;&#38393;&#38047;&#26102;&#38388;&#30340;&#20313;&#30041;&#31186;&#25968;</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">alarm</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seconds</span>);
</pre>
</div>
<p>
参数seconds的值是秒数，经过了指定的seconds秒后会产生信号SIGALRM。信号由内核产生，由于进程调度的延迟，进程得到控制能够处理该信号还需一段时间
</p>

<p>
每个进程只能有一个闹钟时间。如果在调用alarm前已为该进程设置过闹钟时间，而且它还没有超时，则该闹钟时间的余留值作为本次alarm函数调用的值返回。以前登记的闹钟时间则被新值代换
</p>

<p>
如果有以前登记的尚未超过的闹钟时间，而且seconds值是0，则取消以前的闹钟时间，其余留值仍作为函数的返回值
</p>

<p>
虽然SIGALRM的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号，例如执行定时的清除操作等
</p>
</div>
</div>
<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2">pause</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
pause：使调用进程挂起直至捕捉到一个信号
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20351;&#36827;&#31243;&#22312;&#35843;&#29992;&#22788;&#36827;&#20837;&#25346;&#36215;&#29366;&#24577;&#31561;&#24453;&#35813;&#36827;&#31243;&#22788;&#29702;&#19968;&#20010;&#20449;&#21495;</span>

<span style="color: #ffa07a;">   return&#65306;-1&#65292;&#24182;&#19988;errno&#35774;&#32622;&#20026;EINTR</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pause</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>
<p>
只有执行了一个信号处理程序并从其返回后，pause才返回。在这种情况下，pause返回-1，而且errno被设置为EINTR
</p>
</div>
</div>
<div id="outline-container-sec-6-3-3" class="outline-4">
<h4 id="sec-6-3-3">sleep实现</h4>
<div class="outline-text-4" id="text-6-3-3">
</div><div id="outline-container-sec-6-3-3-1" class="outline-5">
<h5 id="sec-6-3-3-1">sleep1</h5>
<div class="outline-text-5" id="text-6-3-3-1">
<p>
使用alarm和pause实现sleep1，进程可使自己睡眠一段指定的时间：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_alrm</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nothing to do, just return to wake up the pause </span><span style="color: #ff4500;">*/</span>
}

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sleep1</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nsecs</span>)
{
    <span style="color: #00ffff;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
    <span style="color: #00ffff;">return</span>(nsecs);
    alarm(nsecs);       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">start the timer </span><span style="color: #ff4500;">*/</span>
    pause();            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">next caught signal wakes us up </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span>(alarm(0));   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">turn off timer, return unslept time </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>
<p>
sleep1实现有下列问题：
</p>
<ul class="org-ul">
<li>如果调用者已设置了闹钟，则它被sleep1函数中的第一次alarm调用擦去
</li>
</ul>

<p>
修正方法：检查第一次调用alarm的返回值，如其小于本次调用alarm的参数值，则只应等到该前次设置的闹钟时间超时。如果前次设置闹钟时间的超时时刻后于本次设置值，则在sleep1函数返回之前，再次设置闹钟时间，使其在预定时间再发生超时
</p>

<ul class="org-ul">
<li>该程序中修改了对SIGALRM的配置。如果编写了一个函数供其他函数调用，则在该函数被调用时先要保存原配置，在该函数返回前再恢复原配置
</li>
</ul>

<p>
修正方法：保存signal函数的返回值，在返回前恢复设置原配置
</p>

<ul class="org-ul">
<li>在调用alarm和pause之间有一个竞态条件：在一个繁忙的系统中，可能alarm在调用pause之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用pause后，如果没有捕捉到其他信号，则调用者将永远被挂起
</li>
</ul>

<p>
有两种修正方法：
</p>
<ol class="org-ol">
<li>使用setjmp，以下会说明
</li>
<li>使用sigprocmask和sigsuspend
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-6-3-3-2" class="outline-5">
<h5 id="sec-6-3-3-2">sleep2</h5>
<div class="outline-text-5" id="text-6-3-3-2">
<p>
即使pause从未执行，在发生SIGALRM时，sleep2函数也返回 
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;setjmp.h&gt;</span>
<span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">jmp_buf</span>  <span style="color: #eedd82;">env_alrm</span>;

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_alrm</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    longjmp(env_alrm, 1);
}

<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sleep2</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nsecs</span>)
{
    <span style="color: #00ffff;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
        <span style="color: #00ffff;">return</span>(nsecs);
    <span style="color: #00ffff;">if</span> (setjmp(env_alrm) == 0) {
        alarm(nsecs);       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">start the timer </span><span style="color: #ff4500;">*/</span>
        pause();            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">next caught signal wakes us up </span><span style="color: #ff4500;">*/</span>
    }
    <span style="color: #00ffff;">return</span>(alarm(0));       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">turn off timer, return unslept time </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>
<p>
但是sleep2函数中却有另一个难于察觉的问题，它涉及到与其他信号的相互作用。如果SIGALRM中断了某个其他信号处理程序，则调用longjmp会提早终止该信号处理程序
</p>
</div>
</div>
<div id="outline-container-sec-6-3-3-3" class="outline-5">
<h5 id="sec-6-3-3-3">其他信号处理程序中调用sleep2</h5>
<div class="outline-text-5" id="text-6-3-3-3">
<p>
故意使SIGINT处理程序中的for循环语句的执行时间超过5秒钟，也就是大于sleep2的参数值，并且整型变量j说明为volatile，这样就阻止了优化编译程序除去循环语句：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;setjmp.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_int</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sleep2</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nsecs</span>);

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>) 
{
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">unslept</span>;

    <span style="color: #00ffff;">if</span> (SIG_ERR == (signal(SIGINT, sig_int)) )
        err_sys(<span style="color: #ffa07a;">"signal(SIGINT) error"</span>);

    unslept = sleep2(5);

    printf(<span style="color: #ffa07a;">"sleep2 returned: %u\n"</span>, unslept);

    exit(0);

}

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_int</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>) 
{
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
    <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>;

    printf(<span style="color: #ffa07a;">"\n sig_int starting \n"</span>);

    <span style="color: #00ffff;">for</span>(i = 0; i &lt; 200000; i++) {
        j += i * i;
        printf(<span style="color: #ffa07a;">"i is %d, j is %d\n"</span>, i, j);
    }


    printf(<span style="color: #ffa07a;">"sig_int finished\n"</span>);

    <span style="color: #00ffff;">return</span>;
}
</pre>
</div>

<p>
测试结果：sleep2中的longjmp终止了sig_int的程序运行
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./src/signal/sleep2
&#710;? <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#38190;&#20837;&#20013;&#26029;&#23383;&#31526;</span>
sig_int starting
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">...</span>

i is 166016, j is -143706370i is 166016, j is -143706370
sleep2 returned: 0
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6-3-4" class="outline-4">
<h4 id="sec-6-3-4">超时限制的读操作</h4>
<div class="outline-text-4" id="text-6-3-4">
<p>
alarm还常用于对可能阻塞的操作设置一个时间上限值，以下程序在一段时间内从标准输入读一行，然后将其写到标准输出上，通过SIGALRM信号来打断read操作以避免read一直阻塞：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_alrm</span>(<span style="color: #98fb98;">int</span>);

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">n</span>;
    <span style="color: #98fb98;">char</span>    <span style="color: #eedd82;">line</span>[MAXLINE];

    <span style="color: #00ffff;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
    err_sys(<span style="color: #ffa07a;">"signal(SIGALRM) error"</span>);

    alarm(10); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">start timer </span>

    <span style="color: #00ffff;">if</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &lt; 0)
    err_sys(<span style="color: #ffa07a;">"read error"</span>);

    alarm(0); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">stop alarm </span>

    write(STDOUT_FILENO, line, n);
    exit(0);
}

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_alrm</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nothing to do, just return to interrupt the read </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>
<p>
但是这程序依然有两个问题:
</p>
<ul class="org-ul">
<li>在第一次alarm调用和read调用之间有一个竞态条件：如果内核在这两个函数调用之间使进程不能占用处理机运行，而其时间长度又超过闹钟时间，则read可能永远阻塞
</li>

<li>如果系统调用是自动再起动的，则当从SIGALRM信号处理程序返回时，read并不被终止。在这种情形下，设置时间限制不会起作用
</li>
</ul>
</div>

<div id="outline-container-sec-6-3-4-1" class="outline-5">
<h5 id="sec-6-3-4-1">read2</h5>
<div class="outline-text-5" id="text-6-3-4-1">
<p>
用longjmp来避免静态条件：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;setjmp.h&gt;</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span>     <span style="color: #87cefa;">sig_alrm</span>(<span style="color: #98fb98;">int</span>);
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">jmp_buf</span>  <span style="color: #eedd82;">env_alrm</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">n</span>;
    <span style="color: #98fb98;">char</span>    <span style="color: #eedd82;">line</span>[MAXLINE];

    <span style="color: #00ffff;">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)
        err_sys(<span style="color: #ffa07a;">"signal(SIGALRM) error"</span>);
    <span style="color: #00ffff;">if</span> (setjmp(env_alrm) != 0)
        err_quit(<span style="color: #ffa07a;">"read timeout"</span>);

    alarm(10);
    <span style="color: #00ffff;">if</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"read error"</span>);
    alarm(0);

    write(STDOUT_FILENO, line, n);
    exit(0);
}

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sig_alrm</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>)
{
    longjmp(env_alrm, 1);
}
</pre>
</div>
<p>
不管是否自动重新启动系统调用，也都会如所预期的那样工作，但是仍旧会有与其他信号处理程序相互作用的问题
</p>

<p>
另一种更好地选择是使用select或poll函数
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">信号集</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

     <br/>
    <div class='ds-thread'></div>
<script>
var duoshuoQuery = {short_name:'klose911'};
(function() {
	 var dsThread = document.getElementsByClassName('ds-thread')[0];
         dsThread.setAttribute('data-thread-key', document.title);
         dsThread.setAttribute('data-title', document.title);
         dsThread.setAttribute('data-url', window.location.href);
	 var ds = document.createElement('script');
	 ds.type = 'text/javascript';ds.async = true;
	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	 ds.charset = 'UTF-8';
	 (document.getElementsByTagName('head')[0] 
				       || document.getElementsByTagName('body')[0]).appendChild(ds);
				       })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90850421-1', 'auto');
  ga('send', 'pageview');
</script>
</div>
</body>
</html>
