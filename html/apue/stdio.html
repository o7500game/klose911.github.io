<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>标准IO</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="file_directory.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">标准IO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org05173a0">标准I/O</a>
<ul>
<li><a href="#orgd9d202e">流和FILE对象</a></li>
<li><a href="#org28c7fe7">标准输入、标准输出和标准出错</a></li>
<li><a href="#org1ed7fb7">缓存</a>
<ul>
<li><a href="#org817062e">全缓存</a></li>
<li><a href="#org9a76680">行缓存</a></li>
<li><a href="#orgb69231b">不带缓存</a></li>
<li><a href="#org8862cf3">默认实现</a></li>
<li><a href="#orgaeb3a92">setbuf和setvbuf函数</a></li>
<li><a href="#org5541b98">fflush函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orged24dbb">流操作</a>
<ul>
<li><a href="#org0894b9e">打开流</a>
<ul>
<li><a href="#orgc8422b7">流读写方式</a></li>
</ul>
</li>
<li><a href="#orgc57bf81">关闭流</a></li>
<li><a href="#org9fcb05d">读写流</a>
<ul>
<li><a href="#org235dd7c">单字符I/O</a>
<ul>
<li><a href="#org6f6cbc6">getc, fgetc, getchar函数</a></li>
<li><a href="#org2135422">EOF判断</a></li>
<li><a href="#orge350d8a">清除EOF标记</a></li>
<li><a href="#org9717bf0">putc, fputc, putchar函数</a></li>
<li><a href="#org2c72f89">ungetc函数</a></li>
</ul>
</li>
<li><a href="#org0e925b6">行I/O</a>
<ul>
<li><a href="#org58d5324">fgets, gets函数</a></li>
<li><a href="#orgb657592">fputs, puts函数</a></li>
</ul>
</li>
<li><a href="#org2c1f940">标准I/O效率比较</a></li>
<li><a href="#orgb4722d0">二进制I/O</a>
<ul>
<li><a href="#orgf63ded4">读或写一个二进制数组</a></li>
<li><a href="#org94a9129">读或写一个结构</a></li>
<li><a href="#org2afae33">二进制I/O代码不可移植</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga3e5de7">定位流</a>
<ul>
<li><a href="#org1cfd4cd">Unix</a></li>
<li><a href="#org43a05c8">ANSI</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1da7f97">格式化I/O</a>
<ul>
<li><a href="#org5464a6c">格式化输出</a>
<ul>
<li><a href="#orga853e27">可变参数列表版本</a></li>
</ul>
</li>
<li><a href="#orga8288e3">格式化输入</a>
<ul>
<li><a href="#org0f2f68d">可变参数列表版本</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge664c67">实现细节</a>
<ul>
<li><a href="#org5422a64">fileno</a>
<ul>
<li><a href="#org9988067">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org95f0395">临时文件</a>
<ul>
<li><a href="#org8eba454">tmpnam, tmpfile</a>
<ul>
<li><a href="#org8ac6409">实例</a></li>
</ul>
</li>
<li><a href="#org48a2115">tempnam</a>
<ul>
<li><a href="#org415574a">实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章说明标准I/O库。因为不仅在UNIX而且在很多操作系统上都实现此库，所以它由ANSIC标准说明。标准I/O库处理很多细节，例如缓存分配，以优化长度执行I/O等。标准I/O库是在系统调用函数基础上构造的 
</p>

<div id="outline-container-org05173a0" class="outline-2">
<h2 id="org05173a0">标准I/O</h2>
<div class="outline-text-2" id="text-org05173a0">
<p>
在第3章中所有I/O函数都是针对文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后读的I/O操作
</p>

<p>
对于标准I/O库，它们的操作则是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时我们已使一个流与一个文件相结合。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针
</p>
</div>

<div id="outline-container-orgd9d202e" class="outline-3">
<h3 id="orgd9d202e">流和FILE对象</h3>
<div class="outline-text-3" id="text-orgd9d202e">
<ul class="org-ul">
<li>FILE对象: 通常是一个结构，包含了I/O库为管理该流所需要的所有信息，比如用于实际I/O的文件描述符，指向流缓存的指针，缓存的长度，当前在缓存中的字符数，出错标志等等</li>
<li>文件指针：指向FILE对象的指针(类型为FILE*)　</li>
</ul>

<p>
为了引用一个流，需将文件指针作为参数传递给每个标准I/O函数
</p>
</div>
</div>

<div id="outline-container-org28c7fe7" class="outline-3">
<h3 id="org28c7fe7">标准输入、标准输出和标准出错</h3>
<div class="outline-text-3" id="text-org28c7fe7">
<p>
对一个进程预定义了三个流，它们自动地可为进程使用：标准输入、标准输出和标准出错。在3.2节中曾用文件描述符STDIN_FILENO，STDOUT_FILENO和STDERR_FILENO分别表示它们
</p>

<p>
这三个标准I/O流通过预定义文件指针stdin，stdout和stderr加以引用。这三个文件指针同样定义在头文件&lt;stdio.h&gt;中
</p>
</div>
</div>

<div id="outline-container-org1ed7fb7" class="outline-3">
<h3 id="org1ed7fb7">缓存</h3>
<div class="outline-text-3" id="text-org1ed7fb7">
<p>
标准I/O提供缓存的目的是尽可能减少使用read和write调用的数量。它也对每个I/O流自动地进行缓存管理，简化了应用程序的实现
</p>

<p>
在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需要的缓存
</p>

<p>
刷新(flush)：标准I/O缓存的写操作。缓存可由标准I/O例程自动地刷新(例如当填满一个缓存时)，或者可以调用函数fflush刷新一个流 
</p>

<p>
标准I/O提供了三种类型的缓存: 全缓存，行缓存，无缓存
</p>
</div>

<div id="outline-container-org817062e" class="outline-4">
<h4 id="org817062e">全缓存</h4>
<div class="outline-text-4" id="text-org817062e">
<p>
当填满标准I/O缓存后才进行实际I/O操作
</p>

<p>
对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的
</p>
</div>
</div>

<div id="outline-container-org9a76680" class="outline-4">
<h4 id="org9a76680">行缓存</h4>
<div class="outline-text-4" id="text-org9a76680">
<p>
当在输入和输出中遇到新行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(用标准I/Ofputc函数)，但只有在写了一行之后才进行实际I/O操作
</p>

<p>
当流涉及一个终端时(例如标准输入和标准输出)，典型地使用行缓存
</p>

<p>
对于行缓存有两个限制：
</p>
<ol class="org-ol">
<li>因为标准I/O库用来收集每一行的缓存的长度是固定的，所以只要填满了缓存，那么即使还没有写一个新行符，也进行I/O操作</li>
<li>任何时候只要通过标准输入输出库要求从以下两种情况得到数据就会造成刷新所有行缓存输出流
<ul class="org-ul">
<li>一个不带缓存的流：从不带缓存的一个流中进行输入要求只能从内核得到数据</li>
<li>一个行缓存的流(它预先要求从内核得到数据)：所需的数据可能已在该缓存中，但并不要求内核在需要该数据时才进行该操作</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-orgb69231b" class="outline-4">
<h4 id="orgb69231b">不带缓存</h4>
<div class="outline-text-4" id="text-orgb69231b">
<p>
标准I/O库不对字符进行缓存。如果用标准I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。
</p>

<p>
标准出错流stderr通常是不带缓存的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符
</p>
</div>
</div>

<div id="outline-container-org8862cf3" class="outline-4">
<h4 id="org8862cf3">默认实现</h4>
<div class="outline-text-4" id="text-org8862cf3">
<p>
ANSIC要求下列缓存特征:
</p>
<ol class="org-ol">
<li>当且仅当标准输入和标准输出并不涉及交互作用设备时，它们才是全缓存的</li>
<li>标准出错决不会是全缓存的</li>
</ol>

<p>
UNIX系统默认使用下列类型的缓存:
</p>
<ol class="org-ol">
<li>标准出错是不带缓存的</li>
<li>如若是涉及终端设备的其他流，则它们是行缓存的，否则是全缓存的</li>
</ol>
</div>
</div>

<div id="outline-container-orgaeb3a92" class="outline-4">
<h4 id="orgaeb3a92">setbuf和setvbuf函数</h4>
<div class="outline-text-4" id="text-orgaeb3a92">
<p>
setbuf和setvbuf函数：设置文件流的缓存
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#25171;&#24320;&#25110;&#20851;&#38381;&#25991;&#20214;&#27969;&#32531;&#23384;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   buf&#65306;&#32531;&#23384;&#21306;&#25351;&#38024;&#65292;&#22914;&#26524;&#20026;NULL&#21017;&#20851;&#38381;&#32531;&#23384;&#65292;&#21453;&#20043;&#21017;&#25171;&#24320;&#32531;&#23384;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026; 0,&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setbuf</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">buf</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35774;&#32622;&#25991;&#20214;&#27969;&#30340;&#32531;&#23384;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   buf&#65306;&#32531;&#23384;&#21306;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   mode&#65306;&#32531;&#23384;&#31867;&#22411;&#65292;_IOFBF &#20840;&#32531;&#23384;&#65292;_IOLBF &#34892;&#32531;&#23384;, _IONBF &#19981;&#24102;&#32531;&#23384;</span>
<span style="color: #ffebcd;">   size&#65306;&#32531;&#23384;&#21306;&#22823;&#23567;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026; 0,&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0   </span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setvbuf</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">buf</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mode</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>); 
</pre>
</div>

<p>
setbuf和setvbuf参数说明
</p>

<!-- This HTML table template is generated by emacs 26.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;函数&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;mode&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存及长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;缓存类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;setbuf&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;nonnull&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      长度为BUFSIZE的用户缓存
    </td>
    <td align="left" valign="top">
      &nbsp;全缓存或行缓存&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;NULL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;　　无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="5" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;setvbuf&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;_IOFBF&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;nonnull&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;长度为size的用户缓存&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;全缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;NULL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;合适长度的系统缓存&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;_IOLBF&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;nonnull&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;长度为size的用户缓存&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;行缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;NULL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;合适长度的系统缓存&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;_IONBF&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;忽略&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无缓存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-org5541b98" class="outline-4">
<h4 id="org5541b98">fflush函数</h4>
<div class="outline-text-4" id="text-org5541b98">
<p>
fflush：强制刷新一个流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#24378;&#21046;&#21047;&#26032;&#19968;&#20010;&#27969;&#65292;&#22914;&#26524;fp&#20026;NULL&#21017;&#21047;&#26032;&#25152;&#26377;&#36755;&#20986;&#27969;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fflush</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
此函数使该流所有未写的数据都被传递至内核。作为一种特殊情形如若fp是NULL，则刷新所有输出流
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orged24dbb" class="outline-2">
<h2 id="orged24dbb">流操作</h2>
<div class="outline-text-2" id="text-orged24dbb">
</div>
<div id="outline-container-org0894b9e" class="outline-3">
<h3 id="org0894b9e">打开流</h3>
<div class="outline-text-3" id="text-org0894b9e">
<p>
以下三个函数用于打开一个I/O流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26681;&#25454;&#25991;&#20214;&#36335;&#24452;&#21517;&#25171;&#24320;IO&#27969;</span>

<span style="color: #ffebcd;">   pathname&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffebcd;">   type&#65306;&#35813;I/O&#27969;&#30340;&#35835;&#12289;&#20889;&#26041;&#24335;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">fopen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>);
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#22312;&#19968;&#20010;&#29305;&#23450;&#30340;&#27969;&#19978;&#25171;&#24320;&#19968;&#20010;&#25351;&#23450;&#30340;&#25991;&#20214;&#65292;&#22914;&#26524;&#27969;&#24050;&#32463;&#25171;&#24320;&#65292;&#37027;&#20808;&#20851;&#38381;&#27969;&#20877;&#25171;&#24320;</span>

<span style="color: #ffebcd;">   pathname&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffebcd;">   type&#65306;&#35813;I/O&#27969;&#30340;&#35835;&#12289;&#20889;&#26041;&#24335;</span>
<span style="color: #ffebcd;">   fp&#65306;&#29305;&#23450;&#30340;&#27969;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">freopen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26681;&#25454;&#25991;&#20214;&#25551;&#36848;&#31526;&#25171;&#24320;IO&#27969;</span>

<span style="color: #ffebcd;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;">   type&#65306;&#35813;I/O&#27969;&#30340;&#35835;&#12289;&#20889;&#26041;&#24335;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">fdopen</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>);
</pre>
</div>
<ul class="org-ul">
<li>fopen打开指定路径名的一个文件</li>
<li>freopen在一个特定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准出错</li>
<li>fdopen取一个现存的文件描述符，并使一个标准的I/O流与该描述符相结合。常用于由创建管道和网络通信通道函数获得的插述符。因为这些特殊类型的文件不能用标准I/O的fopen函数打开，首先必须先调用设备专用函数以获得一个文件描述符</li>
</ul>
</div>
<div id="outline-container-orgc8422b7" class="outline-4">
<h4 id="orgc8422b7">流读写方式</h4>
<div class="outline-text-4" id="text-orgc8422b7">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 打开标准I/O流的type参数</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">r或rb</td>
<td class="org-left">为读而打开</td>
</tr>

<tr>
<td class="org-left">w或wb</td>
<td class="org-left">使文件成为0长，或为写而创建</td>
</tr>

<tr>
<td class="org-left">a或ab</td>
<td class="org-left">添加;为在文件尾写而打开，或为写而创建</td>
</tr>

<tr>
<td class="org-left">r+或r+b或rb+</td>
<td class="org-left">为读和写而打开</td>
</tr>

<tr>
<td class="org-left">w+或w+b或wb+</td>
<td class="org-left">使文件为0长，或为读和写而打开</td>
</tr>

<tr>
<td class="org-left">a+或a+b或ab+</td>
<td class="org-left">为在文件尾读和写而打开或创建</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>字符b作为type的一部分，使得标准I/O可以区分文本文件和二进制文件。但是UNIX并不对这两种文件进行区分，所以无意义</li>
<li>在使用w或a选项时，若文件不存在则自动创建，新建文件的访问模式只能通过进程的umask限制，而无法手动指定权限</li>
<li>当用字符a打开一文件后，则每次写都将数据写到文件的当前尾端处。如若有多个进程用添加方式打开了同一文件，那么每个进程的数据都将正确地写到文件中</li>
<li>当以r+或者w+时，具有下列限制: 
<ul class="org-ul">
<li>如果中间没有fflush、fseek、fsetpos或rewind，则在输出的后面不能直接跟随输入</li>
<li>如果中间没有fseek、fsetpos或rewind或者一个输出操作没有到达文件尾端，则在输入操作之后不能直接跟随输出</li>
</ul></li>
<li>对于fdopen选项w不能截文件为0，而由filedes的open函数决定</li>
</ul>


<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 打开标准I/O流的六种方式</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">限制</th>
<th scope="col" class="org-left">r</th>
<th scope="col" class="org-left">w</th>
<th scope="col" class="org-left">a</th>
<th scope="col" class="org-left">r+</th>
<th scope="col" class="org-left">w+</th>
<th scope="col" class="org-left">a+</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">文件必须已存在</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">文件截断为0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">流可以读</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流可以写</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流只可以在尾部写</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgc57bf81" class="outline-3">
<h3 id="orgc57bf81">关闭流</h3>
<div class="outline-text-3" id="text-orgc57bf81">
<p>
fclose：关闭一个打开的流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20851;&#38381;&#19968;&#20010;&#24320;&#25171;&#30340;&#27969;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fclose</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
在文件被关闭之前，刷新缓存中的输出数据，缓存中的输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓存，则释放此缓存
</p>

<p>
当一个进程正常终止时，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭
</p>
</div>
</div>

<div id="outline-container-org9fcb05d" class="outline-3">
<h3 id="org9fcb05d">读写流</h3>
<div class="outline-text-3" id="text-org9fcb05d">
<p>
一旦打开了流，则可在三种不同类型的非格式化I/O中进行选择，对其进行读、写操作：
</p>
<ol class="org-ol">
<li>每次一个字符的I/O：一次读或写一个字符</li>
<li>每次一行的I/O：一次读或写一行。每行都以一个新行符终止</li>
<li>直接I/O或二进制I/O：每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度</li>
</ol>
</div>

<div id="outline-container-org235dd7c" class="outline-4">
<h4 id="org235dd7c">单字符I/O</h4>
<div class="outline-text-4" id="text-org235dd7c">
<p>
如果流是带缓存的，则标准I/O函数处理所有缓存
</p>
</div>
<div id="outline-container-org6f6cbc6" class="outline-5">
<h5 id="org6f6cbc6">getc, fgetc, getchar函数</h5>
<div class="outline-text-5" id="text-org6f6cbc6">
<p>
从文件流读取单个字符
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#25991;&#20214;&#25351;&#38024;&#35835;&#21462;&#19968;&#20010;&#23383;&#31526;&#65292;&#21487;&#20197;&#23454;&#29616;&#20026;&#23439;&#65292;&#25928;&#29575;&#22909;&#20110;fgetc</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#19979;&#19968;&#20010;&#23383;&#31526;&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getc</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#25991;&#20214;&#25351;&#38024;&#35835;&#21462;&#19968;&#20010;&#23383;&#31526;&#65292;&#19981;&#33021;&#23454;&#29616;&#20026;&#23439;&#65292;&#25928;&#29575;&#27604;getc&#24046;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#19979;&#19968;&#20010;&#23383;&#31526;&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fgetc</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#26631;&#20934;&#36755;&#20837;&#35835;&#20837;&#19968;&#20010;&#23383;&#31526;&#65292;&#31561;&#20215;&#20110;getc(stdin)</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#19979;&#19968;&#20010;&#23383;&#31526;&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getchar</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div>
<ul class="org-ul">
<li>getc可以实现为宏，所以它的参数不应当是具有副作用的表达式</li>
<li>调用fgetc所需时间很可能长于调用getc，因为调用函数通常所需的时间长于调用宏</li>
<li>因为fgetc一定是个函数，可以得到其地址。允许将fgetc的地址作为一个参数传送给另一个函数</li>
<li>getchar()等价于getc(stdin)</li>
</ul>

<p>
这三个函数以unsigned char类型转换为int的方式返回下一个字符。这样就可以返回所有可能的字符值再加上一个已发生错误或已到达文件尾端的指示值。在&lt;stdio.h&gt;中的常数EOF被要求是一个负值，其值经常是-1。所以不能返回结果是一个无符号字符，而必须是一个带符号整数
</p>
</div>
</div>
<div id="outline-container-org2135422" class="outline-5">
<h5 id="org2135422">EOF判断</h5>
<div class="outline-text-5" id="text-org2135422">
<p>
不管是出错还是到达文件尾端，这三个函数都返回同样的值EOF。为了区分这两种不同的情况，必须调用ferror或feof函数：
</p>

<ul class="org-ul">
<li>ferror函数：判断读取文件是否出错</li>
<li>feop函数：判断读取文件是否结束</li>
</ul>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35835;&#21462;&#25991;&#20214;&#26159;&#21542;&#20986;&#38169;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#35835;&#21462;&#20986;&#38169;&#21017;&#20026;&#38750;0(&#30495;)&#65292;&#21542;&#21017;&#20026;0(&#20551;)</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">ferror</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#25991;&#20214;&#26159;&#21542;&#32467;&#26463;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25991;&#20214;&#32467;&#26463;&#21017;&#20026;&#38750;0(&#30495;)&#65292;&#21542;&#21017;&#20026;0(&#20551;)</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">feof</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orge350d8a" class="outline-5">
<h5 id="orge350d8a">清除EOF标记</h5>
<div class="outline-text-5" id="text-orge350d8a">
<p>
在大多数实现的FILE对象中，为每个流保持了两个标志:
</p>
<ul class="org-ul">
<li>出错标志</li>
<li>文件结束标志</li>
</ul>

<p>
clearerr函数：清除这两个标志
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#28165;&#26970;&#25991;&#20214;&#20986;&#38169;&#21644;&#32467;&#23614;&#20004;&#20010;&#26631;&#24535;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   &#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">clearerr</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org9717bf0" class="outline-5">
<h5 id="org9717bf0">putc, fputc, putchar函数</h5>
<div class="outline-text-5" id="text-org9717bf0">
<p>
输出单个字符到文件流     
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36755;&#20986;&#19968;&#20010;&#23383;&#31526;&#21040;&#27969;&#65292;&#21487;&#23454;&#29616;&#20026;&#23439;</span>

<span style="color: #ffebcd;">   c&#65306;&#36755;&#20986;&#23383;&#31526;</span>
<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">putc</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36755;&#20986;&#19968;&#20010;&#23383;&#31526;&#21040;&#27969;&#65292;&#21482;&#21487;&#23454;&#29616;&#20026;&#20989;&#25968;</span>

<span style="color: #ffebcd;">   c&#65306;&#36755;&#20986;&#23383;&#31526;</span>
<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fputc</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36755;&#20986;&#19968;&#20010;&#23383;&#31526;&#21040;&#26631;&#20934;&#36755;&#20986;&#27969;&#65292;&#31561;&#20215;&#20110;putc(c, stdout)</span>

<span style="color: #ffebcd;">   c&#65306;&#36755;&#20986;&#23383;&#31526;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">putchar</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>);
</pre>
</div>

<ul class="org-ul">
<li>putc可以实现为宏</li>
<li>fputc只能实现为函数</li>
<li>putchar(c)等价于putc(c, stdout)</li>
</ul>
</div>
</div>

<div id="outline-container-org2c72f89" class="outline-5">
<h5 id="org2c72f89">ungetc函数</h5>
<div class="outline-text-5" id="text-org2c72f89">
<p>
ungetc函数：将字符压入流中
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#23558;&#23383;&#31526;&#21387;&#20837;&#27969;&#20013;</span>

<span style="color: #ffebcd;">   c&#65306;&#21387;&#20837;&#30340;&#23383;&#31526;</span>
<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;c&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">ungetc</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
下次读取字符读到的就是被ungetc压入的字符。回送的字符不一定必须是上一次读到的字符。EOF不能回送。但是当已经到达文件尾端时仍可以回送一个字符。下次读将返回该字符，再次读则返回EOF。之所以能这样做的原因是一次成功的ungetc调用会清除该流的文件结束指示
</p>

<p>
例如：读到第一个特殊字符时候，这个字符往往暂时没有用，需要先放回去，等处理完前面读出的数据后，再开始重新读
</p>
</div>
</div>
</div>

<div id="outline-container-org0e925b6" class="outline-4">
<h4 id="org0e925b6">行I/O</h4>
<div class="outline-text-4" id="text-org0e925b6">
</div>
<div id="outline-container-org58d5324" class="outline-5">
<h5 id="org58d5324">fgets, gets函数</h5>
<div class="outline-text-5" id="text-org58d5324">
<p>
从文件流读取一行到缓存区
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#19968;&#20010;&#27969;&#35835;&#21462;&#19968;&#34892;&#21040;&#26368;&#22810;n-1&#20010;&#23383;&#31526;&#21040;&#32531;&#23384;&#21306;buf&#65292;&#32531;&#23384;&#21306;&#20197;null&#23383;&#31526;&#32467;&#26463;</span>

<span style="color: #ffebcd;">   buf&#65306;&#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;">   n&#65306;&#35835;&#21462;&#23383;&#31526;&#38271;&#24230;</span>
<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;buf&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">fgets</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">n</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#26631;&#20934;&#36755;&#20837;&#35835;&#21462;&#19968;&#34892;&#21040;&#21040;&#32531;&#23384;&#21306;buf</span>

<span style="color: #ffebcd;">   buf&#65306;&#32531;&#23384;&#21306;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;buf&#65292;&#33509;&#24050;&#22788;&#25991;&#20214;&#23614;&#31471;&#25110;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">gets</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>);
</pre>
</div>

<ul class="org-ul">
<li>fgets函数：必须指定缓存的长度n。一直读到下一个新行符为止，但是不超过n-1个字符，读入的字符被送入缓存。该缓存以null字符结尾。如若该行包括最后一个新行符的字符数超过n-1，则只返回一个不完整的行，而且缓存总是以null字符结尾。对fgets的下一次调用会继续读该行</li>
<li>gets直接从标准输入流读取，会有验证缓存区溢出的问题，缓存区也不会以null字符结尾</li>
</ul>
</div>
</div>

<div id="outline-container-orgb657592" class="outline-5">
<h5 id="orgb657592">fputs, puts函数</h5>
<div class="outline-text-5" id="text-orgb657592">
<p>
缓存区输出一行到文件流
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36755;&#20986;&#19968;&#20010;&#20197;null&#32467;&#23614;&#30340;&#23383;&#31526;&#20018;&#21040;&#25991;&#20214;&#27969;&#65292;&#32456;&#27490;&#31526;null&#19981;&#36755;&#20986;&#65292;&#26032;&#34892;&#31526;\n&#38656;&#35201;&#21253;&#21547;&#22312;&#23383;&#31526;&#20018;&#20869;</span>

<span style="color: #ffebcd;">   str&#65306;&#36755;&#20986;&#30340;&#23383;&#31526;&#20018;</span>
<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#36755;&#20986;&#30340;&#23383;&#31526;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fputs</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36755;&#20986;&#19968;&#20010;null&#32467;&#23614;&#30340;&#23383;&#31526;&#20018;&#21040;&#26631;&#20934;&#36755;&#20986;&#27969;&#65292;&#32456;&#27490;&#31526;null&#19981;&#36755;&#20986;&#65292;&#33258;&#21160;&#22312;&#26368;&#21518;&#28155;&#21152;&#26032;&#34892;&#31526;\n</span>

<span style="color: #ffebcd;">   str&#65306;&#36755;&#20986;&#30340;&#23383;&#31526;&#20018;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#36755;&#20986;&#30340;&#23383;&#31526;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">puts</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>);
</pre>
</div>

<ul class="org-ul">
<li>fputs函数：将一个以null符终止的字符串写到指定的流，终止符null不写出。必须手动在字符串包含新行符\n</li>
<li>puts函数：将一个以null符终止的字符串写到标准输出，终止符null不写出。自动在最后将一个新行符\n写到标准输出</li>
<li>puts函数不像gets函数那么不安全，但也最好尽量避免使用</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2c1f940" class="outline-4">
<h4 id="org2c1f940">标准I/O效率比较</h4>
<div class="outline-text-4" id="text-org2c1f940">
<p>
用getc和putc将标准输入复制到标准输出
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">c</span>;
    <span style="color: #00bfff; font-weight: bold;">while</span> ( (c = getc(stdin)) != EOF)
        <span style="color: #00bfff; font-weight: bold;">if</span>((putc(c, stdout)) == EOF)
            err_sys(<span style="color: #deb887;">"output error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span>(ferror(stdin))
        err_sys(<span style="color: #deb887;">"input error"</span>);

    exit(0);

}
</pre>
</div>
<p>
用fgets和fputs将标准输入复制到标准输出
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">buf</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">while</span>(<span style="color: #ffd700;">NULL</span> != fgets(buf, MAXLINE, stdin))
        <span style="color: #00bfff; font-weight: bold;">if</span>(EOF == fputs(buf, stdout))
            err_sys(<span style="color: #deb887;">"output error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span>(ferror(stdin))
        err_sys(<span style="color: #deb887;">"input error"</span>);

    exit(0);

}
</pre>
</div>

<p>
表5-3中显示了对同一文件(1.5M字节，30，000行)进行操作所得的数据
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 使用标准I/O例程得到的时间结果</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">函数</td>
<td class="org-right">用户CPU(秒)</td>
<td class="org-right">系统CPU(秒)</td>
<td class="org-right">时钟时间(秒)</td>
<td class="org-right">程序正文字节数</td>
</tr>

<tr>
<td class="org-left">表3.1中的最佳时间</td>
<td class="org-right">0.0</td>
<td class="org-right">0.3</td>
<td class="org-right">0.3</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">fgets,fputs</td>
<td class="org-right">2.2</td>
<td class="org-right">0.3</td>
<td class="org-right">2.6</td>
<td class="org-right">184</td>
</tr>

<tr>
<td class="org-left">getc,putc</td>
<td class="org-right">4.3</td>
<td class="org-right">0.3</td>
<td class="org-right">4.8</td>
<td class="org-right">384</td>
</tr>

<tr>
<td class="org-left">fgetc,fputc</td>
<td class="org-right">4.6</td>
<td class="org-right">0.3</td>
<td class="org-right">5.0</td>
<td class="org-right">152</td>
</tr>

<tr>
<td class="org-left">表3.1中的单字节时间</td>
<td class="org-right">23.8</td>
<td class="org-right">397.9</td>
<td class="org-right">423.4</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
对于这三个标准I/O版本的每一个，其用户CPU时间都大于表3-1中的最佳read版本，这是因为每次读一个字符版本中有一个要执行150万次的循环，而在每次读一行的版本中有一个要执行30000次的循环。在read版本中，其循环只需执行180次(对于缓存长度为8192字节)。因为系统CPU时间都相同，所以用户CPU时间差别造成了时钟时间差别
</p>

<p>
系统CPU时间相同的原因是因为所有这些程序对内核提出的读、写请求数相同。因此标准IO已经选择了最佳IO长度，只需要考虑fgets时最大行长度
</p>

<p>
表5-3中的最后一列是每个main函数的文本空间字节数(由C编译产生的机器指令)。使用getc的版本在文本空间中作了getc和putc的宏代换，所以它所需使用的指令数超过了调用fgetc和fputc函数所需指令数，但是在程序中作宏代换和调用两个函数在时间上并没有多大差别
</p>

<p>
fgetc版本较表3-1中BUFFSIZE=1的版本要快得多。两者都使用了约3百万次的函数调用，而fgetc版本的速度在用户CPU时间方面，大约是后者的5倍，而在时钟时间方面则几乎是100倍。原因是：使用read的版本执行了3百万次系统调用。而对于fgetc版本，它也执行3百万次函数调用，但是这只引起360次系统调用。系统调用与普通的函数调用相比是很花费时间的
</p>

<p>
总而言之：标准IO与直接内核调用比起来并不慢很多，但却可以忽略不少细节！
</p>
</div>
</div>

<div id="outline-container-orgb4722d0" class="outline-4">
<h4 id="orgb4722d0">二进制I/O</h4>
<div class="outline-text-4" id="text-orgb4722d0">
<p>
如果想要读写某个结构，必须使用fgetc或者fputc一次读写一个字符来遍历整个结构。因为fputs在遇到null字节时就停止，而在结构中可能含有null字节，所以不能使用每次一行函数。类似地如果输入数据中包含有null字节或新行符，则fgets也不能正确工作。但是每次单个读写字符即不方便也不高效，标准I/O库提供了以下两个函数来支撑面向结构化的I/O
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#25991;&#20214;&#25351;&#38024;fp&#35835;&#21462;nobj&#20010;&#35760;&#24405;&#21040;ptr&#20013;,&#20854;&#20013;&#27599;&#20010;&#35760;&#24405;&#30340;&#38271;&#24230;&#20026;size</span>

<span style="color: #ffebcd;">   ptr&#65306;&#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;">   size&#65306;&#27599;&#26465;&#35760;&#24405;&#38271;&#24230;</span>
<span style="color: #ffebcd;">   nobj&#65306;&#35760;&#24405;&#20010;&#25968;</span>
<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#35835;&#30340;&#23545;&#35937;&#25968;&#65292;&#22914;&#26524;&#25968;&#37327;&#23567;&#20110;nobj&#65292;&#24212;&#36890;&#36807;feof&#25110;ferror&#21028;&#26029;&#32467;&#26524;</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">size_t</span> <span style="color: #daa520; font-weight: bold;">fread</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nobj</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);


<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#32531;&#23384;&#21306;ptr&#20013;&#21462;nobj&#20010;&#35760;&#24405;&#20889;&#21040;fp&#25351;&#21521;&#30340;&#25991;&#20214;&#27969;&#20013;&#65292;&#20854;&#20013;&#27599;&#20010;&#35760;&#24405;&#30340;&#38271;&#24230;&#20026;size</span>

<span style="color: #ffebcd;">   ptr&#65306;&#32531;&#23384;&#21306;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   size&#65306;&#27599;&#26465;&#35760;&#24405;&#30340;&#38271;&#24230;</span>
<span style="color: #ffebcd;">   nobj&#65306;&#35760;&#24405;&#30340;&#20010;&#25968;</span>
<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#20889;&#30340;&#25968;&#37327;&#65292;&#22914;&#26524;&#23567;&#20110;nobj&#19968;&#33324;&#26159;&#20986;&#38169;</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">size_t</span> <span style="color: #daa520; font-weight: bold;">fwrite</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nobj</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
fread和fwrite返回读或写的对象数。对于读，如果出错或到达文件尾端，则此数字可以少于nobj。在这种情况，应调用ferror或feof以判断究竟是那一种情况。对于写，如果返回值少于所要求的nobj，则出错
</p>
</div>

<div id="outline-container-orgf63ded4" class="outline-5">
<h5 id="orgf63ded4">读或写一个二进制数组</h5>
<div class="outline-text-5" id="text-orgf63ded4">
<p>
将一个浮点数组的第2至第5个元素写至一个文件上
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">float</span> <span style="color: #4eee94;">data</span> [10];

<span style="color: #00bfff; font-weight: bold;">if</span>(fwrite (&amp;data[2], <span style="color: #00bfff; font-weight: bold;">sizeof</span>(<span style="color: #98f5ff;">float</span>), 4, fp) != 4)
    err_sys(<span style="color: #deb887;">"fwrite error"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org94a9129" class="outline-5">
<h5 id="org94a9129">读或写一个结构</h5>
<div class="outline-text-5" id="text-org94a9129">
<p>
读写自定义item结构
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> 
{
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">count</span>;
    <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">total</span>;
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">name</span>[NAMESIZE];
} <span style="color: #4eee94;">item</span>;

<span style="color: #00bfff; font-weight: bold;">if</span>(fwrite(&amp;item, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(item), 1, fp) != 1)
    err_sys(<span style="color: #deb887;">"fwrite error"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org2afae33" class="outline-5">
<h5 id="org2afae33">二进制I/O代码不可移植</h5>
<div class="outline-text-5" id="text-org2afae33">
<p>
二进制I/O只能用于读已写在同一系统上的数据。其原因是:
</p>
<ul class="org-ul">
<li>在一个结构中同一成员的位移量可能随编译程序和系统的不同而异(由于不同的对准要求)。某些编译程序有一选择项允许紧密包装结构(节省存储空间，而运行性能则可能有所下降)或准确对齐(以便在运行时易于存取结构中的各成员)。这意味着即使在单系统上，一个结构的二进制存放方式也可能因编译程序的选择项而不同</li>
<li>用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-orga3e5de7" class="outline-3">
<h3 id="orga3e5de7">定位流</h3>
<div class="outline-text-3" id="text-orga3e5de7">
<p>
有两种方法定位标准I/O流：
</p>
<ol class="org-ol">
<li>ftell和fseek：假定文件的位置可以存放在一个long变量中，适用于Unix系统</li>
<li>fgetpos和fsetpos：由ANSIC引入，通过一个新的抽象数据类型fpos_t来记录文件的位置。在非UNIX系统中这种数据类型可以定义为记录一个文件的位置所需的长度</li>
</ol>

<p>
需要移植到非UNIX系统上运行的应用程序应当使用fgetpos和fsetpos 
</p>
</div>
<div id="outline-container-org1cfd4cd" class="outline-4">
<h4 id="org1cfd4cd">Unix</h4>
<div class="outline-text-4" id="text-org1cfd4cd">
<ul class="org-ul">
<li>ftell函数：返回文件流当前位置</li>
<li>fseek函数：设置文件流当前位置</li>
<li><p>
frewind函数：重置文件流当前位置
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36820;&#22238;&#24403;&#21069;&#22312;&#25991;&#20214;&#27969;&#20013;&#30340;&#20301;&#32622;&#65292;&#20197;long&#20026;&#27493;&#38271;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#24403;&#21069;&#25991;&#20214;&#20301;&#32622;&#25351;&#31034;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1L</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">long</span> <span style="color: #daa520; font-weight: bold;">ftell</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20197;whence&#25351;&#23450;&#30340;&#36215;&#22987;&#20301;&#32622;&#65292;&#23558;&#24403;&#21069;&#20301;&#32622;&#37325;&#26032;&#23450;&#20301;&#22312;offset&#22788;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   offset&#65306;&#27493;&#38271;</span>
<span style="color: #ffebcd;">   whence&#65306;&#21021;&#22987;&#20301;&#32622;(SEEK_SET&#65306;&#25991;&#20214;&#24320;&#22836;&#65292;SEEK_CUR&#65306;&#24403;&#21069;&#20301;&#32622;&#65292;SEEK_END&#65306;&#25991;&#20214;&#26411;&#23614;) </span>

<span style="color: #ffebcd;">   return&#65306;&#36820;&#22238;:&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fseek</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">offset</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">whence</span>);


<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#22797;&#20301;&#24403;&#21069;&#20301;&#32622;&#21040;&#25991;&#20214;&#24320;&#22836;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#26080;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">rewind</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org43a05c8" class="outline-4">
<h4 id="org43a05c8">ANSI</h4>
<div class="outline-text-4" id="text-org43a05c8">
<ul class="org-ul">
<li>fgetpos：获取文件流当前位置</li>
<li>fsetpos：设置文件流当前位置</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#23558;&#25991;&#20214;&#27969;&#30340;&#24403;&#21069;&#20301;&#32622;&#23384;&#21040;pos&#23545;&#35937;&#20013;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   pos&#65306;&#25991;&#20214;&#20301;&#32622;&#32467;&#26500;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fgetpos</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #98f5ff;">fpos_t</span> *<span style="color: #4eee94;">pos</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#23558;&#25991;&#20214;&#27969;&#24403;&#21069;&#20301;&#32622;&#35774;&#32622;&#20026;pos&#23545;&#35937;&#34920;&#36798;&#30340;&#20301;&#32622;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#27969;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   pos&#65306;&#25991;&#20214;&#20301;&#32622;&#32467;&#26500;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0   </span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fsetpos</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">fpost_t</span> *<span style="color: #4eee94;">pos</span>);
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org1da7f97" class="outline-2">
<h2 id="org1da7f97">格式化I/O</h2>
<div class="outline-text-2" id="text-org1da7f97">
<p>
可以使用的格式化标记可参考K&amp;R编写的The C Programming Language一书，典型的使用包括%4d, %3.2f, %*.3f等&#x2026;
</p>
</div>
<div id="outline-container-org5464a6c" class="outline-3">
<h3 id="org5464a6c">格式化输出</h3>
<div class="outline-text-3" id="text-org5464a6c">
<ul class="org-ul">
<li>printf函数：格式化字符串输出到标准输出流</li>
<li>fprintf函数：格式化字符串输出到文件流</li>
<li><p>
sprintf函数：格式化字符串输出到缓存区，在缓存区的尾端会自动加一个null字节，但该字节不包括在返回值中
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26684;&#24335;&#21270;&#23383;&#31526;&#20018;format&#36755;&#20986;&#21040;&#26631;&#20934;&#36755;&#20986;stdout</span>

<span style="color: #ffebcd;">   format&#65306;&#36755;&#20986;&#26684;&#24335;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#36755;&#20986;&#23383;&#31526;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;&#36127;&#20540;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">printf</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26684;&#24335;&#21270;&#23383;&#31526;&#20018;format&#36755;&#20986;&#21040;&#25991;&#20214;&#27969;fp</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   format&#65306;&#36755;&#20986;&#23383;&#31526;&#20018;&#26684;&#24335;</span>

<span style="color: #ffebcd;">   &#33509;&#25104;&#21151;&#21017;&#20026;&#36755;&#20986;&#23383;&#31526;&#25968;,&#33509;&#36755;&#20986;&#20986;&#38169;&#21017;&#20026;&#36127;&#20540;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fprintf</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26684;&#24335;&#21270;&#23383;&#31526;&#20018;format&#36755;&#20986;&#21040;&#32531;&#23384;&#21306;buf</span>

<span style="color: #ffebcd;">   buf&#65306;&#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;">   format&#65306;&#36755;&#20986;&#23383;&#31526;&#20018;&#26684;&#24335;</span>

<span style="color: #ffebcd;">   return&#65306;&#23384;&#20837;&#25968;&#32452;&#30340;&#23383;&#31526;&#25968;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sprintf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, ...);
</pre>
</div></li>
</ul>
<p>
注意：sprintf可能会造成由buf指向的缓存区溢出，保证该缓存有足够长度是调用者的责任！ 
</p>
</div>
<div id="outline-container-orga853e27" class="outline-4">
<h4 id="orga853e27">可变参数列表版本</h4>
<div class="outline-text-4" id="text-orga853e27">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span><span style="color: #deb887;">&lt;stdarg.h&gt;</span>
<span style="color: #ffd700;">#include</span><span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vprintf</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vfprintf</span>(FILEfp,*<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* format, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vsprintf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga8288e3" class="outline-3">
<h3 id="orga8288e3">格式化输入</h3>
<div class="outline-text-3" id="text-orga8288e3">
<ul class="org-ul">
<li>scanf函数：从标准输入流读取格式化的字符串</li>
<li>fscanf函数：从文件流读取格式化的字符串</li>
<li><p>
sscanf函数：从缓存区读取格式化的字符串
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span><span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#26631;&#20934;&#36755;&#20837;&#27969;stdin&#35835;&#21462;format&#26684;&#24335;&#30340;&#23383;&#31526;&#20018;</span>

<span style="color: #ffebcd;">   format&#65306;&#36755;&#20837;&#23383;&#31526;&#20018;&#26684;&#24335;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#23450;&#30340;&#36755;&#20837;&#39033;&#25968;,&#12288;&#33509;&#20986;&#38169;&#25110;&#22312;&#20219;&#24847;&#21464;&#25442;&#21069;&#24050;&#33267;&#25991;&#20214;&#23614;&#31471;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">scanf</span>(<span style="color: #00bfff; font-weight: bold;">const</span>&#12288;<span style="color: #98f5ff;">char</span>* format, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#25991;&#20214;&#27969;fp&#35835;&#21462;format&#26684;&#24335;&#30340;&#23383;&#31526;&#20018;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   format&#65306;&#36755;&#20837;&#23383;&#31526;&#20018;&#26684;&#24335;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#23450;&#30340;&#36755;&#20837;&#39033;&#25968;,&#12288;&#33509;&#20986;&#38169;&#25110;&#22312;&#20219;&#24847;&#21464;&#25442;&#21069;&#24050;&#33267;&#25991;&#20214;&#23614;&#31471;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fscanf</span>(<span style="color: #98f5ff;">FILE</span>* <span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">format</span>, ...);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#23383;&#31526;&#32531;&#23384;&#21306;buf&#35835;&#21462;format&#26684;&#24335;&#30340;&#23383;&#31526;&#20018;</span>

<span style="color: #ffebcd;">   buf&#65306;&#23383;&#31526;&#32531;&#23384;&#21306;</span>
<span style="color: #ffebcd;">   format&#65306;&#36755;&#20837;&#23383;&#31526;&#20018;&#26684;&#24335;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#23450;&#30340;&#36755;&#20837;&#39033;&#25968;,&#12288;&#33509;&#20986;&#38169;&#25110;&#22312;&#20219;&#24847;&#21464;&#25442;&#21069;&#24050;&#33267;&#25991;&#20214;&#23614;&#31471;&#21017;&#20026;EOF</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">sscanf</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span>* <span style="color: #4eee94;">format</span>, ...);
</pre>
</div></li>
<li>使用时应输入必须和格式化的字符串匹配，否则第一个不匹配的字符后面的部分将被直接丢弃！</li>
<li>空白字符(空格、制表符等)均归为转义符'\s';</li>
</ul>
</div>
<div id="outline-container-org0f2f68d" class="outline-4">
<h4 id="org0f2f68d">可变参数列表版本</h4>
<div class="outline-text-4" id="text-org0f2f68d">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdarg.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vscanf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vfscanf</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>); 

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">vsscanf</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">buf</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">format</span>, <span style="color: #98f5ff;">va_list</span> <span style="color: #4eee94;">arg</span>);
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orge664c67" class="outline-2">
<h2 id="orge664c67">实现细节</h2>
<div class="outline-text-2" id="text-orge664c67">
<p>
想要了解所使用的系统中标准I/O库的实现，最好从头文件&lt;stdio.h&gt;开始。从中可以看到：
</p>
<ul class="org-ul">
<li>FILE对象是如何定义的</li>
<li>每个流标志的定义</li>
<li>定义为宏的各个标准I/O例程(比如getc等)</li>
</ul>

<p>
在UNIX中，标准I/O库最终都要调用第3章中说明的I/O例程，每个I/O流都有一个与其相关联的文件描述符
</p>
</div>
<div id="outline-container-org5422a64" class="outline-3">
<h3 id="org5422a64">fileno</h3>
<div class="outline-text-3" id="text-org5422a64">
<p>
fileno函数：获得某个文件流相关联的文件描述符
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#33719;&#24471;&#26576;&#20010;&#25991;&#20214;&#27969;&#30456;&#20851;&#32852;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;</span>

<span style="color: #ffebcd;">   fp&#65306;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#19982;&#35813;&#27969;&#30456;&#20851;&#32852;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fileno</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
如果要调用dup或fcntl等函数，需要fileno函数
</p>
</div>
<div id="outline-container-org9988067" class="outline-4">
<h4 id="org9988067">实例</h4>
<div class="outline-text-4" id="text-org9988067">
<p>
为三个标准流以及一个与一个普通文件相关联的流打印有关缓存状态信息
</p>

<p>
注意：在打印缓存状态信息之前，先对每个流执行I/O操作，因为第一个I/O操作通常就造成为该流分配缓存。结构成员_flag、_bufsiz以及常数_IONBF和_IOLBF是由所使用的系统定义的
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_stdio</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *, <span style="color: #98f5ff;">FILE</span> *);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>;
    fputs(<span style="color: #deb887;">"enter any characters\n"</span>, stdout);
    <span style="color: #00bfff; font-weight: bold;">if</span>(EOF == getchar() )
        err_sys(<span style="color: #deb887;">"getchar error"</span>);

    fputs(<span style="color: #deb887;">"one line to standard error\n"</span>, stderr);

    pr_stdio(<span style="color: #deb887;">"stdin"</span>, stdin);
    pr_stdio(<span style="color: #deb887;">"stdout"</span>, stdout);
    pr_stdio(<span style="color: #deb887;">"stderr"</span>, stderr);

    <span style="color: #00bfff; font-weight: bold;">if</span>(<span style="color: #ffd700;">NULL</span> == (fp = fopen(<span style="color: #deb887;">"/etc/man.conf"</span>, <span style="color: #deb887;">"r"</span>)) )
        err_sys(<span style="color: #deb887;">"fopen error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span>(EOF == getc(fp) )
        err_sys(<span style="color: #deb887;">"getc error"</span>);

    pr_stdio(<span style="color: #deb887;">"/etc/man.conf"</span>, fp);

    exit(0);

}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_stdio</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>)
{
    printf(<span style="color: #deb887;">"stream= %s "</span>, name);

    <span style="color: #00bfff; font-weight: bold;">if</span>(fp-&gt;_flags &amp; _IONBF)
        printf(<span style="color: #deb887;">"unbuffered"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span>(fp-&gt;_flags &amp; _IOLBF)
        printf(<span style="color: #deb887;">"line buffered"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span>
        printf(<span style="color: #deb887;">"fully buffered"</span>);

    printf(<span style="color: #deb887;">", buffer size = %d\n"</span>, (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base));

}
</pre>
</div>
<p>
运行程序两次，一次使三个标准流与终端相连接，另一次使它们都重定向到普通文件，则所得结果是:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">stdin, stdout &#21644;stderr&#37117;&#36830;&#33267;&#32456;&#31471;</span>
klose@gentoo ~/Documents/programming/c/apue $ ./src/stdio/printfExample
enter any characters 
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#38190;&#20837;&#26032;&#34892;&#31526;&#21495;</span>
one line to standard error
<span style="color: #4eee94;">stream</span>= stdin fully buffered, buffer size = 1024
<span style="color: #4eee94;">stream</span>= stdout fully buffered, buffer size = 1024
<span style="color: #4eee94;">stream</span>= stderr unbuffered, buffer size = 1
<span style="color: #4eee94;">stream</span>= /etc/man.conf fully buffered, buffer size = 4096

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#19977;&#20010;&#27969;&#37117;&#37325;&#23450;&#21521;&#21040;&#25991;&#20214;</span>
klose@gentoo ~/Documents/programming/c/apue $ ./src/stdio/printfExample &lt; /etc/profile &gt; std.out 2&gt; std.err&#12288;
klose@gentoo ~/Documents/programming/c/apue $ ls -l std.out std.err 
-rw-r--r-- 1 klose klose  27 Feb 12 21:30 std.err
-rw-r--r-- 1 klose klose 220 Feb 12 21:30 std.out

klose@gentoo ~/Documents/programming/c/apue $ cat std.out  
enter any characters
<span style="color: #4eee94;">stream</span>= stdin fully buffered, buffer size = 4096
<span style="color: #4eee94;">stream</span>= stdout fully buffered, buffer size = 4096
<span style="color: #4eee94;">stream</span>= stderr unbuffered, buffer size = 1
<span style="color: #4eee94;">stream</span>= /etc/man.conf fully buffered, buffer size = 4096

klose@gentoo ~/Documents/programming/c/apue $ cat std.err 
one line to standard error
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org95f0395" class="outline-2">
<h2 id="org95f0395">临时文件</h2>
<div class="outline-text-2" id="text-org95f0395">
</div>
<div id="outline-container-org8eba454" class="outline-3">
<h3 id="org8eba454">tmpnam, tmpfile</h3>
<div class="outline-text-3" id="text-org8eba454">
<p>
标准I/O库提供了以下两个函数用来创建临时文件：
</p>
<ul class="org-ul">
<li>tmpnam：产生临时文件名</li>
<li><p>
tmpfile：产生临时文件
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20135;&#29983;&#19968;&#20010;&#19982;&#29616;&#22312;&#25991;&#20214;&#21517;&#19981;&#21516;&#30340;&#19968;&#20010;&#26377;&#25928;&#36335;&#24452;&#21517;&#30340;&#23383;&#31526;&#20018;&#65292;&#33509;ptr&#20026;NULL&#21017;&#23384;&#25918;&#22312;&#19968;&#20010;&#20840;&#23616;&#38745;&#24577;&#32531;&#23384;&#21306;&#65292;&#21453;&#20043;&#20445;&#23384;&#22312;ptr&#20869;</span>

<span style="color: #ffebcd;">   ptr&#65306;&#23384;&#25918;&#20020;&#26102;&#25991;&#20214;&#21517;&#30340;&#32531;&#23384;&#21306;</span>

<span style="color: #ffebcd;">   return&#65306;&#25351;&#21521;&#19968;&#21807;&#19968;&#36335;&#24452;&#21517;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">tmpnam</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">ptr</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#21019;&#24314;&#19968;&#20010;&#20020;&#26102;&#20108;&#36827;&#21046;&#25991;&#20214;(&#31867;&#22411;wb+)&#65292;&#22312;&#20851;&#38381;&#35813;&#25991;&#20214;&#25110;&#31243;&#24207;&#32467;&#26463;&#26102;&#23558;&#33258;&#21160;&#21024;&#38500;&#36825;&#31181;&#25991;&#20214;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">tmpfile</span>(<span style="color: #98f5ff;">void</span>);
</pre>
</div></li>
</ul>
<p>
每次调用tmpnam时，它都产生一个不同的路径名，最多调用次数是TMP_MAX常量。如果ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。下一次再调用tmpnam时会重写该静态区。如果ptr不是NULL，则认为它指向长度至少是L_tmpnam个字符的数组，所产生的路径名存放在该数组中，ptr也作为函数值返回
</p>

<p>
tmpfile创建一个临时二进制文件(类型wb+)，在关闭该文件或程序结束时将自动删除这种文件
</p>

<p>
tmpfile函数的实现是先调用tmpnam产生一个唯一的路径名，然后立即unlink它
</p>
</div>
<div id="outline-container-org8ac6409" class="outline-4">
<h4 id="org8ac6409">实例</h4>
<div class="outline-text-4" id="text-org8ac6409">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">name</span>[L_tmpnam], <span style="color: #4eee94;">line</span>[MAXLINE];
    <span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>;

    printf(<span style="color: #deb887;">"%s\n"</span>, tmpnam(<span style="color: #ffd700;">NULL</span>) );

    tmpnam(name);
    printf(<span style="color: #deb887;">"%s\n"</span>, name);

    <span style="color: #00bfff; font-weight: bold;">if</span>(<span style="color: #ffd700;">NULL</span> == (fp = tmpfile() ) )
        err_sys(<span style="color: #deb887;">"tempfile error"</span>);

    fputs(<span style="color: #deb887;">"Hello World\n"</span>, fp);
    rewind(fp);
    <span style="color: #00bfff; font-weight: bold;">if</span>(<span style="color: #ffd700;">NULL</span> == (fgets(line, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(line), fp) ) )
        err_sys(<span style="color: #deb887;">"fgets error"</span>);
    fputs(line, stdout);

    exit(0);

}
</pre>
</div>
<p>
测试代码：
</p>
<div class="org-src-container">
<pre class="src src-sh">klose@gentoo ~/Documents/programming/c/apue $ ./src/stdio/tempfileExample 
/tmp/fileO0xmAZ
/tmp/fileN1WvPl
Hello World
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org48a2115" class="outline-3">
<h3 id="org48a2115">tempnam</h3>
<div class="outline-text-3" id="text-org48a2115">
<p>
tempnam函数：tmpnam的一个变体，允许调用者为所产生的路径名指定目录和前缀  
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20801;&#35768;&#35843;&#29992;&#32773;&#20026;&#25152;&#20135;&#29983;&#30340;&#36335;&#24452;&#21517;&#25351;&#23450;&#30446;&#24405;&#21644;&#21069;&#32512;</span>

<span style="color: #ffebcd;">   directory&#65306;&#25991;&#20214;&#30446;&#24405;&#21517;</span>
<span style="color: #ffebcd;">   prefix&#65306;&#25991;&#20214;&#21069;&#32512;&#21517;&#65292;&#26368;&#22810;&#20855;&#26377;5&#20010;&#23383;&#31526;</span>

<span style="color: #ffebcd;">   return&#65306;&#25351;&#21521;&#19968;&#21807;&#19968;&#36335;&#24452;&#21517;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">tempnam</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">directory</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">prefix</span>);
</pre>
</div>
<p>
对于目录有四种不同的选择，使用第一个条件为真的作为目录:
</p>
<ol class="org-ol">
<li>如果定义了环境变量TMPDIR，则用其作为目录</li>
<li>如果参数directory非NULL，则用其作为目录</li>
<li>将&lt;stdio.h&gt;中的字符串P_tmpdir用作为目录</li>
<li>将本地目录，通常是/tmp，用作为目录</li>
</ol>

<p>
如果prefix非NULL，则它应该是最多包含5个字符的字符串，用其作为文件名的头几个字符
</p>
</div>
<div id="outline-container-org415574a" class="outline-4">
<h4 id="org415574a">实例</h4>
<div class="outline-text-4" id="text-org415574a">
<p>
根据输入目录名和前缀名打印产生的临时文件名
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #00bfff; font-weight: bold;">if</span>(argc != 3)
        err_quit(<span style="color: #deb887;">"usage tempfileName: &lt;directory&gt; &lt;prefix&gt;"</span>);

    printf(<span style="color: #deb887;">"%s\n"</span>, tempnam(argv[1][0] != <span style="color: #deb887;">' '</span> ? argv[1] : <span style="color: #ffd700;">NULL</span>,
                   argv[2][0] != <span style="color: #deb887;">' '</span> ? argv[2] : <span style="color: #ffd700;">NULL</span>));

    exit(0);
}
</pre>
</div>
<p>
测试代码:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#25351;&#23450;&#30446;&#24405;&#21644;&#21069;&#32512;</span>
$ ./src/stdio/tempfileName ~/tmp/ temp
/home/klose/tmp/tempKcMUjW

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#40664;&#35748;&#30446;&#24405;&#65306;P_tmpdir</span>
$ ./src/stdio/tempfileName <span style="color: #deb887;">" "</span> PFX
/tmp/PFXK8lxrK

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#29615;&#22659;&#21464;&#37327;&#65292;&#26080;&#21069;&#32512;</span>
$ <span style="color: #4eee94;">TMPDIR</span>=/usr/tmp ./src/stdio/tempfileName  /tmp <span style="color: #deb887;">" "</span>
/usr/tmp/file2UoOUE

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#24573;&#30053;&#26080;&#25928;&#30340;&#29615;&#22659;&#21464;&#37327;</span>
$ <span style="color: #4eee94;">TMPDIR</span>=/no/such/file ./src/stdio/tempfileName  <span style="color: #deb887;">" "</span> QQQQ
/tmp/QQQQTL3shI

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#24573;&#30053;&#26080;&#25928;&#30340;&#29615;&#22659;&#21464;&#37327;&#21644;&#30446;&#24405;&#35774;&#32622;</span>
$ <span style="color: #4eee94;">TMPDIR</span>=/no/such/directory ./src/stdio/tempfileName  /no/such/file QQQQ
/tmp/QQQQSSmQeI
</pre>
</div>

<p>
<a href="system_file.html">Next：系统文件</a>
</p>

<p>
<a href="file_directory.html">Previous：文件和目录</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
