<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程间通信</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="daemon.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程间通信</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9a1e8ef">管道</a>
<ul>
<li><a href="#org2639fcf">pipe函数</a>
<ul>
<li><a href="#orgfbac37f">实例：创建管道</a></li>
<li><a href="#org6b11eaf">实例：分页展示文件</a></li>
<li><a href="#orgde7e81a">实例：父子进程同步</a></li>
</ul>
</li>
<li><a href="#orgfc2d634">popen和pclose函数</a>
<ul>
<li><a href="#orge0a0f79">使用popen实现分页读取文件</a></li>
<li><a href="#org019071b">实现popen和pclose函数</a></li>
<li><a href="#orgc7c6d07">用popen变换输入</a></li>
</ul>
</li>
<li><a href="#orga828d1b">协同进程</a>
<ul>
<li><a href="#org039cfe0">对两个数求和的简单过滤</a>
<ul>
<li><a href="#orge58b9da">使用标准IO改写add2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgff364e4">FIFO</a>
<ul>
<li><a href="#org6175dbf">mkfifo函数</a></li>
<li><a href="#org664a9ea">FIFO文件</a></li>
<li><a href="#orgcbc1abf">FIFO用途</a>
<ul>
<li><a href="#orgc6e326e">复制输出流</a></li>
<li><a href="#orgad235af">简单客户-服务器通信</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6160712">系统V IPC</a>
<ul>
<li><a href="#orga1f4631">相似特征</a>
<ul>
<li><a href="#org4b9846e">标识符和关键字</a>
<ul>
<li><a href="#org4c45e83">客户机和服务器使用同一IPC结构</a></li>
<li><a href="#orgf5a8e2b">创建IPC结构</a></li>
</ul>
</li>
<li><a href="#org64f1228">权限结构</a>
<ul>
<li><a href="#orgd8b4dc6">mode字段</a></li>
</ul>
</li>
<li><a href="#orgd53a645">资源限制</a></li>
<li><a href="#orgb648904">优点和缺点</a>
<ul>
<li><a href="#org9f327da">系统V IPC的缺点</a></li>
<li><a href="#org7ee003e">消息队列的优点</a></li>
<li><a href="#org2a5aac2">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1951866">消息队列</a>
<ul>
<li><a href="#org8ff4a3f">msqid_ds结构</a></li>
<li><a href="#org765ba2d">资源限制</a></li>
<li><a href="#org15e4585">msgget函数</a></li>
<li><a href="#orgd4b99ee">msgctl函数</a>
<ul>
<li><a href="#orgbb9d516">cmd参数</a></li>
</ul>
</li>
<li><a href="#org495b096">msgsnd函数</a>
<ul>
<li><a href="#org0d4d45c">ptr指针</a></li>
<li><a href="#org201d492">flag标记</a></li>
</ul>
</li>
<li><a href="#org5fc16e2">msgrcv函数</a>
<ul>
<li><a href="#orgfb82d0b">type参数</a></li>
</ul>
</li>
<li><a href="#org95f98e7">实例</a></li>
<li><a href="#org6b2ab1e">消息队列 VS 流管道</a></li>
</ul>
</li>
<li><a href="#org7b2735f">信号量</a>
<ul>
<li><a href="#org4a830d1">实现</a></li>
<li><a href="#org0705765">semid_ds结构</a></li>
<li><a href="#org52e63f1">资源限制</a></li>
<li><a href="#org66d4fde">semget函数</a></li>
<li><a href="#org4a05d50">semctl函数</a>
<ul>
<li><a href="#org9f212c3">cmd参数</a></li>
</ul>
</li>
<li><a href="#org40126bd">semop函数</a>
<ul>
<li><a href="#orgee0d30f">semoarray参数</a></li>
<li><a href="#org1962193">exit时的信号量调整</a></li>
</ul>
</li>
<li><a href="#orge2224f5">实例</a></li>
<li><a href="#org2e47784">信号量 VS 文件锁</a></li>
</ul>
</li>
<li><a href="#org7316136">共享内存</a>
<ul>
<li><a href="#org09e36c6">shmid_ds结构</a></li>
<li><a href="#org69784f9">资源限制</a></li>
<li><a href="#org0abb7de">shmget函数</a></li>
<li><a href="#orgb1db010">shmctl函数</a>
<ul>
<li><a href="#org4caccef">cmd参数</a></li>
</ul>
</li>
<li><a href="#org69fab86">shmat函数</a></li>
<li><a href="#org9c30cf0">shmdt函数</a></li>
<li><a href="#orgabc0713">打印不同类型的数据所存放的位置</a></li>
<li><a href="#org8724c17">/dev/zero的存储映射</a>
<ul>
<li><a href="#org7c59a42">匿名存储映射</a></li>
<li><a href="#org323a987">共享存储 VS mmap</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2ca7275">客户机-服务器模型</a>
<ul>
<li><a href="#org54b023e">单向管道</a></li>
<li><a href="#org57e5f0b">FIFO</a></li>
<li><a href="#org1810df8">消息队列</a>
<ul>
<li><a href="#org8ac9a7b">实现</a></li>
<li><a href="#orgd1205e2">缺陷</a>
<ul>
<li><a href="#orge7e43e9">安全措施</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge28b6c4">总结</a></li>
</ul>
</div>
</div>
<p>
第8章说明了进程控制原语并且观察了如何调用多个进程。但是这些进程之间交换信息的唯一方法是经由fork或exec传送打开文件，或通过文件系统。本章将说明进程之间相互通信的其他技术IPC
</p>

<p>
UNIX IPC已经是而且继续是各种进程通信方式的统称，其中极少能在所有UNIX的实现中进行移植。表14-1列出了不同实现所支持的不同形式的IPC：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> UNIX IPC</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">IPC类型</td>
<td class="org-left">POSIX.1</td>
<td class="org-left">XPG3</td>
<td class="org-left">V7</td>
<td class="org-left">SVR2</td>
<td class="org-left">SVR3.2</td>
<td class="org-left">SVR4</td>
<td class="org-left">4.3BSD</td>
<td class="org-left">4.3+BSD</td>
</tr>

<tr>
<td class="org-left">管道(半双工)</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">FIFO(命令管道)</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流管道(全双工)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">命令流管道</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">消息队列</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">信号量</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">共享内存</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">套接口</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">流</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
正如上表所示，不管哪一种UNIX实现，都可依靠的唯一一种IPC是半双工的管道。表中前7种IPC通常限于同一台主机的各个进程间的IPC。最后两种：套接口和流，则支持不同主机上各个进程间IPC。虽然中间三种形式的IPC(消息队列、信号量以及共享存储器)在表中说明为只受到系统V的支持，但是在大多数制造商所支持的，从伯克利UNIX导出的UNIX系统中(例如，SunOS以及Ultrix)已经添加了这三种形式的IPC
</p>

<p>
本章将讨论经典的IPC：
</p>
<ul class="org-ul">
<li>管道</li>
<li>FIFO</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
</ul>

<div id="outline-container-org9a1e8ef" class="outline-2">
<h2 id="org9a1e8ef">管道</h2>
<div class="outline-text-2" id="text-org9a1e8ef">
<p>
管道是UNIX IPC的最老形式，并且所有UNIX系统都提供此种通信机制，管道有两种限制; 
</p>
<ol class="org-ol">
<li>半双工的：数据只能在一个方向上流动</li>
<li>只能在具有公共祖先的进程之间使用：通常一个管道由一个进程创建，然后该进程调用fork，此后父、子进程之间就可应用该管道</li>
</ol>

<p>
尽管有这两种限制，半双工管道仍是最常用的IPC形式
</p>
</div>

<div id="outline-container-org2639fcf" class="outline-3">
<h3 id="org2639fcf">pipe函数</h3>
<div class="outline-text-3" id="text-org2639fcf">
<p>
pipe函数：创建管道
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#21019;&#24314;&#31649;&#36947;</span>

<span style="color: #ffebcd;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;&#25968;&#32452;&#65292;iledes[0]&#20026;&#35835;&#32780;&#25171;&#24320;&#65292;filedes[1]&#20026;&#20889;&#32780;&#25171;&#24320;&#65292;</span>
<span style="color: #ffebcd;">        filedes[1]&#30340;&#36755;&#20986;&#26159;filedes[0]&#30340;&#36755;&#20837;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pipe</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>[2]);
</pre>
</div>
<p>
由参数filedes数组返回两个文件描述符：
</p>
<ul class="org-ul">
<li>filedes[0]为读而打开</li>
<li>filedes[1]为写而打开，filedes[1]的输出正好是filedes[0]的输入</li>
</ul>

<p>
有两种方法来描绘一个管道，左半图显示了管道的两端在一个进程中相互连接，右半图则说明数据通过内核在管道中流动：
</p>

<div class="figure">
<p><img src="pic/pipe.jpg" alt="pipe.jpg" width="90%" /> 
</p>
</div>

<p>
fstat函数对管道的每一端都返回一个FIFO类型的文件描述符，可以用S_ISFIFO宏来测试管道
</p>

<p>
单个进程中的管道几乎没有任何用处。通常调用pipe的进程接着调用fork，这样就创建了从父进程到子进程或反之的IPC通道。下图显示了这种情况：
</p>

<div class="figure">
<p><img src="pic/pipe-fork.jpg" alt="pipe-fork.jpg" width="70%" /> 
</p>
</div>

<p>
fork之后做什么取决于我们想要有的数据流的方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程则关闭写端(fd[1])。图14-3显示了描述符的最后安排：
</p>

<div class="figure">
<p><img src="pic/pipe-fork-close.jpg" alt="pipe-fork-close.jpg" width="70%" /> 
</p>
</div>

<p>
当管道的一端被关闭后，下列规则起作用：
</p>
<ol class="org-ol">
<li>当读一个写端已被关闭的管道时，在所有数据都被读取后，read返回0，以指示达到了文件结束处(从技术方面考虑，管道的写端还有进程时，就不会产生文件的结束。可以复制一个管道的描述符，使得有多个进程具有写打开文件描述符。但是，通常一个管道只有一个读进程，一个写进程)</li>
<li>如果写一个读端已被关闭的管道，则产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write出错返回，errno设置为EPIPE</li>
</ol>

<p>
注意：在写管道时，常数PIPE_BUF规定了内核中管道缓存器的大小。如果对管道进行write调用，而且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或FIFO)的write操作穿插进行。但是若有多个进程同时写一个管道(FIFO)，而且某个或某些进程要求写的字节数超过PIPE_BUF字节数，则数据可能会与其他写操作的数据相穿插
</p>
</div>

<div id="outline-container-orgfbac37f" class="outline-4">
<h4 id="orgfbac37f">实例：创建管道</h4>
<div class="outline-text-4" id="text-orgfbac37f">
<p>
创建了一个从父进程到子进程的管道，并且父进程经由该管道向子进程传送数据：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>;
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>[2];
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(fd) &lt; 0)
        err_sys(<span style="color: #deb887;">"pipe error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        close(fd[0]);<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">close read tunnel of pipe in parent process</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(write(fd[1], <span style="color: #deb887;">"hello world\n"</span>, 12) &lt; 0)
            err_sys(<span style="color: #deb887;">"write to pipe error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        close(fd[1]); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">close write tunnel of pipe in child process</span>
        n = read(fd[0], line, MAXLINE);
        <span style="color: #00bfff; font-weight: bold;">if</span>(write(STDOUT_FILENO, line, n) &lt; 0)
            err_sys(<span style="color: #deb887;">"write to console error"</span>);
    }

    exit(0);
}
</pre>
</div>
<p>
上面程序对管道描述符调用read和write。更为普遍的是将管道描述符复制为标准输入和标准输出。在此之后通常子进程调用exec，执行另一个程序，该程序从标准输入(已创建的管道)或将数据写至其标准输出(管道)
</p>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/pipe1

hello world
</pre>
</div>
</div>
</div>

<div id="outline-container-org6b11eaf" class="outline-4">
<h4 id="org6b11eaf">实例：分页展示文件</h4>
<div class="outline-text-4" id="text-org6b11eaf">
<p>
下面程序的功能是每次一页显示已产生的输出。已经有很多UNIX公用程序具有分页功能，因此无需再构造一个新的分页程序，而是调用用户最喜爱的分页程序。为了避免先将所有数据写到一个临时文件中，然后再调用系统中的有关程序显示该文件，将输出通过管道直接送到分页程序。为此先创建一个管道，一个子进程，使子进程的标准输入成为管道的读端，然后exec用户喜爱的分页程序:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DEF_PAGER</span>   <span style="color: #deb887;">"/usr/bin/less"</span>     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">default pager program </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>;
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>[2];
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">char</span>    *<span style="color: #4eee94;">pager</span>, *<span style="color: #4eee94;">argv0</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];
    <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fp</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 2)
        err_quit(<span style="color: #deb887;">"usage: a.out &lt;pathname&gt;"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fopen(argv[1], <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
        err_sys(<span style="color: #deb887;">"can't open %s"</span>, argv[1]);
    <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(fd) &lt; 0)
        err_sys(<span style="color: #deb887;">"pipe error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {                               <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        close(fd[0]);       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close read end </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent copies argv[1] to pipe </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, fp) != <span style="color: #ffd700;">NULL</span>) {
            n = strlen(line);
            <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd[1], line, n) != n)
                err_sys(<span style="color: #deb887;">"write error to pipe"</span>);
        }
        <span style="color: #00bfff; font-weight: bold;">if</span> (ferror(fp))
            err_sys(<span style="color: #deb887;">"fgets error"</span>);

        close(fd[1]);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close write end of pipe for reader </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

        <span style="color: #00bfff; font-weight: bold;">if</span> (waitpid(pid, <span style="color: #ffd700;">NULL</span>, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"waitpid error"</span>);
        exit(0);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        close(fd[1]);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close write end </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (fd[0] != STDIN_FILENO) { <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">standard input descriptor point to fd[0]</span>
            <span style="color: #00bfff; font-weight: bold;">if</span> (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO)
                err_sys(<span style="color: #deb887;">"dup2 error to stdin"</span>);
            close(fd[0]);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">don't need this after dup2 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        }

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">get arguments for execl() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> ((pager = getenv(<span style="color: #deb887;">"PAGER"</span>)) == <span style="color: #ffd700;">NULL</span>)
            pager = DEF_PAGER;
        <span style="color: #00bfff; font-weight: bold;">if</span> ((argv0 = strrchr(pager, <span style="color: #deb887;">'/'</span>)) != <span style="color: #ffd700;">NULL</span>)
            argv0++;        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">step past rightmost slash </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">else</span>
            argv0 = pager;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">no slash in pager </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

        <span style="color: #00bfff; font-weight: bold;">if</span> (execl(pager, argv0, (<span style="color: #98f5ff;">char</span> *)0) &lt; 0)
            err_sys(<span style="color: #deb887;">"execl error for %s"</span>, pager);
    }
    exit(0);
}
</pre>
</div>
<p>
在调用fork之前先创建一个管道。fork之后父进程关闭其读端，子进程关闭其写端。子进程然后调用dup2，使其标准输入指向管道的读端。当执行分页程序时，其标准输入将是管道的读端：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/most2 Makefile

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">Makefile.in generated by automake 1.15 from Makefile.am.</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">Makefile.  Generated from Makefile.in by configure.</span>

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">Copyright (C) 1994-2014 Free Software Foundation, Inc.</span>

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">This Makefile.in is free software; the Free Software Foundation</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">gives unlimited permission to copy and/or distribute it,</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">with or without modifications, as long as this notice is preserved.</span>

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">This program is distributed in the hope that it will be useful,</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">but WITHOUT ANY WARRANTY, to the extent permitted by law; without</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">even the implied warranty of MERCHANTABILITY or FITNESS FOR A</span>
<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">PARTICULAR PURPOSE.</span>



am__is_gnu_make = { <span style="color: #deb887;">\</span>
  <span style="color: #00bfff; font-weight: bold;">if </span><span style="color: #f08080;">test</span> -z <span style="color: #deb887;">'$(MAKELEVEL)'</span>; <span style="color: #00bfff; font-weight: bold;">then</span> <span style="color: #deb887;">\</span>
    false; <span style="color: #deb887;">\</span>
  <span style="color: #00bfff; font-weight: bold;">elif </span><span style="color: #f08080;">test</span> -n <span style="color: #deb887;">'$(MAKE_HOST)'</span>; <span style="color: #00bfff; font-weight: bold;">then</span> <span style="color: #deb887;">\</span>
    true; <span style="color: #deb887;">\</span>
  <span style="color: #00bfff; font-weight: bold;">elif </span><span style="color: #f08080;">test</span> -n <span style="color: #deb887;">'$(MAKE_VERSION)'</span> &amp;&amp; <span style="color: #f08080;">test</span> -n <span style="color: #deb887;">'$(CURDIR)'</span>; <span style="color: #00bfff; font-weight: bold;">then</span> <span style="color: #deb887;">\</span>
: <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20998;&#39029;&#24320;&#22987;</span>
</pre>
</div>

<p>
将一个描述符复制到另一个时，在子进程中，fd[0]复制到标准输入，应当注意该描述符的值并不已经是所希望的值。如果该描述符已经具有所希望的值，并且我们先调用dup2，然后调用close则将关闭此进程中只有该单个描述符所代表的打开文件。在本程序中，如果shell没有打开标准输入，那么程序开始处的fopen应已使用描述符0，也就是最小未使用的描述符，所以fd[0]决不会等于标准输入。尽管如此，只要先调用dup2，然后调用close以复制一个描述符到另一个，作为一种保护性的编程措施，总是先将两个描述符进行比较
</p>

<p>
先使用环境变量PAGER获得用户分页程序名称的。如果操作没有成功，则使用系统默认值。这是环境变量的常见用法
</p>
</div>
</div>

<div id="outline-container-orgde7e81a" class="outline-4">
<h4 id="orgde7e81a">实例：父子进程同步</h4>
<div class="outline-text-4" id="text-orgde7e81a">
<p>
以前使用信号实现了TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT以及WAIT_CHILD。下面则是一个使用管道的实现：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span>  <span style="color: #4eee94;">pfd1</span>[2], <span style="color: #4eee94;">pfd2</span>[2];

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_WAIT</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(pfd1) &lt; 0 || pipe(pfd2) &lt; 0)
        err_sys(<span style="color: #deb887;">"pipe error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_PARENT</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(pfd2[1], <span style="color: #deb887;">"c"</span>, 1) != 1)
        err_sys(<span style="color: #deb887;">"write error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">WAIT_PARENT</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">c</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (read(pfd1[0], &amp;c, 1) != 1)
        err_sys(<span style="color: #deb887;">"read error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (c != <span style="color: #deb887;">'p'</span>)
        err_quit(<span style="color: #deb887;">"WAIT_PARENT: incorrect data"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">TELL_CHILD</span>(<span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(pfd1[1], <span style="color: #deb887;">"p"</span>, 1) != 1)
        err_sys(<span style="color: #deb887;">"write error"</span>);
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">WAIT_CHILD</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">c</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (read(pfd2[0], &amp;c, 1) != 1)
        err_sys(<span style="color: #deb887;">"read error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (c != <span style="color: #deb887;">'c'</span>)
        err_quit(<span style="color: #deb887;">"WAIT_CHILD: incorrect data"</span>);
}
</pre>
</div>
<p>
在fork之前创建了两个管道。父进程在调用TELL_CHILD时经由上一个管道写一个字符'P'，子进程在调用TELL_PARENT时，经由下一个管道写一个字符'C'。相应的WAIT_XXX函数调用read读一个字符，没有读到字符时阻塞(睡眠等待)：
</p>

<div class="figure">
<p><img src="pic/pipe-tell-wait.jpg" alt="pipe-tell-wait.jpg" width="70%" /> 
</p>
</div>

<p>
注意：每一个管道都有一个额外的读取进程，这没有关系。也就是说除了子进程从pfd1[0]读取，父进程也有上一个管道的读端。因为父进程并没有执行对该管道的读操作，所以这不会产生任何影响
</p>
</div>
</div>
</div>

<div id="outline-container-orgfc2d634" class="outline-3">
<h3 id="orgfc2d634">popen和pclose函数</h3>
<div class="outline-text-3" id="text-orgfc2d634">
<p>
常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其发送输入，标准I/O库为实现这些操作提供了两个函数popen和pclose
</p>

<p>
popen实现的操作是：
</p>
<ol class="org-ol">
<li>创建一个管道</li>
<li>fork一个子进程</li>
<li>关闭管道的不使用端</li>
<li>exec一个shell以执行命令</li>
<li>等待命令终止</li>
</ol>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#21019;&#24314;&#19968;&#20010;&#23376;&#36827;&#31243;&#65292;&#29992;&#20110;&#25191;&#34892;&#25351;&#23450;&#30340;shell&#21629;&#20196;</span>
<span style="color: #ffebcd;">   &#21487;&#20197;&#23558;&#27492;&#23376;&#36827;&#31243;&#30340;&#26631;&#20934;&#36755;&#20837;&#25110;&#26631;&#20934;&#36755;&#20986;&#20026;&#31649;&#36947;,&#35813;&#31649;&#36947;&#30340;&#21478;&#19968;&#31471;&#20026;&#35843;&#29992;&#36827;&#31243;&#20013;&#36820;&#22238;&#30340;&#31649;&#36947;&#25991;&#20214;&#27969;&#25351;&#38024;&#25152;&#24341;&#29992;</span>

<span style="color: #ffebcd;">   cmdstring&#65306;&#35201;&#25191;&#34892;&#30340;shell&#21629;&#20196;</span>
<span style="color: #ffebcd;">   type&#65306;&#20026;"r"&#26102;&#65292;&#23376;&#36827;&#31243;&#25152;&#25191;&#34892;&#21629;&#20196;&#30340;&#26631;&#20934;&#36755;&#20986;&#20026;&#31649;&#36947;&#30340;&#36755;&#20837;&#31471;,&#35813;&#31649;&#36947;&#30340;&#36755;&#20986;&#31471;&#20026;popen&#30340;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;">   &#20026;"w"&#26102;&#65292;&#23376;&#36827;&#31243;&#25191;&#34892;&#30340;&#21629;&#20196;&#30340;&#26631;&#20934;&#36755;&#20837;&#20026;&#31649;&#36947;&#30340;&#36755;&#20986;&#31471;,&#35813;&#31649;&#36947;&#30340;&#36755;&#20837;&#31471;&#20026;popen&#30340;&#36820;&#22238;&#20540;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#25991;&#20214;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">popen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>);
</pre>
</div>
<p>
函数popen先执行fork，然后调用exec以执行cmdstring，并且返回一个标准I/O文件指针：
</p>
<ul class="org-ul">
<li>如果type是"r"，则文件指针连接到cmdstring的标准输出(见图14-5)</li>
<li>如果type是"w"，则文件指针连接到cmdstring的标准输入(见图14-6)</li>
</ul>

<div class="figure">
<p><img src="pic/popen.jpg" alt="popen.jpg" width="90%" /> 
</p>
</div>

<p>
pclose函数关闭标准I/O流：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>


<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20851;&#38381;popen&#25171;&#24320;&#30340;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   fp&#65306;popen&#25171;&#24320;&#30340;&#25991;&#20214;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;cmdstring&#30340;&#32456;&#27490;&#29366;&#24577;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">   ,*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pclose</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>);
</pre>
</div>
<p>
pclose函数会等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose返回的终止状态与shell执行exit(127)一样
</p>

<p>
cmdstring由Bourne shell以下列方式执行：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ sh -c cmdstring
</pre>
</div>
<p>
这表示shell将扩展cmdstring中的任何特殊字符。例如可以使用：
</p>
<div class="org-src-container">
<pre class="src src-C">fp = popen(<span style="color: #deb887;">"ls *.c"</span>, <span style="color: #deb887;">"r"</span>);
</pre>
</div>
<p>
或者
</p>
<div class="org-src-container">
<pre class="src src-C">fp = popen(<span style="color: #deb887;">"cmd 2&gt;&amp;1"</span>, <span style="color: #deb887;">"w"</span>);
</pre>
</div>
</div>

<div id="outline-container-orge0a0f79" class="outline-4">
<h4 id="orge0a0f79">使用popen实现分页读取文件</h4>
<div class="outline-text-4" id="text-orge0a0f79">
<p>
shell命令${PAGER:-more}的意思是：如果shell变量PAGER已经定义，且其值非空，则使用其值，否则使用字符串more
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">PAGER</span>   <span style="color: #deb887;">"${PAGER:-more}"</span> <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">environment variable, or default </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];
    <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fpin</span>, *<span style="color: #4eee94;">fpout</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 2)
        err_quit(<span style="color: #deb887;">"usage: a.out &lt;pathname&gt;"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> ((fpin = fopen(argv[1], <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
        err_sys(<span style="color: #deb887;">"can't open %s"</span>, argv[1]);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fpout = popen(PAGER, <span style="color: #deb887;">"w"</span>)) == <span style="color: #ffd700;">NULL</span>)
        err_sys(<span style="color: #deb887;">"popen error"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">copy argv[1] to pager </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, fpin) != <span style="color: #ffd700;">NULL</span>) {
        <span style="color: #00bfff; font-weight: bold;">if</span> (fputs(line, fpout) == EOF)
            err_sys(<span style="color: #deb887;">"fputs error to pipe"</span>);
    }
    <span style="color: #00bfff; font-weight: bold;">if</span> (ferror(fpin))
        err_sys(<span style="color: #deb887;">"fgets error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (pclose(fpout) == -1)
        err_sys(<span style="color: #deb887;">"pclose error"</span>);

    exit(0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org019071b" class="outline-4">
<h4 id="org019071b">实现popen和pclose函数</h4>
<div class="outline-text-4" id="text-org019071b">
<p>
实现popen和pclose函数需要考虑很多细节：
</p>
<ul class="org-ul">
<li>每次调用popen时，应当记住所创建的子进程的进程ID，以及其文件描述符或FILE指针。因此选择在数组childpid中保存子进程ID，并用文件描述符作为其下标</li>
<li>当以FILE指针作为参数调用pclose时，可以调用标准I/O函数fileno以得到文件描述符，然后取得子进程ID，并用于调用waitpid</li>
<li>因为一个进程可能调用popen多次，所以在动态分配childpid数组时(第一次调用popen时)，其长度必须容纳与文件描述符数相同的进程数</li>
</ul>

<p>
根据POSIX要求子进程必须从头逐个检查childpid数组的各元素，关闭仍旧打开的任一描述符，因为fork的子进程可能继承了父进程以前popen所形成的管道
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;"> * Pointer to array allocated at run-time.</span>
<span style="color: #5f9ea0; font-style: italic;"> </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">pid_t</span> *<span style="color: #4eee94;">childpid</span> = <span style="color: #ffd700;">NULL</span>;

<span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;"> * From our open_max(), {Prog openmax}.</span>
<span style="color: #5f9ea0; font-style: italic;"> </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">maxfd</span>;

<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">popen</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">cmdstring</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">type</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">i</span>;
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">pfd</span>[2];
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fp</span>;

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">only allow "r" or "w" </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> ((type[0] != <span style="color: #deb887;">'r'</span> &amp;&amp; type[0] != <span style="color: #deb887;">'w'</span>) || type[1] != 0) {
        errno = EINVAL;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">required by POSIX </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">if</span> (childpid == <span style="color: #ffd700;">NULL</span>) {     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">first time through </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">allocate zeroed out array for child pids </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        maxfd = open_max();
        <span style="color: #00bfff; font-weight: bold;">if</span> ((childpid = calloc(maxfd, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(pid_t))) == <span style="color: #ffd700;">NULL</span>)
            <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    }

    <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(pfd) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">errno set by pipe() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">errno set by fork() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid == 0) {                          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (*type == <span style="color: #deb887;">'r'</span>) {
            close(pfd[0]);
            <span style="color: #00bfff; font-weight: bold;">if</span> (pfd[1] != STDOUT_FILENO) {
                dup2(pfd[1], STDOUT_FILENO);
                close(pfd[1]);
            }
        } <span style="color: #00bfff; font-weight: bold;">else</span> {
            close(pfd[1]);
            <span style="color: #00bfff; font-weight: bold;">if</span> (pfd[0] != STDIN_FILENO) {
                dup2(pfd[0], STDIN_FILENO);
                close(pfd[0]);
            }
        }

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">close all descriptors in childpid[] </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">for</span> (i = 0; i &lt; maxfd; i++)
            <span style="color: #00bfff; font-weight: bold;">if</span> (childpid[i] &gt; 0)
                close(i);

        execl(<span style="color: #deb887;">"/bin/sh"</span>, <span style="color: #deb887;">"sh"</span>, <span style="color: #deb887;">"-c"</span>, cmdstring, (<span style="color: #98f5ff;">char</span> *)0);
        _exit(127);
    }

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent continues... </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (*type == <span style="color: #deb887;">'r'</span>) {
        close(pfd[1]);
        <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fdopen(pfd[0], type)) == <span style="color: #ffd700;">NULL</span>)
            <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        close(pfd[0]);
        <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fdopen(pfd[1], type)) == <span style="color: #ffd700;">NULL</span>)
            <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    }

    childpid[fileno(fp)] = pid; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">remember child pid for this fd </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">return</span>(fp);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pclose</span>(<span style="color: #98f5ff;">FILE</span> *<span style="color: #4eee94;">fp</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">stat</span>;
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (childpid == <span style="color: #ffd700;">NULL</span>) {
        errno = EINVAL;
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">popen() has never been called </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    }

    fd = fileno(fp);
    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = childpid[fd]) == 0) {
        errno = EINVAL;
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">fp wasn't opened by popen() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    }

    childpid[fd] = <span style="color: #ffd700;">NULL</span>;
    <span style="color: #00bfff; font-weight: bold;">if</span> (fclose(fp) == EOF)
        <span style="color: #00bfff; font-weight: bold;">return</span>(-1);

    <span style="color: #00bfff; font-weight: bold;">while</span> (waitpid(pid, &amp;stat, 0) &lt; 0)
        <span style="color: #00bfff; font-weight: bold;">if</span> (errno != EINTR)
            <span style="color: #00bfff; font-weight: bold;">return</span>(-1); <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">error other than EINTR from waitpid() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">return</span>(stat);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">return child's termination status </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
若pclose的调用者已经为信号SIGCHLD设置了一个信号处理程序，则waitpid将返回一个EINTR。因为允许调用者捕捉此信号(或者任何其他可能中断waitpid调用的信号)，所以当waitpid被一个捕捉到的信号中断时，那就必须再次调用waitpid
</p>
</div>
</div>

<div id="outline-container-orgc7c6d07" class="outline-4">
<h4 id="orgc7c6d07">用popen变换输入</h4>
<div class="outline-text-4" id="text-orgc7c6d07">
<p>
考虑一个应用程序，它向标准输出写一个提示，然后从标准输入读1行。使用popen可以在应用程序和输入之间插入一个程序以对输入进行变换处
理。图14-7显示了进程的安排：
</p>

<div class="figure">
<p><img src="pic/filter-input.jpg" alt="filter-input.jpg" width="70%" /> 
</p>
</div>

<p>
下面是一个简单的过滤程序，它只是将输入复制到输出，在复制时将任一大写字符变换为小写字符。在写了一行之后，对标准输出进行了刷清(用fflush)：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;ctype.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">c</span>;

    <span style="color: #00bfff; font-weight: bold;">while</span> ((c = getchar()) != EOF) {
        <span style="color: #00bfff; font-weight: bold;">if</span> (isupper(c))
            c = tolower(c);
        <span style="color: #00bfff; font-weight: bold;">if</span> (putchar(c) == EOF)
            err_sys(<span style="color: #deb887;">"output error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> (c == <span style="color: #deb887;">'\n'</span>)
            fflush(stdout);
    }
    exit(0);
}
</pre>
</div>
<p>
对该过滤程序进行编译，其可执行目标代码存放在文件myuclc中。在下面程序中通过popen调用myuclc完成对输入的过滤：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];
    <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fpin</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fpin = popen(<span style="color: #deb887;">"myuclc"</span>, <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
    err_sys(<span style="color: #deb887;">"popen error"</span>);
    <span style="color: #00bfff; font-weight: bold;">for</span> ( ; ; ) {
    fputs(<span style="color: #deb887;">"prompt&gt; "</span>, stdout);
    fflush(stdout);
    <span style="color: #00bfff; font-weight: bold;">if</span> (fgets(line, MAXLINE, fpin) == <span style="color: #ffd700;">NULL</span>) <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">read from pipe </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">break</span>;
    <span style="color: #00bfff; font-weight: bold;">if</span> (fputs(line, stdout) == EOF)
        err_sys(<span style="color: #deb887;">"fputs error to pipe"</span>);
    }
    <span style="color: #00bfff; font-weight: bold;">if</span> (pclose(fpin) == -1)
    err_sys(<span style="color: #deb887;">"pclose error"</span>);
    putchar(<span style="color: #deb887;">'\n'</span>);
    exit(0);
}
</pre>
</div>
<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/popen1 
prompt&gt; HELLO WORLD
hello world
prompt&gt; ^C
</pre>
</div>
<p>
因为标准输出通常是按行进行缓存的，而提示并不包含新行符，所以在写了提示之后，需要调用fflush
</p>
</div>
</div>
</div>

<div id="outline-container-orga828d1b" class="outline-3">
<h3 id="orga828d1b">协同进程</h3>
<div class="outline-text-3" id="text-orga828d1b">
<p>
UNIX过滤程序从标准输入读取数据，对其进行适当处理后写到标准输出。几个过滤进程通常在shell管道命令中线性地连接。当同一个程序产生某个过滤程序的输入，同时又读取该过
滤程序的输出时，则该过滤程序就成为协同进程：
</p>

<p>
协同进程通常在shell的后台运行，其标准输入和标准输出通过管道连接到另一个程序。虽然要求初始化一个协同进程，并将其输入和输出连接到另一个进程的shell语法是十分奇特的，但是协同进程的工作方式在C程序中也是非常有用的
</p>

<p>
进程先创建两个管道，协同进程的标准输入和协同进程的标准输出。图14-8显示了这种安排：
</p>

<div class="figure">
<p><img src="pic/coprocess.jpg" alt="coprocess.jpg" width="90%" /> 
</p>
</div>

<ul class="org-ul">
<li>popen提供连接到另一个进程的标准输入或标准输出的一个单行管道</li>
<li>协同进程有连接到另一个进程的两个单行管道</li>
</ul>
</div>

<div id="outline-container-org039cfe0" class="outline-4">
<h4 id="org039cfe0">对两个数求和的简单过滤</h4>
<div class="outline-text-4" id="text-org039cfe0">
<p>
下面程序从标准输入读两个数，计算它们的和，然后将结果写至标准输出:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>, <span style="color: #4eee94;">int1</span>, <span style="color: #4eee94;">int2</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">while</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &gt; 0) {
        line[n] = 0;        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">null terminate </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (sscanf(line, <span style="color: #deb887;">"%d%d"</span>, &amp;int1, &amp;int2) == 2) {
            sprintf(line, <span style="color: #deb887;">"%d\n"</span>, int1 + int2);
            n = strlen(line);
            <span style="color: #00bfff; font-weight: bold;">if</span> (write(STDOUT_FILENO, line, n) != n)
                err_sys(<span style="color: #deb887;">"write error"</span>);
        } <span style="color: #00bfff; font-weight: bold;">else</span> {
            <span style="color: #00bfff; font-weight: bold;">if</span> (write(STDOUT_FILENO, <span style="color: #deb887;">"invalid args\n"</span>, 13) != 13)
                err_sys(<span style="color: #deb887;">"write error"</span>);
        }
    }
    exit(0);
}
</pre>
</div>
<p>
从其标准输入读入两个数之后调用add2协同进程，从协同进程送来的值则写到其标准输出，在程序中创建了两个管道，父、子进程各自关闭它们不需使用的端口。创建两个管道的理由是:一个用做协同进程的标准输入，另一个则用做它的标准输出。然后在调用execl之前，子进程调用dup2使管道描述符移至其标准输入和输出： 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_pipe</span>(<span style="color: #98f5ff;">int</span>);      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">our signal handler </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">n</span>, <span style="color: #4eee94;">fd1</span>[2], <span style="color: #4eee94;">fd2</span>[2];
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">if</span> (signal(SIGPIPE, sig_pipe) == SIG_ERR)
        err_sys(<span style="color: #deb887;">"signal error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (pipe(fd1) &lt; 0 || pipe(fd2) &lt; 0)
        err_sys(<span style="color: #deb887;">"pipe error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {                           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        close(fd1[0]);
        close(fd2[1]);

        <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>) {
            n = strlen(line);
            <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd1[1], line, n) != n)
                err_sys(<span style="color: #deb887;">"write error to pipe"</span>);
            <span style="color: #00bfff; font-weight: bold;">if</span> ((n = read(fd2[0], line, MAXLINE)) &lt; 0)
                err_sys(<span style="color: #deb887;">"read error from pipe"</span>);
            <span style="color: #00bfff; font-weight: bold;">if</span> (n == 0) {
                err_msg(<span style="color: #deb887;">"child closed pipe"</span>);
                <span style="color: #00bfff; font-weight: bold;">break</span>;
            }
            line[n] = 0;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">null terminate </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
            <span style="color: #00bfff; font-weight: bold;">if</span> (fputs(line, stdout) == EOF)
                err_sys(<span style="color: #deb887;">"fputs error"</span>);
        }

        <span style="color: #00bfff; font-weight: bold;">if</span> (ferror(stdin))
            err_sys(<span style="color: #deb887;">"fgets error on stdin"</span>);
        exit(0);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                                    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        close(fd1[1]);
        close(fd2[0]);
        <span style="color: #00bfff; font-weight: bold;">if</span> (fd1[0] != STDIN_FILENO) {
            <span style="color: #00bfff; font-weight: bold;">if</span> (dup2(fd1[0], STDIN_FILENO) != STDIN_FILENO)
                err_sys(<span style="color: #deb887;">"dup2 error to stdin"</span>);
            close(fd1[0]);
        }

        <span style="color: #00bfff; font-weight: bold;">if</span> (fd2[1] != STDOUT_FILENO) {
            <span style="color: #00bfff; font-weight: bold;">if</span> (dup2(fd2[1], STDOUT_FILENO) != STDOUT_FILENO)
                err_sys(<span style="color: #deb887;">"dup2 error to stdout"</span>);
            close(fd2[1]);
        }
        <span style="color: #00bfff; font-weight: bold;">if</span> (execl(<span style="color: #deb887;">"./add2"</span>, <span style="color: #deb887;">"add2"</span>, (<span style="color: #98f5ff;">char</span> *)0) &lt; 0)
            err_sys(<span style="color: #deb887;">"execl error"</span>);
    }
    exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_pipe</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>)
{
    printf(<span style="color: #deb887;">"SIGPIPE caught\n"</span>);
    exit(1);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./pipe4  
1
invalid args
2 3
5
4 5
SIGPIPE caught
</pre>
</div>
<p>
当pipe4进程正等待输入时杀死add2协同进程，然后输入两个数，进行写操作时，由于该管道无读进程，于是调用信号处理函数sig_pipe
</p>
</div>

<div id="outline-container-orge58b9da" class="outline-5">
<h5 id="orge58b9da">使用标准IO改写add2</h5>
<div class="outline-text-5" id="text-orge58b9da">
<p>
在协同进程add2中，使用了UNIX的I/O:read和write。现在使用标准I/O改写该协同进程：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">int1</span>, <span style="color: #4eee94;">int2</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>) {
    <span style="color: #00bfff; font-weight: bold;">if</span> (sscanf(line, <span style="color: #deb887;">"%d%d"</span>, &amp;int1, &amp;int2) == 2) {
        <span style="color: #00bfff; font-weight: bold;">if</span> (printf(<span style="color: #deb887;">"%d\n"</span>, int1 + int2) == EOF)
        err_sys(<span style="color: #deb887;">"printf error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {
        <span style="color: #00bfff; font-weight: bold;">if</span> (printf(<span style="color: #deb887;">"invalid args\n"</span>) == EOF)
        err_sys(<span style="color: #deb887;">"printf error"</span>);
    }
    }
    exit(0);
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./spipe4 
1 2 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#27515;&#38145;</span>
</pre>
</div>
<p>
若pipe4调用此新的协同进程，则它不再工作。问题出在系统默认的标准I/O缓存机制上：当add2stdio被调用时，对标准输入的第一个fgets引起标准I/O库分配一个缓存，并选择缓
存的类型。因为标准输入是个管道，所以isatty为假，于是标准I/O库由系统默认是全缓存的。对标准输出也有同样的处理。当add2stdio从其标准输入读取而发生堵塞时，pipe4从管道读时也
发生堵塞，于是产生了死锁
</p>

<p>
对将要执行的这样一个协同进程可以设置buf，可以在add2stdio程序的while循环之前加上如下代码:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">if</span> (setvbuf(stdin, <span style="color: #ffd700;">NULL</span>, _IOLBF, 0) != 0)
    err_sys(<span style="color: #deb887;">"setvbuf error"</span>);

<span style="color: #00bfff; font-weight: bold;">if</span> (setvbuf(stdout, <span style="color: #ffd700;">NULL</span>, _IOLBF, 0)!= 0)
    err_sys(<span style="color: #deb887;">"setvbuf error"</span>);
</pre>
</div>
<p>
这使得当有一行可用时fgets即返回，并使得当输出一新行符时，printf即执行fflush操作
</p>

<p>
这种设置往往要求对协同进程进程代码修改，但在使用一个第三方的协同进程时不一定可以满足，更一般解决方法是使被调用的协同进程认为它的标准输入和输出被连接到一个伪终端。这使得协同进程中的标准I/O例程对这两个I/O流进行行缓存
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgff364e4" class="outline-3">
<h3 id="orgff364e4">FIFO</h3>
<div class="outline-text-3" id="text-orgff364e4">
<p>
FIFO被称为命名管道。管道只能由相关进程使用，它们共同的祖先进程创建了管道，但是通过FIFO不相关的进程也能交换数据
</p>
</div>

<div id="outline-container-org6175dbf" class="outline-4">
<h4 id="org6175dbf">mkfifo函数</h4>
<div class="outline-text-4" id="text-org6175dbf">
<p>
曾经提及FIFO是一种文件类型，而stat结构的成员st_mode的编码指明文件是否是FIFO类型，并且可以用S_ISFIFO宏对此进行测试
</p>

<p>
mkfifo函数：创建命名管道，类似于创建文件，事实上FIFO的路径名存在于文件系统中
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/stat.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#21019;&#24314;&#21629;&#21517;&#31649;&#36947;</span>

<span style="color: #ffebcd;">   pathname&#65306;&#31649;&#36947;&#25991;&#20214;&#21517;</span>
<span style="color: #ffebcd;">   mode&#65306;&#21487;&#36873;&#25321;&#21442;&#25968;&#65292;&#24403;oflag&#21253;&#21547;O_CREAT&#30340;&#26102;&#20505;&#65292;&#34920;&#31034;&#21019;&#24314;&#25991;&#20214;&#30340;&#26435;&#38480;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">mkfifo</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">pathname</span>, <span style="color: #98f5ff;">mode_t</span> <span style="color: #4eee94;">mode</span>);
</pre>
</div>
<ul class="org-ul">
<li>mode参数：规格说明与open函数中的mode相同</li>
<li>FIFO文件的用户和组的所有权与第四章所描述的相同</li>
</ul>
</div>
</div>

<div id="outline-container-org664a9ea" class="outline-4">
<h4 id="org664a9ea">FIFO文件</h4>
<div class="outline-text-4" id="text-org664a9ea">
<p>
一旦已经用mkfifo创建了一个FIFO，就可用open打开它。确实，一般的文件I/O函数close、read、write、unlink等都可用于FIFO
</p>

<p>
当打开一个FIFO时，非阻塞标志(O_NONBLOCK)产生下列影响:
</p>
<ul class="org-ul">
<li>在一般情况中(没有说明O_NONBLOCK)，只读打开要阻塞到某个其他进程为写打开此FIFO。类似为写而打开一个FIFO要阻塞到某个其他进程为读而打开它</li>
<li>如果指定了O_NONBLOCK，则只读打开立即返回。但是如果没有进程已经为读而打开一个FIFO，那么只写打开将出错返回，其errno是ENXIO。</li>
</ul>

<p>
类似于管道，如果写一个尚无进程为读而打开的FIFO，则产生信号SIGPIPE。若某个FIFO的最后一个写进程关闭了该FIFO，则将为该FIFO的读进程产生一个文件结束标志
</p>

<p>
一个给定的FIFO有多个写进程是常见的。这就意味着如果不希望多个进程所写的数据互相穿插，则需考虑原子写操作。正如对于管道一样，常数PIPE_BUF说明了可被原子写到FIFO的最大数据量
</p>
</div>
</div>

<div id="outline-container-orgcbc1abf" class="outline-4">
<h4 id="orgcbc1abf">FIFO用途</h4>
<div class="outline-text-4" id="text-orgcbc1abf">
<ul class="org-ul">
<li>shell命令使用以便将数据从一条管道线传送到另一条，为此无需创建中间临时文件</li>
<li>用于客户机-服务器应用程序中，以在客户机和服务器之间传递数据</li>
</ul>
</div>


<div id="outline-container-orgc6e326e" class="outline-5">
<h5 id="orgc6e326e">复制输出流</h5>
<div class="outline-text-5" id="text-orgc6e326e">
<p>
FIFO可被用于复制串行管道命令之间的输出流，于是也就不需要写数据到中间磁盘文件中，类似于使用管道以避免中间磁盘文件。但是管道只能用于进程间的线性连接，而FIFO因为具有名字，所以它可用于非线性连接
</p>

<p>
考虑这样一个操作过程，它需要对一个经过过滤的输入流进行两次处理。图14-9表示了这种安排：
</p>

<div class="figure">
<p><img src="pic/fifo-two-handler.jpg" alt="fifo-two-handler.jpg" width="60%" /> 
</p>
</div>

<p>
使用FIFO以及UNIX程序tee(1)，就可以实现这样的过程而无需使用临时文件。tee程序将其标准输入同时复制到其标准输出以及其命令行中包含的命名文件中：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mkfifo fifo1 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#31649;&#36947;&#25991;&#20214;fifo1</span>
$ prog3 &lt; fifo1 &amp; <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21518;&#21488;&#21551;&#21160;prog3&#31561;&#24453;fifo1&#30340;&#36755;&#20986;</span>
$ prog1 &lt; infile | tee fifo1 | prog2 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#21551;&#21160;progl, &#29992;tee&#23558;&#20854;&#36755;&#20986;&#21457;&#36865;&#21040;fifo1&#21644;prog2</span>
</pre>
</div>
<p>
创建FIFO，然后在后台起动prog3，它从FIFO读数据。然后起动progl，用tee将其输出发送到FIFO和prog2。图14-10显示了有关安排：
</p>

<div class="figure">
<p><img src="pic/fifo-tee.jpg" alt="fifo-tee.jpg" width="60%" />  
</p>
</div>
</div>
</div>

<div id="outline-container-orgad235af" class="outline-5">
<h5 id="orgad235af">简单客户-服务器通信</h5>
<div class="outline-text-5" id="text-orgad235af">
<p>
FIFO的另一个应用是在客户机和服务器之间传送数据。如果有一个服务器，它与很多客户机有关，每个客户机都可将其请求写到一个该服务器创建的众所周知的FIFO中(所有需与服务器联系的客户机都知道该FIFO的路径名)。因为对于该FIFO有多个写进程，客户机发送给服务器的请求其长度要小于PIPE_BUF字节。这样就能避免客户机各次写之间的穿插。图14-11显示了这种安排：
</p>

<div class="figure">
<p><img src="pic/fifo-client-send-request.jpg" alt="fifo-client-send-request.jpg" width="60%" />  
</p>
</div>

<p>
在这种类型的客户机-服务器通信中使用FIFO的问题是：服务器如何将回答送回各个客户机。不能使用单个FIFO，因为服务器会发出对各个客户机请求的响应，而请求者却不可能知
道什么时候去读才能恰恰得到对它的响应。一种解决方法是每个客户机都在其请求中发送其进程ID。然后服务器为每个客户机创建一个FIFO，所使用的路径名是以客户机的进程ID为基础
的。例如，服务器可以用名字/tmp/serv1.XXXXX创建FIFO，其中XXXXX被替换成客户机的进程ID。图14-12显示了这种安排：
</p>

<div class="figure">
<p><img src="pic/fifo-client-server.jpg" alt="fifo-client-server.jpg" width="60%" />  
</p>
</div>

<p>
这种安排可以工作，但也有一些不足之处：
</p>
<ul class="org-ul">
<li>是服务器不能判断一个客户机是否崩溃终止，这就使得客户机专用的FIFO会遗留在文件系统中</li>
<li>服务器必须捕捉SIGPIPE信号，因为客户机在发送一个请求后没有读取响应就可能终止，于是留下一个有写进程(服务器)而无读进程的客户机专用FIFO</li>
</ul>

<p>
按照图14-12中的安排，如果服务器以只读方式打开众所周知的FIFO(因为它只需读该FIFO)，则每次客户机数从1变成0，服务器就将在FIFO中读到一个文件结束标记。为使服务器免于处理这种情况，一种常见的技巧是使服务器以读-写方式打开该FIFO
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6160712" class="outline-2">
<h2 id="org6160712">系统V IPC</h2>
<div class="outline-text-2" id="text-org6160712">
<ul class="org-ul">
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
</ul>
</div>


<div id="outline-container-orga1f4631" class="outline-3">
<h3 id="orga1f4631">相似特征</h3>
<div class="outline-text-3" id="text-orga1f4631">
</div>
<div id="outline-container-org4b9846e" class="outline-4">
<h4 id="org4b9846e">标识符和关键字</h4>
<div class="outline-text-4" id="text-org4b9846e">
<p>
每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符加以引用。例如，为了对一个消息队列发送或取消息，只需知道其队列标识符。与文件描述符不同，IPC标识符不是小的整数。当一个IPC结构被创建，以后又被删除时，与这种结构相关的标识符连续加1，直至达到一个整型数的最大正值，然后又回转到0。(即使在IPC结构被删除后也记住该值，每次使用此结构时则增1，该值被称为“槽使用顺序号”。它在ipc_perm结构中)
</p>

<p>
无论何时创建IPC结构，都应指定一个关键字，关键字的数据类型由系统规定为key_t，通常在头文件&lt;sys/types.h&gt;中被规定为长整型。关键字由内核变换成标识符
</p>
</div>

<div id="outline-container-org4c45e83" class="outline-5">
<h5 id="org4c45e83">客户机和服务器使用同一IPC结构</h5>
<div class="outline-text-5" id="text-org4c45e83">
<p>
有多种方法使客户机和服务器在同一IPC结构上会合：
</p>
<ul class="org-ul">
<li>服务器可以指定关键字IPC_PRIVATE创建一个新IPC结构，将返回的标识符存放在某处(例如一个文件)以便客户机取用。关键字IPC_PRIVATE保证服务器创建一个新IPC结构。缺点是服务器要将整型标识符写到文件中，然后客户机在此后又要读文件取得此标识符</li>
</ul>

<p>
IPC_PRIVATE关键字也可用于父、子关系进程。父进程指定IPC_PRIVATE创建一个新IPC结构，所返回的标识符在fork后可由子进程使用。子进程可将此标识符作为exec函数的一个参数传给一个新程序
</p>

<ul class="org-ul">
<li>在一个公用头文件中定义一个客户机和服务器都认可的关键字。然后服务器指定此关键字创建一个新的IPC结构。问题是该关键字可能已与一个IPC结构相结合，在此情况下，get函数(msgget、semget或shmget)出错返回。服务器必须处理这一错误，删除已存在的IPC结构，然后试着再创建它</li>

<li>客户机和服务器认同一个路径名和课题ID(课题ID是0~255之间的字符值)，然后调用函数ftok将这两个值变换为一个关键字。然后在第二种方法中使用此关键字。ftok提供的唯一服务就是由一个路径名和课题ID产生一个关键字。因为一般来说，客户机和服务器至少共享一个头文件，所以一个比较简单的方法是避免使用ftok，而只是在该头文件中存放一个大家都知道的关键字。这样做还避免了使用另一个函数</li>
</ul>
</div>
</div>

<div id="outline-container-orgf5a8e2b" class="outline-5">
<h5 id="orgf5a8e2b">创建IPC结构</h5>
<div class="outline-text-5" id="text-orgf5a8e2b">
<p>
三个get函数(msgget、semget和shmget)都有两个类似的参数key和一个整型的flag。如若满足下列条件，则创建一个新的IPC结构(通常由服务器创建)：
</p>
<ol class="org-ol">
<li>key是IPC_PRIVATE</li>
<li>key当前未与特定类型的IPC结构相结合，flag中指定了IPC_CREAT位。为访问现存的队列(通常由客户机进行)，key必须等于创建该队列时所指定的关键字，并且不应指定IPC_CREAT</li>
</ol>

<p>
注意，为了访问一个现存队列，决不能指定IPC_PRIVATE作为关键字。因为这是一个特殊的键值，它总是用于创建一个新队列。为了访问一个用IPC_PRIVATE关键字创建的现存队列，一定要知道与该队列相结合的标识符，然后在其他IPC调用中(例如msgsnd、msgrcv)使用该标识符
</p>

<p>
如果希望创建一个新的IPC结构，保证不是引用具有同一标识符的一个现行IPC结构，那么必须在flag中同时指定IPC_CREAT和IPC_EXCL位。这样做了以后，如果IPC结构已经存在就会造成出错，返回EEXIST(这与指定了O_CREAT和O_EXCL标志的open相类似)
</p>
</div>
</div>
</div>

<div id="outline-container-org64f1228" class="outline-4">
<h4 id="org64f1228">权限结构</h4>
<div class="outline-text-4" id="text-org64f1228">
<p>
系统VIPC为每一个IPC结构设置了一个ipc_perm结构。该结构规定了许可权和所有者：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Data structure used to pass permission information to IPC operations.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span>
{
    <span style="color: #98f5ff;">__key_t</span> <span style="color: #4eee94;">__key</span>;                      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Key.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">__uid_t</span> <span style="color: #4eee94;">uid</span>;                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Owner's user ID.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">__gid_t</span> <span style="color: #4eee94;">gid</span>;                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Owner's group ID.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">__uid_t</span> <span style="color: #4eee94;">cuid</span>;                       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Creator's user ID.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">__gid_t</span> <span style="color: #4eee94;">cgid</span>;                       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Creator's group ID.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mode</span>;            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Read/write permission.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__pad1</span>;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__seq</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Sequence number.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__pad2</span>;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__unused1</span>;
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">__unused2</span>;
};
</pre>
</div>
<p>
在创建IPC结构时，除seq以外的所有字段都赋初值。以后，可以调用msgctl、semctl或shmctl修改uid、gid和mode字段。为了改变这些值，调用进程必须是IPC结构的创建者或超级用户。更改这些字段类似于对文件调用chown和chmod
</p>
</div>

<div id="outline-container-orgd8b4dc6" class="outline-5">
<h5 id="orgd8b4dc6">mode字段</h5>
<div class="outline-text-5" id="text-orgd8b4dc6">
<p>
mode字段的值类似于文件权限的，但是对于任何IPC结构都不存在执行许可权。另外消息队列和共享存储使用术语“读”和“写”，而信号量则用术语“读”和“更改”。表14-2中对每种IPC说明了6种许可权：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 系统V IPC权限</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">权限</td>
<td class="org-left">消息队列</td>
<td class="org-left">信号量</td>
<td class="org-left">共享内存</td>
</tr>

<tr>
<td class="org-left">用户读</td>
<td class="org-left">MSG_R</td>
<td class="org-left">SEM_R</td>
<td class="org-left">SHM_R</td>
</tr>

<tr>
<td class="org-left">用户写(更改)</td>
<td class="org-left">MSG_W</td>
<td class="org-left">SEM_A</td>
<td class="org-left">SHM_W</td>
</tr>

<tr>
<td class="org-left">组读</td>
<td class="org-left">MSG_R &gt;&gt; 3</td>
<td class="org-left">SEM_R &gt;&gt; 3</td>
<td class="org-left">SHM_R &gt;&gt; 3</td>
</tr>

<tr>
<td class="org-left">组写(更改)</td>
<td class="org-left">MSG_W &gt;&gt; 3</td>
<td class="org-left">SEM_A &gt;&gt; 3</td>
<td class="org-left">SHM_W &gt;&gt; 3</td>
</tr>

<tr>
<td class="org-left">其他读</td>
<td class="org-left">MSG_R &gt;&gt; 6</td>
<td class="org-left">SEM_R &gt;&gt; 6</td>
<td class="org-left">SHM_R &gt;&gt; 6</td>
</tr>

<tr>
<td class="org-left">其他写(更改)</td>
<td class="org-left">MSG_W &gt;&gt; 6</td>
<td class="org-left">SEM_A &gt;&gt; 6</td>
<td class="org-left">SHM_R &gt;&gt; 6</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgd53a645" class="outline-4">
<h4 id="orgd53a645">资源限制</h4>
<div class="outline-text-4" id="text-orgd53a645">
<p>
三种形式的系统VIPC都有可能会遇到的资源限制。这些限制的大多数可以通过重新配置而加以更改。当描述每种IPC时，都会指出它的限制
</p>
</div>
</div>

<div id="outline-container-orgb648904" class="outline-4">
<h4 id="orgb648904">优点和缺点</h4>
<div class="outline-text-4" id="text-orgb648904">
</div>
<div id="outline-container-org9f327da" class="outline-5">
<h5 id="org9f327da">系统V IPC的缺点</h5>
<div class="outline-text-5" id="text-org9f327da">
<ul class="org-ul">
<li>IPC结构是在系统范围内起作用的，没有访问计数。如果创建了一个消息队列，在该队列中放入了几则消息，然后终止，但是该消息队列及其内容并不被删除。它们余留在系统中直至：
<ul class="org-ul">
<li>由某个进程调用msgrcv或msgctl读消息或删除消息队列</li>
<li>某个进程执行ipcrm(1)命令删除消息队列</li>
<li>由正在再起动的系统删除消息队列</li>
</ul></li>
</ul>
<p>
与管道pipe相比，那么当最后一个访问管道的进程终止时，管道就被完全地删除了。对于FIFO而言虽然当最后一个引用FIFO的进程终止时其名字仍保留在系统中，直至显式地删除它，但是留在FIFO中的数据却在此时全部删除
</p>

<ul class="org-ul">
<li>这些IPC结构并不按名字为文件系统所知。我们不能用以前的函数来存取它们或修改它们的特性。为了支持它们不得不增加了十多个全新的系统调用(msgget、semop、shmat等)。我们不能用ls命令见到它们，不能用rm命令删除它们，不能用chmod命令更改它们的存取权。于是，也不得不增加了全新的命令ipcs和ipcrm。</li>
</ul>

<p>
因为这些IPC不使用文件描述符，所以不能对它们使用多路转接I/O函数：select和poll。这就使得一次使用多个IPC结构，以及用文件或设备I/O来使用IPC结构很难做到。例如，没有某种形式的忙-等待循环，就不能使一个服务器等待一个消息放在两个消息队列的任一一个中
</p>
</div>
</div>

<div id="outline-container-org7ee003e" class="outline-5">
<h5 id="org7ee003e">消息队列的优点</h5>
<div class="outline-text-5" id="text-org7ee003e">
<ul class="org-ul">
<li>避免多次open, write, close调用</li>
<li>可靠的</li>
<li>流是受到控制的</li>
<li>面向记录</li>
<li>支持非先进先出</li>
</ul>
</div>
</div>

<div id="outline-container-org2a5aac2" class="outline-5">
<h5 id="org2a5aac2">总结</h5>
<div class="outline-text-5" id="text-org2a5aac2">
<p>
下表对不同形式的IPC的某些特征进行了比较：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 不同形式IPC之间特征的比较</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">类型</td>
<td class="org-left">无连接</td>
<td class="org-left">可靠</td>
<td class="org-left">流控制</td>
<td class="org-left">记录</td>
<td class="org-left">消息类型或优先权</td>
</tr>

<tr>
<td class="org-left">消息队列</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">流</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
</tr>

<tr>
<td class="org-left">UNIX流套接字</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">UNIX数据套接字</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
</tr>

<tr>
<td class="org-left">FIFO</td>
<td class="org-left">否</td>
<td class="org-left">是</td>
<td class="org-left">是</td>
<td class="org-left">否</td>
<td class="org-left">否</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>“无连接”指的是无需先调用某种形式的open，就能发送消息的能力。正如前述因为需要有某种技术以获得队列标识符，所以并不认为消息队列具有无连接特性</li>
<li>因为所有这些形式的IPC都限制用在单主机上，所以它们都是可靠的。当消息通过网络传送时，丢失消息的可能性就要加以考虑</li>
<li>流控制的意思是：如果系统资源短缺(缓存)或者如果接收进程不能再接收更多消息，则发送进程就要睡眠。当流控制条件消失时，发送进程应自动地被唤醒。</li>
</ul>

<p>
表中没有表示的一个特征是：IPC设施能否自动地为每个客户机自动地创建一个到服务器的唯一连接。实际上流以及UNIX流套接口可以提供这种能力
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org1951866" class="outline-3">
<h3 id="org1951866">消息队列</h3>
<div class="outline-text-3" id="text-org1951866">
<p>
消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。我们将称消息队列为"队列"，其标识符为“队列ID”
</p>

<ul class="org-ul">
<li>msgget函数：创建一个新队列或打开一个现存的队列</li>
<li>msgsnd函数：将新消息添加到队列尾端。每个消息包含一个正长整型类型字段，一个非负长度以及实际数据字节</li>
<li>msgrcv函数：从队列中取消息。并不一定要以先进先出次序取消息，也可以按消息的类型字段取消息</li>
</ul>
</div>


<div id="outline-container-org8ff4a3f" class="outline-4">
<h4 id="org8ff4a3f">msqid_ds结构</h4>
<div class="outline-text-4" id="text-org8ff4a3f">
<p>
每个队列都有一个msqid_ds结构与其相关。此结构规定了队列的当前状态：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">Structure of record for one message inside the kernel.</span>
<span style="color: #5f9ea0; font-style: italic;">   The type `struct msg' is opaque.  </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msqid_ds</span>
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span> <span style="color: #4eee94;">msg_perm</span>;   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">structure describing operation permission </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msg</span> *<span style="color: #4eee94;">msg_first</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ptr to first message on queue </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msg</span> *<span style="color: #4eee94;">msg_last</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ptr to last message on queue </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">msg_stime</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last msgsnd command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">msg_rtime</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last msgrcv command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">msg_ctime</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last change </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msg_cbytes</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">current number of bytes on queue </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">msgqnum_t</span> <span style="color: #4eee94;">msg_qnum</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">number of messages currently on queue </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">msglen_t</span> <span style="color: #4eee94;">msg_qbytes</span>;          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">max number of bytes allowed on queue </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">msg_lspid</span>;            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of last msgsnd() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">msg_lrpid</span>;            <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of last msgrcv() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>
<p>
两个指针msg-first和msg-last分别指向相应消息在内核中的存放位置，所以它们对用户进程而言是无价值的。结构的其他成员是自定义的
</p>
</div>
</div>

<div id="outline-container-org765ba2d" class="outline-4">
<h4 id="org765ba2d">资源限制</h4>
<div class="outline-text-4" id="text-org765ba2d">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> 影响消息队列的系统限制</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名字</td>
<td class="org-left">说明</td>
<td class="org-right">典型值</td>
</tr>

<tr>
<td class="org-left">MSGMAX</td>
<td class="org-left">可发送的最长消息的字节长度</td>
<td class="org-right">2048</td>
</tr>

<tr>
<td class="org-left">MSGMNB</td>
<td class="org-left">特定队列的最大字节长度(亦即队列中所有消息之和)</td>
<td class="org-right">4096</td>
</tr>

<tr>
<td class="org-left">MSGMNI</td>
<td class="org-left">系统中最大消息队列数</td>
<td class="org-right">50</td>
</tr>

<tr>
<td class="org-left">MSGTOL</td>
<td class="org-left">系统中最大消息数</td>
<td class="org-right">50</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org15e4585" class="outline-4">
<h4 id="org15e4585">msgget函数</h4>
<div class="outline-text-4" id="text-org15e4585">
<ul class="org-ul">
<li><p>
msgget函数：打开一个现存队列或创建一个新队列
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26032;&#24314;&#25110;&#25171;&#24320;&#19968;&#20010;&#28040;&#24687;&#38431;&#21015;</span>

<span style="color: #ffebcd;">   key&#65306;&#28040;&#24687;&#38431;&#21015;&#20851;&#38190;&#23383;&#65292;&#20869;&#26680;&#26681;&#25454;&#35268;&#21017;&#36716;&#25442;&#20026;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   flag&#65306;&#28040;&#24687;&#38431;&#21015;&#26435;&#38480;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#28040;&#24687;&#38431;&#21015;ID&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgget</span>(<span style="color: #98f5ff;">key_t</span> <span style="color: #4eee94;">key</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
当创建一个新队列时，初始化msqid-ds结构的下列成员:
</p>
<ul class="org-ul">
<li>ipc-perm结构按上节中所述进行初始化。该结构中mode按flag中的相应许可权位设置</li>
<li>msg_qnum，msg_lspid、msg_lrpid、msg_stime和msg_rtime都设置为0</li>
<li>msg_ctime设置为当前时间</li>
<li>msg_qbytes设置为系统限制值</li>
</ul>
</div>
</div>

<div id="outline-container-orgd4b99ee" class="outline-4">
<h4 id="orgd4b99ee">msgctl函数</h4>
<div class="outline-text-4" id="text-orgd4b99ee">
<ul class="org-ul">
<li><p>
msgctl函数：对队列执行多种操作，类似于ioctl函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#31649;&#29702;&#19968;&#20010;&#28040;&#24687;&#38431;&#21015;</span>

<span style="color: #ffebcd;">   msgid&#65306;&#28040;&#24687;&#38431;&#21015;ID</span>
<span style="color: #ffebcd;">   cmd&#65306;&#31649;&#29702;&#21629;&#20196;</span>
<span style="color: #ffebcd;">   buf&#65306;&#28040;&#24687;&#38431;&#21015;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgctl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msqid</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">mdqid_ds</span> *<span style="color: #4eee94;">buf</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-orgbb9d516" class="outline-5">
<h5 id="orgbb9d516">cmd参数</h5>
<div class="outline-text-5" id="text-orgbb9d516">
<p>
cmd参数指定对于由msqid规定的队列要执行的命令：
</p>
<ul class="org-ul">
<li>IPC_STAT：取此队列的msqid_ds结构，并将其存放在buf指向的结构中</li>

<li>IPC_SET：由buf指向的结构中的值，设置与此队列相关的结构中的下列四个字段: 
<ol class="org-ol">
<li>msg_perm.uid</li>
<li>msg_perm.gid</li>
<li>msg_perm.mode</li>
<li>msg_qbytes</li>
</ol></li>
</ul>

<p>
此命令只能由下列两种进程执行: 其有效用户ID等于msg_perm.cuid或msg_perm.uid或具有超级用户特权的进程。只有超级用户才能增加msg_qbytes的值 
</p>

<ul class="org-ul">
<li>IPC_RMID：从系统中删除该消息队列以及仍在该队列上的所有数据。这种删除立即生效。仍在使用这一消息队列的其他进程在它们下一次试图对此队列进行操作时，将出错返回EIDRM</li>
</ul>

<p>
此命令只能由下列两种进程执行：其有效用户ID等于msg_perm.cuid或msg_perm.uid或具有超级用户特权的进程
</p>
</div>
</div>
</div>


<div id="outline-container-org495b096" class="outline-4">
<h4 id="org495b096">msgsnd函数</h4>
<div class="outline-text-4" id="text-org495b096">
<ul class="org-ul">
<li><p>
msgsnd函数：将数据放到消息队列上
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#24448;&#38431;&#21015;&#26411;&#23614;&#28155;&#21152;&#19968;&#20010;&#28040;&#24687;</span>

<span style="color: #ffebcd;">   msqid&#65306;&#28040;&#24687;&#38431;&#21015;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   ptr&#65306;&#28040;&#24687;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   nbytes&#65306;&#23454;&#38469;&#25968;&#25454;&#23383;&#33410;</span>
<span style="color: #ffebcd;">   flag&#65306;&#35835;&#21462;&#26041;&#24335;&#26631;&#24535;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgsnd</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msqid</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nbytes</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org0d4d45c" class="outline-5">
<h5 id="org0d4d45c">ptr指针</h5>
<div class="outline-text-5" id="text-org0d4d45c">
<p>
ptr指向的消息结构中包含了正整型消息类型，在其后立即跟随了消息数据(若nbytes是0，则无消息数据)。假设发送的最长消息是512字节，则可定义下列结构:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">mymesg</span>
{
    <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">mtype</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">positive message type </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">mtext</span>[512]; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">message data of length nbytes </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>
<p>
而ptr就是一个指向mymesg结构的指针。接收者可以使用消息类型以非先进先出的次序取消息
</p>
</div>
</div>

<div id="outline-container-org201d492" class="outline-5">
<h5 id="org201d492">flag标记</h5>
<div class="outline-text-5" id="text-org201d492">
<ul class="org-ul">
<li>flag的值可以指定为IPC_NOWAIT：这类似于文件I/O的非阻塞I/O标志。若消息队列已满(或者是队列中的消息总数等于系统限制值，或队列中的字节总数等于系统限制值)，则指定IPC_NOWAIT使得msgsnd立即出错返回EAGAIN</li>

<li>如果没有指定IPC_NOWAIT，则进程阻塞直到：
<ol class="org-ol">
<li>有空间可以容纳要发送的消息</li>
<li>从系统中删除了此队列，返回EIDRM(“标志符被删除”)报错</li>
<li>捕捉到一个信号，并从信号处理程序返回。返回EINTR报错</li>
</ol></li>
</ul>

<p>
注意：对消息队列删除的处理不是很完善。因为对每个消息队列并没有设置一个引用计数器(对打开文件则有这种计数器)，所以删除一个队列使得仍在使用这一队列的进程在下次对队列进行操作时出错返回。信号量机构也以同样方式处理其删除。而删除一个文件则要等到使用该文件的最后一个进程关闭了它，才能删除文件的内容
</p>
</div>
</div>
</div>

<div id="outline-container-org5fc16e2" class="outline-4">
<h4 id="org5fc16e2">msgrcv函数</h4>
<div class="outline-text-4" id="text-org5fc16e2">
<ul class="org-ul">
<li><p>
msgrcv函数：从队列中取消息  
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;&#38431;&#21015;&#20013;&#21462;&#36208;&#19968;&#20010;&#28040;&#24687;&#65292;&#36825;&#24847;&#21619;&#30528;&#28040;&#24687;&#20250;&#34987;&#31227;&#20986;&#38142;&#34920;</span>

<span style="color: #ffebcd;">   msqid&#65306;&#28040;&#24687;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   ptr&#65306;&#28040;&#24687;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   nbytes&#65306;&#28040;&#24687;&#23454;&#38469;&#23383;&#33410;&#38271;&#24230;</span>
<span style="color: #ffebcd;">   type&#65306;&#28040;&#24687;&#31867;&#22411;</span>
<span style="color: #ffebcd;">   flag&#65306;&#21462;&#36208;&#26631;&#24535;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#28040;&#24687;&#25968;&#25454;&#37096;&#20998;&#30340;&#38271;&#24230;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">msgrcv</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msqid</span>, <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nbytes</span>, <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">type</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
如同msgsnd中一样：
</p>
<ul class="org-ul">
<li>ptr参数指向一个长整型数(返回的消息类型存放在其中)，跟随其后的是存放实际消息数据的缓存</li>
<li>nbytes说明数据缓存的长度。若返回的消息大于nbytes:
<ul class="org-ul">
<li>在flag中设置了MSG_NOERROR，则该消息被截短(在这种情况下，不通知我们消息截短了:-()</li>
<li>如果没有设置这一标志，而消息又太长，则出错返回E2BIG(消息仍留在队列中)</li>
</ul></li>
<li>flag值指定IPC_NOWAIT，使操作不阻塞。这使得如果没有所指定类型的消息，则msgrcv出错返回ENOMSG</li>
<li>如果flag没有指定IPC_NOWAIT，则进程阻塞直至：
<ul class="org-ul">
<li>有了指定类型的消息</li>
<li>从系统中删除了此队列(出错返回EIDRM)</li>
<li>捕捉到一个信号并从信号处理程序返回(出错返回EINTR)。</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgfb82d0b" class="outline-5">
<h5 id="orgfb82d0b">type参数</h5>
<div class="outline-text-5" id="text-orgfb82d0b">
<p>
参数type可以指定想要哪一种消息：
</p>
<ul class="org-ul">
<li>type == 0： 返回队列中的第一个消息</li>
<li>type &gt; 0：返回队列中消息类型为type的第一个消息</li>
<li>type &lt; 0：返回队列中消息类型值小于或等于type绝对值，而且在这种消息中，其类型值又是最小的消息</li>
</ul>

<p>
非零的type用于以非先进先出次序读消息。例如，若应用程序对消息赋优先权，那么type就可以是优先权值。如果一个消息队列由多个客户机和一个服务器使用，那么type字段可以用来包
含客户机进程ID。 
</p>
</div>
</div>
</div>
<div id="outline-container-org95f98e7" class="outline-4">
<h4 id="org95f98e7">实例</h4>
<div class="outline-text-4" id="text-org95f98e7">
<p>
向一个消息队列写入消息，读取出对应类型的消息
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/msg.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28040;&#24687;&#32467;&#26500;</span>
<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">message</span>{
    <span style="color: #98f5ff;">long</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">mtype</span>;
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">mtext</span>[512];
};

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#28040;&#24687;&#38431;&#21015;</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">msgid</span> = msgget(IPC_PRIVATE,0666);
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#28040;&#24687;&#32467;&#26500;</span>
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">message</span> <span style="color: #4eee94;">snd</span>;
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28040;&#24687;&#31867;&#22411;</span>
    snd.mtype = 911;
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28040;&#24687;&#20869;&#23481;</span>
    strcpy(snd.mtext,<span style="color: #deb887;">"help"</span>);
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21457;&#36865;&#28040;&#24687;&#21040;&#38431;&#21015;</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(msgsnd(msgid,&amp;snd,5,0) == -1){
        printf(<span style="color: #deb887;">"msgsnd %m\n"</span>);
        <span style="color: #00bfff; font-weight: bold;">return</span> -1;
    }

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#35835;&#21462;&#28040;&#24687;&#38431;&#21015;&#20449;&#24687;</span>
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">msqid_ds</span> <span style="color: #4eee94;">ds</span>;
    <span style="color: #00bfff; font-weight: bold;">if</span>(msgctl(msgid, IPC_STAT, &amp;ds) == -1){
        printf(<span style="color: #deb887;">"msgctl IPC_STAT %m\n"</span>);
        <span style="color: #00bfff; font-weight: bold;">return</span> -1;
    }
    printf(<span style="color: #deb887;">"current bytes:%d ,current number:%d ,max bytes:%d \n"</span>,
           ds.msg_cbytes, ds.msg_qnum, ds.msg_qbytes);

    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">message</span> <span style="color: #4eee94;">rcv</span>;
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#38750;&#38459;&#22622;&#35835;&#21462;&#28040;&#24687;&#31867;&#22411;&#20026;910&#30340;&#28040;&#24687;&#65292;&#20986;&#38169;&#36820;&#22238;</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(msgrcv(msgid, &amp;rcv, 512, 910, IPC_NOWAIT) == -1){
        printf(<span style="color: #deb887;">"msgrcv1 %m\n"</span>);
    }
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#38459;&#22622;&#35835;&#21462;&#28040;&#24687;&#31867;&#22411;&#20026;911&#30340;&#28040;&#24687;</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(msgrcv(msgid, &amp;rcv, 521, 911, 0) == -1){
        printf(<span style="color: #deb887;">"msgrcv2 %m\n"</span>);
        <span style="color: #00bfff; font-weight: bold;">return</span> -1;
    }
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#25171;&#21360;&#35835;&#21462;&#30340;&#28040;&#24687;</span>
    printf(<span style="color: #deb887;">"%s\n"</span>,rcv.mtext);
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#38500;&#28040;&#24687;&#38431;&#21015;</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>(msgctl(msgid,IPC_RMID,<span style="color: #ffd700;">NULL</span>)==-1){
        printf(<span style="color: #deb887;">"msgctl IPC_RMID %m\n"</span>);
    }
    <span style="color: #00bfff; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/msg1 

current bytes:5 ,current number:1 ,max bytes:16384 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#24403;&#21069;&#28040;&#24687;&#38431;&#21015;&#20449;&#24687;&#65306;&#20889;&#20837;5&#20010;&#23383;&#33410;&#65292;&#25317;&#26377;1&#20010;&#28040;&#24687;&#65292;&#26368;&#22823;&#21487;&#20889;&#20837;&#23383;&#33410;&#25968;&#26159;16384 </span>
msgrcv1 No message of desired type <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#26080;&#27861;&#35835;&#21462;&#31867;&#22411;&#20026;910&#30340;&#28040;&#24687;</span>
help <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#35835;&#21462;&#20986;&#30340;&#28040;&#24687;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6b2ab1e" class="outline-4">
<h4 id="org6b2ab1e">消息队列 VS 流管道</h4>
<div class="outline-text-4" id="text-org6b2ab1e">
<p>
如若需要客户机和服务器之间的双向数据流，可以使用消息队列或流管道(用UNIX域套接字来实现)。消息队列原来的实施目的是提供比一般IPC更高速度的进程通信方法，而现在这个优点已经不复存在，所以不推荐使用消息队列！ 
</p>
</div>
</div>
</div>

<div id="outline-container-org7b2735f" class="outline-3">
<h3 id="org7b2735f">信号量</h3>
<div class="outline-text-3" id="text-org7b2735f">
<p>
信号量与已经介绍过的IPC(管道、FIFO以及消息列队)不同。它是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
</p>
<ol class="org-ol">
<li>测试控制该资源的信号量</li>
<li>若此信号量的值为正，则进程可以使用该资源。进程将信号量值减1，表示它使用了一个资源单位</li>
<li>若此信号量的值为0，则进程进入睡眠状态，直至信号量值大于0。若进程被唤醒后， 它返回至第1步</li>
</ol>

<p>
当进程不再使用由一个信息量控制的共享资源时，该信号量值增1。如果有进程正在睡眠等待此信号量，则唤醒它们 
</p>
</div>

<div id="outline-container-org4a830d1" class="outline-4">
<h4 id="org4a830d1">实现</h4>
<div class="outline-text-4" id="text-org4a830d1">
<p>
为了正确地实现信息量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的
</p>

<p>
常用的信号量形式被称之为双态信号量(binary semaphore)。它控制单个资源，其初始值为1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。
</p>

<p>
不幸的是，系统V的信号量与此相比要复杂得多。三种特性造成了这种并非必要的复杂性:
</p>
<ol class="org-ol">
<li>信号量并非是一个非负值，而必需将信号量定义为含有一个或多个信号量值的集合。当创建一个信号量时，要指定该集合中的各个值</li>
<li>创建信息量(semget)与对其赋初值(semctl)分开。这是一个致命的弱点，因为不能原子地创建一个信号量集合，并且对该集合中的所有值赋初值</li>
<li>即使没有进程正在使用各种形式的IPC，它们仍然是存在的，所以不得不为这种程序担心，它在终止时并没有释放已经分配给它的信号量。下面将要说明的undo功能就是假定要处理这种情况的</li>
</ol>
</div>
</div>

<div id="outline-container-org0705765" class="outline-4">
<h4 id="org0705765">semid_ds结构</h4>
<div class="outline-text-4" id="text-org0705765">
<p>
内核为每个信号量设置了一个semid_ds结构：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">semid_ds</span>
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span> <span style="color: #4eee94;">sem_perm</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">see Section 14.6.2 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sem</span> *<span style="color: #4eee94;">sem_base</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">ptr to first semaphore in set </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">sem_nsems</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;"># of semaphores in set </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">sem_otime</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">last-semop() time </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">sem_ctime</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">last-change time </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>
<p>
对用户而言，sem_base指针是没有价值的，它指向内核中的sem结构数组，该数组中包含了sem_nsems个元素，每个元素各对应于集合中的一个信号量值
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sem</span>
{
    <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">semval</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">semaphore value always &gt;= 0</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">sempid</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid for last operation </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">semncnt</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;"># processes awaiting semval &gt; currentval </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">ushort</span> <span style="color: #4eee94;">semzcnt</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;"># processes awaiting semval = 0 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org52e63f1" class="outline-4">
<h4 id="org52e63f1">资源限制</h4>
<div class="outline-text-4" id="text-org52e63f1">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 5:</span> 影响信号量的系统限制</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名字</td>
<td class="org-left">说明</td>
<td class="org-right">典型值</td>
</tr>

<tr>
<td class="org-left">SEMVMX</td>
<td class="org-left">任一信号量的最大值</td>
<td class="org-right">32767</td>
</tr>

<tr>
<td class="org-left">SEMAEM</td>
<td class="org-left">任一信号量的最大终止时调整值</td>
<td class="org-right">16384</td>
</tr>

<tr>
<td class="org-left">SEMMNI</td>
<td class="org-left">系统中信号量集的最大数</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">SEMMNS</td>
<td class="org-left">系统中信号量集的最大数</td>
<td class="org-right">60</td>
</tr>

<tr>
<td class="org-left">SEMMSL</td>
<td class="org-left">每个信号量集中的最大信号量数</td>
<td class="org-right">25</td>
</tr>

<tr>
<td class="org-left">SEMMNU</td>
<td class="org-left">系统中undo结构的最大数</td>
<td class="org-right">30</td>
</tr>

<tr>
<td class="org-left">SEMUME</td>
<td class="org-left">每个undo结构中的最大undo项数</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">SEMOPM</td>
<td class="org-left">每个semop调用所包含的最大操作数</td>
<td class="org-right">10</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org66d4fde" class="outline-4">
<h4 id="org66d4fde">semget函数</h4>
<div class="outline-text-4" id="text-org66d4fde">
<ul class="org-ul">
<li><p>
semget函数：获得一个信号量ID
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26032;&#24314;&#25110;&#25171;&#24320;&#19968;&#20010;&#20449;&#21495;&#37327;&#38598;</span>

<span style="color: #ffebcd;">   key&#65306;&#20449;&#21495;&#37327;&#20851;&#38190;&#23383;&#65292;&#20869;&#26680;&#26681;&#25454;&#35268;&#21017;&#36716;&#25442;&#20026;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   nsems&#65306;&#20449;&#21495;&#37327;&#38598;&#20013;&#30340;&#20449;&#21495;&#25968;&#65292;&#22914;&#26524;&#35843;&#29992;&#35813;&#20989;&#25968;&#26159;&#20026;&#20102;&#24341;&#29992;&#19968;&#20010;&#29616;&#23384;&#30340;&#20449;&#21495;&#37327;&#38598;&#65292;&#21017;&#24212;&#35774;&#20026; 0</span>
<span style="color: #ffebcd;">   flag&#65306;&#20462;&#25913;&#26631;&#35760;&#20301;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#36820;&#22238;&#20449;&#21495;&#37327;&#26631;&#35782;&#31526;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">semget</span>(<span style="color: #98f5ff;">key_t</span> <span style="color: #4eee94;">key</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nsems</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
创建一个新集合时，对semid_ds结构的下列成员赋初值：
</p>
<ul class="org-ul">
<li>对ipc_perm结构赋初值。该结构中的mode被设置为flag中的相应许可权位</li>
<li>sem_otime设置为0</li>
<li>sem_ctime设置为当前时间</li>
<li>sem_nsems设置为nsems。</li>
</ul>

<p>
nsems是该集合中的信号量数。如果是创建新集合(一般在服务器中)，则必须指定nsems。如果引用一个现存的集合(一个客户机)，则将nsems指定为0
</p>
</div>
</div>

<div id="outline-container-org4a05d50" class="outline-4">
<h4 id="org4a05d50">semctl函数</h4>
<div class="outline-text-4" id="text-org4a05d50">
<ul class="org-ul">
<li><p>
semctl函数：信号量操作函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#31649;&#29702;&#19968;&#20010;&#20449;&#21495;&#37327;&#38598;</span>

<span style="color: #ffebcd;">   semid&#65306;&#25351;&#23450;&#30340;&#20449;&#21495;&#37327;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   semnum&#65306;&#38598;&#21512;&#20013;&#25351;&#23450;&#30340;&#20449;&#21495;&#37327;&#65292;&#21462;&#20540;&#33539;&#22260;&#20026;0&#21040;&#24635;&#25968;-1</span>
<span style="color: #ffebcd;">   cmd&#65306;&#25351;&#23450;&#30340;&#25805;&#20316;</span>
<span style="color: #ffebcd;">   arg&#65306;&#25968;&#25454;&#28304;,&#23427;&#26159;&#19968;&#20010;&#32852;&#21512;&#20307;union semun&#31867;&#22411;</span>

<span style="color: #ffebcd;">   return&#65306;&#26681;&#25454;cmd&#19981;&#21516;&#65292;&#36820;&#22238;&#19981;&#21516;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">semctl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semid</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semnum</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, ... <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">union semun arg </span><span style="color: #5f9ea0; font-style: italic;">*/</span>);

<span style="color: #00bfff; font-weight: bold;">union</span> <span style="color: #98f5ff;">semun</span>
{
    <span style="color: #98f5ff;">int</span>              <span style="color: #4eee94;">val</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">cmd &#20026; SETVAL &#26102;&#20316;&#20026;&#25968;&#25454;&#28304; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">semid_ds</span> *<span style="color: #4eee94;">buf</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">cmd &#20026; IPC_STAT &#21644; IPC_SET &#26102;&#30340;&#25968;&#25454;&#28304; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span>  *<span style="color: #4eee94;">array</span>;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">cmd &#20026; GETALL &#21644; SETALL &#26102;&#30340;&#25968;&#25454;&#28304; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org9f212c3" class="outline-5">
<h5 id="org9f212c3">cmd参数</h5>
<div class="outline-text-5" id="text-org9f212c3">
<p>
cmd参数指定下列十种命令中的一种，使其在semid指定的信号量集合上执行此命令。其中有五条命令是针对一个特定的信号量值的，它们用semnum指定该集合中的一个成员。semnum值在0和nsems-1之间(包括0和nsems-1)：
</p>
<ul class="org-ul">
<li>IPC_STAT：对此集合取semid_ds结构，并存放在由arg.buf指向的结构中</li>
<li>IPC_SET：由arg.buf指向的结构中的值设置与此集合相关结构中的下列三个字段值:
<ol class="org-ol">
<li>sem_perm.uid</li>
<li>sem_perm.gid</li>
<li>sem_perm.mode</li>
</ol></li>
</ul>

<p>
此命令只能由下列两种进程执行：其有效用户ID等于sem_perm.cuid或sem_perm.uid的进程或是具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>IPC_RMID：从系统中删除该信号量集合。这种删除是立即的。仍在使用此信号量的其他进程在它们下次意图对此信号量进行操作时，将出错返回EIDRM</li>
</ul>

<p>
此命令只能由下列两种进程执行：有效用户ID等于sem_perm.cuid或sem_perm.uid的进程或是具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>GETVAL：返回成员semnum的semval值</li>
<li>SETVAL：设置成员semnum的semval值，该值由arg.val指定</li>
<li>GETPID：返回成员semnum的sempid值</li>
<li>GETNCNT：返回成员semnum的semncnt值</li>
<li>GETZCNT：返回成员semnum的semzcnt值</li>
<li>GETALL：取该集合中所有信号量的值，并将它们存放在由arg.array指向的数组中</li>
<li>SETALL：按arg.array指向的数组中的值设置该集合中所有信号量的值</li>
</ul>

<p>
对于除GETALL以外的所有GET命令，semctl函数都返回相应值。其他命令的返回值为0
</p>
</div>
</div>
</div>

<div id="outline-container-org40126bd" class="outline-4">
<h4 id="org40126bd">semop函数</h4>
<div class="outline-text-4" id="text-org40126bd">
<ul class="org-ul">
<li><p>
semop函数：自动执行信号量集合上的操作数组
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20351;&#29992;&#20449;&#21495;&#37327;</span>

<span style="color: #ffebcd;">   semid&#65306;&#20449;&#21495;&#37327;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   semoarray&#65306;&#19968;&#32452;sembuf&#23545;&#35937;</span>
<span style="color: #ffebcd;">   nops&#65306;semoarray&#30340;&#20803;&#32032;&#20010;&#25968;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">semop</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semid</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span> <span style="color: #4eee94;">semoparray</span>[], <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nops</span>);
</pre>
</div></li>
</ul>
</div>


<div id="outline-container-orgee0d30f" class="outline-5">
<h5 id="orgee0d30f">semoarray参数</h5>
<div class="outline-text-5" id="text-orgee0d30f">
<p>
semoparray是一个指针，它指向一个信号量操作sembuf结构数组：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span>
{
    <span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">sem_num</span>;   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25351;&#23450;&#38598;&#21512;&#20013;&#30340;&#20449;&#21495;&#37327;,&#21462;&#20540; 0 ~ nsems-1 </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span>          <span style="color: #4eee94;">sem_op</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25351;&#23450;&#25805;&#20316;&#25968; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span>          <span style="color: #4eee94;">sem_flg</span>;   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#21253;&#25324; IPC_NOWAIT &#21644; SEM_UNDO </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
nops规定该数组中操作的数量(元素数)
</p>
</div>

<ul class="org-ul">
<li><a id="org0428e54"></a>sem_op成员<br />
<div class="outline-text-6" id="text-org0428e54">
<p>
对集合中每个成员的操作由相应的sem_op规定。此值可以是负值、0或正值。其undo标志对应于相应sem_flg成员的SEM_UNDO位：
</p>
<ul class="org-ul">
<li>sem_op &gt; 0：这对应于释放进程占用的资源。sem_op值加到信号量的值上。如果指定了undo标志，则也从该进程的此信号量调整值中减去sem_op</li>

<li>若sem_op &lt; 0：则表示要获取由该信号量控制的资源
<ul class="org-ul">
<li>如若该信号量的值大于或等于sem_op的绝对值(具有所需的资源)，则从信号量值中减去sem_op的绝对值。这保证信号量的结果值大于或等于0。如果指定了undo标志，则sem_op的绝对值也加到该进程的此信号量调整值上</li>
<li>如果信号量值小于sem_op的绝对值(资源不能满足要求)，则:
<ul class="org-ul">
<li>若指定了IPC_NOWAIT：则出错返回EAGAIN</li>
<li>若未指定IPC_NOWAIT：则该信号量的semncnt值加1(因为将进入睡眠状态)，然后调用进程被挂起直至下列事件之一发生:
<ul class="org-ul">
<li>此信号量变成大于或等于sem_op的绝对值(即某个进程已释放了某些资源)。此信号量的semncnt值减1(因为已结束等待)，并且从信号量值中减去sem_op的绝对值。如果指定了undo标志，则sem_op的绝对值也加到该进程的此信号量调整值上</li>
<li>从系统中删除了此信号量。在此情况下，函数出错返回ERMID</li>
<li>进程捕捉到一个信号，并从信号处理程序返回，在此情况下，此信号量的semncnt值减1(因为不再等待)，并且函数出错返回EINTR</li>
</ul></li>
</ul></li>
</ul></li>

<li>若sem_op为0，这表示希望等待到该信号量值变成0：
<ul class="org-ul">
<li>如果信号量值当前是0，则此函数立即返回</li>
<li>如果信号量值非0，则:
<ul class="org-ul">
<li>若指定了IPC_NOWAIT，则出错返回EAGAIN</li>
<li>若未指定IPC_NOWAIT，则该信号量的semncnt值加1(因为将进入睡眠状态)，然后调用进程被挂起，直至下列事件之一发生：
<ul class="org-ul">
<li>此信号量值变成0。此信号量的semzcnt值减1(因为已结束等待)</li>
<li>从系统中删除了此信号量。在此情况下，函数出错返回ERMID</li>
<li>进程捕捉到一个信号，并从信号处理程序返回。在此情况下，此信号量的semzcnt值减1(因为不再等待)，并且函数出错返回EINTR</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
semop具有原子性，因为它或者执行数组中的所有操作，或者一个也不做
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1962193" class="outline-5">
<h5 id="org1962193">exit时的信号量调整</h5>
<div class="outline-text-5" id="text-org1962193">
<p>
如果在进程终止时，它占用了经由信号量分配的资源，那么就会成为一个问题。无论何时只要为信号量操作指定了SEM_UNDO标志，然后分配资源(sem_op值小于0)，那么内核就会记住对于该特定信号量，分配给我们多少资源(sem_op的绝对值)。当该进程终止时，不论自愿或者不自愿，内核都将检验该进程是否还有尚未处理的信号量调整值，如果有，则按调整值对相应量值进行调整
</p>

<p>
如果用带SETVAL或SETALL命令的semctl设置一信号量的值，则在所有进程中，对于该信号量的调整值都设置为0
</p>
</div>
</div>
</div>

<div id="outline-container-orge2224f5" class="outline-4">
<h4 id="orge2224f5">实例</h4>
<div class="outline-text-4" id="text-orge2224f5">
<p>
通过信号量来同步父子进程：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/sem.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>){

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21019;&#24314;&#20449;&#21495;&#37327;&#38598;</span>
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">semid</span> = semget(IPC_PRIVATE, 1, 0666);
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">value</span> = 0;

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21021;&#22987;&#21270;&#20449;&#21495;&#37327;&#65292;&#35774;&#32622;&#20449;&#21495;&#37327;&#38598;&#30340;&#31532;&#19968;&#20010;&#20449;&#21495;&#37327;&#30340;&#24403;&#21069;&#20540;&#20026;0</span>
    semctl(semid, 0, SETVAL, &amp;value);

    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">pid</span>=fork();
    <span style="color: #00bfff; font-weight: bold;">if</span>(pid==0){<span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">child</span>
        <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span> <span style="color: #4eee94;">buf</span>;
        buf.sem_num = 0;
        buf.sem_op = -1;
        printf(<span style="color: #deb887;">"child wait to exit\n"</span>);
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#20174;&#20449;&#21495;&#37327;&#38598;&#30340;&#31532;&#19968;&#20010;&#20449;&#21495;&#37327;&#33719;&#21462;&#19968;&#20010;&#36164;&#28304;</span>
        semop(semid, &amp;buf, 1);
        printf(<span style="color: #deb887;">"child about to exit\n"</span>);
        <span style="color: #00bfff; font-weight: bold;">return</span> 0;
    }

    sleep(2);
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">sembuf</span> <span style="color: #4eee94;">buf</span>;
    buf.sem_num = 0;
    buf.sem_op = 1;
    printf(<span style="color: #deb887;">"tell child ready\n"</span>);
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#21521;&#20449;&#21495;&#37327;&#38598;&#30340;&#31532;&#19968;&#20010;&#20449;&#21495;&#37327;&#22686;&#21152;&#19968;&#20010;&#36164;&#28304;</span>
    semop(semid,&amp;buf,1);
    wait(<span style="color: #ffd700;">NULL</span>);

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#29702;&#20449;&#21495;&#37327;&#38598;</span>
    semctl(semid, 0, IPC_RMID);
    <span style="color: #00bfff; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/semp1

child wait to exit
child about to exit
tell child ready

</pre>
</div>
</div>
</div>

<div id="outline-container-org2e47784" class="outline-4">
<h4 id="org2e47784">信号量 VS 文件锁</h4>
<div class="outline-text-4" id="text-org2e47784">
<p>
如果多个进程共享一个资源，则可使用信号量或记录锁
</p>

<p>
虽然实际上记录锁稍慢于信号量锁，但如果只需锁一个资源并且不需要使用信号量的所有花哨的功能，则宁可使用记录锁。理由是：
</p>
<ul class="org-ul">
<li>使用简易</li>
<li>进程终止时，会处理任一遗留下的锁</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org7316136" class="outline-3">
<h3 id="org7316136">共享内存</h3>
<div class="outline-text-3" id="text-org7316136">
<p>
共享存储允许两个或多个进程共享一给定的存储区。因为数据不需要在客户机和服务器之间复制，所以这是最快的一种IPC。使用共享存储的唯一窍门是多个进程之间对一给定存储区 
的同步存取。若服务器将数据放入共享存储区，则在服务器做完这一操作之前，客户机不应当去取这些数据。通常信号量被用来实现对共享存储存取的同步
</p>
</div>

<div id="outline-container-org09e36c6" class="outline-4">
<h4 id="org09e36c6">shmid_ds结构</h4>
<div class="outline-text-4" id="text-org09e36c6">
<p>
内核为每个共享存储段设置了一个shmid_ds结构：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">shmid_ds</span>
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">ipc_perm</span> <span style="color: #4eee94;">shm_perm</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">operation permission struct </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">anop_map</span> *<span style="color: #4eee94;">shm_amp</span>;           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pointer in kernel </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">shm_segsz</span>;                   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">size of segment in bytes </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">shm_atime</span>;                 <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last shmat() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">shm_dtime</span>;                 <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last shmdt() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">time_t</span> <span style="color: #4eee94;">shm_ctime</span>;                 <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">time of last change by shmctl() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">shm_cpid</span>;                   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of creator </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">shm_lpid</span>;                   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">pid of last shmop </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">shmatt_t</span> <span style="color: #4eee94;">shm_nattch</span>;                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">number of current attaches </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">shmatt_t</span> <span style="color: #4eee94;">shm_cattch</span>;              <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">used only for shminfo </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org69784f9" class="outline-4">
<h4 id="org69784f9">资源限制</h4>
<div class="outline-text-4" id="text-org69784f9">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 6:</span> 影响共享内存的系统限制</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名字</td>
<td class="org-left">说明</td>
<td class="org-right">典型值</td>
</tr>

<tr>
<td class="org-left">shmmax</td>
<td class="org-left">共享存储段的最大字节数</td>
<td class="org-right">131072</td>
</tr>

<tr>
<td class="org-left">shmmin</td>
<td class="org-left">共享存储段的最小字节数</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">shmmni</td>
<td class="org-left">系统中共享存储段的最大段数</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-left">shmseg</td>
<td class="org-left">每个进程,共享存储段的最大段数</td>
<td class="org-right">6</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org0abb7de" class="outline-4">
<h4 id="org0abb7de">shmget函数</h4>
<div class="outline-text-4" id="text-org0abb7de">
<ul class="org-ul">
<li><p>
shmget函数：获得一个共享存储标识符
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26032;&#24314;&#25110;&#25171;&#24320;&#19968;&#20010;&#20849;&#20139;&#20869;&#23384;&#23545;&#35937;</span>

<span style="color: #ffebcd;">   key&#65306;&#20849;&#20139;&#20869;&#23384;&#20851;&#38190;&#23383;&#65292;&#20869;&#26680;&#26681;&#25454;&#35268;&#21017;&#36716;&#25442;&#20026;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   size&#65306;&#26032;&#24314;&#24212;&#21462;PAGESIZE&#30340;&#25972;&#25968;&#20493;&#65292;&#29992;&#20316;&#25171;&#24320;&#29616;&#23384;&#30340;&#20849;&#20139;&#20869;&#23384;&#23545;&#35937;&#26102;&#65292;size&#24212;&#35774;&#20026;0</span>
<span style="color: #ffebcd;">   flag&#65306;&#20849;&#20139;&#20869;&#23384;&#23384;&#21462;&#36873;&#39033;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#20849;&#20139;&#20869;&#23384;&#26631;&#35782;&#31526;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">shmget</span>(<span style="color: #98f5ff;">key_t</span> <span style="color: #4eee94;">key</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
当创建一个新共享内存段时，初始化shmid_ds结构的下列成员:
</p>
<ul class="org-ul">
<li>ipc_perm结构按前面所述进行初始化，该结构中的mode按flag中的相应许可权位设置</li>
<li>shm_lpid、shm_nattach、shm_atime、以及shm_dtime都设置为0</li>
<li>shm_ctime设置为当前时间</li>
</ul>

<p>
size是该共享存储段的最小值。如果正在创建一个新段(一般在服务器中)，则必须指定其size。如果正在存访一个现存的段(一个客户机)，则将size指定为0
</p>
</div>
</div>

<div id="outline-container-orgb1db010" class="outline-4">
<h4 id="orgb1db010">shmctl函数</h4>
<div class="outline-text-4" id="text-orgb1db010">
<ul class="org-ul">
<li><p>
shmctl函数：对共享存储段执行多种操作
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#31649;&#29702;&#20849;&#20139;&#20869;&#23384;&#23545;&#35937;</span>

<span style="color: #ffebcd;">   shmid&#65306;&#20849;&#20139;&#20869;&#23384;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   cmd&#65306;&#31649;&#29702;&#21629;&#20196;</span>
<span style="color: #ffebcd;">   buf&#65306;&#20849;&#20139;&#20869;&#23384;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">shmctl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">shmid</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">shmid_ds</span> *<span style="color: #4eee94;">buf</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org4caccef" class="outline-5">
<h5 id="org4caccef">cmd参数</h5>
<div class="outline-text-5" id="text-org4caccef">
<p>
cmd参数指定下列5种命令中一种，使其在shmid指定的段上执行：
</p>
<ul class="org-ul">
<li>IPC_STAT：对此段取shmid_ds结构，并存放在由buf指向的结构中</li>
<li>IPC_SET：按buf指向的结构中的值设置与此段相关结构中的下列三个字段:
<ol class="org-ol">
<li>shm_perm.uid</li>
<li>shm_perm.gid</li>
<li>shm_perm.mode</li>
</ol></li>
</ul>

<p>
此命令只能由下列两种进程执行：其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程或具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>IPC_RMID：从系统中删除该共享存储段。因为每个共享存储段有一个连接计数(shm_nattch在shmid_ds结构中)，所以除非使用该段的最后一个进程终止或与该段脱接，否则不会实际上删除该存储段。不管此段是否仍在使用，该段标识符立即被删除，所以不能再用shmat与该段连接</li>
</ul>

<p>
此命令只能由下列两种进程执行：其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程或具有超级用户特权的进程
</p>

<ul class="org-ul">
<li>SHM_LOCK：锁住共享存储段。此命令只能由超级用户执行</li>
<li>SHM_UNLOCK：解锁共享存储段。此命令只能由超级用户执行</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org69fab86" class="outline-4">
<h4 id="org69fab86">shmat函数</h4>
<div class="outline-text-4" id="text-org69fab86">
<ul class="org-ul">
<li><p>
shmat函数：一旦创建了一个共享存储段，进程就可调用shmat将其连接到它的地址空间中
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#36830;&#25509;&#20849;&#20139;&#20869;&#23384;&#21040;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#65292;&#19968;&#33324;&#20026;&#22534;&#26632;</span>

<span style="color: #ffebcd;">   shmid&#65306;&#20849;&#20139;&#20869;&#23384;&#26631;&#35782;&#31526;</span>
<span style="color: #ffebcd;">   addr&#65306;&#25351;&#23450;&#36827;&#31243;&#22320;&#22336;&#31354;&#38388;&#30340;&#39318;&#22336;&#65292;&#20294;&#19968;&#33324;&#24212;&#21462;NULL&#35753;&#31995;&#32479;&#33258;&#34892;&#36873;&#25321;&#22320;&#22336;</span>
<span style="color: #ffebcd;">   flag&#65306;&#36830;&#25509;&#36873;&#39033;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#36820;&#22238;&#25351;&#21521;&#20849;&#20139;&#23384;&#20648;&#27573;&#30340;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">shmat</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">shmid</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>);
</pre>
</div></li>
</ul>
<p>
共享存储段连接到调用进程的哪个地址上与addr参数以及在flag中是否指定SHM_RND位有关：
</p>
<ul class="org-ul">
<li>如果addr为0：则此段连接到由内核选择的第一个可用地址上</li>
<li>如果addr非0：
<ul class="org-ul">
<li>没有指定SHM_RND：则此段连接到addr所指定的地址上</li>
<li>指定了SHM_RND：则此段连接到(addr - (addr mod SHMLBA))所表示的地址上。SHM_RND意思是取整，SHMLBA的意思是低边界地址倍数，它总是2的乘方。因此该算式是将地址向下取最近1个SHMLBA的倍数。</li>
</ul></li>
</ul>

<p>
除非只计划在一种硬件上运行应用程序，否则不用指定共享段所连接到的地址。所以一般应指定addr为0，以便由内核选择地址
</p>

<ul class="org-ul">
<li>如果在flag中指定了SHM_RDONLY位，则以只读方式连接此段。否则以读写方式连接此段</li>

<li>shmat的返回值是该段所连接的实际地址，如果出错则返回-1</li>
</ul>
</div>
</div>

<div id="outline-container-org9c30cf0" class="outline-4">
<h4 id="org9c30cf0">shmdt函数</h4>
<div class="outline-text-4" id="text-org9c30cf0">
<ul class="org-ul">
<li>shmdt函数：当对共享存储段的操作已经结束时，则调用shmdt脱接该段</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/ipc.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35299;&#38500;&#20849;&#20139;&#20869;&#23384;&#30340;&#36830;&#25509;</span>

<span style="color: #ffebcd;">   addr&#65306;&#25351;&#21521;&#20849;&#20139;&#20869;&#23384;&#30340;&#25351;&#38024;&#65292;&#20197;&#21069;&#35843;&#29992;shmat&#26102;&#30340;&#36820;&#22238;&#20540;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">shmdt</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>);
</pre>
</div>
<p>
注意：这并不从系统中删除其标识符以及其数据结构。该标识符仍然存在，直至某个进程(一般是服务器)调用shmctl(带命令IPC_RMID)特地删除它 
</p>
</div>
</div>


<div id="outline-container-orgabc0713" class="outline-4">
<h4 id="orgabc0713">打印不同类型的数据所存放的位置</h4>
<div class="outline-text-4" id="text-orgabc0713">
<p>
内核将以地址0连接的共享存储段放在什么位置上与系统密切相关。下面程序打印一些信息，它们与指定系统将不同类型的数据放在什么位置有关：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/shm.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">ARRAY_SIZE</span>  40000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">MALLOC_SIZE</span> 100000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SHM_SIZE</span>    100000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SHM_MODE</span>    ( SHM_R | SHM_W )   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">user read/write </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">array</span>[ARRAY_SIZE];  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">uninitialized data = bss </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">shmid</span>;
    <span style="color: #98f5ff;">char</span>    *<span style="color: #4eee94;">ptr</span>, *<span style="color: #4eee94;">shmptr</span>;

    printf(<span style="color: #deb887;">"array[] from %lx to %lx\n"</span>, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)&amp;array[0],
           (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)&amp;array[ARRAY_SIZE]);
    printf(<span style="color: #deb887;">"stack around %lx\n"</span>, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)&amp;shmid);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((ptr = malloc(MALLOC_SIZE)) == <span style="color: #ffd700;">NULL</span>)
        err_sys(<span style="color: #deb887;">"malloc error"</span>);

    printf(<span style="color: #deb887;">"malloced from %lx to %lx\n"</span>, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)ptr,
           (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>) ptr + MALLOC_SIZE);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"shmget error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> ((shmptr = shmat(shmid, 0, 0)) == (<span style="color: #98f5ff;">void</span> *)-1)
        err_sys(<span style="color: #deb887;">"shmat error"</span>);
    printf(<span style="color: #deb887;">"shared memory attached from %lx to %lx\n"</span>,
           (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)shmptr, (<span style="color: #98f5ff;">unsigned</span> <span style="color: #98f5ff;">long</span>)shmptr+SHM_SIZE);

    <span style="color: #00bfff; font-weight: bold;">if</span> (shmctl(shmid, IPC_RMID, 0) &lt; 0)
        err_sys(<span style="color: #deb887;">"shmctl error"</span>);

    exit(0);
}
</pre>
</div>

<p>
测试结果与实际系统有关：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/ipc/tshm

array[] from 602100 to 60bd40 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">bss&#27573;</span>
stack around 7ffea7bbf2e4 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20989;&#25968;&#26632;</span>
malloced from 220c420 to 2224ac0 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#22534;</span>
shared memory attached from 7f6e70571000 to 7f6e705896a0 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#20849;&#20139;&#20869;&#23384;&#21306;&#22495;</span>
</pre>
</div>

<p>
下图显示了这种情况，这与以前讲述的典型存储区布局类似：
</p>

<div class="figure">
<p><img src="pic/shm.png" alt="shm.png" width="60%" />  
</p>
</div>

<p>
注意：共享存储段紧靠在栈之下。实际上在共享存储段和栈之间有大约几M字节的未用地址空间
</p>
</div>
</div>

<div id="outline-container-org8724c17" class="outline-4">
<h4 id="org8724c17">/dev/zero的存储映射</h4>
<div class="outline-text-4" id="text-org8724c17">
<p>
共享存储可由不相关的进程使用。但是如果进程是相关的，则SVR4提供了一种不同的技术
</p>

<p>
设备/dev/zero在读时，是0字节的无限资源。此设备也接收写向它的任何数据，但忽略此数据。我们对此设备作为IPC的兴趣在于，当对其进行存储映射时，它具有一些特殊性质:
</p>
<ul class="org-ul">
<li>创建一个未名存储区，其长度是mmap的第二个参数，将其取整为系统上的最近页长</li>
<li>存储区都初始化为0</li>
<li>如果多个进程的共同祖先进程对mmap指定了MAP_SHARED标志，则这些进程可共享此存储区</li>
</ul>

<p>
程序14-12是使用此特殊设备的一个例子。它打开此/dev/zero设备，然后指定一个长整型调用mmap。一旦该存储区被映射了，就能关闭此设备。然后，进程创建一个子进程。因为在调用mmap时指定了MAP_SHARED，所以一个进程写到存储映照区的数据可由另一进程见到
</p>

<p>
然后父、子进程交替运行，使用父子进程同步函数各自对共享存储映射区中的一个长整型数加1。存储映射区由mmap初始化为0。父进程先对它进行增1操作，使其成为1，然后子
进程对其进行增1操作，使其成为2，然后父进程使其成为3&#x2026;&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">NLOOPS</span>      1000
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">SIZE</span>        <span style="color: #00bfff; font-weight: bold;">sizeof</span>(<span style="color: #98f5ff;">long</span>)    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">size of shared memory area </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">update</span>(<span style="color: #98f5ff;">long</span> *<span style="color: #4eee94;">ptr</span>)
{
    <span style="color: #00bfff; font-weight: bold;">return</span>((*ptr)++);   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">return value before increment </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">counter</span>;
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">void</span>    *<span style="color: #4eee94;">area</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fd = open(<span style="color: #deb887;">"/dev/zero"</span>, O_RDWR)) &lt; 0)
        err_sys(<span style="color: #deb887;">"open error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> ((area = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
             fd, 0)) == MAP_FAILED)
        err_sys(<span style="color: #deb887;">"mmap error"</span>);
    close(fd);      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">can close /dev/zero now that it's mapped </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    TELL_WAIT();

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {           <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">for</span> (i = 0; i &lt; NLOOPS; i += 2) {
            <span style="color: #00bfff; font-weight: bold;">if</span> ((counter = update((<span style="color: #98f5ff;">long</span> *)area)) != i)
                err_quit(<span style="color: #deb887;">"parent: expected %d, got %d"</span>, i, counter);

            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">printf("parent counter: %d \n", counter);</span>

            TELL_CHILD(pid);
            WAIT_CHILD();
        }
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">for</span> (i = 1; i &lt; NLOOPS + 1; i += 2) {
            WAIT_PARENT();

            <span style="color: #00bfff; font-weight: bold;">if</span> ((counter = update((<span style="color: #98f5ff;">long</span> *)area)) != i)
                err_quit(<span style="color: #deb887;">"child: expected %d, got %d"</span>, i, counter);

            <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">printf("child counter: %d \n", counter);</span>

            TELL_PARENT(getppid());
        }
    }

    exit(0);
}
</pre>
</div>
<p>
注意，当在update函数中，对长整型值增1时，必须使用括号，因为增加的是其值，而不是指针
</p>
</div>

<div id="outline-container-org7c59a42" class="outline-5">
<h5 id="org7c59a42">匿名存储映射</h5>
<div class="outline-text-5" id="text-org7c59a42">
<p>
4.3+BSD提供了一种类似于/dev/zero的施设，称为匿名存储映射。为了使用这种功能，在调用mmap时指定MAP_ANON标志，并将描述符指定为-1。结果得到的区域是匿名的(因为它并不通过一个文件描述符与一个路径名相结合)，并且创建一个存储区，它可与后代进程共享：
</p>

<p>
为了使上面程序应用4.3+BSD的这种特征，需要做两个修改：
</p>
<ol class="org-ol">
<li>删除/dev/zero的open条语句</li>
<li><p>
将mmap调用修改成下列形式:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">if</span> ( (area = mmap(0, SIZE, PROT_READ | PROT_WRITE,
          MAP_ANON | MAP_SHARED, -1, 0)) == (<span style="color: #98f5ff;">caddr_t</span>) -1)
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org323a987" class="outline-5">
<h5 id="org323a987">共享存储 VS mmap</h5>
<div class="outline-text-5" id="text-org323a987">
<ul class="org-ul">
<li>mmap的优点：使用简单</li>
<li>mmap的缺点：只能在相关进程间使用，不相关进程只能使用共享存储</li>
</ul>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org2ca7275" class="outline-2">
<h2 id="org2ca7275">客户机-服务器模型</h2>
<div class="outline-text-2" id="text-org2ca7275">
<p>
下面详细说明客户机和服务器的属性，这些属性受到它们之间所使用的IPC的不同类型的影响
</p>
</div>

<div id="outline-container-org54b023e" class="outline-3">
<h3 id="org54b023e">单向管道</h3>
<div class="outline-text-3" id="text-org54b023e">
<p>
客户机fork并执行所希望的服务器。在fork之前先创建两个单向管道以使数据可在两个方向传输。被执行的服务器可能是设置-用户-ID的程序，这使它具有了特权。查看客户机的实际用户ID就可以决定客户机的身份
</p>

<p>
在这种安排下，可以构筑一个“开放式服务器”。它为客户机开放文件而不是客户机调用open函数。这样就可以增加在正常的UNIX用户/组/其他许可权之上或之外的附加的许可权检查。假定服务器是设置-用户-ID程序，这给予了它附加的许可权(很可能是root许可权)。服务器用客户机的实际用户ID以决定是否给予它对所要求的文件的存取。使用这种方式，可以构筑一个服务器，它允许某种用户通常没有的存取权
</p>

<p>
因为服务器是父进程的子进程，所以它能做的一切是将文件内容传送给父进程。这种方式对一般文件工作得很好，同时也可被用于专用设备文件
但问题在于进程关系依赖：虽然父进程可向子进程传送打开文件描述符，然而子进程则不能向父进程传回一个描述符
</p>
</div>
</div>

<div id="outline-container-org57e5f0b" class="outline-3">
<h3 id="org57e5f0b">FIFO</h3>
<div class="outline-text-3" id="text-org57e5f0b">
<p>
服务器是一个守护进程，客户机则用某种形式的IPC与其联系。可以将管道用于这种形式的客户机-服务器关系。要求有一种命名的IPC，例如FIFO。如果服务器必需将数据送回客户机，则对每个客户机都要有单独使用的FIFO。如果客户机-服务器应用程序只有客户机向服务器送数据，则只需要一个众所周知的FIFO。例如，系统V行式打印机假脱机程序使用这种形式的客户机-服务器。客户机是lp(1)命令，服务器是lpsched进程。因为只有从客户机到服务器的数据流，没有任何数据需送回客户机，所以只需使用一个FIFO
</p>

<p>
主要缺点有：
</p>
<ul class="org-ul">
<li>处理管道异常信号</li>
<li>清理已失效的FIFO</li>
</ul>
</div>
</div>

<div id="outline-container-org1810df8" class="outline-3">
<h3 id="org1810df8">消息队列</h3>
<div class="outline-text-3" id="text-org1810df8">
<p>
使用消息队列则存在多种可能性：
</p>
<ol class="org-ol">
<li>在服务器和客户机之间可以只使用一个队列，使用每个消息的类型字段指明谁是消息的接受者。例如，客户机可以用类型字段为1发送它们的消息。在要求之中应包括客户机的进程ID。此后，服务器在发送响应消息时，将类型字段设置为客户机的进程ID。服务器只接受类型字段为1的消息(msgrcv的第四个参数)，客户机则只接受类型字段等于它们的进程ID的消息</li>
<li>另一种方法是每个客户机使用一个单独的消息队列。在向服务器发送第一个请求之前，每个客户机先创建它自己的消息队列，创建时使用关键字IPC_PRIVATE。服务器也有它自己的队列，其关键字或标识符是所有客户机知道的。客户机将其第一个请求送到服务器的众所周知的队列上，该请求中应包含其客户机消息队列的队列ID。服务器将其第一个响应送至客户机队列，此后的所有请求和响应都在此队列上交换</li>
</ol>

<p>
第二种技术的缺点是：
</p>
<ul class="org-ul">
<li>每个客户机专用队列通常只有一个消息在其中或者是对服务器的一个请求，或者是对客户机的响应。这似乎是对有限的系统资源(消息队列)的浪费，可以用一个FIFO来代替</li>
<li>服务器需从多个队列读消息。对于消息队列，select和poll都不起作用</li>
</ul>
</div>


<div id="outline-container-org8ac9a7b" class="outline-4">
<h4 id="org8ac9a7b">实现</h4>
<div class="outline-text-4" id="text-org8ac9a7b">
<p>
使用消息队列的这两种技术都可以用共享存储段和同步方法(信号量或记录锁)实现。使用共享存储段的问题是一次只能有一个消息在共享存储段中（类似于队列限制为只能有一个消息）。为此，在使用共享存储IPC时，通常每个客户机使用一个共享存储段
</p>
</div>
</div>

<div id="outline-container-orgd1205e2" class="outline-4">
<h4 id="orgd1205e2">缺陷</h4>
<div class="outline-text-4" id="text-orgd1205e2">
<p>
消息队列的问题在于：服务器如何准确地标识客户机。除非服务器正在执行一种非特权操作，否则服务器知道谁是客户机是很重要的。例如，若服务器是一个设置-用户-ID程序，就有这种要求。虽然，所有这几种形式的IPC都经由内核，但是它们并未提供任何措施使内核能够标识发送者
</p>

<p>
对于消息队列，如果在客户机和服务器之间使用一个专用队列(于是一次只有一个消息在该队列上)，那么队列的msg_lspid包含了对方进程的进程ID。但是当客户机将请求发送给服务器时，我们想要的是客户机的有效用户ID，而不是它的进程ID。现在还没有一种可移植的方法，在已知进程ID情况下用其可以得到有效用户ID。由于任意进程只要拿到标识符(而无需其它授权)就可以读取消息(使得消息出队)，因此需要针对此专门设计安全措施
</p>
</div>

<div id="outline-container-orge7e43e9" class="outline-5">
<h5 id="orge7e43e9">安全措施</h5>
<div class="outline-text-5" id="text-orge7e43e9">
<p>
同样的技术可用于FIFO、消息队列、信号量或共享存储。下面的说明具体针对FIFO：
</p>

<p>
客户机必须创建它自己的FIFO，并且设置FIFO的文件存取许可权，使得只允许用户-读，用户-写。假定服务器具有超级用户特权或者它很可能并不关心客户机的真实标识，所以服务器仍可读、写此FIFO。当服务器在众所周知的FIFO上接受到客户机的第一个请求时(它应当包含客户机专用FIFO的标识)，服务器调用针对客户机专用FIFO的stat或fstat。服务器所采用的假设是客户机的有效用户ID是FIFO的所有者(stat结构的st_uid字段)。服务器验证该FIFO只有用户-读、用户-写许可权。服务器还应检查是该FIFO的三个时间量(stat结构中的st_atime，st_mtime和st_ctime字段)，要检查它们与当前时间是否很接近(例如不早于当前时间15秒或30秒)。如果一个有预谋的客户机可以创建一个FIFO，使另一个用户成为其所有者，并且设置该文件的许
可权为用户-读和用户-写，那么在系统中就存在了其他基础性的安全问题
</p>

<p>
为了在系统VIPC中应用这种技术，回想一下与每个消息队列、信号量、以及共享存储段相关的ipc_perm结构，其中cuid和cgid字段标识IPC结构的创建者。以FIFO为例，服务器应当要求客户机创建该IPC结构，并使客户机将存取权设置为只允许用户-读和用户-写。服务器也应检验与该IPC相关的时间量与当前时间是否很接近(因为这些IPC结构在显式地删除之前一直存在)
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orge28b6c4" class="outline-2">
<h2 id="orge28b6c4">总结</h2>
<div class="outline-text-2" id="text-orge28b6c4">
<ul class="org-ul">
<li>掌握匿名管道和FIFO技术，因为它们清晰简单</li>
<li>尽量不使用消息队列和信号量，而以流管道和记录锁代替之</li>
<li>可以用mmap代替共享内存</li>
<li><p>
尽量用套接字代替System V的三种IPC
</p>

<p>
<a href="daemon.html">Previous：守护进程</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
