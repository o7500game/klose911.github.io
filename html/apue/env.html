<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进程环境</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="system_file.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程环境</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org443edcd">main函数</a></li>
<li><a href="#orgf281f55">进程终止</a>
<ul>
<li><a href="#org50046d7">exit和_exit</a>
<ul>
<li><a href="#org59106aa">终止状态</a></li>
</ul>
</li>
<li><a href="#orgac80352">atexit</a>
<ul>
<li><a href="#orgafd06a7">示例</a></li>
</ul>
</li>
<li><a href="#org1568219">小结</a></li>
</ul>
</li>
<li><a href="#org37a9da1">命令行参数</a>
<ul>
<li><a href="#orga264a98">打印所有命令行参数</a></li>
</ul>
</li>
<li><a href="#org378cb03">C程序内存模型</a>
<ul>
<li><a href="#org29e3e82">存储器布局</a>
<ul>
<li><a href="#org3d69ba7">正文段</a></li>
<li><a href="#org3a97983">初始化数据段</a></li>
<li><a href="#orgd67b00e">非初始化数据段</a></li>
<li><a href="#org0c6360e">栈</a></li>
<li><a href="#orge3af3c5">堆</a></li>
<li><a href="#org4a0290c">存储器总结</a></li>
</ul>
</li>
<li><a href="#org8a4f818">共享库</a></li>
<li><a href="#org585ad9f">动态内存管理</a>
<ul>
<li><a href="#org1e92821">分配内存</a></li>
<li><a href="#orgf307f3a">释放内存</a></li>
<li><a href="#org306a232">实现细节</a></li>
<li><a href="#org857e77c">注意事项</a></li>
<li><a href="#orgfd95812">alloca函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb79954d">环境变量表</a>
<ul>
<li><a href="#org0c50bfc">常见环境变量</a></li>
<li><a href="#org706e7fb">环境变量函数</a>
<ul>
<li><a href="#org6b702aa">getenv</a></li>
<li><a href="#org6938206">putsenv, setenv, unsetenv</a></li>
<li><a href="#orgee72c38">实现细节</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org69742e3">栈间跳转</a>
<ul>
<li><a href="#orgc74c368">cmd_add</a></li>
<li><a href="#org3acccd2">setjmp, longjmp</a>
<ul>
<li><a href="#org227b37b">cmd_add2</a></li>
</ul>
</li>
<li><a href="#orgc39560a">volatile变量</a></li>
<li><a href="#orgb41c9f7">自动变量陷阱</a></li>
</ul>
</li>
<li><a href="#org699fdf7">资源限制</a>
<ul>
<li><a href="#org813902e">resource常量</a></li>
<li><a href="#org2b0cb10">rlimit结构</a></li>
<li><a href="#orgef2cfed">实例</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章主要说明：
</p>
<ul class="org-ul">
<li>当执行程序时其main函数是如何被调用的</li>
<li>进程终止的不同方式</li>
<li>命令行参数是如何传送给执行程序的</li>
<li>典型的存储器布局是什么样式</li>
<li>如何分配另外的存储空间进程</li>
<li>如何使用环境变量</li>
<li>longjmp和setjmp函数以及它们与栈的交互作用</li>
<li>进程的资源限制</li>
</ul>

<div id="outline-container-org443edcd" class="outline-2">
<h2 id="org443edcd">main函数</h2>
<div class="outline-text-2" id="text-org443edcd">
<p>
C程序总是从main函数开始执行，其中argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20027;&#20989;&#25968;</span>

<span style="color: #ffebcd;">   argc&#65306;&#21629;&#20196;&#34892;&#21442;&#25968;&#30340;&#25968;&#30446;</span>
<span style="color: #ffebcd;">   argv&#65306;&#25351;&#38024;&#25968;&#32452;&#65292;&#20854;&#20803;&#32032;&#26159;&#25351;&#21521;&#21508;&#20010;&#21629;&#20196;&#34892;&#21442;&#25968;&#30340;&#23383;&#31526;&#20018;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#36820;&#22238;&#20540;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[]);
</pre>
</div>

<p>
当内核使用一个exec函数起动C程序时，在调用main函数前先调用一个特殊的起动例程：从内核取得命令行参数和环境变量值，然后为调用main函数作好准备
</p>

<p>
C语言编译的时候会调用链接器(ld)，而链接器会设置这个特殊的启动例程为可执行文件的起始地址
</p>
</div>
</div>

<div id="outline-container-orgf281f55" class="outline-2">
<h2 id="orgf281f55">进程终止</h2>
<div class="outline-text-2" id="text-orgf281f55">
<p>
图7-1显示了一个C程序是如何起动的，以及它终止的各种方式
</p>

<div class="figure">
<p><img src="pic/process-lifecycle.png" alt="process-lifecycle.png" width="90%" />
</p>
</div>

<p>
有五种方式使进程终止:
</p>
<ul class="org-ul">
<li>正常终止:
<ul class="org-ul">
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit</li>
</ul></li>
<li>异常终止:
<ul class="org-ul">
<li>调用abort</li>
<li>由一个信号终止</li>
</ul></li>
</ul>

<p>
上节提及的起动例程使得从main函数返回后立即调用exit函数：
</p>

<p>
如果将起动例程以C代码形式表示(实际上该例程常常用汇编语言编写)
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #daa520; font-weight: bold;">exit</span>(main(argc&#65292;argv)); 
</pre>
</div>
</div>

<div id="outline-container-org50046d7" class="outline-3">
<h3 id="org50046d7">exit和_exit</h3>
<div class="outline-text-3" id="text-org50046d7">
<p>
exit和_exit函数用于正常终止一个程序：
</p>
<ul class="org-ul">
<li>_exit：立刻进入内核</li>
<li>exit：先执行一些清除处理(包括调用执行各终止处理程序，关闭所有标准I/O流等)，然后进入内核</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>

<span style="color: #ffebcd;">   &#20808;&#25191;&#34892;&#19968;&#20123;&#28165;&#38500;&#22788;&#29702;&#65292;&#28982;&#21518;&#36827;&#20837;&#20869;&#26680;&#32456;&#27490;&#31243;&#24207;</span>

<span style="color: #ffebcd;">   status&#65306;&#31243;&#24207;&#32456;&#27490;&#36820;&#22238;&#29366;&#24577;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">exit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">status</span>);

<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#31435;&#21051;&#36827;&#20837;&#20869;&#26680;&#32456;&#27490;&#31243;&#24207;</span>

<span style="color: #ffebcd;">   status&#65306;&#31243;&#24207;&#36820;&#22238;&#29366;&#24577;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">_exit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">status</span>);
</pre>
</div>
<p>
exit函数总是执行一个标准I/O库的清除关闭操作：对于所有打开流调用fclose函数，这使得缓存中的所有数据都被刷新(写到文件上)
</p>
</div>

<div id="outline-container-org59106aa" class="outline-4">
<h4 id="org59106aa">终止状态</h4>
<div class="outline-text-4" id="text-org59106aa">
<p>
exit和_exit都带一个整型参数，称之为终止状态。如果出现下述状况，则该进程的终止状态是末定义的：
</p>
<ol class="org-ol">
<li>调用这些函数时不带终止状态</li>
<li>main执行了一个无返回值的return语句</li>
<li>main执行隐式返回</li>
</ol>

<p>
下列经典性的C语言程序是不完整的，其返回状态未定义
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #daa520; font-weight: bold;">main</span> ()
{
    printf (<span style="color: #deb887;">"hello, world \n"</span>);
}
</pre>
</div>

<p>
大多数UNIX shell都提供检查一个进程终止状态的方法：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/hello 
hello, world 

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#36820;&#22238;&#29366;&#24577;&#26410;&#23450;&#20041;</span>
$ echo $<span style="color: #4eee94;">?</span>
14
</pre>
</div>

<p>
向执行此程序的进程返回终止状态0 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">return</span> 0;
<span style="color: #98f5ff;">&#25110;&#32773;</span>
<span style="color: #daa520; font-weight: bold;">exit</span>(0);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgac80352" class="outline-3">
<h3 id="orgac80352">atexit</h3>
<div class="outline-text-3" id="text-orgac80352">
<p>
终止处理程按序：照ANSIC的规定一个进程可以登记多至32个函数，这些函数将在调用后exit被自动调用
</p>

<p>
atexit：登记注册终止处理程序
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#27880;&#20876;&#31243;&#24207;&#32456;&#27490;&#20989;&#25968;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026; 0,&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">atexit</span>(<span style="color: #98f5ff;">void</span> (*<span style="color: #daa520; font-weight: bold;">func</span>)(<span style="color: #98f5ff;">void</span>));
</pre>
</div>
<p>
其中atexit的参数是一个函数地址，当调用此函数时无需向它传送任何参数，也不期望它返回一个值
</p>
</div>

<div id="outline-container-orgafd06a7" class="outline-4">
<h4 id="orgafd06a7">示例</h4>
<div class="outline-text-4" id="text-orgafd06a7">
<p>
以下示例说明了如何使用atexit函数。注意：main函数使用了return来隐式调用exit函数
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit1</span>(<span style="color: #98f5ff;">void</span>);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit2</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (atexit(my_exit2) != 0)
        err_sys(<span style="color: #deb887;">"can't register my_exit2"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (atexit(my_exit1) != 0)
        err_sys(<span style="color: #deb887;">"can't register my_exit1"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (atexit(my_exit1) != 0)
        err_sys(<span style="color: #deb887;">"can't register my_exit1"</span>);

    printf(<span style="color: #deb887;">"main is done\n"</span>);
    <span style="color: #00bfff; font-weight: bold;">return</span>(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit1</span>(<span style="color: #98f5ff;">void</span>)
{
    printf(<span style="color: #deb887;">"first exit handler\n"</span>);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">my_exit2</span>(<span style="color: #98f5ff;">void</span>)
{
    printf(<span style="color: #deb887;">"second exit handler\n"</span>);
}

</pre>
</div>

<p>
exit以登记相反的顺序调用终止函数，同一函数如果被登记多次，则也会被调用多次！
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/doatexit 

main is done
first exit handler
first exit handler
second exit handler
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1568219" class="outline-3">
<h3 id="org1568219">小结</h3>
<div class="outline-text-3" id="text-org1568219">
<ul class="org-ul">
<li>内核使程序执行：调用exec函数</li>
<li>进程自愿终止：显式或隐式地调用exit或_exit函数
<ul class="org-ul">
<li>exit函数：首先调用各终止处理程序，然后按需多次调用fclose关闭所有打开流</li>
</ul></li>
<li>进程非自愿终止：通过信号量</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org37a9da1" class="outline-2">
<h2 id="org37a9da1">命令行参数</h2>
<div class="outline-text-2" id="text-org37a9da1">
<p>
调用exec函数可将命令行参数传递给被执行的新程序
</p>
</div>

<div id="outline-container-orga264a98" class="outline-3">
<h3 id="orga264a98">打印所有命令行参数</h3>
<div class="outline-text-3" id="text-orga264a98">
<p>
ANSIC和POSIX.1都要求argv[argc]是一个空指针，所以循环可以通过空指针判断来中断，等价于i &lt; argc 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>;
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">echo all command line args</span>
    <span style="color: #00bfff; font-weight: bold;">for</span>(i = 0; argv[i] != <span style="color: #ffd700;">NULL</span>; i++)
        printf(<span style="color: #deb887;">"argv[%d]: %s\n"</span>, i, argv[i]);

    <span style="color: #00bfff; font-weight: bold;">return</span> 0;

}
</pre>
</div>

<p>
argv的第一个字符串：被执行的程序路径名
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/arg arg1 TEST foo

argv[0]: ./src/environ/arg
argv[1]: arg1
argv[2]: TEST
argv[3]: foo
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org378cb03" class="outline-2">
<h2 id="org378cb03">C程序内存模型</h2>
<div class="outline-text-2" id="text-org378cb03">
</div>
<div id="outline-container-org29e3e82" class="outline-3">
<h3 id="org29e3e82">存储器布局</h3>
<div class="outline-text-3" id="text-org29e3e82">
<p>
C程序一直由下列几部分组成：
</p>
</div>
<div id="outline-container-org3d69ba7" class="outline-4">
<h4 id="org3d69ba7">正文段</h4>
<div class="outline-text-4" id="text-org3d69ba7">
<p>
CPU执行的机器指令部分，也被称为代码段
</p>

<p>
通常正文段是可共享的，所以即使是经常执行的程序(如文本编辑程序、C编译程序、shell等)在存储器中也只需有一个副本，另外正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令
</p>
</div>
</div>
<div id="outline-container-org3a97983" class="outline-4">
<h4 id="org3a97983">初始化数据段</h4>
<div class="outline-text-4" id="text-org3a97983">
<p>
此段也被称为数据段，它包含了程序中需赋初值的变量
</p>

<p>
任何函数之外声明会把变量的初值存放在初始化数据段中：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">int</span>&#12288;maxcount=99;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd67b00e" class="outline-4">
<h4 id="orgd67b00e">非初始化数据段</h4>
<div class="outline-text-4" id="text-orgd67b00e">
<p>
通常将此段称为bss段，在程序开始执行之前，内核将此段初始化为0
</p>

<p>
例如：在函数外声明位初始化的数组
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">sum</span>[1000];
</pre>
</div>
</div>
</div>
<div id="outline-container-org0c6360e" class="outline-4">
<h4 id="org0c6360e">栈</h4>
<div class="outline-text-4" id="text-org0c6360e">
<p>
自动变量以及每次函数调用时所需保存的信息都存放在此段中
</p>

<p>
每次函数调用时其返回地址、以及调用者的环境信息(例如某些机器寄存器)都存放在栈中，然后新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈C函数可以递归调用
</p>
</div>
</div>

<div id="outline-container-orge3af3c5" class="outline-4">
<h4 id="orge3af3c5">堆</h4>
<div class="outline-text-4" id="text-orge3af3c5">
<p>
在堆中进行动态存储分配
</p>

<p>
由于历史上形成的惯例，堆位于非初始化数据段顶和栈底之间
</p>
</div>
</div>

<div id="outline-container-org4a0290c" class="outline-4">
<h4 id="org4a0290c">存储器总结</h4>
<div class="outline-text-4" id="text-org4a0290c">
<p>
图7-3显示了C程序在内存中的一种典型安排方式：
</p>

<div class="figure">
<p><img src="pic/memory.png" alt="memory.png" width="90%" />
</p>
</div>

<p>
对于VAX上的4.3+BSD而言
</p>
<ul class="org-ul">
<li>正文段从0位置开始，栈顶则在0x7fffffff之下开始，堆顶和栈底之间未用的虚地址空间很大</li>
<li>栈一般是从高地址往低地址增长</li>
<li>堆一般是从低地址往高地址增长</li>
<li>末初始化数据段的内容并不存放在磁盘程序文件中，需要存放在磁盘程序文件中的段只有正文段和初始化数据段</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">size(1)&#21629;&#20196;&#25253;&#21578;&#27491;&#25991;&#27573;&#12289;&#25968;&#25454;&#27573;&#21644;bss&#27573;&#30340;&#38271;&#24230;(&#21333;&#20301;:&#23383;&#33410;)&#65306;</span>
$ size /usr/bin/cc /bin/sh
   text    data     bss     dec     hex filename
   7537     800       0    8337    2091 /usr/bin/cc
 712531   37360   18656  768547   bba23 /bin/sh
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8a4f818" class="outline-3">
<h3 id="org8a4f818">共享库</h3>
<div class="outline-text-3" id="text-org8a4f818">
<p>
现在很多UNIX系统支持共享库。共享库使得可执行文件中不再需要包含常用的库函数，而只需在所有进程都可存取的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态连接方法将程序与共享库函数相连接。这减少了每个可执行
文件的长度，但增加了一些运行时间开销。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑(假定参数的数目和类型都没有发生改变)
</p>
</div>
</div>

<div id="outline-container-org585ad9f" class="outline-3">
<h3 id="org585ad9f">动态内存管理</h3>
<div class="outline-text-3" id="text-org585ad9f">
</div>
<div id="outline-container-org1e92821" class="outline-4">
<h4 id="org1e92821">分配内存</h4>
<div class="outline-text-4" id="text-org1e92821">
<p>
ANSI C说明了三个用于存储空间动态分配的函数： 
</p>
<ol class="org-ol">
<li>malloc：分配指定字节数的存储区，此存储区中的初始值不确定</li>
<li>calloc：为指定长度的对象分配能容纳其指定个数的存储空间，该空间中的每一位(bit)都初始化为0</li>
<li><p>
realloc：更改以前分配区的长度(增加或减少)，当增加长度时可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26681;&#25454;&#25152;&#25351;&#23450;&#30340;size&#20998;&#37197;&#31354;&#38388;</span>

<span style="color: #ffebcd;">   size&#65306;&#20998;&#37197;&#31354;&#38388;&#22823;&#23567;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#26102;&#36820;&#22238;&#31354;&#38388;&#30340;&#39318;&#22336;&#65292;&#22833;&#36133;&#26102;&#36820;&#22238;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">malloc</span>(<span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20998;&#37197;nobj&#20010;size&#22823;&#23567;&#30340;&#36830;&#32493;&#31354;&#38388;</span>

<span style="color: #ffebcd;">   nobj&#65306;object&#25968;&#37327;</span>
<span style="color: #ffebcd;">   size&#65306;object&#22823;&#23567;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#26102;&#23558;&#35813;&#27573;&#20869;&#23384;&#20840;&#37096;&#28165;&#38646;&#24182;&#36820;&#22238;&#20854;&#39318;&#22336;&#65292;&#22833;&#36133;&#26102;&#36820;&#22238;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">calloc</span>(<span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">nobj</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">size</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20026;&#24050;&#20998;&#37197;&#30340;ptr&#37325;&#26032;&#20998;&#37197;&#19968;&#22359;&#22823;&#23567;&#20026;newsize&#30340;&#31354;&#38388;</span>

<span style="color: #ffebcd;">   ptr&#65306;&#24050;&#32463;&#20998;&#37197;&#30340;&#31354;&#38388;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   newsize&#65306;&#26032;&#30340;&#31354;&#38388;&#22823;&#23567;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#26102;&#36820;&#22238;&#31354;&#38388;&#30340;&#39318;&#22336;&#65292;&#22833;&#36133;&#26102;&#36820;&#22238;NULL;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">realloc</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">newsize</span>);
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgf307f3a" class="outline-4">
<h4 id="orgf307f3a">释放内存</h4>
<div class="outline-text-4" id="text-orgf307f3a">
<p>
free：释放ptr指向的存储空间
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#37322;&#25918;&#25351;&#23450;&#30340;ptr&#23545;&#24212;&#30340;&#22320;&#22336;&#31354;&#38388;</span>

<span style="color: #ffebcd;">   ptr&#65306;&#24050;&#32463;&#20998;&#37197;&#30340;&#22320;&#22336;&#31354;&#38388;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">free</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">ptr</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org306a232" class="outline-4">
<h4 id="org306a232">实现细节</h4>
<div class="outline-text-4" id="text-org306a232">
<ul class="org-ul">
<li>分配函数通常通过系统调用sbrk(2)实现来实现</li>
<li>分配函数所返回的指针一定是适当对齐的，遵守最苛刻的对齐要求，使其可用于任何数据对象</li>
<li>分配函数所返回的指针可用于任何指针，不需要强制转换</li>
<li>大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息：分配块的长度，指向下一个分配块的指针等等</li>
<li>free函数被释放的空间通常被送入可用存储区池，以后再调用分配函数时再分配，但是这并不会减小进程的存储开销，也就是说free释放的空间并不会返回给内核，供其他程序使用</li>
</ul>
</div>
</div>

<div id="outline-container-org857e77c" class="outline-4">
<h4 id="org857e77c">注意事项</h4>
<div class="outline-text-4" id="text-org857e77c">
<ul class="org-ul">
<li>分配函数返回的指针不应该参与任何指针运算</li>
<li>realloc可能会移动存储区，任何指向原来分配区内部的指针都可能失效</li>
<li>realloc的最后一个参数是存储区的newsize(新长度)，而不是新、旧长度之差</li>
<li>free调用完毕不会设置对应的ptr指针为NULL，若再次直接访问ptr指向的地址是不安全的操作</li>
<li>释放一个已经释放了的块和调用free时所用的指针不是三个alloc函数的返回值都会发生段异常</li>
<li>分配而不再使用的堆空间，应尽快通过free回收，否则会出现内存泄漏</li>
</ul>
</div>
</div>


<div id="outline-container-orgfd95812" class="outline-4">
<h4 id="orgfd95812">alloca函数</h4>
<div class="outline-text-4" id="text-orgfd95812">
<p>
alloca：类似于malloc，但是不是在堆上分配空间，而是在函数对应的栈内分配空间
</p>

<ul class="org-ul">
<li>优点：函数调用结束，自动释放</li>
<li>缺点：并不是所有系统都支持</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb79954d" class="outline-2">
<h2 id="orgb79954d">环境变量表</h2>
<div class="outline-text-2" id="text-orgb79954d">
<p>
每个程序都接收到一张环境表。与参数表类似，环境表也是一个字符指针数组，其中每个指针包含一个字符串的地址。全局变量environ则包含了该指针数组的地址
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">extern</span> <span style="color: #98f5ff;">char</span> **<span style="color: #4eee94;">environ</span>;
</pre>
</div>
<p>
如果该环境包含五个字符串，那么它看起来可能如图7-2中所示：
</p>

<div class="figure">
<p><img src="pic/env.png" alt="env.png" width="90%" />
</p>
</div>

<ul class="org-ul">
<li>环境指针：environ</li>
<li>环境表：environ指向的指针数组，以NULL结尾</li>
<li>环境变量：各指针指向的字符串，以'\0'结尾</li>
</ul>

<p>
按照惯例环境由:
</p>
<pre class="example">
name=value
</pre>
<p>
这样的字符串组成，这与图7-2中所示相同。大多数环境变量名完全由大写字母组成，但这也只是一个惯例
</p>
</div>

<div id="outline-container-org0c50bfc" class="outline-3">
<h3 id="org0c50bfc">常见环境变量</h3>
<div class="outline-text-3" id="text-org0c50bfc">
<p>
POSIX.1和XPG3定义了某些环境变量。表7-1列出了由这两个标准定义并受到SVR4和4.3+BSD支持的环境变量：
</p>
<!-- This HTML table template is generated by emacs 26.1 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;POSIX.1&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;XPG3&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;4.3+BSD&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;HOME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;初始目录&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LANG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;本地语言&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LC_ALL&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;本地编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_COLLATE&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;排序编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_CTYPE&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;输入编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_MONETARY
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;货币编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      LC_NUMERIC&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;数字编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LC_TIME&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;日期编码&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;LOGNAME&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;登录名&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      可执行文件搜<br />
      索路径&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;TERM&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;终端类型&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;TZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;本地时区&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-org706e7fb" class="outline-3">
<h3 id="org706e7fb">环境变量函数</h3>
<div class="outline-text-3" id="text-org706e7fb">
<p>
除了取环境变量值，有时也需要设置环境变量，或者是改变现有变量的值，或者是增加新的环境变量。但并不是所有系统都支持这种能力。表7-2列出了由不同的标准及实现支持的各种函数：
</p>
<!-- This HTML table template is generated by emacs 26.1 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;变量&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="3" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;ANSI&nbsp;C&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;POSIX.1&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;XPG3&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;SVR4&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;4.3+BSD&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;getenv&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;putenv&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可能&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;setenv&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;unsetenv&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;clearenv&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可能&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>

<div id="outline-container-org6b702aa" class="outline-4">
<h4 id="org6b702aa">getenv</h4>
<div class="outline-text-4" id="text-org6b702aa">
<p>
getenv：读取环境变量
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26681;&#25454;&#32473;&#23450;&#30340;&#29615;&#22659;&#21464;&#37327;&#21517;&#23383;&#36820;&#22238;&#20854;&#20540;</span>

<span style="color: #ffebcd;">   name&#65306;&#29615;&#22659;&#21464;&#37327;&#21517;</span>

<span style="color: #ffebcd;">   return&#65306;&#25351;&#21521;&#19982;name&#20851;&#32852;&#30340;value&#30340;&#25351;&#38024;&#65292;&#33509;&#26410;&#25214;&#21040;&#21017;&#20026;NULL</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">char</span> *<span style="color: #daa520; font-weight: bold;">getenv</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>);
</pre>
</div>
<p>
注意：应当使用getenv从环境中取一个环境变量的值，而不是直接存取environ指针！
</p>
</div>
</div>

<div id="outline-container-org6938206" class="outline-4">
<h4 id="org6938206">putsenv, setenv, unsetenv</h4>
<div class="outline-text-4" id="text-org6938206">
<p>
putenv：使用形式为name=value的字符串将其放到环境表中。如果name已经存在，则先删除其原来的定义
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#25226;&#21464;&#37327;&#25918;&#36827;&#29615;&#22659;&#34920;&#20013;</span>

<span style="color: #ffebcd;">   str&#65306;&#24418;&#24335;&#20026;name=value&#30340;&#23383;&#31526;&#20018;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">putenv</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">str</span>);
</pre>
</div>
<p>
setenv：设置名字为name的环境变量其值为value。如果在环境中name已经存在，那么：
</p>
<ul class="org-ul">
<li>若rewrite非0，则首先删除其现存的定义</li>
<li><p>
若rewrite为0，则不删除其现存定义(name不设置为新的value，而且也不出错)
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35774;&#32622;&#21517;&#23383;&#20026;name&#30340;&#29615;&#22659;&#21464;&#37327;&#20854;&#20540;&#20026;value</span>

<span style="color: #ffebcd;">   name&#65306;&#29615;&#22659;&#21464;&#37327;&#21517;&#23383;</span>
<span style="color: #ffebcd;">   value&#65306;&#35201;&#35774;&#32622;&#30340;&#29615;&#22659;&#21464;&#37327;&#20540;</span>
<span style="color: #ffebcd;">   rewrite&#65306;&#26159;&#21542;&#35206;&#30422;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setenv</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">value</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">rewrite</span>);
</pre>
</div>

<p>
unsetenv：删除环境变量名为name的定义。即使环境表中不存在对应的变量也不会出错
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35299;&#38500;&#29615;&#22659;&#21464;&#37327;&#23450;&#20041;</span>

<span style="color: #ffebcd;">   name&#65306;&#29615;&#22659;&#21464;&#37327;&#21517;</span>

<span style="color: #ffebcd;">   return&#65306;&#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">unsetenv</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>);
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgee72c38" class="outline-4">
<h4 id="orgee72c38">实现细节</h4>
<div class="outline-text-4" id="text-orgee72c38">
<p>
环境表(指向实际name=value字符串的指针数组)和环境字符串典型地存放在进程存储空间的顶部(栈之上)
</p>

<ol class="org-ol">
<li>删除：找到对应的字符串指针，然后将所有环境表中后面元素指向原来的下移一个位置</li>
<li>替换：
<ul class="org-ul">
<li>新value的长度少于或等于现存value的长度：只要在原字符串所用空间中写入新字符串</li>
<li>如果新value的长度大于原长度：必须调用malloc为新字符串分配空间，然后将新字符写入该空间中，最后使环境表中针对name的指针指向新分配区</li>
</ul></li>
<li>增加：首先调用malloc为name=value分配空间，然后将该字符串写入此空间中，然后：
<ul class="org-ul">
<li>第一次增加一个新name：必须调用malloc为新的指针表分配空间。将原来的环境表复制到新分配区，并将指向新name=value的指针存在该指针表的表尾，接着将一个NULL指针存在其后，最后使environ指向新指针表。这意味着环境表被移至堆中，但是此表中的大多数指针仍指向栈顶之上的各name=value字符串</li>
<li>这不是第一次增加一个新name：则可知以前已调用malloc在堆中为环境表分配了空间，所以只要调用realloc分配比原空间多存放一个指针的空间。然后将该指向新name=value字符串的指针存放在该表表尾，最后在后面跟着一个NULL指针</li>
</ul></li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-org69742e3" class="outline-2">
<h2 id="org69742e3">栈间跳转</h2>
<div class="outline-text-2" id="text-org69742e3">
</div>
<div id="outline-container-orgc74c368" class="outline-3">
<h3 id="orgc74c368">cmd_add</h3>
<div class="outline-text-3" id="text-orgc74c368">
<p>
先看以下程序的骨干部分：
</p>
<ol class="org-ol">
<li>主循环是从标准输入读一行，然后调用do_line处理</li>
<li>do_line该函数调用get_token从该输入行中取下一个记号
<ul class="org-ul">
<li>假设每一行中的第一个记号对应于某条命令，比如记号是'5'对应加法，就调用cmd_add函数</li>
<li>cmd_add函数继续调用get_token获得其余参数，最后执行的加法逻辑</li>
</ul></li>
</ol>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">TOK_ADD</span>    5

<span style="color: #98f5ff;">void</span>    <span style="color: #daa520; font-weight: bold;">do_line</span>(<span style="color: #98f5ff;">char</span> *);
<span style="color: #98f5ff;">void</span>    <span style="color: #daa520; font-weight: bold;">cmd_add</span>(<span style="color: #98f5ff;">void</span>);
<span style="color: #98f5ff;">int</span>     <span style="color: #daa520; font-weight: bold;">get_token</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>)
        do_line(line);
    exit(0);
}

<span style="color: #98f5ff;">char</span>    *<span style="color: #4eee94;">tok_ptr</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">global pointer for get_token() </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">do_line</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">ptr</span>)     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">process one line of input </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">cmd</span>;

    tok_ptr = ptr;
    <span style="color: #00bfff; font-weight: bold;">while</span> ((cmd = get_token()) &gt; 0) {
        <span style="color: #00bfff; font-weight: bold;">switch</span> (cmd) {  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">one case for each command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">case</span> TOK_ADD:
            cmd_add();
            <span style="color: #00bfff; font-weight: bold;">break</span>;
        }
    }
}

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cmd_add</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">token</span>;

    token = get_token();
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">rest of processing for this command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">get_token</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">fetch next token from line pointed to by tok_ptr </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
图7-4显示了调用了cmd_add之后栈的大致使用情况：
</p>

<div class="figure">
<p><img src="pic/stack.png" alt="stack.png" width="90%" />
</p>
</div>

<p>
自动变量的存储单元在每个函数的栈桢中。数组line在main的栈帧中，整型cmd在do_line的栈帧中，整型token在cmd_add的栈帧中
</p>

<p>
一个经常会遇到的问题是：如何处理非致命性的错误？例如cmd_add函数发现一个错误，比如说一个无效的数，那么它可能先打印一个出错消息，然后希望忽略输入行的余下部分，返回main函数并读下一输入行。如果不得不以检查返回值的方法逐层返回，那就会变得非常麻烦
</p>

<p>
解决这种问题的方法就是使用非局部跳转。这不是在一个函数内的普通的C语言goto语句，而是在栈上跳过若干调用帧返回到当前函数调用路径上的一个函数内
</p>
</div>
</div>

<div id="outline-container-org3acccd2" class="outline-3">
<h3 id="org3acccd2">setjmp, longjmp</h3>
<div class="outline-text-3" id="text-org3acccd2">
<ul class="org-ul">
<li>setjmp：栈定位信息保存到jmp_buf变量env中。jmp_buf是一种特殊数据类型，某种形式的数组，其中存放在调用longjmp时能用来恢复栈状态的所有信息，其中包括当初的寄存器上的值</li>
<li><p>
longjmp：跳转到保存好的变量env上，然后返回val。多个longjmp跳到同一个setjmp处时，就可以通过返回的不同val值进行区别
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35774;&#32622;&#19968;&#20010;&#20197;env&#20026;&#26631;&#35782;&#30340;&#26632;&#23450;&#20301;&#28857;</span>

<span style="color: #ffebcd;">   env&#65306;&#36339;&#36716;&#28857;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#30452;&#25509;&#35843;&#29992;&#21017;&#20026;0&#65292;&#33509;&#20174;longjmp&#36820;&#22238;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setjmp</span>(<span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">env</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20110;&#36339;&#36716;&#21040;env&#25152;&#23450;&#20301;&#30340;setjmp&#20989;&#25968;&#22788;</span>

<span style="color: #ffebcd;">   env&#65306;&#36339;&#36716;&#28857;</span>
<span style="color: #ffebcd;">   val&#65306;&#36339;&#36716;&#22238;&#21435;&#21518;setjmp&#30340;&#36820;&#22238;&#20540;</span>

<span style="color: #ffebcd;">   return&#65306;&#26080;&#36820;&#22238;</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">longjmp</span>(<span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">env</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">val</span>);
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-org227b37b" class="outline-4">
<h4 id="org227b37b">cmd_add2</h4>
<div class="outline-text-4" id="text-org227b37b">
<p>
main函数中设定跳转点jmpbuffer，其当前返回值是0
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">jmpbuffer</span>;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">line</span>[MAXLINE];

    <span style="color: #00bfff; font-weight: bold;">if</span> (setjmp(jmpbuffer) != 0)
        printf(<span style="color: #deb887;">"error"</span>);
    <span style="color: #00bfff; font-weight: bold;">while</span> (fgets(line, MAXLINE, stdin) != <span style="color: #ffd700;">NULL</span>)
        do_line(line);
    exit(0);
}
</pre>
</div>
<p>
在cmd_add2函数中如果出错，则使用longjmp跳转到jmpbuffer保存的栈定位点上，这时候setjmp返回的值是1，也就是cmd_add2中longjmp的第二个参数。同样我们可以在get_token函数内调用longjmp(jmpbuffer,2)，这使得main函数可以对不同的longjmp调用点进行区别对待 
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">cmd_add2</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">token</span>;

    token = get_token();
    <span style="color: #00bfff; font-weight: bold;">if</span> (token &lt; 0)      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">an error has occurred </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        longjmp(jmpbuffer, 1);
    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">rest of processing for this command </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc39560a" class="outline-3">
<h3 id="orgc39560a">volatile变量</h3>
<div class="outline-text-3" id="text-orgc39560a">
<p>
全局和静态变量的值在执行longjmp后保持不变。当发生跳转后，在main函数中的自动变量和寄存器变量的状态如何？当longjmp返回到main函数时，这些变量的值是否能恢复到以前调用setjmp时的值(即滚回原先值)，或者这些变量的值保持为调用do_line时的值(do_line调用cmd_add，cmd_add又调用longjmp)?
</p>

<p>
存放在寄存器内的变量会回滚到调用setjmp的时候，而存放在内存中的变量并不会回滚
</p>

<p>
如果有一个自动变量，而又不想使其值滚回，则必须定义其为volatile
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;setjmp.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f1</span>(<span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">int</span>, <span style="color: #98f5ff;">int</span>);
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f2</span>(<span style="color: #98f5ff;">void</span>);

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">jmp_buf</span> <span style="color: #4eee94;">jmpbuffer</span>;

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>) 
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">count</span>;
    <span style="color: #00bfff; font-weight: bold;">register</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">val</span>;
    <span style="color: #00bfff; font-weight: bold;">volatile</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">sum</span>;

    count = 2;
    val = 3;
    sum = 4;

    <span style="color: #00bfff; font-weight: bold;">if</span>(setjmp(jmpbuffer) != 0){
        printf(<span style="color: #deb887;">"atfer longjmp: count = %d, val = %d, sum = %d\n"</span>, count, val, sum);
        exit(0);
    }

    count = 97;
    val = 98;
    sum = 99;
    f1(count, val, sum);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f1</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">j</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">k</span>)
{
    printf(<span style="color: #deb887;">"in f1(): count = %d, val = %d, sum = %d\n"</span>, i, j, k);
    f2();
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">f2</span>(<span style="color: #98f5ff;">void</span>) 
{
    longjmp(jmpbuffer, 1);

}
</pre>
</div>

<p>
从下面测试代码可以看出：
</p>

<p>
不开启编译优化，哪怕寄存器变量都会被保存在内存中，跳转回来后这些变量都不回滚。而开启优化后只有volatile变量才保存在内存中，其他变量都可能被保存到寄存器中，这些变量往往都会回滚到原来的值
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#36866;&#29992;&#32534;&#35793;&#22120;&#20248;&#21270;&#30340;&#26102;&#20505;</span>
$ cc -o volatileExample1 volatileExample.c
$ ./volatileExample1 

<span style="color: #00bfff; font-weight: bold;">in</span> f1(): count = 97, val = 98, sum = 99
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#19981;&#20248;&#21270;&#30340;&#21464;&#37327;&#20445;&#23384;&#22312;&#20869;&#23384;&#20013;&#65292;&#36825;&#20123;&#21464;&#37327;&#19981;&#20250;&#22238;&#28378;&#65292;&#36824;&#26159;&#20462;&#25913;&#21518;&#30340;&#20540;</span>
atfer longjmp: count = 97, val = 98, sum = 99

<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;&#32534;&#35793;&#22120;&#20248;&#21270;&#30340;&#26102;&#20505;</span>
$ cc -O -o volatileExample2 volatileExample.c
$ ./volatileExample2

<span style="color: #00bfff; font-weight: bold;">in</span> f1(): count = 97, val = 98, sum = 99
<span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#32534;&#35793;&#20248;&#21270;&#21518;&#21464;&#37327;&#20250;&#23613;&#37327;&#20445;&#23384;&#21040;&#23492;&#23384;&#22120;&#65292;&#33258;&#21160;&#12289;&#23492;&#23384;&#22120;&#21464;&#37327;&#23558;&#22238;&#28378;&#21040;&#21407;&#26469;&#65292;&#20294;&#26159;volatile&#21464;&#37327;&#36824;&#26159;&#20351;&#29992;&#20462;&#25913;&#21518;&#30340;&#65292;&#22240;&#20026;volaile&#21464;&#37327;&#27704;&#36828;&#20445;&#23384;&#22312;&#20869;&#23384;&#20013;</span>
atfer longjmp: count = 2, val = 3, sum = 99
</pre>
</div>

<p>
如果要编写可移植的非局部跳转，则必须使用volatile属性！
</p>
</div>
</div>

<div id="outline-container-orgb41c9f7" class="outline-3">
<h3 id="orgb41c9f7">自动变量陷阱</h3>
<div class="outline-text-3" id="text-orgb41c9f7">
<p>
open_data的函数：打开了一个标准I/O流，然后为该流设置缓存
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span>    <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">DATAFILE</span>    <span style="color: #deb887;">"datafile"</span>

<span style="color: #98f5ff;">FILE</span> *<span style="color: #daa520; font-weight: bold;">open_data</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">FILE</span>    *<span style="color: #4eee94;">fp</span>;
    <span style="color: #98f5ff;">char</span>    <span style="color: #4eee94;">databuf</span>[BUFSIZ];  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">setvbuf makes this the stdio buffer </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fp = fopen(DATAFILE, <span style="color: #deb887;">"r"</span>)) == <span style="color: #ffd700;">NULL</span>)
        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (setvbuf(fp, databuf, _IOLBF, BUFSIZ) != 0)
        <span style="color: #00bfff; font-weight: bold;">return</span>(<span style="color: #ffd700;">NULL</span>);
    <span style="color: #00bfff; font-weight: bold;">return</span>(fp);     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">error </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
当open_data返回时，它在栈上所使用的空间将由下一个被调用函数的栈帧使用。但是标准I/O库函数仍将使用原先为databuf在栈上分配的存储空间作为该流的缓存。这就产生了冲突和混乱
</p>

<p>
因此自动变量的函数已经返回后，必须不再引用这些自动变量。如果还需这些变量，那就用全局变量(extern)，静态变量(static)或者使用堆上的动态分配内存(malloc/calloc&#x2026;)
</p>
</div>
</div>
</div>

<div id="outline-container-org699fdf7" class="outline-2">
<h2 id="org699fdf7">资源限制</h2>
<div class="outline-text-2" id="text-org699fdf7">
<ul class="org-ul">
<li>getrlimit：查询进程的资源限制</li>
<li>setrlimit：更改进程的资源限制</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/resource.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#26597;&#35810;&#36164;&#28304;&#38480;&#21046;</span>

<span style="color: #ffebcd;">   resource&#65306;&#20195;&#34920;&#36164;&#28304;&#30340;&#24120;&#37327;</span>
<span style="color: #ffebcd;">   rlptr&#65306;&#36164;&#28304;&#38480;&#21046;&#32467;&#26500;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#22833;&#36133;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">getrlimit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">resource</span>, <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span> *<span style="color: #4eee94;">rlptr</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20462;&#25913;&#36164;&#28304;&#38480;&#21046;</span>

<span style="color: #ffebcd;">   resource&#65306;&#20195;&#34920;&#36164;&#28304;&#30340;&#24120;&#37327;</span>
<span style="color: #ffebcd;">   rlptr&#65306;&#36164;&#28304;&#38480;&#21046;&#32467;&#26500;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#22833;&#36133;&#21017;&#20026;&#38750;0</span>
<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">setrlimit</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">resource</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span> *<span style="color: #4eee94;">rlptr</span>);
</pre>
</div>
</div>

<div id="outline-container-org813902e" class="outline-3">
<h3 id="org813902e">resource常量</h3>
<div class="outline-text-3" id="text-org813902e">
<p>
resource参数取下列值之一，注意：并非所有资源限制都受到每个系统的支持
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 资源限制常量</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">资源常量名</td>
<td class="org-left">支持系统</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">RLIMIT_CORE</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">core文件的最大字节数，若其值为0则阻止创建core文件</td>
</tr>

<tr>
<td class="org-left">RLIMIT_CPU</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">CPU时间的最大量值(秒)，当超过此软限制时，向该进程发送SIGXCPU信号</td>
</tr>

<tr>
<td class="org-left">RLIMIT_DATA</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">数据段的最大字节长度。初始化数据、非初始化数据以及堆的总和</td>
</tr>

<tr>
<td class="org-left">RLIMIT_FSIZE</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">可以创建的文件的最大字节长度。当超过此软限制时，则向该进程发送SIGXFSZ信号</td>
</tr>

<tr>
<td class="org-left">RLIMIT_MEMLOCK</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">锁定在存储器地址空间(尚未实现)</td>
</tr>

<tr>
<td class="org-left">RLIMIT_NOFILE</td>
<td class="org-left">SVR4</td>
<td class="org-left">每个进程能打开的最多文件数</td>
</tr>

<tr>
<td class="org-left">RLIMIT_NPROC</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">每个实际用户ID所拥有的最大子进程数</td>
</tr>

<tr>
<td class="org-left">RLIMIT_OFILE</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">与RLIMIT_NOFILE相同</td>
</tr>

<tr>
<td class="org-left">RLIMIT_RSS</td>
<td class="org-left">4.3+BSD</td>
<td class="org-left">最大驻内存集字节长度(RSS)</td>
</tr>

<tr>
<td class="org-left">RLIMIT_STACK</td>
<td class="org-left">SVR4及4.3+BSD</td>
<td class="org-left">栈的最大字节长度</td>
</tr>

<tr>
<td class="org-left">RLIMIT_VMEM</td>
<td class="org-left">SVR4</td>
<td class="org-left">可映照地址空间的最大字节长度</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org2b0cb10" class="outline-3">
<h3 id="org2b0cb10">rlimit结构</h3>
<div class="outline-text-3" id="text-org2b0cb10">
<p>
在更改资源限制时，须遵循下列三条规则：
</p>
<ol class="org-ol">
<li>任何一个进程都可将一个软限制更改为小于或等于其硬限制</li>
<li>任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低对普通用户而言是不可逆反的</li>
<li><p>
只有超级用户可以提高硬限制
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span> {
    <span style="color: #98f5ff;">rlim_t</span> <span style="color: #4eee94;">rlim_cur</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">soft limit: current limit </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">rlim_t</span> <span style="color: #4eee94;">rlim_max</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">hard limit: maximum value for rlim_cur </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div></li>
</ol>
<p>
一个无限量的限制由常数RLIM_INFINITY指定    
</p>
</div>
</div>
<div id="outline-container-orgef2cfed" class="outline-3">
<h3 id="orgef2cfed">实例</h3>
<div class="outline-text-3" id="text-orgef2cfed">
<p>
打印linux系统支持的某些进程资源的当前软限制和硬限制：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/resource.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">FMT</span> <span style="color: #deb887;">"%10ld  "</span>
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">doit</span>(<span style="color: #4eee94;">name</span>)  pr_limits(#name, name)

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_limits</span>(<span style="color: #98f5ff;">char</span> *, <span style="color: #98f5ff;">int</span>);

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_AS
    doit(RLIMIT_AS);
<span style="color: #ffd700;">#endif</span>
    doit(RLIMIT_CORE);
    doit(RLIMIT_CPU);
    doit(RLIMIT_DATA);
    doit(RLIMIT_FSIZE);
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_LOCKS
    doit(RLIMIT_LOCKS);
<span style="color: #ffd700;">#endif</span>
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_MEMLOCK
    doit(RLIMIT_MEMLOCK);
<span style="color: #ffd700;">#endif</span>
    doit(RLIMIT_NOFILE);
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_NPROC
    doit(RLIMIT_NPROC);
<span style="color: #ffd700;">#endif</span>
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_RSS
    doit(RLIMIT_RSS);
<span style="color: #ffd700;">#endif</span>
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_SBSIZE
    doit(RLIMIT_SBSIZE);
<span style="color: #ffd700;">#endif</span>
    doit(RLIMIT_STACK);
<span style="color: #ffd700;">#ifdef</span>  RLIMIT_VMEM
    doit(RLIMIT_VMEM);
<span style="color: #ffd700;">#endif</span>
    exit(0);
}

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">pr_limits</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">resource</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">rlimit</span>   <span style="color: #4eee94;">limit</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (getrlimit(resource, &amp;limit) &lt; 0)
        err_sys(<span style="color: #deb887;">"getrlimit error for %s"</span>, name);
    printf(<span style="color: #deb887;">"%-14s  "</span>, name);
    <span style="color: #00bfff; font-weight: bold;">if</span> (limit.rlim_cur == RLIM_INFINITY)
        printf(<span style="color: #deb887;">"(infinite)  "</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span>
        printf(FMT, limit.rlim_cur);
    <span style="color: #00bfff; font-weight: bold;">if</span> (limit.rlim_max == RLIM_INFINITY)
        printf(<span style="color: #deb887;">"(infinite)"</span>);
    <span style="color: #00bfff; font-weight: bold;">else</span>
        printf(FMT, limit.rlim_max);
    putchar((<span style="color: #98f5ff;">int</span>)<span style="color: #deb887;">'\n'</span>);
}
</pre>
</div>
<p>
运行结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/environ/rlimitExample

<span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">&#36164;&#28304;&#21517;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#36719;&#38480;&#21046;&#12288;&#12288;&#12288;&#12288;&#30828;&#38480;&#21046;</span>
<span style="color: #daa520; font-weight: bold;">RLIMIT_AS</span>       (infinite)  (infinite)
RLIMIT_CORE              0  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_CPU</span>      (infinite)  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_DATA</span>     (infinite)  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_FSIZE</span>    (infinite)  (infinite)
<span style="color: #daa520; font-weight: bold;">RLIMIT_LOCKS</span>    (infinite)  (infinite)
RLIMIT_MEMLOCK       65536       65536  
RLIMIT_NOFILE         1024        4096  
RLIMIT_NPROC         15591       15591  
<span style="color: #daa520; font-weight: bold;">RLIMIT_RSS</span>      (infinite)  (infinite)
RLIMIT_STACK       8388608  (infinite)
</pre>
</div>

<p>
资源限制影响到调用进程并由其子进程继承，这就意味着为了影响一个用户的所有后续进程，需要将进程资源放在shell中进行。事实上sh，bash也都具有ulimit(1)命令来查看和修改进程资源限制：　
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ulimit -a <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#26597;&#30475;&#25152;&#26377;bash&#19979;&#30340;&#36827;&#31243;&#36164;&#28304;&#38480;&#21046;</span>
core file size          (blocks, -c) 0 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_CORE</span>
data seg size           (kbytes, -d) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_DATA</span>
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_FSIZE</span>
pending signals                 (-i) 15591 
max locked memory       (kbytes, -l) 64 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_MEMLOCK</span>
max memory size         (kbytes, -m) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_RSS</span>
open files                      (-n) 1024 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_NOFILE</span>
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_STACK</span>
cpu time               (seconds, -t) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_CPU</span>
max user processes              (-u) 15591 <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_NPROC</span>
virtual memory          (kbytes, -v) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_AS</span>
file locks                      (-x) unlimited <span style="color: #5f9ea0; font-style: italic;"># </span><span style="color: #5f9ea0; font-style: italic;">RLIMIT_LOCKS</span>
</pre>
</div>

<p>
<a href="process.html">Next：进程控制</a>
</p>

<p>
<a href="system_file.html">Previous：系统文件</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
