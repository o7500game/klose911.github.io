<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>文件和目录</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="standard.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">文件和目录</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">stat、fstat和lstat函数</a>
<ul>
<li><a href="#sec-1-1">stat结构</a></li>
</ul>
</li>
<li><a href="#sec-2">文件类型</a>
<ul>
<li><a href="#sec-2-1">文件类型测试宏</a></li>
</ul>
</li>
<li><a href="#sec-3">文件权限</a>
<ul>
<li><a href="#sec-3-1">进程相关的用户和组ID</a></li>
<li><a href="#sec-3-2">设置-用户-ID和设置-组-ID</a></li>
<li><a href="#sec-3-3">文件存取许可权</a>
<ul>
<li><a href="#sec-3-3-1">存取权限规则</a></li>
<li><a href="#sec-3-3-2">存取权限测试</a></li>
<li><a href="#sec-3-3-3">新文件和目录的所有权</a></li>
</ul>
</li>
<li><a href="#sec-3-4">access函数</a>
<ul>
<li><a href="#sec-3-4-1">mode参数</a></li>
<li><a href="#sec-3-4-2">access函数实例</a></li>
</ul>
</li>
<li><a href="#sec-3-5">umask函数</a>
<ul>
<li><a href="#sec-3-5-1">umask实例</a></li>
</ul>
</li>
<li><a href="#sec-3-6">chmod和fchmod函数</a>
<ul>
<li><a href="#sec-3-6-1">mode参数</a>
<ul>
<li><a href="#sec-3-6-1-1">S_ISVTX</a></li>
</ul>
</li>
<li><a href="#sec-3-6-2">chmod实例</a></li>
<li><a href="#sec-3-6-3">自动忽略某些权限常数</a></li>
</ul>
</li>
<li><a href="#sec-3-7">chown, fchown和lchown函数</a>
<ul>
<li><a href="#sec-3-7-1">chown限制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">文件长度</a>
<ul>
<li><a href="#sec-4-1">st_blksize和st_blocks</a></li>
<li><a href="#sec-4-2">文件空洞</a></li>
<li><a href="#sec-4-3">truncate和ftruncate函数</a></li>
</ul>
</li>
<li><a href="#sec-5">文件系统</a>
<ul>
<li><a href="#sec-5-1">i节点</a></li>
<li><a href="#sec-5-2">目录项</a></li>
<li><a href="#sec-5-3">数据块</a></li>
<li><a href="#sec-5-4">连接</a>
<ul>
<li><a href="#sec-5-4-1">硬连接</a></li>
<li><a href="#sec-5-4-2">符号连接</a></li>
<li><a href="#sec-5-4-3">目录连接</a></li>
</ul>
</li>
<li><a href="#sec-5-5">link函数</a></li>
<li><a href="#sec-5-6">unlink函数</a>
<ul>
<li><a href="#sec-5-6-1">删除文件</a></li>
<li><a href="#sec-5-6-2">unlink实例</a></li>
</ul>
</li>
<li><a href="#sec-5-7">remove函数</a></li>
<li><a href="#sec-5-8">rename函数</a></li>
<li><a href="#sec-5-9">符号连接</a>
<ul>
<li><a href="#sec-5-9-1">函数对符号连接的处理</a></li>
<li><a href="#sec-5-9-2">符号连接循环</a></li>
</ul>
</li>
<li><a href="#sec-5-10">symlink函数</a></li>
<li><a href="#sec-5-11">readlink函数</a></li>
</ul>
</li>
<li><a href="#sec-6">文件的时间</a></li>
</ul>
</div>
</div>
<p>
首先从stat函数开始逐个说明stat结构的每一个成员以了解文件的所有属性，然后将说明修改这些属性的各个函数(更改所有者,更改许可权等)，接着更详细地察看UNIX文件系统的结构以及符号连接，最后介绍对目录进行操作的各个函数并且开发了一个以降序遍历目录层次结构的函数
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">stat、fstat和lstat函数</h2>
<div class="outline-text-2" id="text-1">
<p>
获取一个文件的详细信息可以使用stat函数组：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#26681;&#25454;&#25991;&#20214;&#36335;&#24452;&#21517;&#33719;&#21462;&#25991;&#20214;&#30340;&#35814;&#32454;&#20449;&#24687;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   buf&#65306;&#25351;&#21521;&#25991;&#20214;&#20449;&#24687;&#32467;&#26500;&#20307;stat&#21464;&#37327;&#30340;&#25351;&#38024;</span>

<span style="color: #ffa07a;">   &#36820;&#22238;&#65306;&#27491;&#30830;&#36820;&#22238;0&#65292;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">stat</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span>* <span style="color: #eedd82;">buf</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#26681;&#25454;&#25991;&#20214;&#25551;&#36848;&#31526;&#33719;&#21462;&#25991;&#20214;&#30340;&#35814;&#32454;&#20449;&#24687;</span>

<span style="color: #ffa07a;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;&#21495;</span>
<span style="color: #ffa07a;">   buf&#65306;&#25351;&#21521;&#25991;&#20214;&#20449;&#24687;&#32467;&#26500;&#20307;stat&#21464;&#37327;&#30340;&#25351;&#38024;</span>

<span style="color: #ffa07a;">   &#36820;&#22238;&#65306;&#27491;&#30830;&#36820;&#22238;0&#65292;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fstat</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">filedes</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span>* <span style="color: #eedd82;">buf</span>);  


<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#36820;&#22238;&#38142;&#25509;&#25991;&#20214;&#30340;&#26377;&#20851;&#20449;&#24687;,&#32780;&#19981;&#26159;&#30001;&#35813;&#38142;&#25509;&#24341;&#29992;&#30340;&#25991;&#20214;&#30340;&#20449;&#24687;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   buf&#65306;&#25351;&#21521;&#25991;&#20214;&#20449;&#24687;&#32467;&#26500;&#20307;stat&#21464;&#37327;&#30340;&#25351;&#38024;</span>

<span style="color: #ffa07a;">   &#36820;&#22238;&#65306;&#27491;&#30830;&#36820;&#22238;0&#65292;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">lstat</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span>* <span style="color: #eedd82;">buf</span>);
</pre>
</div>
<p>
使用stat函数最多的可能是ls -l命令，用其可以获得有关一个文件的所有信息
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">stat结构</h3>
<div class="outline-text-3" id="text-1-1">
<p>
stat结构给出了Unix下文件(目录)各种属性的相关信息
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span>  
{  
    <span style="color: #98fb98;">mode_t</span> <span style="color: #eedd82;">st_mode</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25991;&#20214;&#30340;&#31867;&#22411;&#21644;&#26435;&#38480;  </span>
    <span style="color: #98fb98;">ino_t</span> <span style="color: #eedd82;">st_ino</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">inode&#30340;&#33410;&#28857;&#21495;  </span>
    <span style="color: #98fb98;">dev_t</span> <span style="color: #eedd82;">st_dev</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#35774;&#22791;&#21495;  </span>
    <span style="color: #98fb98;">dev_t</span> <span style="color: #eedd82;">st_rdev</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#29305;&#27530;&#35774;&#22791;&#21495;  </span>
    <span style="color: #98fb98;">nlink_t</span> <span style="color: #eedd82;">st_nlink</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36830;&#25509;&#25968;  </span>
    <span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">st_uid</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25991;&#20214;&#25152;&#26377;&#32773;  </span>
    <span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">st_gid</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25991;&#20214;&#25152;&#23646;&#32452;  </span>
    <span style="color: #98fb98;">off_t</span> <span style="color: #eedd82;">st_st_size</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25991;&#20214;&#30340;&#23383;&#33410;&#25968;  </span>
    <span style="color: #98fb98;">time_t</span> <span style="color: #eedd82;">st_atime</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25991;&#20214;&#30340;&#26368;&#21518;&#23384;&#21462;&#26102;&#38388;  </span>
    <span style="color: #98fb98;">time_t</span> <span style="color: #eedd82;">mtime</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25991;&#20214;&#30340;&#26368;&#21518;&#20462;&#25913;&#26102;&#38388;  </span>
    <span style="color: #98fb98;">time_t</span> <span style="color: #eedd82;">ctime</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25991;&#20214;&#26435;&#38480;&#30340;&#26368;&#21518;&#20462;&#25913;&#26102;&#38388;  </span>
    <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">st_blksize</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#26368;&#20339;&#30340;IO&#22359;&#38271;&#24230;  </span>
    <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">st_blocks</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">512&#23383;&#33410;&#30340;&#22359;&#25968;  </span>
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">文件类型</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>普通文件
</li>
<li>目录
</li>
<li>字符特殊设备：某些类型的设备，终端等
</li>
<li>块特殊设备：磁盘设备
</li>
<li>FIFO管道：进程间的通信
</li>
<li>Socket套接字：主要是进程间的网络通信，也可以是同一台机器不同进程间通信
</li>
<li>符号链接：文件指向另一个文件
</li>
</ol>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">文件类型测试宏</h3>
<div class="outline-text-3" id="text-2-1">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader　">
<caption class="t-above"><span class="table-number">Table 1:</span> &lt;sys/stat.h&gt;中的文件类型宏</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">宏</td>
<td class="left">文件类型</td>
</tr>

<tr>
<td class="left">S_ISREG()</td>
<td class="left">普通文件</td>
</tr>

<tr>
<td class="left">S_ISDIR()</td>
<td class="left">目录文件</td>
</tr>

<tr>
<td class="left">S_ISCHR()</td>
<td class="left">字符特殊文件</td>
</tr>

<tr>
<td class="left">S_ISBLK()</td>
<td class="left">块特殊文件</td>
</tr>

<tr>
<td class="left">S_ISFIFO()</td>
<td class="left">管道或FIFO</td>
</tr>

<tr>
<td class="left">S_ISLNK()</td>
<td class="left">符号连接</td>
</tr>

<tr>
<td class="left">S_ISSOCK()</td>
<td class="left">套接字</td>
</tr>
</tbody>
</table>

<p>
文件类型信息包含在stat解构的st_mode成员内，以其为参数调用以下宏进行测试，如果返回为真则说明是此种文件类型
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span> 
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span> 

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) 
{
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; 
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> <span style="color: #eedd82;">buf</span>; 
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">ptr</span>; 

    <span style="color: #00ffff;">for</span>(i = 1; i &lt; argc; ++i) { 
        printf(<span style="color: #ffa07a;">"%s: "</span>, argv[i]);
        <span style="color: #00ffff;">if</span>(lstat(argv[i], &amp;buf) &lt; 0) {
            err_ret(<span style="color: #ffa07a;">"lstat error"</span>); 
            <span style="color: #00ffff;">continue</span>; 
        }
        <span style="color: #00ffff;">if</span>(S_ISREG(buf.st_mode))
            ptr = <span style="color: #ffa07a;">"regular"</span>; 
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(S_ISDIR(buf.st_mode)) 
            ptr = <span style="color: #ffa07a;">"directory"</span>; 
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(S_ISCHR(buf.st_mode)) 
            ptr = <span style="color: #ffa07a;">"character special"</span>; 
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(S_ISBLK(buf.st_mode)) 
            ptr = <span style="color: #ffa07a;">"block special"</span>; 
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(S_ISFIFO(buf.st_mode)) 
            ptr = <span style="color: #ffa07a;">"fifo"</span>; 
<span style="color: #7fffd4;">#ifdef</span> S_ISLNK 
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(S_ISLNK(buf.st_mode)) 
            ptr = <span style="color: #ffa07a;">"symbolic link"</span>; 
<span style="color: #7fffd4;">#endif</span> 
<span style="color: #7fffd4;">#ifdef</span> S_ISSOCK
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(S_ISSOCK(buf.st_mode)) 
            ptr = <span style="color: #ffa07a;">"socket"</span>; 
<span style="color: #7fffd4;">#endif</span> 
        <span style="color: #00ffff;">else</span> 
            ptr = <span style="color: #ffa07a;">"** unknown mode **"</span>;

        printf(<span style="color: #ffa07a;">"%s\n"</span>, ptr); 
    }

    exit(0);
}
</pre>
</div>

<p>
测试文件类型
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./filetype ./filetype.c ./filetype.o ./ /dev/sda1 /dev/tty1 /dev/log /dev/fd/0

./filetype.c: regular
./filetype.o: regular
./: directory
/dev/sda1: block special
/dev/tty1: character special
/dev/log: socket
/dev/fd/0: symbolic link
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">文件权限</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">进程相关的用户和组ID</h3>
<div class="outline-text-3" id="text-3-1">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 与一个进程相关联的用户ID和组ID</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">ID类型</th>
<th scope="col" class="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">实际用户ID, 实际组ID</td>
<td class="left">我们实际上是谁</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">有效用户ID，有效组ID，添加组ID</td>
<td class="left">用于文件存取许可权检查</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">保存设置-用户-ID，保存-设置-组ID</td>
<td class="left">由exec函数保存</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>实际用户ID和实际组ID这两个字段在登录时取自口令文件中的登录项。通常在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们
</li>
<li>有效用户ID，有效组ID以及添加组ID决定了文件访问权
</li>
<li>保存的设置-用户-ID和设置-组-ID在执行一个程序时包含了有效用户ID和有效组ID的副本
</li>
</ul>

<p>
通常有效用户ID等于实际用户ID，有效组ID等于实际组ID
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">设置-用户-ID和设置-组-ID</h3>
<div class="outline-text-3" id="text-3-2">
<p>
每个文件有一个所有者和组所有者。所有者由stat结构中的st_uid表示，组所有者则由st_gid成员表示。 
</p>

<p>
当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组ID。但是可以在st_mode中设置一个特殊标志，其定义是“当执行此文件时，将进程的有效用户ID设置为文件的所有者(st_uid)”。与此相类似，在文件方式字中可以设置另一位,它使得执行此文件的进程的有效组ID设置为文件的组所有者(st_gid)。这两位被称之为设置-用户-ID(set-user-ID)位和设置-组-ID(set-group-ID)位。这两位可用常数S_ISUID和S_ISGID测试
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">文件存取许可权</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Unix对文件定义了三组用户权限，分别对应为属主用户(user)、组用户(group)、其它用户(other)，每组用户各有自己对此文件的读、写、执行权限。权限值以八进制的形式表示,也记录在stat结构的st_mode字段中
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="groups" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 9个存取许可权位</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">st_mode mask</th>
<th scope="col" class="left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">S_IRUSR</td>
<td class="left">用户读</td>
</tr>

<tr>
<td class="left">S_IWUSR</td>
<td class="left">用户写</td>
</tr>

<tr>
<td class="left">S_IXUSR</td>
<td class="left">用户执行</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">S_IRGRP</td>
<td class="left">组读</td>
</tr>

<tr>
<td class="left">S_IWGRP</td>
<td class="left">组写</td>
</tr>

<tr>
<td class="left">S_IXGRP</td>
<td class="left">组执行</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">S_IROTH</td>
<td class="left">其他用户读</td>
</tr>

<tr>
<td class="left">S_IWOTH</td>
<td class="left">其他用户写</td>
</tr>

<tr>
<td class="left">S_IXOTH</td>
<td class="left">其他用户执行</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">存取权限规则</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行许可权。
</li>
<li>对于一个文件的读许可权决定了是否能够打开该文件进行读操作。这对应于open函数的O_RDONLY和O_RDWR标志
</li>
<li>对于一个文件的写许可权决定了我们是否能够打开该文件进行写操作。这对应于open函数的O_WRONLY和O_RDWR标志
</li>
<li>为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写许可权
</li>
<li>为了在一个目录中创建一个新文件，必须对该目录具有写许可权和执行许可权
</li>
<li>为了删除一个文件，必须对包含该文件的目录具有写许可权和执行许可权。对该文件本身则不需要有读、写许可权
</li>
<li>如果用6个exec函数中的任何一个执行某个文件，都必须对该文件具有执行许可权
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">存取权限测试</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
适当的存取许可权位指的是： 
</p>
<ul class="org-ul">
<li>若进程为读而打开该文件，则相应读位应为1
</li>
<li>若进程为写而打开该文件，则相应写位应为1
</li>
<li>若进程将执行该文件，则相应执行位应为1
</li>
</ul>

<p>
进程每次打开、创建或删除一个文件时，内核就进行文件存取许可权测试，而这种测试可能涉及文件的所有者(st_uid和st_gid)，进程的有效ID(有效用户ID和有效组ID)以及进程的添加组ID(若支持的话)。两个所有者ID是文件的性质，而有效ID和添加组ID则是进程的性质。内核进行的测试是:
</p>
<ol class="org-ol">
<li>若进程的有效用户ID是0(超级用户)，则允许存取。这给予了超级用户对文件系统进行处理的最充分的自由
</li>
<li>若进程的有效用户ID等于文件的所有者ID(也就是该进程拥有此文件):
<ul class="org-ul">
<li>若适当的所有者存取许可权位被设置，则允许存取
</li>
<li>否则拒绝存取 
</li>
</ul>
</li>
<li>若进程的有效组ID或进程的添加组ID之一等于文件的组ID:
<ul class="org-ul">
<li>若适当的组存取许可权位被设置，则允许存取
</li>
<li>否则拒绝存取 
</li>
</ul>
</li>
<li>若适当的其他用户存取许可权位被设置，则允许存取，否则拒绝存取
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">新文件和目录的所有权</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
创建新文件和目录的用户ID被设置为进程的有效用户ID
</p>

<p>
关于组ID，POSIX.1允许选择下列之一作为新文件和目录的组ID： 
</p>
<ol class="org-ol">
<li>新文件的组ID可以是进程的有效组ID
</li>
<li>新文件的组ID可以是它所在目录的组ID
</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">access函数</h3>
<div class="outline-text-3" id="text-3-4">
<p>
access函数：按实际用户ID和实际组ID测试存取权限
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#25353;&#23454;&#38469;&#29992;&#25143;ID&#21644;&#23454;&#38469;&#32452;ID&#36827;&#34892;&#23384;&#21462;&#35768;&#21487;&#26435;&#27979;&#35797;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#21517;&#36335;&#24452;</span>
<span style="color: #ffa07a;">   mode: &#23384;&#21462;&#26435;&#38480;</span>

<span style="color: #ffa07a;">   return: &#33509;&#25317;&#26377;&#26435;&#38480;&#21017;&#20026;0&#65292;&#26080;&#26435;&#38480;&#25110;&#20986;&#38169;&#21017;&#20026;-1&#65292;&#26681;&#25454;errorno&#36827;&#34892;&#21028;&#26029;</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">access</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pathname</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mode</span>);
</pre>
</div>
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">mode参数</h4>
<div class="outline-text-4" id="text-3-4-1">
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> access函数中的mode常数，取自&lt;unistd.h&gt;</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">mode</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">R_OK</td>
<td class="left">测试读许可权</td>
</tr>

<tr>
<td class="left">W_OK</td>
<td class="left">测试写许可权</td>
</tr>

<tr>
<td class="left">X_OK</td>
<td class="left">测试执行许可权</td>
</tr>

<tr>
<td class="left">F_OK</td>
<td class="left">测试文件是否存在</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">access函数实例</h4>
<div class="outline-text-4" id="text-3-4-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[]) 
{
    <span style="color: #00ffff;">if</span>(argc != 2) 
        err_quit(<span style="color: #ffa07a;">"usage: a.out &lt;pathname&gt;"</span>); 

    <span style="color: #00ffff;">if</span>(access(argv[1], R_OK) &lt; 0) 
        err_ret(<span style="color: #ffa07a;">"access error for %s"</span>, argv[1]); 
    <span style="color: #00ffff;">else</span> 
        printf(<span style="color: #ffa07a;">"read access OK\n"</span>);

    <span style="color: #00ffff;">if</span>(open(argv[1], O_RDONLY) &lt; 0) 
        err_ret(<span style="color: #ffa07a;">"open error for %s"</span>, argv[1]); 
    <span style="color: #00ffff;">else</span> 
        printf(<span style="color: #ffa07a;">"open for reading OK\n"</span>);

    exit(0);
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">umask函数</h3>
<div class="outline-text-3" id="text-3-5">
<p>
umask函数为进程设置文件方式创建mask值。当该进程结束时，mask值仍保持原来系统中的值不变
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/type.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20026;&#36827;&#31243;&#35774;&#32622;&#25991;&#20214;&#26041;&#24335;&#21019;&#24314;&#23631;&#34109;&#23383;,&#24182;&#36820;&#22238;&#20197;&#21069;&#30340;&#20540;</span>

<span style="color: #ffa07a;">   cmask&#65306;&#35774;&#32622;&#36827;&#31243;&#30340;mask&#20540;&#65292;&#30001;&#34920;4-4&#20013;&#30340;9&#20010;&#24120;&#25968;(S_IRUSR,S_IWUSR&#31561;)&#36880;&#20301;&#8220;&#25110;&#8221;&#26500;&#25104;&#30340;</span>

<span style="color: #ffa07a;">   return&#65306;&#36820;&#22238;&#24403;&#21069;&#36827;&#31243;&#30340;mask&#20540;&#65292;&#26080;&#20986;&#38169;&#36820;&#22238;</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">mode_t</span> <span style="color: #87cefa;">umask</span>(<span style="color: #98fb98;">mode_t</span> <span style="color: #eedd82;">cmask</span>);
</pre>
</div>
<p>
从创建文件时指定的权限中减掉umask中指定的权限。比如进程创建文件时指定的用户权限是:777(rwxrwxrwx)，而指定的umask指定的值是022，则该进程创建的文件的权限就是755(rwxr-xr-x)
</p>
</div>

<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">umask实例</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
创建第一个时umask值为0，创建第二个时umask值禁止所有组和其他存取许可权。结果是第一个文件的权限是rw-rw-rw-，第二个权限是rw- &#x2014; &#x2014;
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    umask(0); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">foo&#30340;&#26435;&#38480;&#26159;666</span>
    <span style="color: #00ffff;">if</span>(creat(<span style="color: #ffa07a;">"foo"</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"creat error for foo"</span>);

    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">bar&#30340;&#26435;&#38480;&#26159;600</span>
    <span style="color: #00ffff;">if</span>(creat(<span style="color: #ffa07a;">"bar"</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"creat error for bar"</span>);

    exit(0);

}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">chmod和fchmod函数</h3>
<div class="outline-text-3" id="text-3-6">
<p>
chmod/fchmod函数：改变文件访问权限
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#26681;&#25454;&#25991;&#20214;&#36335;&#24452;&#21517;&#25913;&#21464;&#25991;&#20214;&#23384;&#21462;&#26435;&#38480;</span>

<span style="color: #ffa07a;">   filename&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   mode_t&#65306;&#25991;&#20214;&#23384;&#21462;&#26435;&#38480;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">chmod</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>, <span style="color: #98fb98;">mode_t</span> <span style="color: #eedd82;">mode</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#26681;&#25454;&#25991;&#20214;&#25551;&#36848;&#31526;&#25913;&#21464;&#25991;&#20214;&#23384;&#21462;&#26435;&#38480;</span>

<span style="color: #ffa07a;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffa07a;">   mode_t&#65306;&#25991;&#20214;&#23384;&#21462;&#26435;&#38480;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fchmod</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">filedes</span>, <span style="color: #98fb98;">mode_t</span> <span style="color: #eedd82;">mode</span>);
</pre>
</div>
</div>

<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">mode参数</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
参数mode：根据表4-6中所示常数的位运算获得
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="groups" frame="boader">
<caption class="t-above"><span class="table-number">Table 5:</span> chmod函数的mode常数，取自&lt;sys/stat.h&gt;</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">mode</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">S_ISUID</td>
<td class="left">执行时设置-用户-ID</td>
</tr>

<tr>
<td class="left">S_ISGID</td>
<td class="left">执行时设置-组-ID</td>
</tr>

<tr>
<td class="left">S_ISVTX</td>
<td class="left">保存正文</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">S_IRWXU</td>
<td class="left">用户(所有者)读、写和执行</td>
</tr>

<tr>
<td class="left">S_IRUSR</td>
<td class="left">用户(所有者)读</td>
</tr>

<tr>
<td class="left">S_IWUSR</td>
<td class="left">用户(所有者)写</td>
</tr>

<tr>
<td class="left">S_IXUSR</td>
<td class="left">用户(所有者)执行</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">S_IRWXG</td>
<td class="left">组读、写和执行</td>
</tr>

<tr>
<td class="left">S_IRGRP</td>
<td class="left">组读</td>
</tr>

<tr>
<td class="left">S_IWGRP</td>
<td class="left">组写</td>
</tr>

<tr>
<td class="left">S_IXGRP</td>
<td class="left">组执行</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">S_IRWXO</td>
<td class="left">其他读、写和执行</td>
</tr>

<tr>
<td class="left">S_IROTH</td>
<td class="left">其他读</td>
</tr>

<tr>
<td class="left">S_IWOTH</td>
<td class="left">其他写</td>
</tr>

<tr>
<td class="left">S_IXOTH</td>
<td class="left">其他执行</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-3-6-1-1" class="outline-5">
<h5 id="sec-3-6-1-1">S_ISVTX</h5>
<div class="outline-text-5" id="text-3-6-1-1">
<p>
如果一个可执行程序文件的这一位被设置了，在该程序第一次执行并结束时，该程序正文的一个文本被保存在交换区。(程序的正文部分是机器指令部分)，这使得下次执行该程序时能较快地将其装入内存区。其原因是：在交换区，该文件是被连续存放的，而在一般的UNIX文件系统中，文件的各数据块很可能是随机存放的。现今较新的UNIX系统大多数都具有虚存系统以及快速文件系统，所以不再需要使用这种技术
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2">chmod实例</h4>
<div class="outline-text-4" id="text-3-6-2">
<p>
根据foo的当前状态设置其许可权。为此先调用stat获得其当前许可权，然后修改它。显式地打开了设置-组-ID位、关闭了组-执行位。最后直接修改bar的权限
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> <span style="color: #eedd82;">statbuf</span>;

    <span style="color: #00ffff;">if</span>(stat(<span style="color: #ffa07a;">"foo"</span>, &amp;statbuf) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"stat error for foo"</span>);

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">turn on set-group-ID and turn off group-execute </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span>(chmod(<span style="color: #ffa07a;">"foo"</span>, (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"chmod error for foo"</span>);

    <span style="color: #ff4500;">/*</span><span style="color: #ff4500;">set absolute mode to "rw-r--r--"</span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span>(chmod(<span style="color: #ffa07a;">"bar"</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"chmod error for bar"</span>);

    exit(0);

}
</pre>
</div>
<ul class="org-ul">
<li>ls命令将组-执行许可权表示为l
</li>
<li>chmod函数更新的只是i节点最近一次被更改的时间，而ls-l列出的是最后修改文件内容的时间
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-6-3" class="outline-4">
<h4 id="sec-3-6-3">自动忽略某些权限常数</h4>
<div class="outline-text-4" id="text-3-6-3">
<ol class="org-ol">
<li>如果我们试图设置普通文件的S_ISVTX，而且又没有超级用户优先权，那么mode中的粘住位自动被关闭。这意味着只有超级用户才能设置普通文件的粘住位。这样做的理由是可以防止不怀好意的用户设置粘住位，并试图以此方式填满交换区
</li>
<li>新创建文件的组ID可能不是调用进程所属的组。特别地如果新文件的组ID不等于进程的有效组ID或者进程添加组ID中的一个，以及进程没有超级用户优先数，那么设置-组-ID位自动被关闭。这就防止了用户创建一个设置-组-ID文件，而该文件是由并非该用户所属的组拥有的
</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">chown, fchown和lchown函数</h3>
<div class="outline-text-3" id="text-3-7">
<p>
chown函数组：更改文件的用户ID和组ID
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#26681;&#25454;&#25991;&#20214;&#36335;&#24452;&#21517;&#26356;&#25913;&#29992;&#25143;ID&#21644;&#32452;ID</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   owner&#65306;&#29992;&#25143;ID</span>
<span style="color: #ffa07a;">   group&#65306;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">chown</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>, <span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">owner</span>, <span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">group</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#26681;&#25454;&#25171;&#24320;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;&#26356;&#25913;&#29992;&#25143;ID&#21644;&#32452;ID</span>

<span style="color: #ffa07a;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffa07a;">   owner&#65306;&#29992;&#25143;ID</span>
<span style="color: #ffa07a;">   group&#65306;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fchown</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">filedes</span>, <span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">owner</span>, <span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">group</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20462;&#25913;&#38142;&#25509;&#25991;&#20214;&#26412;&#36523;&#30340;&#26356;&#25913;&#29992;&#25143;ID&#21644;&#32452;ID&#65292;&#32780;&#19981;&#26159;&#25152;&#25351;&#21521;&#30340;&#25991;&#20214;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   owner&#65306;&#29992;&#25143;ID</span>
<span style="color: #ffa07a;">   group&#65306;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">lchown</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>, <span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">owner</span>, <span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">group</span>);
</pre>
</div>
</div>

<div id="outline-container-sec-3-7-1" class="outline-4">
<h4 id="sec-3-7-1">chown限制</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
若_POSIX_CHOWN_RESTRICTED系统配置常量对指定的文件起作用，则
</p>
<ol class="org-ol">
<li>只有超级用户进程能更改该文件的用户ID
</li>
<li>若满足下列条件，一个非超级用户进程可以更改该文件的组ID:
<ul class="org-ul">
<li>进程拥有此文件(其有效用户ID等于该文件的用户ID)
</li>
<li>参数owner等于文件的用户ID，参数group等于进程的有效组ID或进程的添加组ID之一
</li>
</ul>
</li>
</ol>

<p>
也就是说当_POSIX_CHOWN_RESTRICTED有效时，不能更改其他用户的文件的用户ID。你可以更改你所拥用的文件的组ID，但只能改到你所属于的组
</p>

<p>
如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置-用户-ID位和设置-组-ID位都被清除
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">文件长度</h2>
<div class="outline-text-2" id="text-4">
<p>
stat结构的成员st_size包含了以字节为单位的该文件的长度。此字段只对普通文件、目录文件和符号连接有意义
</p>
<ul class="org-ul">
<li>普通文件：其文件长度可以是0，在读这种文件时，将得到文件结束指示
</li>
<li>目录：文件长度通常是16或512的整倍数
</li>
<li>符号连接：文件长度是被链接文件名的实际字节数
</li>
</ul>
<p>
例如：ant -&gt; apache-ant-1.9.7/，其文件长度17就是路径名apache-ant-1.9.7的长度
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ls -l 
lrwxrwxrwx  1 klose klose   17 Nov 20 21:14 ant -&gt; apache-ant-1.9.7/
</pre>
</div>
<p>
注意：因为符号连接文件长度总是由st_size指示，所以符号连接并不包含通常C语言用作名字结尾的null字符 
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">st_blksize和st_blocks</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>st_blksize：对文件I/O较好的块长度
</li>
<li>st_blocks：所分配的实际st_blksize大小的字节块数
</li>
</ul>

<p>
st_blksize表示读操作时读一个文件所需的最少时间量。为了效率的缘故，标准I/O库也试图一次读、写st_blksize个字节
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">文件空洞</h3>
<div class="outline-text-3" id="text-4-2">
<p>
空洞是所设置的偏移量超过文件尾端并写入数据后造成的
</p>

<p>
空洞并不会占用实际的磁盘空间，因此使用du则只会显示使用了多少字节块，但是使用ls查看文件大小时会计算空洞的大小
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ls -l file.hole

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">ls&#26174;&#31034;&#23454;&#38469;&#25991;&#20214;&#38271;&#24230;&#26159;4000010&#23383;&#33410;</span>
-rw-r--r-- 1 klose klose 4000010 Jan 30 20:41 file.hole

$ du ./file.hole

<span style="color: #ff4500;">#</span><span style="color: #ff4500;">du&#26174;&#31034;&#20102;&#23454;&#38469;&#19978;&#25991;&#20214;&#21482;&#21344;&#20102;12&#20010;1024&#23383;&#33410;&#22359;</span>
12      ./file.hole
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">truncate和ftruncate函数</h3>
<div class="outline-text-3" id="text-4-3">
<p>
truncate函数组：以指定长度截短文件
</p>

<p>
len为0等价于使用O_TRUNC标记调用open函数，在打开文件时将文件的内容清空
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20197;&#25351;&#23450;&#38271;&#24230;&#25130;&#30701;&#25991;&#20214;&#12288;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   len&#65306;&#25351;&#23450;&#38271;&#24230;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">truncate</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>, <span style="color: #98fb98;">off_t</span> <span style="color: #eedd82;">len</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20197;&#25351;&#23450;&#38271;&#24230;&#25130;&#30701;&#25991;&#20214;&#12288;</span>

<span style="color: #ffa07a;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffa07a;">   len&#65306;&#25351;&#23450;&#38271;&#24230;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ftruncate</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">filedes</span>, <span style="color: #98fb98;">off_t</span> <span style="color: #eedd82;">len</span>);
</pre>
</div>
<ul class="org-ul">
<li>如果该文件以前的长度大于len，则超过len以外的数据就不再能存取
</li>
<li>如果以前的长度短于length，则其后果与系统有关。比如某个实现的处理是扩展该文件，则在以前的文件尾端和新的文件尾端之间的数据将读作0(也就是在文件中创建了一个空洞)
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">文件系统</h2>
<div class="outline-text-2" id="text-5">
<p>
Unix/Linux系统下可以使用多种文件系统实现，如基于BSD的Unix文件系统（UFS），EXT，传统的V文件系统等。这些文件系统都不影响下面的描述　
</p>

<p>
一个磁盘分成一个或多个分区，见图4-1，每个分区可以包含一个文件系统
</p>

<div class="figure">
<p><img src="./pic/fs-1.png" alt="fs-1.png" width="90%" />
</p>
</div>

<p>
如果在忽略自举块和超级块情况下更仔细地观察文件系统，则可以得到图4-2中所示的情况
</p>

<div class="figure">
<p><img src="./pic/fs-2.jpg" alt="fs-2.jpg" width="90%" />
</p>
</div>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">i节点</h3>
<div class="outline-text-3" id="text-5-1">
<p>
i节点：包含有关文件的大部分信息，比如文件类型，文件访问权限位，文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点
</p>

<p>
每个文件只有一个i节点
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">目录项</h3>
<div class="outline-text-3" id="text-5-2">
<p>
目录项：文件名和i节点编号数，i节点编号数的数据类型是ino_t。
</p>

<p>
因为目录项中的i节点编号数指向同一文件系统中的i节点，所以不能使一个目录项指向另一个文件系统的i节点。这就是为什么ln(1)命令不能跨越文件系统的原因
</p>

<p>
当在同一个分区内为一个文件更名时，该文件的实际内容并未移动，只需构造一个指向现存i节点的新目录项，并删除老的目录项。例如将文件/usr/lib/foo更名为/usr/foo，如果目录/usr/lib和/usr在同一文件系统上，则文件foo的内容无需移动。这就是mv(1)命令的通常操作方式
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">数据块</h3>
<div class="outline-text-3" id="text-5-3">
<p>
数据块：用来记录文件的实际内容，它在磁盘上的位置由i结点来指示
</p>

<p>
它的大小可以为1，2，4K字节
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">连接</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">硬连接</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
在图4-2中有两个目录项指向同一i节点。每个i节点中都有一个连接计数，其值是指向该i节点的目录项数。这种连接被称为硬连接。
</p>

<p>
只有当连接计数减少为0时，才可删除该文件(也就是可以释放该文件占用的数据块)。这就是为什么解除对一个文件的连接操作并不总是意味着释放该文件占用的磁盘块的原因。也就是为什么删除一个目录项的函数被称之为unlink而不是delete的原因。
</p>

<p>
在stat结构中，连接计数包含在st_nlink成员中，其基本系统数据类型是nlink_t
</p>
</div>
</div>

<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">符号连接</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
该文件的实际内容(在数据块中)包含了该符号连接所指向的文件的名字
</p>

<p>
比如lib-&gt;urs/lib：该目录项中的文件名是lib，而在该文件中包含了7个数据字节usr/lib。该i节点中的文件类型是S_IFLNK，于是系统知道这是一个符号连接 
</p>
</div>
</div>

<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">目录连接</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
创建新的目录testdir
</p>
<div class="org-src-container">

<pre class="src src-sh">$ mkdir testdir
</pre>
</div>
<p>
图4-3显示了其结果：
</p>

<div class="figure">
<p><img src="./pic/inodes.png" alt="inodes.png" width="90%" />
</p>
</div>
<ul class="org-ul">
<li>编号为2549的i节点，其类型字段表示它是一个目录。连接计数为2：任何一个叶子目录(不包含任何其他目录)其连接计数总是2，数值2来自于命名该目录(testdir)的目录项以及在该目录中的..项
</li>

<li>编号为1267的i节点，其类型字段表示它是一个目录。连接计数则大于或等于3：一个是命名它的目录项(在图4-3中没有表示出来)，第二个是在该目录中的.项，第三个是在其子目录testdir中的..项
</li>
</ul>

<p>
注意：在工作目录中的每个子目录都使该工作目录的连接计数增1
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">link函数</h3>
<div class="outline-text-3" id="text-5-5">
<p>
link函数：创建一个向现存文件目录项
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#21019;&#24314;&#19968;&#20010;&#25351;&#21521;&#29616;&#23384;&#25991;&#20214;&#30340;&#30446;&#24405;&#39033;</span>

<span style="color: #ffa07a;">   existingpath&#65306;&#24050;&#32463;&#23384;&#22312;&#30340;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   newpath&#65306;&#36830;&#25509;&#21518;&#30340;&#25991;&#20214;&#36335;&#24452;&#21517;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">link</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">existingpath</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">newpath</span>);
</pre>
</div>
<p>
创建一个新目录项newpath，它引用现存文件existingpath，如若newpath已经存在，则返回出错
</p>

<p>
创建新目录项以及增加连接计数应当是个原子操作！
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">unlink函数</h3>
<div class="outline-text-3" id="text-5-6">
<p>
unlink函数：删除一个现存的目录项
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#21024;&#38500;&#19968;&#20010;&#29616;&#23384;&#30340;&#30446;&#24405;&#39033;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#25110;&#32773;&#30446;&#24405;&#36335;&#24452;&#21517;&#12288;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">unlink</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>);
</pre>
</div>
<p>
删除目录项，并将由pathname所引用的文件的连接计数减1，如果出错，则不对该文件作任何更改
</p>

<p>
为了解除对文件的连接,必须对包含该目录项的目录具有写和执行许可权
</p>

<p>
如果pathname是符号连接，那么unlink涉及的是符号连接而不是由该连接所引用的文件
</p>

<p>
超级用户可以调用带参数pathname的unlink指定一个目录，但是通常不使用这种方式，而使用函数rmdir 
</p>
</div>
<div id="outline-container-sec-5-6-1" class="outline-4">
<h4 id="sec-5-6-1">删除文件</h4>
<div class="outline-text-4" id="text-5-6-1">
<p>
如果文件还有其他连接，则仍可通过其他连接存取该文件的数据。只有当连接计数达到0时并且没有进程打开该文件，文件的内容才可被删除
</p>

<p>
关闭一个文件时内核首先检查使该文件打开的进程计数，如果该计数达到0，然后内核检查其连接计数，如果这也是0，那么就删除该文件的内容
</p>
</div>
</div>

<div id="outline-container-sec-5-6-2" class="outline-4">
<h4 id="sec-5-6-2">unlink实例</h4>
<div class="outline-text-4" id="text-5-6-2">
<p>
打开一个文件，然后unlink它。执行该程序的进程然后睡眠15秒钟，接着就终止
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #00ffff;">if</span>(open(<span style="color: #ffa07a;">"tempfile"</span>, O_RDWR) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"open error"</span>);

    <span style="color: #00ffff;">if</span>(unlink(<span style="color: #ffa07a;">"tempfile"</span>) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"unlink error"</span>);
    printf(<span style="color: #ffa07a;">"file unlinked\n"</span>);

    sleep(15);
    printf(<span style="color: #ffa07a;">"done\n"</span>);

    exit(0);

}
</pre>
</div>
<p>
测试代码：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ echo <span style="color: #ffa07a;">"hello world "</span> &gt; tempfile

$ ls -l tempfile
<span style="color: #ff4500;"># </span><span style="color: #ff4500;">1&#34920;&#31034;&#26377;1&#20010;&#30446;&#24405;&#39033;&#30446;&#25351;&#21521;tempfile</span>
-rw-r--r-- 1 klose klose 13 Jan 30 22:53 tempfile

$ ./unlinkExample

file unlinked
<span style="color: #00ffff;">done</span>

$ ls -l tempfile

ls: cannot access <span style="color: #ffa07a;">'tempfile'</span>: No such file or directory
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7">remove函数</h3>
<div class="outline-text-3" id="text-5-7">
<p>
remove函数：对于文件remove与unlink一样，对于目录remove与rmdir一样
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#23545;&#20110;&#25991;&#20214;remove&#19982;unlink&#19968;&#26679;&#65292;&#23545;&#20110;&#30446;&#24405;remove&#19982;rmdir&#19968;&#26679;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#25991;&#20214;&#25110;&#30446;&#24405;&#36335;&#24452;&#21517;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">remove</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8">rename函数</h3>
<div class="outline-text-3" id="text-5-8">
<p>
rename函数：修改文件或者目录名字
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20462;&#25913;&#25991;&#20214;&#25110;&#32773;&#30446;&#24405;&#21517;&#23383;</span>

<span style="color: #ffa07a;">   oldname&#65306;&#26087;&#30340;&#25991;&#20214;&#25110;&#30446;&#24405;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   newname&#65306;&#26032;&#30340;&#24681;&#35265;&#25110;&#30446;&#24405;&#36335;&#24452;&#21517;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">rename</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">oldname</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">newname</span>);
</pre>
</div>
<ul class="org-ul">
<li>如果oldname是一个文件而不是目录，那么为该文件更名。在这种情况下如果newname已存在，则它不能引用一个目录。如果newname已存在而且不是一个目录，则先将该目录项删除然后将oldname更名为newname。对包含oldname的目录以及包含newname的目录，调用进程必须具有写许可权，因为将更改这两个目录
</li>
<li>如若oldname是一个目录，那么为该目录更名。如果newname已存在，则它必须引用一个目录，而且该目录应当是空目录(空目录指的是该目录中只有.和..项)。如果newname存在(而且是一个空目录)，则先将其删除，然后将oldname更名为newname。另外，当为一个目录更名时，newname不能包含oldname作为其路径前缀。例如，不能将/usr/foo更名为/usr/foo/testdir，因为老名字(/usr/foo)是新名字的路径前缀，因而不能将其删除
</li>
<li>作为一个特例，如果oldname和newname引用同一文件，则函数不做任何更改而成功返回
</li>
</ul>

<p>
若newname已经存在，则调用进程需要对其有写许可权。另外调用进程将删除oldname目录项，并可能要创建newname目录项，所以它需要对包含oldname及包含newname的目录具有写和执行许可权
</p>
</div>
</div>

<div id="outline-container-sec-5-9" class="outline-3">
<h3 id="sec-5-9">符号连接</h3>
<div class="outline-text-3" id="text-5-9">
<p>
符号连接是对一个文件的间接指针，而硬连接直接指向文件的i节点
</p>

<p>
引进符号连接的原因是为了避免硬连接的一些限制：
</p>
<ul class="org-ul">
<li>硬连接通常要求连接和文件位于同一文件系统中
</li>
<li>只有超级用户才能创建到目录的硬连接
</li>
</ul>

<p>
对符号连接以及它指向什么没有文件系统限制，任何用户都可创建指向目录的符号连接。符号连接一般用于将一个文件或整个目录结构移到系统中其他某个位置
</p>
</div>

<div id="outline-container-sec-5-9-1" class="outline-4">
<h4 id="sec-5-9-1">函数对符号连接的处理</h4>
<div class="outline-text-4" id="text-5-9-1">
<ul class="org-ul">
<li>跟随：则该函数的路径名参数引用由符号连接指向的文件
</li>
<li>不跟随：处理该符号连接路径名本身而不是由符号连接引用的文件 
</li>
</ul>


<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader　">
<caption class="t-above"><span class="table-number">Table 6:</span> 各个函数对符号连接的处理</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">函数</td>
<td class="left">不跟随符号连接</td>
<td class="left">跟随符号连接</td>
</tr>

<tr>
<td class="left">access</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">chdir</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">chmod</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">chown</td>
<td class="left">•</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">creat</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">exec</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">lchown</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">link</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">lstat</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">mkdir</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">mkfifo</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">mknod</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">open</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">opendir</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">pathconf</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">readlink</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">remove</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">rename</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">stat</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">truncate</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">unlink</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-5-9-2" class="outline-4">
<h4 id="sec-5-9-2">符号连接循环</h4>
<div class="outline-text-4" id="text-5-9-2">
<p>
使用符号连接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都返回值为ELOOP的errno
</p>

<p>
创建了一个目录foo，它包含了一个名为a的文件以及一个指向foo的符号连接
</p>
<div class="org-src-container">

<pre class="src src-sh">$<span style="color: #eedd82;">mkdir</span> foo <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#21019;&#24314;&#19968;&#20010;&#26032;&#30446;&#24405;</span>

$<span style="color: #eedd82;">touch</span> foo/a <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#21019;&#24314;0&#38271;&#25991;&#20214;</span>

$<span style="color: #eedd82;">ln</span> - s ../foo foo/testdir <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#21019;&#24314;&#19968;&#31526;&#21495;&#36830;&#25509;</span>

$<span style="color: #eedd82;">ls</span> -1 foo

total 1
-rw-rw-r-- 1 stevens 0 Dec6 06:06 a
lrwxrwxrwx 1 stevens 6 Dec6 06:06 testdir -&gt; ../foo
</pre>
</div>
<p>
如果遍历目录不考虑这种情况，那么从foo到/foo/testdir则又会回到foo
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5-10" class="outline-3">
<h3 id="sec-5-10">symlink函数</h3>
<div class="outline-text-3" id="text-5-10">
<p>
symlink函数：创建一个符号连接
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span><span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#21019;&#24314;&#19968;&#20010;&#31526;&#21495;&#36830;&#25509;</span>

<span style="color: #ffa07a;">   actualpath&#65306;&#34987;&#24341;&#29992;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   sympath&#65306;&#31526;&#21495;&#36830;&#25509;&#25991;&#20214;&#36335;&#24452;&#21517;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">symlink</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">actualpath</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">sympath</span>);
</pre>
</div>
<p>
创建了一个指向actualpath的新目录项sympath，在创建此符号连接时，并不要求actualpath已经存在，并且actualpath和sympath并不需要位于同一文件系统中
</p>
</div>
</div>

<div id="outline-container-sec-5-11" class="outline-3">
<h3 id="sec-5-11">readlink函数</h3>
<div class="outline-text-3" id="text-5-11">
<p>
readlink函数：因为open函数跟随符号连接，所以需要有一种方法打开该连接本身文件，而readlink函数就提供了这个功能
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#35835;&#21462;&#19968;&#20010;&#31526;&#21495;&#38142;&#25509;&#65292;&#23427;&#19981;&#20250;&#36319;&#38543;&#31526;&#21495;&#38142;&#25509;&#25351;&#21521;&#30340;&#25991;&#20214;&#65292;&#36820;&#22238;&#30340;&#26159;&#31526;&#21495;&#38142;&#25509;&#26412;&#36523;&#30340;&#20449;&#24687;&#65292;&#21363;&#25351;&#21521;&#30340;&#25991;&#20214;&#30340;&#21517;&#23383;</span>

<span style="color: #ffa07a;">   pathname&#65306;&#31526;&#21495;&#38142;&#25509;&#25991;&#20214;&#36335;&#24452;&#21517;</span>
<span style="color: #ffa07a;">   buf&#65306;&#20445;&#23384;&#25351;&#21521;&#25991;&#20214;&#21517;&#23383;&#30340;&#32531;&#23384;&#21306;</span>
<span style="color: #ffa07a;">   bufsize&#65306;&#32531;&#23384;&#21306;&#22823;&#23567;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#35835;&#30340;&#23383;&#33410;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>

<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">readlink</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">pathname</span>, <span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bufsize</span>);
</pre>
</div>
<p>
此函数组合了open，read和close的所有操作
</p>

<p>
注意：在buf中返回的符号连接的内容不以null字符终止！
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">文件的时间</h2>
</div>
</div>
<div id="postamble" class="status">

     <br/>
    <div class='ds-thread'></div>
<script>
var duoshuoQuery = {short_name:'klose911'};
(function() {
	 var dsThread = document.getElementsByClassName('ds-thread')[0];
         dsThread.setAttribute('data-thread-key', document.title);
         dsThread.setAttribute('data-title', document.title);
         dsThread.setAttribute('data-url', window.location.href);
	 var ds = document.createElement('script');
	 ds.type = 'text/javascript';ds.async = true;
	 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	 ds.charset = 'UTF-8';
	 (document.getElementsByTagName('head')[0] 
				       || document.getElementsByTagName('body')[0]).appendChild(ds);
				       })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90850421-1', 'auto');
  ga('send', 'pageview');
</script>
</div>
</body>
</html>
