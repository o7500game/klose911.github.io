<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>高级IO</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="signal.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">高级IO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orged9c918">非阻塞IO</a>
<ul>
<li><a href="#orgd76be9e">轮询</a></li>
</ul>
</li>
<li><a href="#org109efd9">流机制</a></li>
<li><a href="#orge4f9c76">I/O多路转接</a>
<ul>
<li><a href="#orgaef86cc">读和写各使用一个进程</a></li>
<li><a href="#org2593e4c">使用非阻塞IO</a></li>
<li><a href="#org1012879">多路转接</a>
<ul>
<li><a href="#org106862d">select函数</a>
<ul>
<li><a href="#org405d6d8">fd_set数据类型</a></li>
<li><a href="#orgbfdedf8">maxfdp1参数</a></li>
<li><a href="#org1db5b01">timeval结构</a></li>
<li><a href="#orgd846c1f">返回值</a></li>
<li><a href="#org3298acd">pselect函数</a></li>
</ul>
</li>
<li><a href="#org3d4f674">poll函数</a>
<ul>
<li><a href="#org06a22cc">pollfd结构</a></li>
<li><a href="#orgbcec766">nfds参数</a></li>
<li><a href="#org039d149">timeout参数</a></li>
<li><a href="#org4205fdc">返回值</a></li>
</ul>
</li>
<li><a href="#org3ce09ff">中断性</a></li>
</ul>
</li>
<li><a href="#org0f937da">异步IO</a>
<ul>
<li><a href="#orgc8369de">BSD实现</a>
<ul>
<li><a href="#org7034740">实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc4ed23c">readv和writev</a>
<ul>
<li><a href="#org4fc7424">iovec结构</a></li>
<li><a href="#org5bbffa3">性能测试</a></li>
</ul>
</li>
<li><a href="#orgd29cb0a">存储映射IO</a>
<ul>
<li><a href="#org0a96bec">mmap函数</a>
<ul>
<li><a href="#org509997f">参数说明</a>
<ul>
<li><a href="#org6168bec">prot参数</a></li>
<li><a href="#org8254d55">flag参数</a></li>
<li><a href="#orgd7e6c11">off和addr参数限制</a></li>
</ul>
</li>
<li><a href="#orgc2c083d">信号和进程</a></li>
</ul>
</li>
<li><a href="#org9727c56">munmap函数</a></li>
<li><a href="#orge175495">msync函数</a></li>
<li><a href="#orgbd8d9df">使用内存映射拷贝文件</a></li>
</ul>
</li>
<li><a href="#org4461bec">记录锁</a>
<ul>
<li><a href="#orgc523dac">历史</a></li>
<li><a href="#orgd1c833a">fcntl记录锁</a>
<ul>
<li><a href="#orge79315b">flock结构</a>
<ul>
<li><a href="#org7cdbdaa">锁类型</a></li>
<li><a href="#org56af928">锁区域</a></li>
</ul>
</li>
<li><a href="#orgcdfa32b">cmd命令</a>
<ul>
<li><a href="#org6cb22e9">要求和释放一把锁</a></li>
<li><a href="#org4e63363">测试一把锁</a></li>
</ul>
</li>
<li><a href="#orgf9157e1">死锁</a>
<ul>
<li><a href="#orgf797553">死锁实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1c29ed4">锁的隐含继承和释放</a></li>
<li><a href="#orga692d44">BSD的实现</a>
<ul>
<li><a href="#orgbdabe15">守护进程号加锁</a></li>
<li><a href="#orgcd61c31">文件末尾加锁</a></li>
</ul>
</li>
<li><a href="#org93f42f4">建议性锁和强制性锁</a>
<ul>
<li><a href="#org02d1778">校验系统是否支持强制性锁</a></li>
<li><a href="#org592d52f">两人编辑同一文件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章内容包括：
</p>
<ul class="org-ul">
<li>非阻塞IO</li>
<li>IO多路转接(select和poll函数)</li>
<li>readv和writev函数</li>
<li>存储映照I/O(mmap)</li>
<li>记录锁</li>
</ul>

<p>
接下来的进程间通信(IPC)要使用这里所述的很多概念和函数
</p>
<div id="outline-container-orged9c918" class="outline-2">
<h2 id="orged9c918">非阻塞IO</h2>
<div class="outline-text-2" id="text-orged9c918">
<p>
在上一章曾将系统调用分成两类：低速系统调用和其他。低速系统调用是可能会使进程永远阻塞的一类系统调用，比如读写未准备好的伪终端，网络，管道等
</p>

<p>
虽然读、写磁盘文件会使调用在短暂时间内阻塞，但并不能将它们视为“低速”。
</p>

<p>
非阻塞I/O：是使调用不会永远阻塞的I/O操作，如果这种操作不能完成，则立即出错返回，表示该操作如继续执行将继续阻塞下去
</p>

<p>
对于一个给定的描述符有两种方法对其指定非阻塞I/O: 
</p>
<ol class="org-ol">
<li>如果是调用open以获得该描述符，则可指定O_NONBLOCK标志</li>
<li>对于已经打开的一个描述符，则可调用fcntl打开O_NONBLOCK文件状态标志</li>
</ol>

<p>
对于一个非阻塞的文件描述符，如果没有数据可读写，则read和write将直接返回-1，并设置errno为EAGAIN
</p>
</div>
<div id="outline-container-orgd76be9e" class="outline-3">
<h3 id="orgd76be9e">轮询</h3>
<div class="outline-text-3" id="text-orgd76be9e">
<p>
下面程序从标准输入读100000字节，并试图将它们写到标准输出上。该程序先将标准输出设置为非阻塞的，然后用轮询进行输出，每次写的结果都在标准出错上打印。函数clr-fl清除一个或多个标志位：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>

<span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">buf</span>[100000];

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">ntowrite</span>, <span style="color: #4eee94;">nwrite</span>;
    <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">ptr</span>;

    ntowrite = read(STDIN_FILENO, buf, <span style="color: #00bfff; font-weight: bold;">sizeof</span>(buf));
    fprintf(stderr, <span style="color: #deb887;">"read %d bytes\n"</span>, ntowrite);

    set_fl(STDOUT_FILENO, O_NONBLOCK);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">set nonblocking </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    ptr = buf;
    <span style="color: #00bfff; font-weight: bold;">while</span> (ntowrite &gt; 0) {
        errno = 0;
        nwrite = write(STDOUT_FILENO, ptr, ntowrite);
        fprintf(stderr, <span style="color: #deb887;">"nwrite = %d, errno = %d\n"</span>, nwrite, errno);

        <span style="color: #00bfff; font-weight: bold;">if</span> (nwrite &gt; 0) {
            ptr += nwrite;
            ntowrite -= nwrite;
        }
    }

    clr_fl(STDOUT_FILENO, O_NONBLOCK);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">clear nonblocking </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    exit(0);
}
</pre>
</div>

<p>
注意：在linux上的测试结果显示并没有如想象中的调用多次非阻塞写操作，而是只有一次写操作
</p>

<p>
虽然关于非阻塞IO内容可能已经过时，但是程序中出现的轮询却还一直被用在各种非阻塞操作中。轮询往往会导致浪费CPU时间，一种更加有效的方法是使用非阻塞描述符的I/O多路转接
</p>
</div>
</div>
</div>

<div id="outline-container-org109efd9" class="outline-2">
<h2 id="org109efd9">流机制</h2>
<div class="outline-text-2" id="text-org109efd9">
<p>
除了SVR4及其后代如Solaris之外流机制并不是很常用，现在更多被使用的是BSD的socket机制
</p>
</div>
</div>

<div id="outline-container-orge4f9c76" class="outline-2">
<h2 id="orge4f9c76">I/O多路转接</h2>
<div class="outline-text-2" id="text-orge4f9c76">
<p>
当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞I/O：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">while</span> ( (n = read(STDIN_FILENO, buf, BUFSIZ)) &gt; 0 )
    <span style="color: #00bfff; font-weight: bold;">if</span>( write(STDOUT_FILENO, buf, n) != n)
        err_sys(<span style="color: #deb887;">"write error"</span>);
</pre>
</div>
<p>
这种形式的阻塞I/O到处可见。但是如果必须读两个描述符又将如何呢？　如果仍旧使用阻塞I/O，那么就可能长时间阻塞在一个描述符上，而另一个描述符虽有很多数据却不能得到及时处理。所以为了处理这种情况显然需要另一种不同的技术
</p>

<p>
首先观察一个调制解调器拨号程序(telnet)的工作情况。该程序读终端(标准输入)，将所得数据写到调制解调器(telnetd)上，同时读调制解调器，将所得数据写到终端上(标准输出)。图12-1显示这种工作情况：
</p>

<div class="figure">
<p><img src="pic/modem-dialer.gif" alt="modem-dialer.gif" width="90%" /> 
</p>
</div>
</div>

<div id="outline-container-orgaef86cc" class="outline-3">
<h3 id="orgaef86cc">读和写各使用一个进程</h3>
<div class="outline-text-3" id="text-orgaef86cc">
<p>
处理这种特殊问题的一种方法是设置两个进程，每个进程处理一条数据通路。图12-2中显示了这种安排：
</p>

<div class="figure">
<p><img src="pic/modem-processes.gif" alt="modem-processes.gif" width="90%" /> 
</p>
</div>

<p>
如果使用两个进程，则可使每个进程都执行阻塞read。但是也产生了这两个进程间相互配合问题。如果子进程接收到文件结束符(由于电话线的一端已经挂断，使调制解调器也挂断)，那么该子进程终止，然后父进程接收到SIGCHLD信号。但是，如若父进程终止(用户在终端上键入了文件结束符)，那么父进程应通知子进程停止工作。为此可以使用一个信号(例如SIGUSR1)。这使程序变得更加复杂
</p>
</div>
</div>

<div id="outline-container-org2593e4c" class="outline-3">
<h3 id="org2593e4c">使用非阻塞IO</h3>
<div class="outline-text-3" id="text-org2593e4c">
<p>
另一个方式是仍旧使用一个进程执行该程序，但调用非阻塞I/O读取数据，其基本思想是：将两个输入描述符都设置为非阻塞的，对第一个描述符发一个read。如果该输入上有数据，则读数据并处理它。如果无数据可读，则read立即返回。然后对第二个描述符作用样的处理。在此之后，等待若干秒再读第一个描述符。这种形式的循环称为轮询。
</p>

<p>
这种方法的不足之处是浪费CPU时间：
</p>
<ul class="org-ul">
<li>大多数时间实际上是无数据可读，但是仍不断反复执行read，这浪费了CPU时间</li>
<li>在每次循环后要等多长时间再执行下一轮循环也很难确定</li>
</ul>

<p>
轮询技术在支持非阻塞I/O的系统上都可使用，但是在多任务系统中应当避免使用
</p>
</div>
</div>

<div id="outline-container-org1012879" class="outline-3">
<h3 id="org1012879">多路转接</h3>
<div class="outline-text-3" id="text-org1012879">
<p>
一种比较好的技术是使用I/O多路转接，其基本思想是：先构造一张有关描述符的表，然后调用一个函数，它要到这些描述符中的一个已准备好进行I/O时才返回。 在返回时它告诉进程哪一个描述符已准备好可以进行I/O
</p>
</div>

<div id="outline-container-org106862d" class="outline-4">
<h4 id="org106862d">select函数</h4>
<div class="outline-text-4" id="text-org106862d">
<p>
select函数可以在SVR4和4.3+BSD之下可以执行I/O多路转接，传向select的参数告诉内核:
</p>
<ul class="org-ul">
<li>所关心的描述符</li>
<li>对于每个描述符所关心的条件：是否读一个给定的描述符？是否想写一个给定的描述符？是否关心一个描述符的异常条件？等</li>
<li>希望等待多长时间：永远等待，等待一个固定量时间，或完全不等待</li>
</ul>

<p>
从select返回时，内核告诉我们：
</p>
<ul class="org-ul">
<li>已准备好的描述符的数量</li>
<li>哪一个描述符已准备好读、写或异常条件</li>
</ul>

<p>
使用这种返回值，就可调用相应的I/O函数(一般是read或write)，并且确知该函数不会阻塞
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/select.h&gt;</span> 

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20351;&#29992;select&#20989;&#25968;&#36827;&#34892;IO&#22810;&#36335;&#36716;&#25509;</span>

<span style="color: #ffebcd;">   maxfdp1&#65306;readfds, writefds, exceptfds&#19977;&#20010;&#25551;&#36848;&#31526;&#20013;&#22823;&#30340;fd&#20540;&#21152;1</span>
<span style="color: #ffebcd;">   readfds&#65306;&#25351;&#21521;&#35835;&#25991;&#20214;&#25551;&#36848;&#31526;&#38598;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   writefds&#65306;&#25351;&#21521;&#20889;&#25991;&#20214;&#25551;&#36848;&#31526;&#38598;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   exceptfds&#65306;&#25351;&#21521;&#24322;&#24120;&#25991;&#20214;&#25551;&#36848;&#31526;&#38598;&#30340;&#25351;&#38024;</span>
<span style="color: #ffebcd;">   tvptr&#65306;&#25351;&#21521;&#31561;&#24453;&#26102;&#38388;&#32467;&#26500;&#30340;&#25351;&#38024;</span>

<span style="color: #ffebcd;">   return&#65306;&#20934;&#22791;&#23601;&#32490;&#30340;&#25551;&#36848;&#31526;&#25968;&#23383;&#65292;&#33509;&#36229;&#26102;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">select</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">maxfdp1</span>,
       <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">readfds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">write_fds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">exceptfds</span>,
       <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">timeval</span> *<span style="color: #4eee94;">tvptr</span>);
</pre>
</div>
</div>

<div id="outline-container-org405d6d8" class="outline-5">
<h5 id="org405d6d8">fd_set数据类型</h5>
<div class="outline-text-5" id="text-org405d6d8">
<p>
指向描述符集的指针：
</p>
<ul class="org-ul">
<li>readfds：关心的可读的各个描述符</li>
<li>writefds：关心的可写描述符号各个描述符</li>
<li>exceptfds：关心的处于异常条件的各个描述符</li>
</ul>

<p>
每个描述符集存放在一个fd_set数据类型中，这种数据类型的实现可见图12-9，它为每一可能的描述符保持了一位：
</p>

<div class="figure">
<p><img src="pic/fd-set.jpg" alt="fd-set.jpg" width="90%" /> 
</p>
</div>

<p>
对fg_set数据类型可以进行的处理是:
</p>
<ul class="org-ul">
<li>分配一个这种类型的变量</li>
<li>将这种类型的一个变量赋与同类型的另一个变量</li>
<li><p>
对于这种类型的变量使用下列四个宏:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">FD_ISSET</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#27979;&#35797;&#26576;&#25991;&#20214;&#25551;&#36848;&#31526;&#23545;&#24212;&#30340;&#20301;&#26159;&#21542;&#34987;&#35774;&#32622;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">FD_SET</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#35774;&#32622;&#26576;&#25991;&#20214;&#25551;&#36848;&#31526;&#23545;&#24212;&#30340;&#20301;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">FD_CLR</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#38500;&#26576;&#25991;&#20214;&#25551;&#36848;&#31526;&#23545;&#24212;&#30340;&#20301;</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">FD_ZERO</span>(<span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">set</span>); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#28165;&#38500;&#20854;&#25152;&#26377;&#20301;</span>
</pre>
</div></li>
</ul>
<p>
select中间三个参数中的任意一个(或全部)可以是空指针，这表示对相应条件并不关心。如果所有三个指针都是空指针，则select提供了较sleep更精确的计时器
</p>
</div>
</div>

<div id="outline-container-orgbfdedf8" class="outline-5">
<h5 id="orgbfdedf8">maxfdp1参数</h5>
<div class="outline-text-5" id="text-orgbfdedf8">
<p>
第一个参数maxfdp1的意思是”最大fd加1“，在三个描述符集中找出最高描述符编号值，然后加1。也可将第一个参数设置为FD_SETSIZE，它说明了最大的描述符数(经常是256或1024)。但是对大多数应用程序而言此值太大了，大多数应用程序只使用3~10个描述符。如果将第三个参数设置为最高描述符编号值加1，内核就只需在此范围内寻找打开的位，而不必在数百位的大范围内搜索
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #98f5ff;">fd_set</span> <span style="color: #4eee94;">readset</span>, <span style="color: #4eee94;">writeset</span>;
FD_ZERO(&amp;readset);
FD_ZERO(&amp;writeset);

FD_SET(0, &amp;readset);
FD_SET(3, &amp;readset);
FD_SET(1, &amp;writeset);
FD_SET(2, &amp;writeset);

select(4, &amp;readset, &amp;writeset, <span style="color: #ffd700;">NULL</span>, <span style="color: #ffd700;">NULL</span>);
</pre>
</div>

<p>
图12-10显示了这两个描述符集的情况：
</p>

<div class="figure">
<p><img src="pic/fd-set-sample.jpg" alt="fd-set-sample.jpg" width="90%" /> 
</p>
</div>

<p>
因为描述符编号从0开始，所以要在最大描述符编号值上加1，实际上是要检查的描述符数量
</p>
</div>
</div>

<div id="outline-container-org1db5b01" class="outline-5">
<h5 id="org1db5b01">timeval结构</h5>
<div class="outline-text-5" id="text-org1db5b01">
<p>
最后一个参数tvptr是一个指向timeval结构的指针，它指定愿意等待的时间：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">timeval</span>{
    <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">tv_sec</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">seconds </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">long</span> <span style="color: #4eee94;">tv_usec</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">and microseconds </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
};
</pre>
</div>

<p>
有以下三种情况：
</p>
<ul class="org-ul">
<li>永远等待</li>
</ul>
<div class="org-src-container">
<pre class="src src-C">tvptr = <span style="color: #ffd700;">NULL</span> 
</pre>
</div>
<p>
当所指定的描述符中的一个已准备好或捕捉到一个信号则返回，否则无限期等待
</p>

<ul class="org-ul">
<li>完全不等待</li>
</ul>
<div class="org-src-container">
<pre class="src src-C">tvptr-&gt;tv_sec = 0 &amp;&amp; tvptr-&gt;tv_usec = 0
</pre>
</div>
<p>
测试所有指定的描述符并立即返回。这是得到多个描述符的状态而不阻塞select函数的轮询方法
</p>

<ul class="org-ul">
<li>等待指定的秒数和微秒数</li>
</ul>
<div class="org-src-container">
<pre class="src src-C">tvptr-&gt;tv_sec !=0 || tvptr-&gt;tv_usec != 0
</pre>
</div>
<p>
当指定的描述符之一已准备好，或当指定的时间值已经超过时立即返回，与第一种情况一样，等待可被捕捉到的信号中断
</p>
</div>
</div>

<div id="outline-container-orgd846c1f" class="outline-5">
<h5 id="orgd846c1f">返回值</h5>
<div class="outline-text-5" id="text-orgd846c1f">
<p>
select有三个可能的返回值：
</p>
<ul class="org-ul">
<li>-1：出错，例如在所指定的描述符都没有准备好时捕捉到一个信号，并且errno设置为EINTR</li>
<li>0：没有描述符准备好，而且指定的时间已经超过</li>
<li>&gt;0：已经准备好的描述符数，在这种情况下三个描述符集中仍旧打开的位是对应于已准备好的描述符位</li>
</ul>

<p>
对于“准备好”的意思要作一些更具体的说明：
</p>
<ul class="org-ul">
<li>若对读集中的一个描述符的read不会阻塞，则此描述符是准备好的</li>
<li>若对写集中的一个描述符的write不会阻塞，则此描述符是准备好的</li>
<li>若对异常条件集(exceptfds)中的一个描述符有一个未决异常条件，则此描述符是准备好的。而异常条件包括:
<ul class="org-ul">
<li>在网络连接上到达指定波特率外的数据</li>
<li>在处于数据包方式的伪终端上发生了某些条件</li>
</ul></li>
</ul>

<p>
一个描述符阻塞与否并不影响select是否阻塞，也就是说如果希望读一个非阻塞描述符，并且以超时值为5秒调用select，则select最多阻塞5秒。相类似如果指定一个无限的超时值，则select阻塞到对该描述符数据准备好，或捕捉到一个信号
</p>

<p>
如果在一个描述符上碰到了文件结束，则select认为该描述符是可读的。然后调用read，它返回0，这是UNIX指示到达文件结尾处的方法。很多人错误地认为，当到达文件结尾处时，select会指示一个异常条件
</p>
</div>
</div>

<div id="outline-container-org3298acd" class="outline-5">
<h5 id="org3298acd">pselect函数</h5>
<div class="outline-text-5" id="text-org3298acd">
<p>
pselect函数是select的变体：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/select.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">pselect</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">nfds</span>,
        <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">readfds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">writefds</span>, <span style="color: #98f5ff;">fd_set</span> *<span style="color: #4eee94;">exceptfds</span>,
        <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">timespec</span> *<span style="color: #4eee94;">timeout</span>,
        <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">sigset_t</span> *<span style="color: #4eee94;">sigmask</span>);
</pre>
</div>
<p>
主要区别：
</p>
<ul class="org-ul">
<li>定时采用了纳秒级的timespec结构</li>
<li>timespec参数声明为const</li>
<li>使用信号集屏蔽不需要的信号</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3d4f674" class="outline-4">
<h4 id="org3d4f674">poll函数</h4>
<div class="outline-text-4" id="text-org3d4f674">
<p>
SVR4的poll函数类似于select，但是其调用形式则有所不同
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;poll.h&gt;</span>

<span style="color: #ffebcd;">/**</span>

<span style="color: #ffebcd;"> */</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">poll</span>(<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">pollfd</span> *<span style="color: #4eee94;">fds</span>, <span style="color: #98f5ff;">nfds_t</span> <span style="color: #4eee94;">nfds</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">timeout</span>);
</pre>
</div>
</div>
<div id="outline-container-org06a22cc" class="outline-5">
<h5 id="org06a22cc">pollfd结构</h5>
<div class="outline-text-5" id="text-org06a22cc">
<p>
与select不同，poll不是为每个条件构造一个描述符集，而是构造一个pollfd结构数组，每个数组元素指定一个描述符编号以及对其所关心的条件：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">pollfd</span>
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25991;&#20214;&#25551;&#36848;&#31526;&#21495;&#25110;&lt;0&#34920;&#31034;&#24573;&#30053;</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">events</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#20851;&#24515;&#30340;&#20107;&#20214;,&#30001;&#29992;&#25143;&#31243;&#24207;&#35774;&#32622; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">revents</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#24050;&#32463;&#21457;&#29983;&#30340;&#20107;&#20214;,&#30001;&#31995;&#32479;&#35774;&#32622; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
events成员应该被设置为表12-1中所示值的一个或几个。这些值告诉内核对该描述符关心的是什么。同样返回时，内核设置revents成员，以说明对该描述符发生了什么事件：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> poll的events和revents标志</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">名称</td>
<td class="org-left">从events得到的输入</td>
<td class="org-left">从revents得到的结果</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">POLLIN</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取出高优先级之外的数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLRDNORM</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取普通数据(优先级为0)，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLRDBAND</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取非0优先级波段数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLPRI</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">读取高优先级数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLOUT</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">写普通数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLWRNORM</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">和POLLOUT相同</td>
</tr>

<tr>
<td class="org-left">POLLWRBAND</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">写非0优先级数据，不阻塞</td>
</tr>

<tr>
<td class="org-left">POLLERR</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">已经出错</td>
</tr>

<tr>
<td class="org-left">POLLHUP</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">已经挂断</td>
</tr>

<tr>
<td class="org-left">POLLNVAL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">描述符无效</td>
</tr>
</tbody>
</table>

<p>
头四行测试可读性，接着三行测试可写性，最后三行则是异常条件。最后三行是由内核在返回时设置的。即使在events字段中没有指定这三个值，如果相应条件发生，则在revents中也返回它们
</p>

<p>
当一个描述符被挂断后(POLLHUP)，就不能再写向该描述符。但是仍可能从该描述符读取到数据
</p>

<p>
注意：poll没有更改events成员，这与select不同，select修改其参数以指示哪一个描述符已准备好了
</p>
</div>
</div>
<div id="outline-container-orgbcec766" class="outline-5">
<h5 id="orgbcec766">nfds参数</h5>
<div class="outline-text-5" id="text-orgbcec766">
<p>
nfds参数表明fds数组的元素数目
</p>
</div>
</div>
<div id="outline-container-org039d149" class="outline-5">
<h5 id="org039d149">timeout参数</h5>
<div class="outline-text-5" id="text-org039d149">
<p>
timeout参数说明想要等待多少时间。有三种不同的情形: 
</p>

<ul class="org-ul">
<li>永远等待：</li>
</ul>
<div class="org-src-container">
<pre class="src src-C">timeout = INFTIM
</pre>
</div>
<p>
常数INFTIM定义在&lt;stropts.h&gt;，其值通常是-1。当所指定的描述符中的一个已准备好，或捕捉到一个信号则返回
</p>

<ul class="org-ul">
<li>不等待：</li>
</ul>
<div class="org-src-container">
<pre class="src src-C">timeout = 0
</pre>
</div>
<p>
测试所有描述符并立即返回。这是得到很多个描述符的状态而不阻塞poll函数的轮询方法
</p>

<ul class="org-ul">
<li>等待timeout毫秒：</li>
</ul>
<div class="org-src-container">
<pre class="src src-C">timeout &gt; 0
</pre>
</div>
<p>
当指定的描述符之一已准备好或指定的时间值已超过时立即返回。同样可以被一个信号中断
</p>
</div>
</div>
<div id="outline-container-org4205fdc" class="outline-5">
<h5 id="org4205fdc">返回值</h5>
<div class="outline-text-5" id="text-org4205fdc">
<p>
poll也有三个可能的返回值：
</p>
<ul class="org-ul">
<li>-1：出错，例如在所指定的描述符都没有准备好时捕捉到一个信号，并且errno设置为EINTR</li>
<li>0：没有描述符准备好，而且指定的时间已经超过</li>
<li>&gt;0：准备就绪的描述符数，在这种情况下三个描述符集中仍旧打开的位是对应于已准备好的描述符位</li>
</ul>

<p>
不论一个描述符是否阻塞,并不影响poll是否阻塞
</p>

<p>
文件结束与挂断之间的区别：如果正在终端输入数据，并键入文件结束字符，POLLIN被打开，于是就可读文件结束指示(read返回0)，POLLHUP在revents中没有打开。如果读调制解调器，并且电话线已挂断，则在revents中将接到POLLHUP
</p>
</div>
</div>
</div>
<div id="outline-container-org3ce09ff" class="outline-4">
<h4 id="org3ce09ff">中断性</h4>
<div class="outline-text-4" id="text-org3ce09ff">
<p>
中断的系统调用的自动再起动是由4.2+BSD引进的，但当时select函数是不再起动的。这种特性延续到4.3+BSD，即使指定了SA_RESTART也是为此。但是，在SVR4之下，如果指定了SA_RESTART，那么select和poll也是自动再起动的。为了将软件移植到SVR4时阻止这一点，如果信号可能中断select或poll，则总是使用signal_intr函数
</p>
</div>
</div>
</div>

<div id="outline-container-org0f937da" class="outline-3">
<h3 id="org0f937da">异步IO</h3>
<div class="outline-text-3" id="text-org0f937da">
<p>
还有一种技术称之为异步I/O，基本思想是进程告诉内核，当一个描述符已准备好可以进行I/O时，用一个信号通知进程。这种技术有两个问题：
</p>
<ol class="org-ol">
<li>并非所有系统都支持这种机制，现在它还不是POSIX的组成部分。SVR4为此技术提供SIGPOLL信号，但是仅当描述符引用流设备时才能工作。4.3+BSD有一个类似的信号SIGIO，但是仅当描述符引用终端设备或网络时才能工作</li>
<li>这种信号对每个进程而言只有1个。如果使该信号对两个描述符都起作用，那么在接到此信号时进程无法判别是哪一个描述符已准备好可以进行I/O。为了确定是哪一个描述符已准备好，仍需将这两个描述符都设置为非阻塞的，并顺序试执行I/O</li>
</ol>

<p>
系统只是告诉某个事件发生在文件描述符，但并不告诉关于文件描述符状态变化的任何信息，需要主动地使用select或poll来查询描述符状态
</p>
</div>

<div id="outline-container-orgc8369de" class="outline-4">
<h4 id="orgc8369de">BSD实现</h4>
<div class="outline-text-4" id="text-orgc8369de">
<p>
BSD实现异步IO使用的信号是SIGIO和SIGURG。SIGIO是通用异步信号，而SIGURG是通知进程在网络连接上有非规定波特率数据
</p>

<p>
为了使用SIGIO的话，需要执行下面三个步骤：
</p>
<ol class="org-ol">
<li>调用signal为SIGIO建立处理函数</li>
<li>使用F_SETOWN为fd设置进程和进程组。因为一旦fd触发信号的话，系统是要决定信号投递到哪个进程和进程组的</li>
<li>使用F_SETFL来设置O_ASYNC文件状态标志，仅仅用于终端或者是网络的描述符</li>
</ol>

<p>
对于SIGURG只需要设置前面两个步骤，信号仅仅是用于支持非规定波特率数据的网络连接描述符产生的
</p>
</div>

<div id="outline-container-org7034740" class="outline-5">
<h5 id="org7034740">实例</h5>
<div class="outline-text-5" id="text-org7034740">
<p>
使用SIGIO信号实现异步IO
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;signal.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">id</span> = 0;

<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">sig_handler</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">signo</span>){
    printf(<span style="color: #deb887;">"%d received(%d)\n"</span>,strsignal(signo),id);
    id++;
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(){
    signal(SIGIO,sig_handler);
    fcntl(0,F_SETOWN,getpid());
    fcntl(0,F_SETFL,fcntl(0,F_GETFL) | O_ASYNC);
    pause();
    <span style="color: #00bfff; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc4ed23c" class="outline-2">
<h2 id="orgc4ed23c">readv和writev</h2>
<div class="outline-text-2" id="text-orgc4ed23c">
<p>
readv和writev函数用于在一个函数调用中读、写多个非连续缓存
</p>
<ul class="org-ul">
<li>readv：散布读</li>
<li>writev：聚集写</li>
</ul>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span> 
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/uio.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20174;fileds&#20013;&#35835;&#20837;&#30340;&#25968;&#25454;&#25353;&#39034;&#24207;&#36880;&#22359;&#20998;&#25955;&#23384;&#20648;&#22312;iov&#25351;&#21521;&#30340;iovcnt&#20010;&#32531;&#20914;&#21306;&#20013;</span>

<span style="color: #ffebcd;">   fileds&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;">   iov&#65306;&#25351;&#21521;&#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;</span>
<span style="color: #ffebcd;">   iovcnt&#65306;&#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#20803;&#32032;&#25968;&#30446;</span>

<span style="color: #ffebcd;">   return&#65306;&#24050;&#35835;&#21462;&#30340;&#23383;&#33410;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520; font-weight: bold;">readv</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">iovec</span> *<span style="color: #4eee94;">iov</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">iovcnt</span>);

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#23558;iovcnt&#20010;&#32531;&#20914;&#21306;&#30340;&#25968;&#25454;&#25353;&#39034;&#24207;&#36880;&#22359;&#36830;&#32493;&#30340;&#20889;&#20837;fileds</span>

<span style="color: #ffebcd;">   fileds&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;">   iov&#65306;&#25351;&#21521;&#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#20803;&#32032;</span>
<span style="color: #ffebcd;">   iovcnt&#65306;&#32531;&#23384;&#21306;&#32467;&#26500;&#25968;&#32452;&#30340;&#20803;&#32032;&#25968;&#30446;</span>

<span style="color: #ffebcd;">   return&#65306;&#24050;&#20889;&#20986;&#30340;&#23383;&#33410;&#25968;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">ssize_t</span> <span style="color: #daa520; font-weight: bold;">writev</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">iovec</span> *<span style="color: #4eee94;">iov</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">iovcnt</span>);
</pre>
</div>
</div>

<div id="outline-container-org4fc7424" class="outline-3">
<h3 id="org4fc7424">iovec结构</h3>
<div class="outline-text-3" id="text-org4fc7424">
<p>
iovec结构用来说明缓存区：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">iovec</span>
{
    <span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">iov_base</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#32531;&#20914;&#21306;&#36215;&#22987;&#22320;&#22336; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">iov_len</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#32531;&#20914;&#21306;&#38271;&#24230; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
图12-11显示了readv和writev的参数和iovec结构之间的关系：
</p>


<div class="figure">
<p><img src="pic/iovec.png" alt="iovec.png" width="90%" /> 
</p>
</div>

<ul class="org-ul">
<li>writev以顺序iov[ 0 ]，iov[ 1 ]至iov[ iovcnt-1 ]从缓存中聚集输出数据。writev返回输出的字节总数，等于所有缓存长度之和</li>
<li>readv则将读入的数据按上述同样顺序散布到缓存中，总是先填满一个缓存，然后再填写下一个。readv返回读得的总字节数，如果遇到文件结尾，已无数据可读，则返回0</li>
</ul>
</div>
</div>


<div id="outline-container-org5bbffa3" class="outline-3">
<h3 id="org5bbffa3">性能测试</h3>
<div class="outline-text-3" id="text-org5bbffa3">
<p>
有三种方法可以实现从两个缓存区写入一个文件:
</p>
<ol class="org-ol">
<li>调用write两次，一次一个缓存</li>
<li>分配一个大到足以包含两个缓存的新缓存。将两个缓存的内容复制到新缓存中。然后对该缓存调用wrtre一次</li>
<li>调用writev输出两缓存</li>
</ol>

<p>
测试结果显示：调用两次write几乎是另外两种方法的2倍时间，采用缓存复制后用一个write与采用一个writev所用CPU时间几乎一样，但一般说来，因为前者还需要分配一个临时缓存用于存储及复制，所以后者更复杂
</p>
</div>
</div>
</div>

<div id="outline-container-orgd29cb0a" class="outline-2">
<h2 id="orgd29cb0a">存储映射IO</h2>
<div class="outline-text-2" id="text-orgd29cb0a">
<p>
存储映射I/O使一个磁盘文件与存储空间中的一个缓存相映射。于是当从缓存中取数据就相当于读文件中的相应字节，而将数据存入缓存，则相应字节就自动地写入文件。这样，就可以在不使用read和write的情况下执行I/O
</p>
</div>

<div id="outline-container-org0a96bec" class="outline-3">
<h3 id="org0a96bec">mmap函数</h3>
<div class="outline-text-3" id="text-org0a96bec">
<p>
mmap函数：告诉内核将一个给定的文件映射到一个存储区域中
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#30913;&#30424;&#25991;&#20214;&#26144;&#23556;&#21040;&#20869;&#23384;&#20013;&#30340;&#32531;&#20914;&#21306;</span>

<span style="color: #ffebcd;">   addr&#65306;&#32531;&#23384;&#21306;&#30340;&#39318;&#22320;&#22336;&#65292;&#19968;&#33324;&#20026;NULL&#65292;&#34920;&#31034;&#31995;&#32479;&#33258;&#24049;&#20998;&#37197;&#65292;&#24212;&#20026;&#31995;&#32479;&#34394;&#25311;&#20869;&#23384;&#39029;&#30340;&#25972;&#25968;&#20493;</span>
<span style="color: #ffebcd;">   len&#65306;&#32531;&#23384;&#21306;&#38271;&#24230;</span>
<span style="color: #ffebcd;">   prot&#65306;&#25991;&#20214;&#20445;&#25252;&#27169;&#24335;&#65292;PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC&#30340;&#20219;&#24847;&#25110;&#36923;&#36753;&#30340;&#32452;&#21512;</span>
<span style="color: #ffebcd;">   flag&#65306;MAP_FIXED &#35201;&#27714;&#31995;&#32479;&#20351;&#29992;&#25351;&#23450;&#30340; addr,&#19981;&#24314;&#35758;&#20351;&#29992;&#27492;&#26631;&#24535;</span>
<span style="color: #ffebcd;">     MAP_SHARED &#20462;&#25913;&#32531;&#20914;&#21306;&#21363;&#20026;&#30452;&#25509;&#20462;&#25913;&#25991;&#20214;</span>
<span style="color: #ffebcd;">     MAP_PRIVATE(&#32531;&#20914;&#21306;&#20165;&#20165;&#26159;&#25991;&#20214;&#30340;&#21103;&#26412;</span>
<span style="color: #ffebcd;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;">   off&#65306;&#25991;&#20214;&#20013;&#30340;&#36215;&#22987;&#20301;&#32622;&#65292;&#24212;&#20026;&#31995;&#32479;&#34394;&#25311;&#20869;&#23384;&#39029;&#30340;&#25972;&#25968;&#20493;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#26144;&#23556;&#21306;&#30340;&#36215;&#22987;&#22320;&#22336;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> *<span style="color: #daa520; font-weight: bold;">mmap</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">prot</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flag</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">off</span>);
</pre>
</div>
<p>
返回值：该映射区的起始地址
</p>
</div>
<div id="outline-container-org509997f" class="outline-4">
<h4 id="org509997f">参数说明</h4>
<div class="outline-text-4" id="text-org509997f">
<ul class="org-ul">
<li>addr：映射存储区的起始地址，通常将其设置为NULL，这表示由系统选择该映射区的起始地址</li>
<li>filedes：要被映射文件的描述符。在映射该文件到一个地址空间之前，先要打开该文件</li>
<li>len：映射的字节数</li>
<li>off：要映射字节在文件中的起始位移量</li>
</ul>
</div>

<div id="outline-container-org6168bec" class="outline-5">
<h5 id="org6168bec">prot参数</h5>
<div class="outline-text-5" id="text-org6168bec">
<p>
prot参数说明映射存储区的保护要求：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> 存储映射区的保护</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">prot</td>
<td class="org-left">说明</td>
</tr>

<tr>
<td class="org-left">PROT_READ</td>
<td class="org-left">区域可读</td>
</tr>

<tr>
<td class="org-left">PROT_WRITE</td>
<td class="org-left">区域可写</td>
</tr>

<tr>
<td class="org-left">PROT_EXEC</td>
<td class="org-left">区域可执行</td>
</tr>

<tr>
<td class="org-left">PROT_NONE</td>
<td class="org-left">区域可存取(BSD无此选项)</td>
</tr>
</tbody>
</table>

<p>
对于映射存储区所指定的保护要求与文件的open方法匹配。例如，若该文件是只读打开的，那么对映射存储区就不能指定PROT_WRITE 
</p>
</div>
</div>
<div id="outline-container-org8254d55" class="outline-5">
<h5 id="org8254d55">flag参数</h5>
<div class="outline-text-5" id="text-org8254d55">
<p>
flag参数影响映射存储区的多种属性：
</p>
<ul class="org-ul">
<li>MAP_FIXED：返回值必须等于addr。因为这不利于可移植性，所以不鼓励使用此标志。如果未指定此标志，而且addr非0，则内核只把addr视为何处设置映射区的一种建议。通过将addr指定为NULL可获得最大可移植性</li>
<li>MAP_SHARED：本进程对映射区所进行的存储操作的配置。指定存储操作修改映射文件，这意味着存储操作相当于对该文件write</li>
<li>MAP_PRIVATE：对映射区的存储操作导致创建该映射文件的一个副本。所有后来对该映射区的存访都是存访该副本，而不是原始文件</li>
</ul>
</div>
</div>
<div id="outline-container-orgd7e6c11" class="outline-5">
<h5 id="orgd7e6c11">off和addr参数限制</h5>
<div class="outline-text-5" id="text-orgd7e6c11">
<p>
下图显示了一个存储映射文件：
</p>

<div class="figure">
<p><img src="pic/mmap.png" alt="mmap.png" width="90%" /> 
</p>
</div>

<p>
off和addr的值通常应当是系统虚存页长度的倍数，一般这2个值都是NULL或0，所以这不会造成太大的问题 
</p>

<p>
因为映射文件的起动位移量受系统虚存页长度的限制，那么如果映射区的长度不是页长度的整数倍时，将如何呢？假定文件长12字节，系统页长为512字节，则系统通常提供512字节的映射区，其中后500字节被设为0。可以修改这500字节，但任何变动都不会在文件中反映出来
</p>
</div>
</div>
</div>
<div id="outline-container-orgc2c083d" class="outline-4">
<h4 id="orgc2c083d">信号和进程</h4>
<div class="outline-text-4" id="text-orgc2c083d">
<p>
与映射存储区相关有两个信号：
</p>
<ul class="org-ul">
<li>SIGSEGV：通常用于指示进程试图存取它不能存取的存储区。如果进程企图存数据到用mmap指定为只读的映射存储区，那么也产生此信号</li>
<li>SIGBUS：如果存取映射区的某个部分，而在存储时这一部分已不存在，则产生此信号。例如用文件长度映射一个文件，但在存访该映射区之前，另一个进程已将该文件截短，此时如果进程企图存取对应于该文件尾端部分的映射区，则接收到SIGBUS信号</li>
</ul>

<p>
进程在fork和exec后：
</p>
<ul class="org-ul">
<li>fork：子进程继承存储映射区，这是因为子进程复制父进程地址空间，而存储映射区是该地址空间中的一部分</li>
<li>exec：新程序则不继承此存储映射区</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org9727c56" class="outline-3">
<h3 id="org9727c56">munmap函数</h3>
<div class="outline-text-3" id="text-org9727c56">
<p>
munmap函数：解除内存映射
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#35299;&#38500;&#23384;&#20648;&#26144;&#23556;</span>

<span style="color: #ffebcd;">   addr&#65306;&#32531;&#23384;&#21306;&#39318;&#22320;&#22336;</span>
<span style="color: #ffebcd;">   len&#65306;&#32531;&#23384;&#21306;&#38271;&#24230;</span>

<span style="color: #ffebcd;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">munmap</span>(<span style="color: #98f5ff;">caddr_t</span> <span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>);
</pre>
</div>
<p>
进程终止时或调用了munmap之后，存储映射区就被自动去除
</p>

<p>
注意：关闭文件描述符filedes并不解除映射区
</p>
</div>
</div>

<div id="outline-container-orge175495" class="outline-3">
<h3 id="orge175495">msync函数</h3>
<div class="outline-text-3" id="text-orge175495">
<p>
调用munmap并不使映射区的内容写到磁盘文件上，调用msync函数才使修改后的数据反应到映射的磁盘文件中　
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#20351;&#20462;&#25913;&#21518;&#30340;&#25968;&#25454;&#26356;&#26032;&#21040;&#26144;&#23556;&#30340;&#30913;&#30424;&#25991;&#20214;&#20013;</span>

<span style="color: #ffebcd;">   addr&#65306;&#26144;&#23556;&#32531;&#23384;&#21306;&#39318;&#22320;&#22336;</span>
<span style="color: #ffebcd;">   len&#65306;&#26144;&#23556;&#32531;&#23384;&#21306;&#38271;&#24230;</span>
<span style="color: #ffebcd;">   flags&#65306;&#26356;&#26032;&#26041;&#24335; MS_ASYNC(&#24322;&#27493;&#26356;&#26032;&#65292;&#31435;&#21363;&#36820;&#22238;)&#65292;MS_SYNC(&#21516;&#27493;&#26356;&#26032;&#65292;&#26356;&#26032;&#23436;&#25104;&#21518;&#25165;&#36820;&#22238;)</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">msync</span>(<span style="color: #98f5ff;">void</span> *<span style="color: #4eee94;">addr</span>, <span style="color: #98f5ff;">size_t</span> <span style="color: #4eee94;">len</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">flags</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd8d9df" class="outline-3">
<h3 id="orgbd8d9df">使用内存映射拷贝文件</h3>
<div class="outline-text-3" id="text-orgbd8d9df">
<p>
下面程序用存储映射I/O复制一个文件。首先打开两个文件，然后调用fstat得到输入文件的长度。在调用mmap和设置输出文件长度时都需使用输入文件长度，因此调用lseek，然后写一个字节以设置输出文件的长度。如果不设置输出文件的长度，则对输出文件调用mmap也可以，但是对相关存储区的第一次存访会产生SIGBUS。也可使用ftruncate函数来设置输出文件的长度，但是并非所有系统都支持该函数扩充文件长度
</p>

<p>
然后对每个文件调用mmap，将文件映射到存储区，最后调用memcpy将输入缓存的内容复制到输出缓存。在从输入缓存(src)取数据字节时，内核自动读输入文件，同样在将数据存入输出缓存(dst)时，内核自动将数据写到输出文件中
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/mman.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span>         <span style="color: #4eee94;">fdin</span>, <span style="color: #4eee94;">fdout</span>;
    <span style="color: #98f5ff;">void</span>        *<span style="color: #4eee94;">src</span>, *<span style="color: #4eee94;">dst</span>;
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">stat</span> <span style="color: #4eee94;">statbuf</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 3)
        err_quit(<span style="color: #deb887;">"usage: %s &lt;fromfile&gt; &lt;tofile&gt;"</span>, argv[0]);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fdin = open(argv[1], O_RDONLY)) &lt; 0)
        err_sys(<span style="color: #deb887;">"can't open %s for reading"</span>, argv[1]);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((fdout = open(argv[2], O_RDWR | O_CREAT | O_TRUNC,
              FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"can't creat %s for writing"</span>, argv[2]);

    <span style="color: #00bfff; font-weight: bold;">if</span> (fstat(fdin, &amp;statbuf) &lt; 0)  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">need size of input file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        err_sys(<span style="color: #deb887;">"fstat error"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">set size of output file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (lseek(fdout, statbuf.st_size - 1, SEEK_SET) == -1)
        err_sys(<span style="color: #deb887;">"lseek error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(fdout, <span style="color: #deb887;">""</span>, 1) != 1)
        err_sys(<span style="color: #deb887;">"write error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((src = mmap(0, statbuf.st_size, PROT_READ, MAP_SHARED,
            fdin, 0)) == MAP_FAILED)
        err_sys(<span style="color: #deb887;">"mmap error for input"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> ((dst = mmap(0, statbuf.st_size, PROT_READ | PROT_WRITE,
            MAP_SHARED, fdout, 0)) == MAP_FAILED)
        err_sys(<span style="color: #deb887;">"mmap error for output"</span>);

    memcpy(dst, src, statbuf.st_size);  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">does the file copy </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    exit(0);
}
</pre>
</div>

<p>
测试：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">&#20351;&#29992;cp&#21644;mmap&#25335;&#36125;&#19968;&#20010;1.2G&#38271;&#24230;&#30340;&#25991;&#20214;</span>
$ time cp ~/Movie/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land.mkv ./ 

real    0m23.824s
user    0m0.010s
sys     0m2.170s

$ time ./mcopy ~/Movie/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land/La<span style="color: #deb887;">\ </span>La<span style="color: #deb887;">\ </span>Land.mkv ./a.mkv

real    0m16.796s
user    0m0.186s
sys     0m1.079s
</pre>
</div>

<p>
测试结果显示将一个普通文件复制到另一个普通文件中时，存储映射I/O比较快。但是有一些限制，如不能用在某些设备之间(例如网络设备或终端设备)进行复制。并且对被复制的文件进行映射后，也要注意该文件的长度是否改变。尽管如此有很多应用程序会从存储映射I/O得到好处，因为它处理的是内存而不是读、写一个文件，所以常常可以简化算法
</p>
</div>
</div>
</div>

<div id="outline-container-org4461bec" class="outline-2">
<h2 id="org4461bec">记录锁</h2>
<div class="outline-text-2" id="text-org4461bec">
<p>
当两个人同时编辑一个文件时，其后果将如何呢？在很多UNIX系统中，该文件的最后状态取决于写该文件的最后一个进程。但是对于有些应用程序，例如数据库，有时进程需要确保它正在单独写一个文件。为了向进程提供这种功能，较新的UNIX系统提供了记录锁机制
</p>

<p>
记录锁的功能是：一个进程正在读或修改文件的某个部分时，可以阻止其他进程修改同一文件区。对于UNIX，“记录”这个定语也是误用，因为UNIX内核根本没有使用文件记录这种概念。一个更适合的术语可能是“区域锁”，因为它锁定的只是文件的一个区域(也可能是整个文件)
</p>
</div>

<div id="outline-container-orgc523dac" class="outline-3">
<h3 id="orgc523dac">历史</h3>
<div class="outline-text-3" id="text-orgc523dac">
<p>
下面表列出了各种UNIX系统提供的不同形式的记录锁：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> 各种UNIX系统支持的记录锁形式</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">系统</td>
<td class="org-left">建议性</td>
<td class="org-left">强制性</td>
<td class="org-left">fcntl</td>
<td class="org-left">lockf</td>
<td class="org-left">flock</td>
</tr>

<tr>
<td class="org-left">POSIX.1</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">XPG3</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SVR2</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SVR3,SVR4</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">4.3BSD</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>

<tr>
<td class="org-left">4.3BSD Reno</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">•</td>
</tr>
</tbody>
</table>

<p>
POSIX.1选择了以fcntl函数为基础的系统V风格的记录锁，这种风格也得到4.3BSDReno版本的支持:
</p>

<ul class="org-ul">
<li>fcntl函数可以锁文件中的任一区域，大至整个文件，小至单个字节</li>
<li>早期的伯克利版只支持flock函数，此函数只锁整个文件，而不锁文件中的一个区域</li>
<li>系统V的lockf函数只是fcntl函数的一个界面</li>
</ul>
</div>
</div>

<div id="outline-container-orgd1c833a" class="outline-3">
<h3 id="orgd1c833a">fcntl记录锁</h3>
<div class="outline-text-3" id="text-orgd1c833a">
<p>
第三章已经给出了fcntl函数的原型：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/types.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #ffebcd;">/**</span>
<span style="color: #ffebcd;">   &#25913;&#21464;&#24050;&#32463;&#25171;&#24320;&#25991;&#20214;&#30340;&#24615;&#36136;</span>

<span style="color: #ffebcd;">   filedes&#65306;&#25991;&#20214;&#25551;&#36848;&#31526;</span>
<span style="color: #ffebcd;">   cmd&#65306;&#21151;&#33021;</span>
<span style="color: #ffebcd;">   args&#65306;&#21487;&#36873;&#21442;&#25968;</span>

<span style="color: #ffebcd;">   return&#65306;&#25104;&#21151;&#20381;&#36182;&#20110;cmd&#65292;&#22833;&#36133;-1</span>
<span style="color: #ffebcd;">*/</span>
<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">fcntl</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">filedes</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, ...<span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">int arg</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
</pre>
</div>
<p>
对于记录锁：
</p>
<ul class="org-ul">
<li>cmd：
<ol class="org-ol">
<li>F_GETLK</li>
<li>F_SETLK</li>
<li>F_SETLKW</li>
</ol></li>
<li>第三个参数flockptr是一个指向flock结构的指针</li>
</ul>
</div>

<div id="outline-container-orge79315b" class="outline-4">
<h4 id="orge79315b">flock结构</h4>
<div class="outline-text-4" id="text-orge79315b">
<p>
记录锁结构：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">flock</span> {
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">l_type</span>;      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#21253;&#25324; F_RDLOCK, F_WRLOCK, F_UNLOCK </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">l_start</span>;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#38145;&#30340;&#36215;&#28857; </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">short</span> <span style="color: #4eee94;">l_whence</span>;    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#21253;&#25324; SEEK_SET, SEEK_CUR, SEEK_END </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">l_len</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#20026; 0 &#26102;,&#34920;&#31034;&#20174;&#36215;&#28857;&#21040; EOF </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #98f5ff;">pid_t</span> <span style="color: #4eee94;">l_pid</span>;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">&#25317;&#26377;&#27492;&#38145;&#30340;&#36827;&#31243; PID </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
</div>

<div id="outline-container-org7cdbdaa" class="outline-5">
<h5 id="org7cdbdaa">锁类型</h5>
<div class="outline-text-5" id="text-org7cdbdaa">
<p>
锁类型：
</p>
<ol class="org-ol">
<li>F_RDLCK：共享读锁</li>
<li>F_WRLCK：独占性写锁</li>
<li>F_UNLCK：解锁一个区域</li>
</ol>

<p>
多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上的写锁则只能由一个进程独用。更进一步，如果在一个给定字节上已经有一把或多把读锁，则不能在该字节上再加写锁，如果在一个字节上已经有一把独占性的写锁，则不能再对它加任何读锁。下表中示出了这些规则：
</p>
<!-- This HTML table template is generated by emacs 26.1 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;区域当前&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;锁类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;读锁&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;写锁&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;无锁&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;允许&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;允许&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      一至多把读
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;允许&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;拒绝&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;一把写锁&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;拒绝&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;拒绝&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

<ul class="org-ul">
<li>加读锁时，该文件描述符必须是读打开</li>
<li>加写锁时，该文件描述符必须是写打开</li>
</ul>
</div>
</div>

<div id="outline-container-org56af928" class="outline-5">
<h5 id="org56af928">锁区域</h5>
<div class="outline-text-5" id="text-org56af928">
<ul class="org-ul">
<li>要加锁或解锁的区域的起始地址由l_start和l_whence两者决定：
<ol class="org-ol">
<li>l_start是相对位移量(字节)</li>
<li>l_whence则决定了相对位移量的起点</li>
</ol></li>
<li>区域的长度由l_len表示</li>
</ul>

<p>
注意：
</p>
<ul class="org-ul">
<li>该区域可以在当前文件尾端处开始或越过其尾端处开始，但是不能在文件起始位置之前开始或越过该起始位置</li>
<li>如果l_len为0，则表示锁的区域从其起点开始直至最大可能位置为止。不管添写到该文件中多少数据，都处于锁的范围</li>
<li>为了锁整个文件，通常的方法是将l_start说明为0，l_whence说明为SEEK_SET，l_len说明为0</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcdfa32b" class="outline-4">
<h4 id="orgcdfa32b">cmd命令</h4>
<div class="outline-text-4" id="text-orgcdfa32b">
<p>
以下说明fcntl函数的三种命令：
</p>
<ol class="org-ol">
<li>F_GETLK：测试由flockptr所描述的锁是否被另外一把锁所排斥(阻塞)
<ul class="org-ul">
<li>如果存在一把锁，它阻止创建由flockptr所描述的锁，则这把现存的锁的信息写到flockptr指向的结构中</li>
<li>如果不存在这种情况，则除了将l_type设置为F_UNLCK之外，flockptr所指向结构中的其他信息保持不变</li>
</ul></li>
<li>F_SETLK：设置由flockptr所描述的锁
<ul class="org-ul">
<li>如果试图建立一把按上述兼容性规则并不允许的锁，则fcntl立即出错返回，此时errno设置为EACCES或EAGAIN</li>
<li>也用来清除由flockptr说明的锁(l_type为F_UNLCK)</li>
</ul></li>
<li>F_SETLKW：F_SETLK的阻塞版本
<ul class="org-ul">
<li>如果由于存在其他锁，那么按兼容性规则由flockptr所要求的锁不能被创建，则调用进程睡眠，如果捕捉到信号则睡眠中断</li>
</ul></li>
</ol>

<p>
使用过程中要注意：
</p>
<ul class="org-ul">
<li>用F_GETLK测试能否建立一把锁，然后用F_SETLK和F_SETLKW企图建立一把锁，这两者不是一个原子操作。在这两个操作之间可能会有另一个进程插入并建立一把相关的锁，使原来测试到的情况发生变化</li>
<li>如果不希望在建立锁时可能产生的长期阻塞，则应使用F_SETLK，并对返回结果进行测试，以判别是否成功地建立了所要求的锁</li>
<li>在设置或释放文件上的一把锁时，系统按需组合或裂开相邻区：
<ul class="org-ul">
<li>若对字节0~99设置一把读锁，然后对字节0~49设置一把写锁，则有两个加锁区:0~49字节(写锁)及50~99(读锁)</li>
<li>若100~199字节是加锁的区，需解锁第150字节，则内核将维持两把锁，一把用于100~149字节，另一把用于151~199字节</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org6cb22e9" class="outline-5">
<h5 id="org6cb22e9">要求和释放一把锁</h5>
<div class="outline-text-5" id="text-org6cb22e9">
<p>
为了避免每次分配flock结构，然后又填入各项信息，可以用函数lock_reg来处理这些细节：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">lock_reg</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">cmd</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">type</span>,
         <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">offset</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">whence</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">len</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">flock</span>    <span style="color: #4eee94;">lock</span>;

    lock.l_type = type;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">F_RDLCK, F_WRLCK, F_UNLCK </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_start = offset;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">byte offset, relative to l_whence </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_whence = whence; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">SEEK_SET, SEEK_CUR, SEEK_END </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_len = len;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">#bytes (0 means to EOF) </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">return</span>(fcntl(fd, cmd, &amp;lock));
}
</pre>
</div>
<p>
使用下面五个宏来简化调用：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">read_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                          \
    lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">readw_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                             \
    lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">write_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                         \
    lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">writew_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                            \
    lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">un_lock</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                            \
    lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))
</pre>
</div>
<p>
用与lseek函数同样的顺序定义这些宏中的三个参数
</p>
</div>
</div>

<div id="outline-container-org4e63363" class="outline-5">
<h5 id="org4e63363">测试一把锁</h5>
<div class="outline-text-5" id="text-org4e63363">
<p>
lock_test函数用来测试一把锁：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #98f5ff;">pid_t</span> <span style="color: #daa520; font-weight: bold;">lock_test</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">type</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">offset</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">whence</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">len</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">flock</span>    <span style="color: #4eee94;">lock</span>;

    lock.l_type = type;     <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">F_RDLCK or F_WRLCK </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_start = offset;  <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">byte offset, relative to l_whence </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_whence = whence; <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">SEEK_SET, SEEK_CUR, SEEK_END </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    lock.l_len = len;       <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">#bytes (0 means to EOF) </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

    <span style="color: #00bfff; font-weight: bold;">if</span> (fcntl(fd, F_GETLK, &amp;lock) &lt; 0)
        err_sys(<span style="color: #deb887;">"fcntl error"</span>);

    <span style="color: #00bfff; font-weight: bold;">if</span> (lock.l_type == F_UNLCK)
        <span style="color: #00bfff; font-weight: bold;">return</span>(0);      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">false, region isn't locked by another proc </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">return</span>(lock.l_pid); <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">true, return pid of lock owner </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
}
</pre>
</div>
<p>
如果存在一把锁阻止由参数说明的锁，则此函数返回持有这把现存锁的进程的ID，否则此函数返回0。通常用下面两个宏来调用此函数：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">is_read_lockable</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                   \
    (lock_test((fd), F_RDLCK, (offset), (whence), (len)) == 0)
<span style="color: #ffd700;">#define</span> <span style="color: #daa520; font-weight: bold;">is_write_lockable</span>(<span style="color: #4eee94;">fd</span>, <span style="color: #4eee94;">offset</span>, <span style="color: #4eee94;">whence</span>, <span style="color: #4eee94;">len</span>)                  \
    (lock_test((fd), F_WRLCK, (offset), (whence), (len)) == 0)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf9157e1" class="outline-4">
<h4 id="orgf9157e1">死锁</h4>
<div class="outline-text-4" id="text-orgf9157e1">
<p>
如果两个进程相互等待对方持有并且不释放(锁定)的资源时，则这两个进程就处于死锁状态。如果一个进程已经控制了文件中的一个加锁区域，然后它又试图对另一个进程控制的区域加锁，则它就会睡眠，在这种情况下，有发生死锁的可能性
</p>
</div>

<div id="outline-container-orgf797553" class="outline-5">
<h5 id="orgf797553">死锁实例</h5>
<div class="outline-text-5" id="text-orgf797553">
<p>
子进程锁字节0，父进程锁字节1。然后它们中的每一个又试图锁对方已经加锁的字节。在该程序中使用了父子进程同步方法(TELL_xxx和WAIT_xxx)，使得对方都能建立第一把锁：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #98f5ff;">void</span> <span style="color: #daa520; font-weight: bold;">lockabyte</span>(<span style="color: #00bfff; font-weight: bold;">const</span> <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">name</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>, <span style="color: #98f5ff;">off_t</span> <span style="color: #4eee94;">offset</span>)
{
    <span style="color: #00bfff; font-weight: bold;">if</span> (writew_lock(fd, offset, SEEK_SET, 1) &lt; 0)
        err_sys(<span style="color: #deb887;">"%s: writew_lock error"</span>, name);
    printf(<span style="color: #deb887;">"%s: got the lock, byte %ld\n"</span>, name, offset);
}

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span>     <span style="color: #4eee94;">fd</span>;
    <span style="color: #98f5ff;">pid_t</span>   <span style="color: #4eee94;">pid</span>;

    <span style="color: #5f9ea0; font-style: italic;">/*</span>
<span style="color: #5f9ea0; font-style: italic;">     * Create a file and write two bytes to it.</span>
<span style="color: #5f9ea0; font-style: italic;">     </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> ((fd = creat(<span style="color: #deb887;">"templock"</span>, FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"creat error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd, <span style="color: #deb887;">"ab"</span>, 2) != 2)
        err_sys(<span style="color: #deb887;">"write error"</span>);

    TELL_WAIT();
    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid == 0) {          <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        lockabyte(<span style="color: #deb887;">"child"</span>, fd, 0);
        TELL_PARENT(getppid()); <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#29238;&#36827;&#31243;</span>
        WAIT_PARENT();
        lockabyte(<span style="color: #deb887;">"child"</span>, fd, 1);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        lockabyte(<span style="color: #deb887;">"parent"</span>, fd, 1);
        TELL_CHILD(pid); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">&#31561;&#24453;&#23376;&#36827;&#31243;</span>
        WAIT_CHILD();
        lockabyte(<span style="color: #deb887;">"parent"</span>, fd, 0);
    }
    exit(0);
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./deadlock 
parent: got the lock, byte 1
child: got the lock, byte 0
parent: writew_lock error: Resource deadlock avoided 
child: got the lock, byte 1

</pre>
</div>
<p>
检测到死锁时，内核必须选择一个进程收到出错返回。在本例中，选择了父进程，这是一个实现细节。当此程序在另一个系统上运行时有可能是子进程接到出错信息
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org1c29ed4" class="outline-3">
<h3 id="org1c29ed4">锁的隐含继承和释放</h3>
<div class="outline-text-3" id="text-org1c29ed4">
<p>
关于记录锁的自动继承和释放有三条规则:
</p>
<ul class="org-ul">
<li>锁与进程、文件两方面有关：
<ol class="org-ol">
<li>当一个进程终止时，它所建立的锁全部释放</li>
<li>任何时候关闭一个描述符时，则该进程通过这一描述符可以存访的文件上的任何一把锁都被释放(这些锁都是该进程设置的)</li>
</ol></li>
</ul>

<p>
如果执行下列四步:
</p>
<div class="org-src-container">
<pre class="src src-C">fd1 = open(pathname <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #daa520; font-weight: bold;">read_lock</span>(fd1 <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
fd2 = dup(fd1) ;
<span style="color: #daa520; font-weight: bold;">close</span>(fd2) ;
</pre>
</div>
<p>
则在close(fd2)后，在fd1上设置的锁被释放。如果将dup代换为open，其效果也一样:
</p>
<div class="org-src-container">
<pre class="src src-C">fd1 = open(pathname <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #daa520; font-weight: bold;">read_lock</span>(fd1 <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">, ...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
fd2 = open(fd1) ;
<span style="color: #daa520; font-weight: bold;">close</span>(fd2) ;
</pre>
</div>

<ul class="org-ul">
<li>由fork产生的子程序不继承父进程所设置的锁：若一个进程得到一把锁，然后调用fork，那么对于父进程获得的锁而言，子进程被视为另一个进程，对于从父进程处继承过来的任一描述符，子进程要调用fcntl以获得它自己的锁。如果子进程继承父进程的锁，则父、子进程就可以同时写同一个文件，而锁的作用就是为了阻止多个进程同时写同一个文件(或同一文件区域)。</li>

<li>在执行exec后，新程序可以继承原执行程序的锁</li>
</ul>
</div>
</div>

<div id="outline-container-orga692d44" class="outline-3">
<h3 id="orga692d44">BSD的实现</h3>
<div class="outline-text-3" id="text-orga692d44">
<p>
考虑一个进程，它执行下列语句(忽略出错返回)：
</p>
<div class="org-src-container">
<pre class="src src-C">fd1 = open(pathname<span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">,...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
<span style="color: #daa520; font-weight: bold;">write_lock</span>(fd1, 0, SEEK_SET, 1); <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">parent write locks byte 0</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
<span style="color: #00bfff; font-weight: bold;">if</span>(fork() &gt; 0) { <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">parent</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    fd2 = dup(fd1);
    fd3 = open(pathname<span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">,...</span><span style="color: #5f9ea0; font-style: italic;">*/</span>);
    pause();
} <span style="color: #00bfff; font-weight: bold;">else</span> {
    read_lock(fd1, 1, SEEK_SET, 1); <span style="color: #5f9ea0; font-style: italic;">/*</span><span style="color: #5f9ea0; font-style: italic;">child read locks byte 1</span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    pause();
}
</pre>
</div>
<p>
图12-1显示了父、子进程暂停(执行pause())后的数据结构情况：
</p>

<div class="figure">
<p><img src="pic/flock.png" alt="flock.png" width="90%" /> 
</p>
</div>

<p>
有了记录锁后，在原来的这些图上新加了flock结构，它们由i节点结构开始相互连接起来。注意：每个flock结构说明了一个给定进程的一个加锁区域。图中显示了两个flock结构，一个是由父进程调用write_lock形成的，另一个则是由子进程调用read_lock形成的。每一个结构都包含了相应进程ID
</p>

<p>
在父进程中关闭fd1、fd2和fd3中的任意一个都将释放由父进程设置的写锁。在关闭这三个描述符中的任意一个时，内核会从该描述符所关连的i节点开始逐个检查flock连接表中各项，并释放由调用进程持有的各把锁。内核并不清楚也不关心父进程是用哪一个描述符来设置这把锁的
</p>
</div>

<div id="outline-container-orgbdabe15" class="outline-4">
<h4 id="orgbdabe15">守护进程号加锁</h4>
<div class="outline-text-4" id="text-orgbdabe15">
<p>
守护进程使用建议性锁以保证该守护进程只有一个副本在运行。起动时很多守护进程都把它们的进程ID写到一个各自专用的PID文件上。系统停机时，可以从这些文件中取用这些守护进程的进程ID。防止一个守护进程有多份副本同时运行的方法是:在守护进程开始运行时，在它的进程ID文件上设置一把写锁。如果在它运行时一直保持这把锁，则不可能再起动它的其他副本：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;unistd.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdlib.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;syslog.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;string.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;stdio.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/stat.h&gt;</span>

<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">LOCKFILE</span> <span style="color: #deb887;">"/var/run/deamon.pid"</span>
<span style="color: #ffd700;">#define</span> <span style="color: #4eee94;">LOCKMODE</span> (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">already_running</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">fd</span>; 
    <span style="color: #98f5ff;">char</span> <span style="color: #4eee94;">buf</span>[16];

    fd = open(LOCKFILE, O_RDWR|O_CREAT, LOCKMODE);

    <span style="color: #00bfff; font-weight: bold;">if</span>(fd &lt; 0) {
        err_sys(<span style="color: #deb887;">"open error"</span>);
        exit(1);
    }   

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">try and set write lock </span>
    <span style="color: #00bfff; font-weight: bold;">if</span>( write_lock(fd, 0, SEEK_SET, 0) &lt; 0) {
        <span style="color: #00bfff; font-weight: bold;">if</span>(errno == EACCES || errno == EAGAIN) {
            close(fd); <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">daemon is already running</span>
            <span style="color: #00bfff; font-weight: bold;">return</span> (1);
        }                        

        err_sys(<span style="color: #deb887;">"write lock error"</span>);
        exit(1);
    }   

    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">we have the lock now, truncate the file length to zero</span>
    <span style="color: #00bfff; font-weight: bold;">if</span>( ftruncate(fd, 0) &lt; 0)
        err_sys(<span style="color: #deb887;">"ftruncate error"</span>);
    <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">write our process id</span>
    sprintf(buf, <span style="color: #deb887;">"%ld"</span>, (<span style="color: #98f5ff;">long</span>)getpid());
    <span style="color: #00bfff; font-weight: bold;">if</span>( write(fd, buf, strlen(buf)) != strlen(buf))
        err_sys(<span style="color: #deb887;">"write error"</span>);

    <span style="color: #00bfff; font-weight: bold;">return</span> (0);
}

</pre>
</div>

<p>
因为进程ID文件可能包含以前的守护进程ID，而且其长度可能长于当前进程的ID，例如该文件中以前的内容可能是12345\n，而现在的进程ID是654，我们希望该文件现在只包含654\n，而不是654\n5\n，所以在写该文件时，先将其截短为0。 注意： 要在设置了锁之后再调用截短文件长度的函数ftruncate。在调用open时不能指定O_TRUNC，因为这样做会在有一个守护进程运行并对该文件加锁时也会使该文件截短为0
</p>
</div>
</div>

<div id="outline-container-orgcd61c31" class="outline-4">
<h4 id="orgcd61c31">文件末尾加锁</h4>
<div class="outline-text-4" id="text-orgcd61c31">
<p>
在相对文件尾端加锁或解锁时需要特别小心。大多数实现按照l_whence的SEEK_CUR或SEEK_END值，用文件当前位置或当前长度以及l_start得到绝对的文件位移量。但是，通常需要相对于文件的当前位置或当前长度指定一把锁
</p>

<p>
下面程序写一个大文件，一次一个字节。在每次循环中，从文件当前尾端开始处加锁直到将来可能扩充到的尾端为止(最后一个参数，长度指定为0)，并写1个字节。然后解除这把锁，写另一个字节。如果系统用“从当前尾端开始，直到将来可能扩充的尾端”这种记法来跟踪锁，那么这段程序能够正常工作。但是如果系统将相对位移量变换成绝对位移量就会有问题：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">void</span>)
{
    <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>, <span style="color: #4eee94;">fd</span>;


    <span style="color: #00bfff; font-weight: bold;">if</span>( (fd = open(<span style="color: #deb887;">"temp.lock"</span>, O_RDWR | O_CREAT | O_TRUNC, FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"open error"</span>);

    <span style="color: #00bfff; font-weight: bold;">for</span>(i = 0; i &lt; 1000000; i++) {
        <span style="color: #5f9ea0; font-style: italic;">//</span><span style="color: #5f9ea0; font-style: italic;">lock from current EOF to EOF</span>
        <span style="color: #00bfff; font-weight: bold;">if</span>(writew_lock(fd, 0, SEEK_END, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"write lock error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(write(fd, &amp;fd, 1) != 1)
            err_sys(<span style="color: #deb887;">"write error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(un_lock(fd, 0, SEEK_END, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"unlock error"</span>);

        <span style="color: #00bfff; font-weight: bold;">if</span>(write(fd, &amp;fd, 1) != 1)
            err_sys(<span style="color: #deb887;">"write error"</span>);
    }

    exit(0);
}
</pre>
</div>

<p>
测试结果：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./lockeof

writew_lock error: No record locks available
</pre>
</div>
<p>
第一次调用writew_lock指定“直至将来可能扩充到尾端”，所以图中锁定区域超过了所写的第一个字节。然后调用un_lock，从当前尾端处开始直至将来可能扩充到的尾端为止解锁，箭头的右端缩回到第一字节位置端部，然后将第二个字节写到文件中：
</p>

<div class="figure">
<p><img src="pic/flock-eof.jpg" alt="flock-eof.jpg" width="90%" />
</p>
</div>

<p>
这样每次循环，都会分配一个新的flock结构，这种情况不断重复，直至内核为该进程用完了锁结构。此时fcntl出错返回，errno设置为ENOLCK
</p>

<p>
在此程序中每次写的字节数是已知的，所以可将un_lock的第二个参数(其值将赋与l_start)改换成所写字节数的负值(在本程序中是-1)。这就使得un_lock去除上次加的锁
</p>
</div>
</div>
</div>

<div id="outline-container-org93f42f4" class="outline-3">
<h3 id="org93f42f4">建议性锁和强制性锁</h3>
<div class="outline-text-3" id="text-org93f42f4">
<p>
考虑数据库存取例程序。如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函数存取数据库的任何进程集为合作进程。如果这些函数是唯一的用来存取数据库的函数，那么它们使用建议性锁是可行的。但是建议性锁并不能阻止对数据库文件有写许可权的任何其他进程写数据库文件。不使用协同一致的方法来存取数据库的进程是一个非合作进程
</p>

<p>
SVR4的强制性锁机制中，内核对每一个open、read和write都要检查调用进程对正在存取的文件是否违背了某一把锁的作用：对一个特定文件打开其设置-组-ID位，关闭其组-执行位则对该文件启动了强制性锁机制。因为当组-执行位关闭时，设置-组-ID位不再有意义，所以设计者借用两者的这种组合来指定对一个文件的锁是强制性的而非建议性的
</p>

<p>
如果一个进程试图读、写一个强制性锁起作用的文件，而欲读、写的部分又由其他进程加上了读、写锁，此时会发生什么呢?对这一问题的回答取决于三方面的因素:操作类型(read或write)，其他进程保有的锁的类型(读锁或写锁)，以及有关描述符是阻塞还是非阻塞的。下表列出了这8种可能性：
</p>
<!-- This HTML table template is generated by emacs 26.1 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      区域上的锁<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阻塞描述符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非阻塞描述符&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;读&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;写&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;读&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;写&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      强制性读锁
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可以&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;阻塞&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;可以&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;EAGAIN&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      强制性写锁
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;阻塞&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;阻塞&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;EAGAIN&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;EAGAIN&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

<p>
除了表中的read，write函数，其他进程的强制性锁也会对open函数产生影响。通常即使正在打开的文件具有强制性记录锁，该打开操作也会成功。下面的read或write依从于中所示的规则。但是如果欲打开的文件具有强制性锁(读锁或写锁)，而且open调用中的flag为O_TRUNC或O_CREAT，则不论是否指定O_NONBLOCK，open都立即出错返回，errno设置为EAGAIN。对O_TRUNC情况出错返回是有意义的，因为其他进程对该文件持有读、写锁，所以不能将其截短为0。对O_CREAT情况在返回时也设置errno则无意义，因为该标志的意义是如果该文件不存在则创建，由于其他进程对该文件持有记录锁，因而该文件肯定是存在的
</p>

<p>
这种处理方式可能导致令人惊异的结果。例如某个程序打开一个文件(其模式指定为强制性锁)，然后对该文件的整体设置一把读锁，然后进入睡眠一段时间。在这段睡眠时间内，用某些常规的UNIX程序和操作符对该文件进行处理，发现下列情况:
</p>
<ul class="org-ul">
<li>可用ed编辑程序对该文件进行编辑操作，而且编辑结果可以写回磁盘!强制性记录锁对此毫无影响。对ed操作进行跟踪分析发现，ed将新内容写到一个临时文件中，然后删除原文件，最后将临时文件名改名为原文件名。于是，发现强制性锁机制对unlink函数没有影响</li>
<li>不能用vi编辑程序编辑该文件。vi可以读该文件，但是如果试图将新的数据写到该文件中，则出错返回(EAGAIN)。如果试图将新数据添加到该文件中，则write阻塞。vi的这种行为与所希望的一样</li>
<li>使用KornShell的&gt;和&gt;&gt;算符重写或添写到该文件中，产生出错信息“cannotcreat”</li>
<li>在Bourneshell下使用&gt;算符出错，但是使用&gt;&gt;算符则阻塞，在删除了强制性锁后再继续进行处理。执行添加操作所产生的区别是因为:KornShell以O_CREAT和O_APPEND标志打开文件，而上面已提及指定O_CREAT会产生出错返回。但是Bourneshell在该文件已存在时并不指定O_CREAT，所以open成功，而下一个write则阻塞</li>
</ul>

<p>
一个别有用心的用户可以对大家都可读的文件加一把读锁(强制性)，这样就能阻止任何其他人写该文件。当然该文件应当是强制性锁机制起作用的，这可能要求该用户能够更改该文件的许可权位。所以使用强制性锁的时候必须小心谨慎
</p>
</div>

<div id="outline-container-org02d1778" class="outline-4">
<h4 id="org02d1778">校验系统是否支持强制性锁</h4>
<div class="outline-text-4" id="text-org02d1778">
<p>
下面程序检查当前系统是否支持强制性锁：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ffd700;">#include</span> <span style="color: #deb887;">"apue.h"</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;errno.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;fcntl.h&gt;</span>
<span style="color: #ffd700;">#include</span> <span style="color: #deb887;">&lt;sys/wait.h&gt;</span>

<span style="color: #98f5ff;">int</span> <span style="color: #daa520; font-weight: bold;">main</span>(<span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">argc</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">argv</span>[])
{
    <span style="color: #98f5ff;">int</span>             <span style="color: #4eee94;">fd</span>;
    <span style="color: #98f5ff;">pid_t</span>           <span style="color: #4eee94;">pid</span>;
    <span style="color: #98f5ff;">char</span>            <span style="color: #4eee94;">buf</span>[5];
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">stat</span>     <span style="color: #4eee94;">statbuf</span>;

    <span style="color: #00bfff; font-weight: bold;">if</span> (argc != 2) {
        fprintf(stderr, <span style="color: #deb887;">"usage: %s filename\n"</span>, argv[0]);
        exit(1);
    }
    <span style="color: #00bfff; font-weight: bold;">if</span> ((fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, FILE_MODE)) &lt; 0)
        err_sys(<span style="color: #deb887;">"open error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (write(fd, <span style="color: #deb887;">"abcdef"</span>, 6) != 6)
        err_sys(<span style="color: #deb887;">"write error"</span>);

    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">turn on set-group-ID and turn off group-execute </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
    <span style="color: #00bfff; font-weight: bold;">if</span> (fstat(fd, &amp;statbuf) &lt; 0)
        err_sys(<span style="color: #deb887;">"fstat error"</span>);
    <span style="color: #00bfff; font-weight: bold;">if</span> (fchmod(fd, (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID) &lt; 0)
        err_sys(<span style="color: #deb887;">"fchmod error"</span>);

    TELL_WAIT();

    <span style="color: #00bfff; font-weight: bold;">if</span> ((pid = fork()) &lt; 0) {
        err_sys(<span style="color: #deb887;">"fork error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> <span style="color: #00bfff; font-weight: bold;">if</span> (pid &gt; 0) {   <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">parent </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">write lock entire file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (write_lock(fd, 0, SEEK_SET, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"write_lock error"</span>);

        TELL_CHILD(pid);

        <span style="color: #00bfff; font-weight: bold;">if</span> (waitpid(pid, <span style="color: #ffd700;">NULL</span>, 0) &lt; 0)
            err_sys(<span style="color: #deb887;">"waitpid error"</span>);
    } <span style="color: #00bfff; font-weight: bold;">else</span> {                <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">child </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        WAIT_PARENT();      <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">wait for parent to set lock </span><span style="color: #5f9ea0; font-style: italic;">*/</span>

        set_fl(fd, O_NONBLOCK);

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">first let's see what error we get if region is locked </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (read_lock(fd, 0, SEEK_SET, 0) != -1)    <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">no wait </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
            err_sys(<span style="color: #deb887;">"child: read_lock succeeded"</span>);
        printf(<span style="color: #deb887;">"read_lock of already-locked region returns %d\n"</span>,
               errno);

        <span style="color: #5f9ea0; font-style: italic;">/* </span><span style="color: #5f9ea0; font-style: italic;">now try to read the mandatory locked file </span><span style="color: #5f9ea0; font-style: italic;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">if</span> (lseek(fd, 0, SEEK_SET) == -1)
            err_sys(<span style="color: #deb887;">"lseek error"</span>);
        <span style="color: #00bfff; font-weight: bold;">if</span> (read(fd, buf, 2) &lt; 0)
            err_ret(<span style="color: #deb887;">"read failed (mandatory locking works)"</span>);
        <span style="color: #00bfff; font-weight: bold;">else</span>
            printf(<span style="color: #deb887;">"read OK (no mandatory locking), buf = %2.2s\n"</span>,
                   buf);
    }
    exit(0);
}
</pre>
</div>
<p>
首先创建一个文件，并使强制性锁机制对其起作用。然后fork一个子进程。父进程对整个文件设置一把写锁，子进程则将该文件的描述符设置为非阻塞的，然后企图对该文件设置一把读锁，期望这会出错返回，并希望看到系统返回值是EACCES或EAGAIN。接着子进程将文件读、写位置调整到文件起点，并试图读该文件。如果系统提供强制性锁机制，则read应返回EACCES或EAGAIN(因为该描述符是非阻塞的)。否则read返回所读的数据
</p>

<p>
测试结果显示linux并不支持强制锁
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ./src/aio/mandatory temp.lock

read_lock of already-locked region returns 11 <span style="color: #5f9ea0; font-style: italic;">#</span><span style="color: #5f9ea0; font-style: italic;">EAGAIN</span>
<span style="color: #f08080;">read</span> OK (no mandatory locking), buf = ab
</pre>
</div>
</div>
</div>

<div id="outline-container-org592d52f" class="outline-4">
<h4 id="org592d52f">两人编辑同一文件</h4>
<div class="outline-text-4" id="text-org592d52f">
<p>
当两个人同时编辑同一个文件将会怎样呢？一般的UNIX文本编辑器并不使用记录锁，所以对此问题的回答仍然是：该文件的最后结果取决于写该文件的最后一个进程。即使我们在一个编辑器，例如vi中使用了建议性锁，可是这把锁并不能阻止其他用户使用另一个没有使用建议性记录锁的编辑器
</p>

<p>
若系统提供强制性记录锁，那么可以修改常用的编辑器。如没有该编辑器的源代码，那么可以试一试下述方法。编写一个vi的前端程序。该程序立即调用fork，然后父进程等待子进程终止，子进程打开在命令行中指定的文件，使强制性锁起作用，对整个文件设置一把写锁，然后运行vi。在vi运行时，该文件是加了写锁的，所以其他用户不能修改它。当vi结束时，父进程从wait返回，此时自编的前端程序也就结束。本例中假定锁能跨越exec，这正是前面所说的SVR4的情况(SVR4是提供强制性锁的唯一系统)
</p>

<p>
这种类型的前端程序是可以编写的，但却往往不能起作用。问题出在大多数编辑器读它们的输入文件，然后关闭它。只要引用被编辑文件的描述符关闭了，那么加在该文件上的锁就被释放了。这意味着在编辑器读了该文件的内容，然后关闭了它，那么锁也就不存在了。前端程序中没有任何方法可以阻止这一点
</p>

<p>
<a href="daemon.html">Next：守护进程</a>
</p>

<p>
<a href="signal.html">Previous：信号</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
