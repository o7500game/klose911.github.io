<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>进程控制</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="env.html"> UP </a>
 |
 <a accesskey="H" href="apue.html"> HOME </a>
</div><div id="content">
<h1 class="title">进程控制</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">进程标识</a></li>
<li><a href="#sec-2">进程生命周期</a>
<ul>
<li><a href="#sec-2-1">创建进程</a>
<ul>
<li><a href="#sec-2-1-1">fork</a>
<ul>
<li><a href="#sec-2-1-1-1">子进程的进程环境</a></li>
<li><a href="#sec-2-1-1-2">写时复制</a></li>
<li><a href="#sec-2-1-1-3">fork实例</a></li>
<li><a href="#sec-2-1-1-4">父、子进程的资源共享</a></li>
<li><a href="#sec-2-1-1-5">父、子进程的区别</a></li>
<li><a href="#sec-2-1-1-6">fork的常见用法</a></li>
</ul>
</li>
<li><a href="#sec-2-1-2">vfork</a>
<ul>
<li><a href="#sec-2-1-2-1">vfork实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2-2">终止进程</a>
<ul>
<li><a href="#sec-2-2-1">wait</a>
<ul>
<li><a href="#sec-2-2-1-1">wait实例</a></li>
</ul>
</li>
<li><a href="#sec-2-2-2">waitpid</a>
<ul>
<li><a href="#sec-2-2-2-1">waitpid实例</a></li>
</ul>
</li>
<li><a href="#sec-2-2-3">wait3和wait4</a></li>
</ul>
</li>
<li><a href="#sec-2-3">竞争条件</a>
<ul>
<li><a href="#sec-2-3-1">竞争条件实例</a></li>
</ul>
</li>
<li><a href="#sec-2-4">执行程序</a>
<ul>
<li><a href="#sec-2-4-1">exec家族函数</a>
<ul>
<li><a href="#sec-2-4-1-1">exec进程特征</a></li>
<li><a href="#sec-2-4-1-2">exec实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">更改用户ID和组ID</a>
<ul>
<li><a href="#sec-3-1">setuid, setgid</a>
<ul>
<li><a href="#sec-3-1-1">改变ID规则</a>
<ul>
<li><a href="#sec-3-1-1-1">注意事项</a></li>
<li><a href="#sec-3-1-1-2">实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3-2">setreuid, setregid</a></li>
<li><a href="#sec-3-3">seteuid和setegid函数</a></li>
<li><a href="#sec-3-4">总结</a></li>
<li><a href="#sec-3-5">组ID</a></li>
</ul>
</li>
<li><a href="#sec-4">解释器</a>
<ul>
<li><a href="#sec-4-1">exec调用解释器文件</a></li>
<li><a href="#sec-4-2">awk实例</a></li>
<li><a href="#sec-4-3">解释器文件的优劣</a></li>
</ul>
</li>
<li><a href="#sec-5">system函数</a>
<ul>
<li><a href="#sec-5-1">system简单实现</a>
<ul>
<li><a href="#sec-5-1-1">mysystem实例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">进程会计</a>
<ul>
<li><a href="#sec-6-1">acct结构</a>
<ul>
<li><a href="#sec-6-1-1">会记记录的缺陷</a></li>
</ul>
</li>
<li><a href="#sec-6-2">用户标识</a></li>
<li><a href="#sec-6-3">进程时间</a>
<ul>
<li><a href="#sec-6-3-1">打印进程时间实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章介绍Unix的进程控制：
</p>
<ul class="org-ul">
<li>创建新进程、执行程序和进程终止
</li>
<li>进程的实际、有效和保存的用户和组ID
</li>
<li>解释器文件和system函数
</li>
<li>进程会计机制
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">进程标识</h2>
<div class="outline-text-2" id="text-1">
<p>
每个进程都有一个非负整型的唯一进程ID。因为进程ID标识符总是唯一的，常将其用做其他标识符的一部分以保证其唯一性：
</p>
<ol class="org-ol">
<li>ID 0进程：调度进程，它是内核进程，用来执行进程管理，也被称为交换进程
</li>
<li>ID 1进程：通常是init进程，在自举过程结束时由内核调用/sbin/init，通常读与系统有关的初始化文件(/etc/rc*文件)，并将系统引导到一个状态(例如多用户)。init进程决不会终止，它是一个普通的用户进程(不是内核中的系统进程)，但是它以超级用户特权运行
</li>
</ol>


<p>
除了进程ID每个进程还有一些其他标识符，下列函数返回这些标识符：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#36827;&#31243;ID&#12288;</span>

<span style="color: #ffa07a;">   &#36820;&#22238;&#65306;&#35843;&#29992;&#36827;&#31243;&#30340;&#36827;&#31243;ID</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">getpid</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#29238;&#36827;&#31243;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#35843;&#29992;&#36827;&#31243;&#30340;&#29238;&#36827;&#31243;ID </span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">getppid</span>(<span style="color: #98fb98;">void</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#23454;&#38469;&#29992;&#25143;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#35843;&#29992;&#36827;&#31243;&#30340;&#23454;&#38469;&#29992;&#25143;ID</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">uid_t</span> <span style="color: #87cefa;">getuid</span>(<span style="color: #98fb98;">void</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#26377;&#25928;&#29992;&#25143;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#35843;&#29992;&#36827;&#31243;&#30340;&#26377;&#25928;&#29992;&#25143;ID</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">uid_t</span> <span style="color: #87cefa;">geteuid</span>(<span style="color: #98fb98;">void</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#23454;&#38469;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#35843;&#29992;&#36827;&#31243;&#30340;&#23454;&#38469;&#32452;ID</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">gid_t</span> <span style="color: #87cefa;">getgid</span>(<span style="color: #98fb98;">void</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#24471;&#35843;&#29992;&#36827;&#31243;&#30340;&#26377;&#25928;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#35843;&#29992;&#36827;&#31243;&#30340;&#26377;&#25928;&#32452;ID</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">gid_t</span> <span style="color: #87cefa;">getegid</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>
<p>
注意：这些函数都没有出错返回！
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">进程生命周期</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">创建进程</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">fork</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
fork：创建新进程的唯一方法 (除了上面提到的那些特殊进程，它们是内核启动时候以特殊方式创建的)
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#21019;&#24314;&#26032;&#36827;&#31243;</span>

<span style="color: #ffa07a;">   return&#65306;&#23376;&#36827;&#31243;&#36820;&#22238;0&#65292;&#29238;&#36827;&#31243;&#36820;&#22238;&#23376;&#36827;&#31243;&#30340;ID&#65292;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">fork</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>
<p>
由fork创建的新进程被称为子进程。因为子进程和父进程都会继续执行fork之后的指令，所以该函数虽然被调用一次，但却会返回两次结果。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新子进程的进程ID：
</p>
<ul class="org-ul">
<li>将子进程ID返回给父进程的理由是：一个进程的子进程可以多于一个，没有一个函数可以使一个进程获得其所有子进程的进程ID。如果接下来父进程要使用子进程ID，那么只能在fork后记录返回的子进程ID
</li>
<li>fork使子进程得到返回值0的理由是：
<ol class="org-ol">
<li>进程ID为0总是由调度/交换进程使用，一个子进程的进程ID不可能为0，所以可以通过fork的返回结果来判断是不是子进程
</li>
<li>另外一个进程只会有一个父进程，子进程可以调用getppid以获得其父进程的进程ID，所以没有必要去返回父进程的ID
</li>
</ol>
</li>
</ul>
</div>

<div id="outline-container-sec-2-1-1-1" class="outline-5">
<h5 id="sec-2-1-1-1">子进程的进程环境</h5>
<div class="outline-text-5" id="text-2-1-1-1">
<p>
子进程是父进程的复制品：如果正文段是只读的，则父、子进程共享正文段。除此之外子进程获得父进程的初始化数据段、非初始化数据段、堆和栈的复制品。注意这是子进程所拥有的独立拷贝，父、子进程并不共享这些存储空间部分！
</p>
</div>
</div>

<div id="outline-container-sec-2-1-1-2" class="outline-5">
<h5 id="sec-2-1-1-2">写时复制</h5>
<div class="outline-text-5" id="text-2-1-1-2">
<p>
现在很多的实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着exec执行另外一个程序。而作为替代使用了在写时复制(Copy-On-Write)的技术。例如在图1里面fork函数刚刚创建子进程的时候，父、子进程的数据指向同一块物理内存，但是内核将这些内存的访问变为只读的了。当父、子进程中的任何一个想要修改数据的时候，内核会为修改区域的那块内存制作一个副本，并将自己的虚拟地址映射到物理地址的指向修改为副本的地址，从此父子进程互不干扰，效率也提高了许多。新分配的副本大小通常是虚拟存储系统中的一个“页”
</p>

<div class="figure">
<p><img src="pic/child-process.png" alt="child-process.png" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-1-3" class="outline-5">
<h5 id="sec-2-1-1-3">fork实例</h5>
<div class="outline-text-5" id="text-2-1-1-3">
<p>
fork一个进程，修改相关变量并打印
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">glob</span> = 6;
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[] = <span style="color: #ffa07a;">"a write to stdin\n"</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">var</span>;
    <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>;

    var = 88;
    <span style="color: #00ffff;">if</span>(write(STDOUT_FILENO, buf, <span style="color: #00ffff;">sizeof</span>(buf) - 1) != (<span style="color: #00ffff;">sizeof</span>(buf) - 1))
        err_sys(<span style="color: #ffa07a;">"write error"</span>);
    printf(<span style="color: #ffa07a;">"before fork\n"</span>); <span style="color: #ff4500;">// </span><span style="color: #ff4500;">we don't flush stdout</span>

    <span style="color: #00ffff;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);

    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(0 == pid) { <span style="color: #ff4500;">//</span><span style="color: #ff4500;">child process</span>
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">modify variable</span>
        glob++; 
        var++; 
    } <span style="color: #00ffff;">else</span> { <span style="color: #ff4500;">// </span><span style="color: #ff4500;">parent process</span>
        sleep(2);
    }

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">child &amp; parent share code</span>
    printf(<span style="color: #ffa07a;">"pid = %d, glob = %d, var = %d\n"</span>, getpid(), glob, var);
    exit(0);
}
</pre>
</div>
<p>
一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。如果要求父、子进程之间相互同步，则要求某种形式的进程间通信。在这个程序中父进程使自己睡眠2秒钟，以此使子进程先执行，但2秒钟并不一定保证已经足够
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./src/process/forkExample

a write to stdin
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#32456;&#31471;&#26159;&#34892;&#32531;&#23384;&#30340;&#65292;&#25152;&#20197;printf("before fork")&#30452;&#25509;&#36755;&#20986;</span>
before fork
pid = 8898, glob = 7, var = 89 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#23376;&#36827;&#31243;&#25171;&#21360;&#25913;&#21464;&#21518;&#30340;&#21464;&#37327;&#20540;</span>
pid = 8897, glob = 6, var = 88 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#29238;&#36827;&#31243;&#25171;&#21360;&#26410;&#25913;&#21464;&#30340;&#21464;&#37327;&#20540;</span>

$ ./src/process/forkExample &gt; temp.out

$ cat temp.out 
a write to stdin
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#25991;&#20214;&#26159;&#20840;&#32531;&#23384;&#30340;&#65292;&#25152;&#20197;fork&#20043;&#21069;&#30340;printf&#25226;"before fork\n"&#25918;&#20837;&#20102;&#32531;&#23384;&#65292;&#20294;&#24182;&#27809;&#26377;&#36755;&#20986;</span>
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">fork&#25226;&#29238;&#36827;&#31243;&#30340;&#26631;&#20934;IO&#32531;&#23384;&#22797;&#21046;&#20102;&#65292;&#22240;&#27492;&#22312;&#26368;&#21518;&#30340;prinf("pid= %d ...)&#20063;&#36755;&#20986;&#20102;before fork\n</span>
before fork 
pid = 8962, glob = 7, var = 89 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#23376;&#36827;&#31243;</span>
before fork
pid = 8961, glob = 6, var = 88 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#29238;&#36827;&#31243;</span>
</pre>
</div>
<p>
fork与I/O函数之间的关系：
</p>
<ul class="org-ul">
<li>文件IO是不带缓存的：所以"a write to stdin"只被write函数写到标准输出一次
</li>
<li>标准I/O库是带缓存的：如果标准输出连到终端设备，则它是行缓存的，否则它是全缓存的
<ol class="org-ol">
<li>当以交互方式运行该程序时：因为标准输出缓存由新行符刷新，所以"before fork"只被printf输出一次
</li>
<li>当将标准输出重新定向到一个文件时：在fork之前调用了printf("before fork")一次，但当调用fork时该行数据仍在缓存内，然后在父进程数据空间复制到子进程中时该缓存数据也被复制到子进程中。于是那时父、子进程各自有了"before fork"的缓存。所以当每个进程终止时，其缓存中的所有内容被写到相应文件中
</li>
</ol>
</li>
</ul>

<p>
因此在fork进程前请务必考虑flush所有的缓存！
</p>
</div>
</div>
<div id="outline-container-sec-2-1-1-4" class="outline-5">
<h5 id="sec-2-1-1-4">父、子进程的资源共享</h5>
<div class="outline-text-5" id="text-2-1-1-4">
<p>
所有由父进程打开的描述符都被复制到子进程中。父、子进程每个相同的打开描述符共享一个文件表项。所以在上面程序中重定向了父进程的标准输出时，子进程的标准输出也被同样重定向
</p>

<p>
再比如一个进程打开了三个不同文件，它们是标准输入、标准输出和标准出错。在从fork返回时，我们有了如图8-1中所示的安排
</p>
<p>
<img src="pic/child-fd.png" alt="child-fd.png" width="90%" />
这种共享文件的方式使父、子进程对同一文件使用了一个文件位移量。如果父、子进程写到同一描述符文件，但又没有任何形式的同步(例如使父进程等待子进程)，那么它们的输出就会相互混合，但是这种情况并不常见。在fork之后处理文件描述符有两种常见的情况：
</p>
<ol class="org-ol">
<li>父进程等待子进程完成。父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件位移量已做了相应更新
</li>
<li>父、子进程各自执行不同的程序段。在fork之后父、子进程各自关闭它们不需使用的文件描述符，并且不干扰对方使用的文件描述符。这种方法是网络服务进程中经常使用
</li>
</ol>

<p>
除了打开文件之外，很多父进程的其他性质也由子进程继承:
</p>
<ul class="org-ul">
<li>实际用户ID、实际组ID、有效用户ID、有效组ID
</li>
<li>添加组ID
</li>
<li>进程组ID
</li>
<li>对话期ID
</li>
<li>控制终端
</li>
<li>设置-用户-ID标志和设置-组-ID标志
</li>
<li>当前工作目录
</li>
<li>根目录
</li>
<li>文件方式创建屏蔽字
</li>
<li>信号屏蔽和排列
</li>
<li>对任一打开文件描述符的在执行时关闭标志
</li>
<li>环境
</li>
<li>连接的共享存储段
</li>
<li>资源限制
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-5" class="outline-5">
<h5 id="sec-2-1-1-5">父、子进程的区别</h5>
<div class="outline-text-5" id="text-2-1-1-5">
<ul class="org-ul">
<li>fork的返回值
</li>
<li>进程ID
</li>
<li>不同的父进程ID
</li>
<li>子进程的tms_utime，tms_stime，tms_cutime以及tms_ustime设置为0
</li>
<li>父进程设置的锁，子进程不继承
</li>
<li>子进程的未决告警被清除
</li>
<li>子进程的未决信号集设置为空集
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-6" class="outline-5">
<h5 id="sec-2-1-1-6">fork的常见用法</h5>
<div class="outline-text-5" id="text-2-1-1-6">
<ol class="org-ol">
<li>一个父进程希望复制自己，使父、子进程同时执行不同的代码段。这在网络服务进程中是常见的：父进程等待委托者的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求
</li>
<li>一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程在从fork返回后立即调用exec
</li>
</ol>

<p>
某些操作系统将第二种用法中的两个操作(fork之后执行exec)组合成一个，并称其为spawn。UNIX将这两个操作分开，因为在很多场合需要单独使用fork，其后并不跟随exec
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">vfork</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
vfork：用于创建一个新进程，而该新进程的目的是为了exec一个新程序
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#21019;&#24314;&#26032;&#36827;&#31243;&#65292;&#32780;&#35813;&#26032;&#36827;&#31243;&#26159;&#30446;&#30340;&#26159;&#20026;&#20102;exec&#19968;&#20010;&#26032;&#31243;&#24207;</span>

<span style="color: #ffa07a;">   return&#65306;&#23376;&#36827;&#31243;&#36820;&#22238;0&#65292;&#29238;&#36827;&#31243;&#36820;&#22238;&#23376;&#36827;&#31243;&#30340;ID&#65292;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">vfork</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>
<p>
vfork与fork的不同：
</p>
<ol class="org-ol">
<li>vfork并不将父进程的地址空间复制到子进程中，在子进程exec之前完全使用父进程的地址空间，这意味着子进程如果修改了某个变量，这个修改对父进程也是可见的！
</li>
<li>vfork保证了子进程在父进程之前执行，父进程会阻塞运行直到子进程执行了exec或者exit函数。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁，特别是子进程并不继承父进程的记录锁，这时使用父进程打开的文件时可能会被阻塞！
</li>
</ol>
</div>
<div id="outline-container-sec-2-1-2-1" class="outline-5">
<h5 id="sec-2-1-2-1">vfork实例</h5>
<div class="outline-text-5" id="text-2-1-2-1">
<p>
改写fork实例
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #ff4500;">// </span><span style="color: #ff4500;">external variable in initialized data</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">glob</span> = 6;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">automatic variable on the stack</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">var</span>;
    <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>;

    var = 88;
    printf(<span style="color: #ffa07a;">"before fork\n"</span>);

    <span style="color: #00ffff;">if</span>((pid = vfork()) &lt; 0) {
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(pid == 0) { <span style="color: #ff4500;">//</span><span style="color: #ff4500;">child </span>
        glob++; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">change variable </span>
        var++; 
        _exit(0); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">child terminated</span>
        <span style="color: #ff4500;">//</span><span style="color: #ff4500;">exit(0) </span>
    }

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">parent</span>
    printf(<span style="color: #ffa07a;">"pid = %d, glob = %d, var = %d\n"</span>, getpid(), glob, var);
    exit(0);
}
</pre>
</div>

<p>
子进程对变量glob和var做加1操作，结果改变了父进程中的变量值。因为子进程在父进程的地址空间中运行
</p>
<div class="org-src-container">

<pre class="src src-sh">$ gcc -I/home/klose/Documents/programming/c/apue/include -c -o vforkExample.o src/process/vforkExample.c <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#32534;&#35793;c&#25991;&#20214;&#65292;&#27880;&#24847;&#19981;&#33021;&#26377;&#20248;&#21270;&#21442;&#25968;&#65281;</span>
$ gcc -o vforkExample vforkExample.o src/lib/libapue.a <span style="color: #ff4500;"># </span><span style="color: #ff4500;">&#38142;&#25509;&#38745;&#24577;&#24211;&#25991;&#20214;&#65292;&#20135;&#29983;&#21487;&#25191;&#34892;&#25991;&#20214;</span>

$ ./vforkExample 
before fork
pid = 19302, glob = 7, var = 89

$ gcc -O2 -I/home/klose/Documents/programming/c/apue/include -c -o vforkExample1.o src/process/vforkExample.c 
$ gcc -O2 -o vforkExample1 vforkExample1.o src/lib/libapue.a

$ ./vforkExample1 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#30001;&#20110;&#20248;&#21270;&#65292;var&#34987;&#25918;&#22312;&#23492;&#23384;&#22120;&#20869;&#65292;&#25152;&#20197;&#20002;&#22833;&#20102;&#23376;&#32447;&#31243;&#30340;&#20462;&#25913;</span>
before fork
pid = 19471, glob = 7, var = 88
</pre>
</div>
<p>
注意：子进程对变量的改动只对保存在内存中的变量有效，而对寄存器中的变量有可能会回滚。如果编译使用了优化参数，结果可能并不同，为了保证效果可以使用volatile
</p>

<p>
因为写时复制技术的普及，实际上vfork已经是个过时的函数，尽量避免使用vfork
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">终止进程</h3>
<div class="outline-text-3" id="text-2-2">
<p>
进程有三种正常终止法及两种异常终止法：
</p>
<ul class="org-ul">
<li>正常终止:
<ol class="org-ol">
<li>在main函数内执行return语句，这等效于调用exit
</li>
<li>调用exit函数，其操作包括调用各终止处理程序(终止处理程序在调用atexit函数时登录)，然后关闭所有标准I/O流等。但因为并不处理文件描述符、多进程(父、子进程)以及作业控制，所以这一定义对UNIX系统而言是不完整的
</li>
<li>调用_exit系统调用函数，此函数由exit调用，它处理UNIX特定的细节。_exit是由POSIX.1说明的
</li>
</ol>
</li>
<li>异常终止:
<ol class="org-ol">
<li>调用abort产生SIGABRT信号，是下一种异常终止的一种特例
</li>
<li>当进程接收到某个信号时。进程本身(例如调用abort函数)、其他进程和内核都能产生传送到某一进程的信号(例如进程越出其地址空间访问存储单元，或者除以0)，内核就会为该进程产生相应的信号
</li>
</ol>
</li>
</ul>

<p>
不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开的文件描述符，释放它所使用的存储器等等
</p>

<p>
对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于exit和_exit，这是依靠传递给它们的退出状态参数来实现的。在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的终止状态。注意这里使用了退出状态和终止状态两个不同术语，事实上最后调用_exit函数时内核会将退出状态转化为终止状态
</p>

<p>
在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态
</p>

<p>
如果父进程在子进程之前终止，对于其父进程已经终止的所有进程，它们的父进程都改变为init进程。这些进程由init进程领养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止的进程的子进程，如果是则该进程的父进程ID就更改为1(init进程的ID)。这种处理方法保证了每个进程有一个父进程
</p>

<p>
如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢？内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到有关信息。这种信息至少包括进程ID、该进程的终止状态、以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储器，关闭其所有打开文件
</p>

<p>
一个已经终止，但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为僵尸进程。ps(1)命令会将僵尸进程状态打印为Z
</p>

<p>
一个由init进程领养的进程终止时不会变成一个僵尸进程，因为init被编写成只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中有很多僵尸进程
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">wait</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是个异步事件，所以这种信号也是内核向父进程发的异步通知。父进程可以忽略该信号，或者提供一个该信号发生时即被调用执行的函数。对于这种信号的系统默认动作是忽略它。现在我们只需要知道的是调用wait的进程可能会:
</p>
<ul class="org-ul">
<li>如果其所有子进程都还在运行：阻塞调用wait的进程
</li>
<li>如果一个子进程已终止，并且正等待父进程存取其终止状态：带子进程的终止状态立即返回
</li>
<li>如果它没有任何子进程：出错立即返回

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#38459;&#22622;&#31561;&#24453;&#30452;&#21040;&#26377;&#19968;&#20010;&#23376;&#36827;&#31243;&#36864;&#20986;&#65292;&#24182;&#23558;&#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;&#35760;&#24405;&#21040;status&#22788;</span>

<span style="color: #ffa07a;">   status&#65306;&#25972;&#24418;&#25351;&#38024;&#65292;&#35760;&#24405;&#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;&#65292;&#22914;&#26524;&#19981;&#20851;&#24515;&#32456;&#27490;&#29366;&#24577;&#65292;&#21017;&#21487;&#23558;&#35813;&#21442;&#25968;&#25351;&#23450;&#20026;&#31354;&#25351;&#38024;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">wait</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">status</span>);
</pre>
</div>
<p>
status是一个整型指针。如果status不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针
</p>

<p>
status状态整形字是由实现定义的。其中某些位表示退出状态(正常返回)，其他位则指示信号编号(异常返回)，有一位指示是否产生了一个core文件等等。POSIX.1规定终止状态用定义在&lt;sys/wait.h&gt;中的各个宏来查看。有三个互斥的宏可用来取得进程终止的原因，基于它们中哪一个值是真,就可选用其他宏来取得终止状态、信号编号等。这些都在表8-1中给出：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 检查wait和waitpid所返回的终止状态的宏</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">宏</td>
<td class="left">说明</td>
</tr>

<tr>
<td class="left">WIFEXITED(status)</td>
<td class="left">如果子进程是正常终止则为真，执行WEXITSTATUS(status)获得子进程传送给exit或_exit参数的低8位</td>
</tr>

<tr>
<td class="left">WIFSIGNALED(status)</td>
<td class="left">如果子进程是异常终止则为真，执行WTERMSIG(status)获得子进程终止的信号编号。另外SVR4和4.3+BSD(非POSIX.1)定义宏: WCOREDUMP(status)若已产生终止进程的core文件则返回真</td>
</tr>

<tr>
<td class="left">WIFSTOPPED(status)</td>
<td class="left">如果是子进程的状态是暂停则为真，执行WSTOPSIG(status)获得使子进程暂停的信号编号</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div id="outline-container-sec-2-2-1-1" class="outline-5">
<h5 id="sec-2-2-1-1">wait实例</h5>
<div class="outline-text-5" id="text-2-2-1-1">
<p>
pr_exit使用表8-1中的宏以打印进程的终止状态。注意如果定义了WCOREDUMP，则此函数也处理该宏
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pr_exit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>) 
{
    <span style="color: #00ffff;">if</span>( WIFEXITED(status) )
        printf(<span style="color: #ffa07a;">"normal termination, exit status = %d\n"</span>,
               WEXITSTATUS(status));

    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>( WIFSIGNALED(status) )
        printf(<span style="color: #ffa07a;">"abnormal termination, signal number = %d%s\n"</span>,
               WTERMSIG(status),
<span style="color: #7fffd4;">#ifdef</span> WCOREDUMP
               WCOREDUMP(status) ? <span style="color: #ffa07a;">"(corefile generated)"</span> : <span style="color: #ffa07a;">""</span>);

<span style="color: #7fffd4;">#else</span>
    <span style="color: #ffa07a;">""</span>);
<span style="color: #7fffd4;">#endif</span>

<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>( WIFSTOPPED(status) ) 
    printf(<span style="color: #ffa07a;">"child stopped, signal number = %d\n"</span>,
           WSTOPSIG(status));
}
</pre>
</div>
<p>
打印不同终止的状态值
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>) 
{
    <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>;

    <span style="color: #00ffff;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(0 == pid)
        exit(7); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23376;&#36827;&#31243;&#27491;&#24120;&#36864;&#20986;</span>

    <span style="color: #00ffff;">if</span> ( wait(&amp;status) != pid)
        err_sys(<span style="color: #ffa07a;">"wait error"</span>);
    pr_exit(status);

    <span style="color: #00ffff;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(0 == pid)
        abort(); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23376;&#36827;&#31243;&#35843;&#29992;abort</span>

    <span style="color: #00ffff;">if</span> ( wait(&amp;status) != pid)
        err_sys(<span style="color: #ffa07a;">"wait error"</span>);
    pr_exit(status);

    <span style="color: #00ffff;">if</span>( (pid = fork() ) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(0 == pid)
        status /= 0; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23376;&#36827;&#31243;&#20135;&#29983;&#24322;&#24120;&#20449;&#21495;</span>

    <span style="color: #00ffff;">if</span> ( wait(&amp;status) != pid)
        err_sys(<span style="color: #ffa07a;">"wait error"</span>);
    pr_exit(status);

    exit(0);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./src/process/waitExample

normal termination, exit status = 7
abnormal termination, signal number = 6 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">SIGABRT</span>
abnormal termination, signal number = 8 <span style="color: #ff4500;"># </span><span style="color: #ff4500;">SIGFPE</span>
</pre>
</div>
<p>
不幸的是没有一种可移植的方法将WTERMSIG得到的信号编号映射为说明性的名字。必须查看&lt;signal.h&gt;头文件才能知道SIGABRT的值是6，SIGFPE的值是8
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">waitpid</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
waitpid：可以指定子进程的PID，并设置相关阻塞选项
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   wait&#30340;&#25193;&#23637;&#29256;&#26412;&#65292;&#21487;&#20197;&#25351;&#23450;&#23376;&#36827;&#31243;pid&#65292;&#20197;&#21450;&#30456;&#20851;&#38459;&#22622;&#36873;&#39033;</span>

<span style="color: #ffa07a;">   pid&#65306;&#23376;&#36827;&#31243;pid</span>
<span style="color: #ffa07a;">   status&#65306;&#23384;&#20648;&#32456;&#27490;&#29366;&#24577;&#30340;&#25351;&#38024;</span>
<span style="color: #ffa07a;">   options&#65306;&#38459;&#22622;&#36873;&#39033;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">waitpid</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">status</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">options</span>);
</pre>
</div>

<p>
pid参数与其值有关：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 2:</span> waitpid的pid参数</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">pid取值</td>
<td class="left">说明</td>
</tr>

<tr>
<td class="left">pid == -1</td>
<td class="left">等待任一子进程，与wait等效</td>
</tr>

<tr>
<td class="left">pid &gt; 0</td>
<td class="left">等待其进程ID与pid相等的子进程</td>
</tr>

<tr>
<td class="left">pid == 0</td>
<td class="left">等待其组ID等于调用进程的组ID的任一子进程</td>
</tr>

<tr>
<td class="left">pid &lt; -1</td>
<td class="left">等待其组ID等于pid的绝对值的任一子进程</td>
</tr>
</tbody>
</table>

<p>
options参数或者是0，或者是下表中常数的逐位或运算
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 3:</span> waitpid的option参数</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">常量</td>
<td class="left">说明</td>
</tr>

<tr>
<td class="left">WNOHANG</td>
<td class="left">如果pid指定的子进程并不立即可用，则waitpid不阻塞，直接返回值为0</td>
</tr>

<tr>
<td class="left">WUNTRACED</td>
<td class="left">如果实现支持作业控制，则由pid指定的任一子进程状态已暂停，并且其状态自暂停以来还未报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应于一个暂停子进程</td>
</tr>

<tr>
<td class="left">0</td>
<td class="left">阻塞并等待pid指定的子进程终止</td>
</tr>
</tbody>
</table>

<p>
因此waitpid函数提供了wait函数没有提供的三个功能:
</p>
<ol class="org-ol">
<li>waitpid等待一个特定的进程(而wait则返回任一终止子进程的状态)
</li>
<li>waitpid提供了一个wait的非阻塞版本。只是希望取得一个子进程的状态，但不想阻塞
</li>
<li>waitpid支持作业控制(以WUNTRACED选择项)
</li>
</ol>
</div>

<div id="outline-container-sec-2-2-2-1" class="outline-5">
<h5 id="sec-2-2-2-1">waitpid实例</h5>
<div class="outline-text-5" id="text-2-2-2-1">
<p>
如果一个进程要fork一个子进程，但不要求它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止。这可以通过调用fork两次来实现：第一个fork子线程提前终止，使得由它fork的第二个子进程被init托管，这样第二个子进程结束会自动被init进程调用wait处理，同时主进程只需要等待第一个子进程终止即可
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36827;&#31243;p</span>
    <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>;

    <span style="color: #00ffff;">if</span>( ( pid = fork() ) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"1. fork error"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (0 == pid) { <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23376;&#36827;&#31243;1&#65292;&#23427;&#30340;&#29238;&#36827;&#31243;&#26159;&#36827;&#31243;p</span>
        <span style="color: #00ffff;">if</span>( ( pid = fork() ) &lt; 0)
            err_sys(<span style="color: #ffa07a;">"2.fork error"</span>);
        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(pid &gt; 0) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23376;&#36827;&#31243;1 </span>
            exit(0); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#32467;&#26463;&#23376;&#36827;&#31243;1</span>

        <span style="color: #ff4500;">/*</span>
<span style="color: #ff4500;">          &#36825;&#26159;&#23376;&#36827;&#31243;2&#65292;&#23427;&#30340;&#29238;&#36827;&#31243;&#21407;&#26412;&#26159;&#23376;&#36827;&#31243;1&#65292;&#20294;&#26159;&#22240;&#20026;&#23376;&#36827;&#31243;&#27491;&#24120;&#32456;&#27490;&#20102;&#65292;&#25152;&#20197;&#30001;init&#36827;&#31243;&#25176;&#31649;</span>
<span style="color: #ff4500;">        </span><span style="color: #ff4500;">*/</span>
        sleep(2);
        printf(<span style="color: #ffa07a;">"second child parent pid = %d\n"</span>, getppid());
        exit(0); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#24403;&#23376;&#36827;&#31243;2&#32456;&#27490;&#26102;&#65292;init&#36827;&#31243;&#20250;&#35843;&#29992;wait&#28165;&#29702;&#23376;&#36827;&#31243;2</span>
    }

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36827;&#31243;p&#38459;&#22622;&#31561;&#24453;&#23376;&#36827;&#31243;1&#32456;&#27490;&#65292;&#24182;&#28165;&#29702;&#23376;&#36827;&#31243;1</span>
    <span style="color: #00ffff;">if</span>(waitpid(pid, <span style="color: #7fffd4;">NULL</span>, 0) != pid)
        err_sys(<span style="color: #ffa07a;">"waitpid error"</span>); 

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36827;&#31243;p&#32456;&#27490;</span>
    exit(0);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./src/process/zombieAvoid

$ second child parent pid = 1 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#31532;&#19968;&#20010;fork&#30340;&#23376;&#36827;&#31243;&#32456;&#27490;&#20102;&#65292;&#23427;&#30340;&#23376;&#36827;&#31243;&#34987;init&#36827;&#31243;&#25176;&#31649;</span>
</pre>
</div>
<p>
在第二个子进程中调用sleep是为了保证在打印父进程ID时第一个子进程已终止。在fork之后，父、子进程都可继续执行，但无法预知哪一个会先执行。如果不使第二个子进程睡眠，则在fork之后它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程，而不是init进程
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">wait3和wait4</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
wait3和wait4这两个函数比wait和waitpid分别要多一个参数rusage，该参数用于内核返回由终止进程及其所有子进程使用的资源信息摘要，包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。这些资源信息只包括终止子进程，并不包括处于停止状态的子进程
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/time.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/resources.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#31561;&#24453;&#20219;&#19968;&#36827;&#31243;&#32456;&#27490;&#65292;&#24182;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201;</span>

<span style="color: #ffa07a;">   status&#65306;&#23384;&#20648;&#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;&#30340;&#25351;&#38024;</span>
<span style="color: #ffa07a;">   options&#65306;&#38459;&#22622;&#36873;&#39033;</span>
<span style="color: #ffa07a;">   rusage&#65306;&#23384;&#20648;&#32456;&#27490;&#23376;&#36827;&#31243;&#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201;&#30340;&#32467;&#26500;&#25351;&#38024;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">wait3</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">status</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">options</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rusage</span> *<span style="color: #eedd82;">rusage</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#31561;&#24453;&#25351;&#23450;&#23376;&#36827;&#31243;&#32456;&#27490;&#65292;&#24182;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201;</span>

<span style="color: #ffa07a;">   pid&#65306;&#25351;&#23450;&#23376;&#36827;&#31243;ID</span>
<span style="color: #ffa07a;">   status&#65306;&#23384;&#20648;&#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;&#30340;&#25351;&#38024;</span>
<span style="color: #ffa07a;">   options&#65306;&#38459;&#22622;&#36873;&#39033;</span>
<span style="color: #ffa07a;">   rusage&#65306;&#23384;&#20648;&#32456;&#27490;&#23376;&#36827;&#31243;&#20351;&#29992;&#30340;&#36164;&#28304;&#25688;&#35201;&#30340;&#32467;&#26500;&#25351;&#38024;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#36820;&#22238;&#32456;&#27490;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#33509;&#20986;&#38169;&#36820;&#22238;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">pid_t</span> <span style="color: #87cefa;">wait4</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">status</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">options</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rusage</span> *<span style="color: #eedd82;">rusage</span>);
</pre>
</div>
<p>
表8-4中列出了各个wait函数所支持的不同的参数：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 4:</span> 不同系统上各个wait函数所支持的参数</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">函数</td>
<td class="left">pid</td>
<td class="left">options</td>
<td class="left">rusage</td>
<td class="left">POSIX</td>
<td class="left">SVR4</td>
<td class="left">4.3+BSD</td>
</tr>

<tr>
<td class="left">wait</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">•</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">waitpid</td>
<td class="left">•</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">•</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">wait3</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">wait4</td>
<td class="left">•</td>
<td class="left">•</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">•</td>
</tr>
</tbody>
</table>
<p>
对Linux而言，wait4是wait家族各个函数的系统调用入口，其它几个函数都基于wait4重新实现
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">竞争条件</h3>
<div class="outline-text-3" id="text-2-3">
<p>
当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，这就产生了竞态条件。如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行，那么fork函数就会是竞态条件活跃的孳生地。通常无法预料哪一个进程先运行。即使知道哪一个进程先运行，那么在该进程开始运行后所发生的事情也依赖于系统负载以及内核的调度算法
</p>

<p>
例如在waitpid的实例中，当第二个子进程打印其父进程ID时就可以看到了一个潜在的竞态条件。如果第二个子进程在第一个子进程之前运行，则其父进程将会是第一个子进程。但是如果第一个子进程先运行，并有足够的时间到达并执行exit，则第二个子进程的父进程就是init。即使在程序中调用sleep，这也不保证什么。如果系统负担很重，那么在第二个子进程从sleep返回时，可能第一个子进程还没有得到机会运行。这种形式的问题很难排除，因为在大部分时间，这种问题并不出现
</p>

<p>
如果一个进程希望等待一个子进程终止，则它必须调用wait函数。如果一个进程要等待其父进程终止，则可使用下列轮询的循环:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #00ffff;">while</span>(getppid() != 1) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#29238;&#36827;&#31243;&#32456;&#27490;&#65292;&#23376;&#36827;&#31243;&#30001;init&#36827;&#31243;&#25176;&#31649;</span>
    sleep(1);
</pre>
</div>
<p>
但轮询的问题是它浪费了CPU时间，因为调用者每隔1秒都被唤醒，然后进行条件测试
</p>

<p>
为了避免竞态条件和定期询问，在多个进程之间需要有某种形式的信号机制。在UNIX中可以使用信号机制和各种形式的进程间通信
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">竞争条件实例</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
输出两个字符串：一个由子进程输出，一个由父进程输出。因为输出依赖于内核使进程运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞态条件
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">charatatime</span>(<span style="color: #98fb98;">char</span> *);

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>) 
{
    <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>;

    <span style="color: #00ffff;">if</span>( ( pid = fork() ) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>(0 == pid) {
        charatatime(<span style="color: #ffa07a;">"output from child\n"</span>);
    } <span style="color: #00ffff;">else</span> {
        charatatime(<span style="color: #ffa07a;">"output from parent\n"</span>);
    }

    exit(0);

}

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">charatatime</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>)
{
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">ptr</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;

    setbuf(stdout, <span style="color: #7fffd4;">NULL</span>);
    <span style="color: #00ffff;">for</span>(ptr = str; c = *ptr++; )
        putc(c, stdout);

}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./src/process/raceCondition <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#20808;&#32467;&#26463;&#20102;&#23376;&#36827;&#31243; </span>
output from parent 
output from child

$ ./src/process/raceCondition <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#20808;&#32467;&#26463;&#20102;&#29238;&#36827;&#31243;</span>
output from parent
$ output from child
</pre>
</div>

<p>
下面的代码会保证父进程比子进程先打印
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">pid_t</span>   <span style="color: #eedd82;">pid</span>;

+   TELL_WAIT();

    <span style="color: #00ffff;">if</span> ((pid = fork()) &lt; 0) {
    err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (pid == 0) {
+       WAIT_PARENT();      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">parent goes first </span><span style="color: #ff4500;">*/</span>
    charatatime(<span style="color: #ffa07a;">"output from child\n"</span>);
    } <span style="color: #00ffff;">else</span> {
    charatatime(<span style="color: #ffa07a;">"output from parent\n"</span>);
+       TELL_CHILD(pid);
    }
    exit(0);
}
</pre>
</div>
<p>
以后会用信号量来实现五个例程TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT以及WAIT_CHILD
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">执行程序</h3>
<div class="outline-text-3" id="text-2-4">
<p>
当进程调用一种exec函数时，该进程完全由新程序代换，而新程序则从其main函数开始执行。调用exec并不创建新进程，因此进程ID并未改变。exec只是用另一个新程序替换了当前进程的正文、数据、堆和栈段
</p>
</div>

<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">exec家族函数</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
exec家族函数：将指定的程序装入当前进程，使之替换掉当前进程大部分的上下文环境。一共6个变体，使用类似但形式不同的参数。
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">execl</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pathname</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">arg0</span>, ..., <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">(char *)0 </span><span style="color: #ff4500;">*/</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">execlp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">arg</span>, ..., <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">(char *)0 </span><span style="color: #ff4500;">*/</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">execle</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pathname</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">arg0</span>, ..., <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">(char *)0, char *const envp[] </span><span style="color: #ff4500;">*/</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">execv</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pathname</span>, <span style="color: #98fb98;">char</span> *<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">argv</span>[]);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">execvp</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>, <span style="color: #98fb98;">char</span> *<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">argv</span>[]);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">execve</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pathname</span>, <span style="color: #98fb98;">char</span> *<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">argv</span>[], <span style="color: #98fb98;">char</span> *<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">envp</span>[]);
</pre>
</div>
<p>
这六个函数若出错则为-1，若成功则不返回
</p>

<ul class="org-ul">
<li>字母p表示该函数取filename作为参数，并且用PATH环境变量寻找可执行文件，没有字母ｐ表示pathname路径名
</li>
<li>字母l表示该函数取一个参数表，与字母v互斥，v表示该函数取一个argv[]
</li>
<li>字母e表示该函数取envp[]数组，而不使用当前环境
</li>
</ul>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boade">
<caption class="t-above"><span class="table-number">Table 5:</span> 6个exec函数的参数区别</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">函数</td>
<td class="left">pathname</td>
<td class="left">filename</td>
<td class="left">&#xa0;</td>
<td class="left">参数表</td>
<td class="left">argv[]</td>
<td class="left">&#xa0;</td>
<td class="left">enviorn</td>
<td class="left">envp[]</td>
</tr>

<tr>
<td class="left">execl</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">execlp</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">execle</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">execv</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">execvp</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">execve</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">•</td>
</tr>

<tr>
<td class="left">字母表示</td>
<td class="left">&#xa0;</td>
<td class="left">p</td>
<td class="left">&#xa0;</td>
<td class="left">l</td>
<td class="left">v</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">e</td>
</tr>
</tbody>
</table>

<p>
在很多UNIX实现中，这六个函数中只有一个execve是内核的系统调用。另外五个只是库函数，它们最终都要调用execve系统调用。这六个函数之间的关系示于图8-2中：
</p>

<div class="figure">
<p><img src="pic/exec-family.jpg" alt="exec-family.jpg" width="90%" />
</p>
</div>
</div>
<div id="outline-container-sec-2-4-1-1" class="outline-5">
<h5 id="sec-2-4-1-1">exec进程特征</h5>
<div class="outline-text-5" id="text-2-4-1-1">
<p>
执行exec后进程还保持了原进程的下列特征:
</p>
<ul class="org-ul">
<li>进程ID和父进程ID
</li>
<li>实际用户ID和实际组ID
</li>
<li>添加组ID
</li>
<li>进程组ID
</li>
<li>对话期ID
</li>
<li>控制终端
</li>
<li>闹钟尚余留的时间
</li>
<li>当前工作目录
</li>
<li>根目录
</li>
<li>文件方式创建屏蔽字
</li>
<li>文件锁
</li>
<li>进程信号屏蔽
</li>
<li>未决信号
</li>
<li>资源限制
</li>
<li>tms_utime，tms_stime，tms_cutime以及tms_ustime值
</li>
</ul>

<p>
对打开文件的处理与每个描述符的exec关闭标志值FD_CLOEXEC有关。进程中每个打开描述符都有一个exec关闭标志。若此标志设置，则在执行exec时关闭该描述符，否则该描述符仍打开。除非特地用fcntl设置了该标志，否则系统的默认操作是在exec后仍保持这种描述符打开
</p>

<p>
POSIX.1明确要求在exec时关闭打开目录流。这通常是由opendir函数实现的，它调用fcntl函数为对应于打开目录流的描述符设置exec关闭标志
</p>

<p>
注意：在exec前后实际用户ID和实际组ID保持不变，而有效ID是否改变则取决于所执行程序的文件的设置-用户-ID位和设置-组-ID位是否设置。如果新程序的设置-用户-ID位已设置，则有效用户ID变成程序文件所有者的ID，否则有效用户ID不变。对组ID的处理方式与此相同！
</p>
</div>
</div>
<div id="outline-container-sec-2-4-1-2" class="outline-5">
<h5 id="sec-2-4-1-2">exec实例</h5>
<div class="outline-text-5" id="text-2-4-1-2">
<p>
程序echoall是一个普通程序，回送其所有命令行参数及其全部环境表
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
    <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">ptr</span>;
    <span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">environ</span>;

    <span style="color: #00ffff;">for</span>(i = 0; i &lt; argc; i++)
        printf(<span style="color: #ffa07a;">"argv[%d]: %s\n"</span>, i, argv[i]);

    <span style="color: #00ffff;">for</span>(ptr = environ; *ptr != 0 ; ptr++ )
        printf(<span style="color: #ffa07a;">"%s\n"</span>, *ptr);

    exit(0);  
}
</pre>
</div>

<p>
调用execle要求一个路径名和一个特定的环境。下一个调用的是execlp用一个文件名，并将调用者的环境传送给新程序
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">env_init</span>[] = { <span style="color: #ffa07a;">"USER=unknown"</span>, <span style="color: #ffa07a;">"PATH=/tmp"</span>, <span style="color: #7fffd4;">NULL</span>};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>) 
{
    <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>;
    <span style="color: #00ffff;">if</span>( (pid = fork() ) &lt; 0 )
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>( 0 == pid ) {
        <span style="color: #00ffff;">if</span>(execle(<span style="color: #ffa07a;">"/home/klose/bin/echoall"</span>,
              <span style="color: #ffa07a;">"echoall"</span>, <span style="color: #ffa07a;">"myarg1"</span>, <span style="color: #ffa07a;">"MY ARG2"</span>, (<span style="color: #98fb98;">char</span> *) 0,
              env_init) &lt; 0 )
            err_sys(<span style="color: #ffa07a;">"execle error"</span>);

    }

    <span style="color: #00ffff;">if</span> (waitpid(pid, <span style="color: #7fffd4;">NULL</span>, 0) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"wait error"</span>);

    <span style="color: #00ffff;">if</span>( (pid = fork() ) &lt; 0 )
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);

    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (0 == pid) {
        <span style="color: #00ffff;">if</span>(execlp(<span style="color: #ffa07a;">"echoall"</span>,
              <span style="color: #ffa07a;">"echoall"</span>, <span style="color: #ffa07a;">"only 1 arg"</span>, (<span style="color: #98fb98;">char</span> *) 0) &lt; 0)
            err_sys(<span style="color: #ffa07a;">"execlp error"</span>);
    }

    exit(0);

}
</pre>
</div>

<p>
测试代码如下
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./execExample
argv[0]: echoall <span style="color: #ff4500;">#</span><span style="color: #ff4500;">execle&#25191;&#34892;echoall  </span>
argv[1]: myarg1
argv[2]: MY ARG2
<span style="color: #eedd82;">USER</span>=unknown
<span style="color: #eedd82;">PATH</span>=/tmp
argv[0]: echoall <span style="color: #ff4500;">#</span><span style="color: #ff4500;">execlp&#25191;&#34892;echoall</span>
$ argv[1]: only 1 arg
<span style="color: #eedd82;">LC_PAPER</span>=en_US.UTF8
<span style="color: #eedd82;">HOME</span>=/home/klose
<span style="color: #ff4500;"># </span><span style="color: #ff4500;">...... &#20854;&#20182;&#21508;&#31181;&#29615;&#22659;&#21464;&#37327; </span>
<span style="color: #eedd82;">_</span>=./execExample
</pre>
</div>
<p>
注意：shell提示符号'$'出现在第二个exec打印"echo all"和"only 1 arg"之间，这是因为父进程并不等待该子进程结束
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">更改用户ID和组ID</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>通过fork创建的子进程，其实际用户ID和有效用户ID将继承自父进程
</li>
<li>用exec执行一个程序时，若该进程的程序文件有"保存设置-用户-ID"位，则其有效用户ID为"exec执行程序的文件所属用户的ID"，否则继承自exec之前的上下文
</li>
<li>实际组ID和有效组ID的情况与之类似
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">setuid, setgid</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>setuid：设置实际用户ID和有效用户ID
</li>
<li>setgid：设置实际组ID和有效组ID
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#35774;&#32622;&#23454;&#38469;&#29992;&#25143;ID&#21644;&#26377;&#25928;&#29992;&#25143;ID</span>

<span style="color: #ffa07a;">   uid&#65306;&#29992;&#25143;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1&#65292;&#24182;&#35774;&#32622;errno</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setuid</span>(<span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">uid</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#35774;&#32622;&#23454;&#38469;&#32452;ID&#21644;&#26377;&#25928;&#32452;ID</span>

<span style="color: #ffa07a;">   gid&#65306;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1&#65292;&#24182;&#35774;&#32622;errno</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setgid</span>(<span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">gid</span>);
</pre>
</div>
</li>
</ul>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">改变ID规则</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
setuid/setgid的规则：
</p>
<ol class="org-ol">
<li>如果进程具有超级用户特权，则setuid函数将实际用户ID、有效用户ID，以及保存的设置-用户-ID设置为uid
</li>
<li>如果进程没有超级用户特权，但是uid等于实际用户ID或保存的设置-用户-ID，则setuid只将有效用户ID设置为uid。不改变实际用户ID和保存的设置-用户-ID
</li>
<li>如果上面两个条件都不满足，则errno设置为EPERM，并返回出错
</li>
</ol>
</div>

<div id="outline-container-sec-3-1-1-1" class="outline-5">
<h5 id="sec-3-1-1-1">注意事项</h5>
<div class="outline-text-5" id="text-3-1-1-1">
<ul class="org-ul">
<li>只有超级用户进程可以更改实际用户ID。通常，实际用户ID是在用户登录时由login(1)程序设置的，而且决不会改变它。因为login是一个超级用户进程，当它调用setuid时设置所有三个用户ID
</li>
<li>仅当对程序文件设置了设置-用户-ID位时，exec函数设置有效用户ID。如果设置-用户-ID位没有设置，则exec函数不会改变有效用户ID，而将其维持为原先值。任何时候都可以调用setuid，将有效用户ID设置为实际用户ID或保存的设置-用户-ID，但是不能将有效用户ID设置为任一随机值
</li>
<li>保存的设置-用户-ID是由exec从有效用户ID复制的：在exec按文件用户ID设置了有效用户ID后，即进行这种复制，并将此副本保存起来
</li>
</ul>

<p>
下面表格列出了改变这三个用户ID的不同方法：
</p>
<!-- This HTML table template is generated by emacs 24.5.1 -->
<table border="1">
  <tr>
    <td rowspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td colspan="2" align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setuid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;设置-用户-ID关闭&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;设置-用户-ID打开&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;超级用户&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非超级用户&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;实际用户ID&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;有效用户ID&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;程序文件的用户ID&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      保存的设置-用户-ID
    </td>
    <td align="left" valign="top">
      &nbsp;从有效用户ID复制&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;从有效用户ID复制&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>
</div>
</div>

<div id="outline-container-sec-3-1-1-2" class="outline-5">
<h5 id="sec-3-1-1-2">实例</h5>
<div class="outline-text-5" id="text-3-1-1-2">
<p>
观察的tip(1)程序，这个程序连接到一个远程系统，或者是直接连接，或者是拨号一个调制解调器。当tip使用调制解调器时，它必须通过使用锁文件来独占使用它。此锁文件与UUCP程序共享，因为这两个程序可能要同时使用同一调制解调器。对其工作步骤说明如下:
</p>
<ol class="org-ol">
<li>tip程序文件是由用户uucp拥有的，并且其设置-用户-ID位已设置。当exec此程序时，则关于用户ID得到下列结果:
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID
</li>
<li>有效用户ID = uucp
</li>
<li>保存设置-用户-ID = uucp
</li>
</ul>
</li>
<li>tip存取所要求的锁文件。这些锁文件是由uucp的用户所拥有的，因为有效用户ID是uucp，所以tip可以存取这些锁文件
</li>
<li>tip执行setuid(getuid())。因为tip不是超级用户进程，所以这仅仅改变有效用户ID。此时得到：
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID(未改变)
</li>
<li>有效用户-ID = 我们的用户ID(未改变)：这就意味着能存取的只有我们通常可以存取的，没有额外的许可权
</li>
<li>保存设置-用户-ID=uucp(未改变) 
</li>
</ul>
</li>
<li>当执行完所需的操作后，tip执行setuid(uucpuid)，其中uucpuid是用户uucp的数值用户ID(tip很可能在起动时调用geteuid，得到uucp的用户ID，然后将其保存起来，我们并不认为tip会搜索口令文件以得到这一数值用户ID)。因为setuid的参数等于保存的设置-用户-ID，所以这种调用是许可的(这就是为什么需要保存的设置-用户-ID的原因)。现在得到: 
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID(未改变)
</li>
<li>有效用户ID = uucp
</li>
<li>保存设置-用户-ID = uucp(未改变)
</li>
</ul>
</li>
<li>tip现在可对其锁文件进行操作以释放它们，因为tip的有效用户ID是uucp。以这种方法使用保存的设置-用户-ID，在进程的开始和结束部分就可以使用由于程序文件的设置用户ID而得到的额外优先权。但是进程在其运行的大部分时间只具有普通的许可权。如果进程不能在其结束部分切换回保存的设置-用户-ID，那么就不得不在全部运行时间都保持额外的许可权(这可能会造成安全问题)
</li>
</ol>

<p>
如果在tip运行时生成一个shell进程(先fork，然后exec)将发生什么？因为实际用户ID和有效用户ID都是我们的普通用户ID(上面的第(3)步)，所以该shell没有额外的许可权。它不能存取tip运行时设置成uucp的保存的设置-用户-ID，因为该shell所保存的设置-用户-ID是由exec复制有效用户ID而得到的。所以在执行exec的子进程中：
</p>
<ul class="org-ul">
<li>实际用户ID = 我们的用户ID
</li>
<li>有效用户ID = 我们的用户ID
</li>
<li>保存设置-用户-ID = 我们的用户ID
</li>
</ul>

<p>
总结如下：
</p>
<pre class="example">
对于进程特权的改变，应遵循“使用能完成工作的最小特权”的原则，以避免用户进程越权操作：
1. 在不需要设置-用户-ID带来的权限时，使用setuid(getuid())降低有效用户ID的特权
2. getuid和geteuid函数只能获得实际用户ID和有效用户ID的当前值，
  而不能获得所保存的设置-用户-ID的当前值。必须在降低权限前通过调用geteuid然后保存
3. 再次需要高级权限的时候，可以通过setuid(保存的euid)来恢复
4. 在子进程执行exec之前，应setuid(getuid())以避免设置-用户-ID引起的特权传递
5. 如果程序的设置-用户-ID为root，以超级用户特权调用setuid就会设置所有三个用户ID，慎用！
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">setreuid, setregid</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>setreuid：交换实际用户ID和有效用户ID的值
</li>
<li>setregid：交换实际组ID和有效组ID的值
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20132;&#25442;&#23454;&#38469;&#29992;&#25143;ID&#21644;&#26377;&#25928;&#29992;&#25143;ID&#30340;&#20540;</span>

<span style="color: #ffa07a;">   ruid&#65306;&#23454;&#38469;&#29992;&#25143;ID</span>
<span style="color: #ffa07a;">   euid&#65306;&#26377;&#25928;&#29992;&#25143;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setreuid</span>(<span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">ruid</span>, <span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">euid</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20132;&#25442;&#23454;&#38469;&#32452;ID&#21644;&#26377;&#25928;&#32452;ID&#30340;&#20540;</span>

<span style="color: #ffa07a;">   rgid&#65306;&#23454;&#38469;&#32452;ID</span>
<span style="color: #ffa07a;">   egid&#65306;&#26377;&#25928;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setregid</span>(<span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">rgid</span>, <span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">egid</span>);
</pre>
</div>
</li>
</ul>
<p>
一个非特权用户总能交换实际用户ID和有效用户ID。这就允许一个设置-用户-ID程序转换成只具有用户的普通许可权，以后又可再次转换回设置-用户-ID所得到的额外许可权。POSIX.1引进了保存的设置-用户-ID特征后，其作用也相应加强，它也允许一个非特权用 户将其有效用户ID设置为保存的设置-用户-ID
</p>

<p>
实际上更方便了调用上述程序，而无须手动进行保存有效用户ID，再手动setuid
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">seteuid和setegid函数</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>seteuid：设置有效用户ID，而setuid函数更改三个用户ID
</li>
<li>setegid：设置有效组ID

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#35774;&#32622;&#26377;&#25928;&#29992;&#25143;ID</span>

<span style="color: #ffa07a;">   euid&#65306;&#26377;&#25928;&#29992;&#25143;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1&#65292;&#24182;&#35774;&#32622;errno</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">seteuid</span>(<span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">euid</span>);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#35774;&#32622;&#26377;&#25928;&#32452;ID</span>

<span style="color: #ffa07a;">   egid&#65306;&#26377;&#25928;&#32452;ID</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;0&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1&#65292;&#24182;&#35774;&#32622;errno</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setegid</span>(<span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">egid</span>);
</pre>
</div>
</li>
</ul>
<p>
规则类似于setuid函数：一个非特权用户可将其有效用户ID设置为其实际用户ID或其保存的设置-用户-ID，一个特权用户则可将有效用户ID设置为uid
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">总结</h3>
<div class="outline-text-3" id="text-3-4">
<p>
图8-3给出了修改三个不同用户ID的各个函数：
</p>

<div class="figure">
<p><img src="pic/uid.png" alt="uid.png" width="90%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">组ID</h3>
<div class="outline-text-3" id="text-3-5">
<p>
上面描述的适用于各个组ID。添加组ID不受setgid函数的影响
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">解释器</h2>
<div class="outline-text-2" id="text-4">
<p>
解释器文件是文本文件，其起始行的形式是:  
</p>
<pre class="example">
#!pathname [optional-argument]
</pre>
<p>
在惊叹号和pathname之间的空格是可任选的。最常见的是以下列行开始:
</p>
<pre class="example">
#!/bin/sh
</pre>
<p>
pathname通常是个绝对路径名，不需要使用PATH进行路径搜索。对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程实际执行的文件并不是该解释器文件，而是在该解释器文件的第一行中pathname所指定的程序文件！
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">exec调用解释器文件</h3>
<div class="outline-text-3" id="text-4-1">
<p>
解释器文件testinterp，程序echoall(解释器)回送每一个命令行参数
</p>
<pre class="example">
#!/home/klose/bin/echoall foo
</pre>
<p>
使用exec调用解释器文件/home/klose/bin/testinterp
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>;

    <span style="color: #00ffff;">if</span>( (pid = fork()) &lt; 0 )
        err_sys(<span style="color: #ffa07a;">"fork error"</span>);
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ( 0 == pid ) <span style="color: #ff4500;">//</span><span style="color: #ff4500;">child </span>
        <span style="color: #00ffff;">if</span>(execl(<span style="color: #ffa07a;">"/home/klose/bin/testinterp"</span>, <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#35299;&#37322;&#22120;&#25991;&#20214;&#36335;&#24452;&#21517;pathname</span>
             <span style="color: #ffa07a;">"testinterp"</span>, <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#25191;&#34892;&#31243;&#24207;&#21517;&#65292;&#25171;&#21360;&#30340;&#26102;&#20505;&#20250;&#34987;pathname&#20195;&#26367;</span>
             <span style="color: #ffa07a;">"myarg1"</span>, <span style="color: #ffa07a;">"MY ARG2"</span>, <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#12288;&#21629;&#20196;&#34892;&#21442;&#25968;</span>
             (<span style="color: #98fb98;">char</span> *) 0 <span style="color: #ff4500;">//</span><span style="color: #ff4500;">NULL&#23383;&#31526;&#25351;&#38024;</span>
               ) &lt; 0 )
            err_sys(<span style="color: #ffa07a;">"execl error"</span>);

    <span style="color: #00ffff;">if</span> (waitpid(pid, <span style="color: #7fffd4;">NULL</span>, 0) != pid )
        err_sys(<span style="color: #ffa07a;">"waitpid error"</span>);

    exit(0);

}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">$ ./src/process/interpret

argv[0]: /home/klose/bin/echoall
argv[1]: foo
argv[2]: /home/klose/bin/testinterp
argv[3]: myarg1
argv[4]: MY ARG2
<span style="color: #eedd82;">LC_PAPER</span>=en_US.UTF8
<span style="color: #ff4500;">#</span><span style="color: #ff4500;">...</span>
=./src/process/interpret
</pre>
</div>
<p>
当内核exec执行解释器(/home/klose/bin/echoll)时，argv <code>[0]</code> 是该解释器的pathname，argv <code>[1]</code> 是解释器文件中的可选参数，其余参数是pathname(/home/klose/bin/testinterp)，以及程序中调用execl的第二和第三个参数(myarg1和MY ARG2)。调用execl时的argv <code>[1]</code> 和argv <code>[2]</code> 已右移了两个位置。注意：内核取execl中的pathname代替第一个参数(testinterp)，因为一般pathname包含了较第一个参数更多的信息！
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">awk实例</h3>
<div class="outline-text-3" id="text-4-2">
<p>
在解释器pathname后可跟随可选参数，它们常用于为支持-f选择项的程序指定该选择项。例如，可以以下列方式执行awk(1)程序：
</p>
<div class="org-src-container">

<pre class="src src-sh">awk -f myfile
</pre>
</div>
<p>
它告诉awk从文件myfile中读awk程序，而在在解释器文件中使用-f选择项，可以写成:
</p>
<pre class="example">
#!awk -f 
(在解释器文件中的awk程序)
</pre>
<p>
以下awk程序打印所有的参数
</p>
<div class="org-src-container">

<pre class="src src-awk"><span style="color: #ff4500;">#</span><span style="color: #ff4500;">!/bin/awk -f</span>

<span style="color: #00ffff;">BEGIN</span> {
    <span style="color: #00ffff;">for</span> (i = 0; i &lt; <span style="color: #eedd82;">ARGC</span>; i++)
        <span style="color: #7fffd4;">printf</span> <span style="color: #ffa07a;">"ARGV[%d] = %s\n"</span>, i, <span style="color: #eedd82;">ARGV</span>[i]
    <span style="color: #00ffff;">exit</span>
}
</pre>
</div>
<p>
测试:
</p>
<div class="org-src-container">

<pre class="src src-C">$ ./awkexample filel FILENAME2 f3 

ARGV[0] = awk
ARGV[1] = filel
ARGV[2] = FILENAME2
ARGV[3] = f3
</pre>
</div>
<p>
执行/bin/awk时，其命令行参数是：
</p>
<pre class="example">
/bin/awk -f /home/klose/Documents/programming/c/apue/orignal/proc/awkexample file1 FILENAME2 f3
</pre>
<p>
解释器文件的路径名(/usr/local/bin/awkexample)被传送给解释器。因为不能期望该解释器(在本例中是/bin/awk)会使用PATH变量定位该解释器文件，所以只传送其路径名中的文件名是不够的。当awk读解释器文件时，因为#是awk的注释字符，所以在awk读解释器文件时，它忽略第一行
</p>

<p>
在此例子中解释器的-f选择项是必需的。因为它告诉awk在什么地方得到awk程序。如果在解释器文件中删除-f选择项，则其结果是: 
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./awkexample filel FILENAME2 f3 

awk: cmd. line:1: ./awkexample
awk: cmd. line:1: ^ syntax error
awk: cmd. line:1: ./awkexample
awk: cmd. line:1:   ^ unterminated regexp
</pre>
</div>
<p>
因为其命令行参数变成了：
</p>
<pre class="example">
/bin/awk /home/klose/Documents/programming/c/apue/orignal/proc/awkexample file1 FILENAME2 f3
</pre>
<p>
于是awk企图将字符串/usr/local/bin/awkexample解释为一个awk程序。如果不能向解释器传递至少一个可选参数(在本例中是-f)，那么这些解释器文件只有对shell才是有用的
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">解释器文件的优劣</h3>
<div class="outline-text-3" id="text-4-3">
<p>
解释器文件的劣势主要在于效率，因为内核需要识别解释器文件，这会带来额外的开销。但是解释器文件还是有用的:
</p>
<ul class="org-ul">
<li>某些程序是用某种语言写的脚本，可以隐藏这一事实。例如只需使用下列命令行:
</li>
</ul>
<div class="org-src-container">

<pre class="src src-sh">$ awkexample optional-arguments
</pre>
</div>
<p>
而并不需要知道该程序实际上是一个awk脚本，否则就要以下列方式执行该程序:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ awk -f awkexample optional-arguments
</pre>
</div>
<ul class="org-ul">
<li>解释器脚本在效率方面也提供了好处。再考虑一下前面的例子，如果将其放在一个shell脚本中:
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff4500;">#</span><span style="color: #ff4500;">!/bin/</span><span style="color: #00ffff;">sh</span>

awk <span style="color: #ffa07a;">'BEGIN {</span>
<span style="color: #ffa07a;">for (i = 0; i &lt; ARGC; i++)</span>
<span style="color: #ffa07a;">printf "ARGV[%d] = %s\n", i, ARGV[i]</span>
<span style="color: #ffa07a;">e x i t</span>
<span style="color: #ffa07a;">}'</span> $<span style="color: #eedd82;">*</span>
</pre>
</div>
</li>
</ul>
<p>
这只会要求做更多的工作。首先shell读此命令，然后试图execlp此文件名。因为shell脚本是一个可执行文件，但却不是机器可执行的，于是返回一个错误，execlp就认为该文件是一个shell脚本。然后再执行/bin/sh，并以该shell脚本的路径名作为其参数。shell正确地执行脚本，但是为了运行awk程序，它调用fork，exec和wait。用一个shell脚本代替解释器脚本往往需要更多的开销
</p>

<ul class="org-ul">
<li>使用解释器脚本可以调用除/bin/sh以外的其他shell来编写shell脚本。当execlp找到一个非机器可执行的可执行文件时，它总是调用/bin/sh来解释执行该文件。但是用解释器脚本则可编写成: 
<pre class="example">
#!/bin/csh
(在解释器文件中后随Cshell脚本)
</pre>
</li>
</ul>
<p>
虽然可将此放在一个/bin/sh脚本中(然后由其调用Cshell)，但同样会有更多的开销
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">system函数</h2>
<div class="outline-text-2" id="text-5">
<p>
system：在程序中执行一个命令字符串，是否支持system完全依赖于操作系统
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#20351;&#29992;/bin/sh&#25191;&#34892;&#25351;&#23450;&#30340;&#21629;&#20196;&#20018;&#25191;&#34892;&#26631;&#20934;&#30340;shell&#21629;&#20196;</span>

<span style="color: #ffa07a;">   cmdstring&#65306;&#21629;&#20196;&#20018;</span>

<span style="color: #ffa07a;">   return: 1. &#22914;&#26524;fork&#22833;&#36133;&#25110;&#32773;waitpid&#36820;&#22238;&#38500;EINTR&#20043;&#22806;&#30340;&#20986;&#38169;&#65292;&#21017;system&#36820;&#22238;-1&#65292;&#32780;&#19988;errno&#20013;&#35774;&#32622;&#20102;&#38169;&#35823;&#31867;&#22411;&#12290;</span>
<span style="color: #ffa07a;">       2. &#22914;&#26524;exec&#22833;&#36133;(&#34920;&#31034;&#19981;&#33021;&#25191;&#34892;shell)&#65292;&#21017;&#20854;&#36820;&#22238;&#20540;&#22914;&#21516;shell&#25191;&#34892;&#20102;exit(127)&#19968;&#26679;&#12290;</span>
<span style="color: #ffa07a;">       3. &#25152;&#26377;&#19977;&#20010;&#20989;&#25968;(fork&#65292;exec&#21644;waitpid)&#37117;&#25104;&#21151;&#65292;&#24182;&#19988;system&#30340;&#36820;&#22238;&#20540;&#26159;shell&#30340;&#32456;&#27490;&#29366;&#24577;</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">system</span>(cont <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">cmdstring</span>);
</pre>
</div>
<p>
如果cmdstring是一个空指针，则仅当system命令处理程序可用时返回非0值，这一特征可以用来判定在一个给定的操作系统上是否支持system函数。在UNIX中system总是可用的
</p>

<p>
因为system在其实现中调用了fork、exec和waitpid，因此有三种返回值:
</p>
<ol class="org-ol">
<li>如果fork失败或者waitpid返回除EINTR之外的出错，则system返回-1，而且errno中设置了错误类型
</li>
<li>如果exec失败(表示不能执行shell)，则其返回值如同shell执行了exit(127)一样
</li>
<li>否则所有三个函数(fork，exec和waitpid)都成功，并且system的返回值是shell的终止状态，其格式已在waitpid中说明
</li>
</ol>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">system简单实现</h3>
<div class="outline-text-3" id="text-5-1">
<p>
以下程序是system的一个实现，没有考虑信号处理
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;errno.h&gt;</span>
<span style="color: #7fffd4;">#include</span>    <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#32570;&#23569;&#20449;&#21495;&#22788;&#29702; </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">mysystem</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">cmdstring</span>) 
{
    <span style="color: #98fb98;">pid_t</span>   <span style="color: #eedd82;">pid</span>;
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">status</span>;

    <span style="color: #00ffff;">if</span> (cmdstring == <span style="color: #7fffd4;">NULL</span>)
        <span style="color: #00ffff;">return</span>(1); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36820;&#22238;1&#34920;&#31034;&#25903;&#25345;system&#20989;&#25968;    </span>

    <span style="color: #00ffff;">if</span> ((pid = fork()) &lt; 0) {
        status = -1;    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#26080;&#27861;&#20877;&#21019;&#24314;&#26032;&#30340;&#36827;&#31243;</span>
    } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (pid == 0) { <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#23376;&#36827;&#31243;</span>
        execl(<span style="color: #ffa07a;">"/bin/sh"</span>, <span style="color: #ffa07a;">"sh"</span>, <span style="color: #ffa07a;">"-c"</span>, cmdstring, (<span style="color: #98fb98;">char</span> *)0);
        _exit(127);     <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#26080;&#27861;&#25191;&#34892;exec&#20989;&#25968;&#65292;&#36820;&#22238;127</span>
    } <span style="color: #00ffff;">else</span> { <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#29238;&#36827;&#31243;&#31561;&#24453;&#23376;&#36827;&#31243;&#32467;&#26463;</span>
        <span style="color: #00ffff;">while</span> (waitpid(pid, &amp;status, 0) &lt; 0) {
            <span style="color: #00ffff;">if</span> (errno != EINTR) {
                status = -1; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">waitpid&#19981;&#26159;&#36890;&#36807;&#25429;&#33719;&#20013;&#26029;&#20449;&#21495;&#32780;&#36820;&#22238;&#65292;&#20986;&#38169;&#36820;&#22238;-1 </span><span style="color: #ff4500;">*/</span>
                <span style="color: #00ffff;">break</span>;
            }
        }
    }

    <span style="color: #00ffff;">return</span>(status); <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#36820;&#22238;&#23376;&#36827;&#31243;&#30340;&#32456;&#27490;&#29366;&#24577;</span>
}
</pre>
</div>
<p>
shell的-c选择项告诉shell程序取下一个命令行参数(在这里是cmdstring)作为命令输入(而不是从标准输入或从一个给定的文件中读命令)。shell对以null字符终止的命令字符串进行语法分析，将它们分成分隔开的命令行参数。传递给shell的实际命令串可以包含任一有效的shell命令。例如可以用'&lt;'和'&gt;'对输入和输出重新定向
</p>

<p>
如果不使用shell执行此命令，而是试图由我们自己去执行它，那么将相当困难。首先必须用execlp而不是execl，像shell那样使用PATH变量。那么必须将null符结尾的命令字符串分成各个命令行参数，以便调用execlp。最后也不能使用任何一个shell元字符。
</p>

<p>
注意：最后调用_exit而不是exit。这是为了防止任一标准I/O缓存(这些缓存会在fork中由父进程复制到子进程)在子进程中被刷新！
</p>
</div>

<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">mysystem实例</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
调用mystem来执行shell命令：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>

<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">mysystem</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">cmdstring</span>);

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">status</span>;

    <span style="color: #00ffff;">if</span> ((status = mysystem(<span style="color: #ffa07a;">"date"</span>)) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"system() error"</span>);
    pr_exit(status);

    <span style="color: #00ffff;">if</span> ((status = mysystem(<span style="color: #ffa07a;">"nosuchcommand"</span>)) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"system() error"</span>);
    pr_exit(status);

    <span style="color: #00ffff;">if</span> ((status = mysystem(<span style="color: #ffa07a;">"who; exit 44"</span>)) &lt; 0)
        err_sys(<span style="color: #ffa07a;">"system() error"</span>);
    pr_exit(status);

    exit(0);
}
</pre>
</div>
<p>
测试：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ ./src/process/mysystest1 

Thu Mar  9 23:57:44 CST 2017
normal termination, exit status = 0 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#25104;&#21151;&#25191;&#34892;&#32456;&#27490;&#29366;&#24577;&#36820;&#22238;0</span>
sh: nosuchcommand: command not found
normal termination, exit status = 127 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#26080;&#27861;&#25191;&#34892;shell&#21629;&#20196;&#65292;&#32456;&#27490;&#29366;&#24577;&#36820;&#22238;127</span>
klose    tty1         2017-03-09 22:08
klose    pts/0        2017-03-09 22:19 (:0.0)
klose    pts/1        2017-03-09 22:29 (:0.0)
normal termination, exit status = 44 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#25163;&#21160;&#36820;&#22238;&#32456;&#27490;&#29366;&#24577;44</span>
</pre>
</div>

<p>
使用system而不直接使用fork和exec的原因是：system进行了所需的各种出错处理，以及各种信号处理
</p>

<p>
如果一个进程正以特殊的许可权(设置-用户-ID或设置-组-ID)运行，但又想生成另一个进程执行另一个程序，则它应当直接使用fork和exec，而且在fork之后、exec之前要改回到普通许可权。设置-用户-ID或设置-组-ID程序决不应调用system函数。另外，作为服务器程序时也不应使用system处理客户程序提供的字符串参数，以避免恶意用户利用shell中的特殊操作符进行越权操作
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">进程会计</h2>
<div class="outline-text-2" id="text-6">
<p>
很多UNIX系统提供了一个选择项以进行进程会计事务处理。当取了这种选择项后，每当进程结束时内核就写一个会计记录。典型的会计记录是32字节长的二进制数据，包括命令名、所使用的CPU时间总量、用户ID和组ID、起动时间等
</p>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">acct结构</h3>
<div class="outline-text-3" id="text-6-1">
<p>
会计记录结构定义在头文件&lt;sys/acct.h&gt;中，其样式如下：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">u_int16_t</span> <span style="color: #98fb98;">comp_t</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">acct</span>
{
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">ac_flag</span>;         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Flags.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">u_int16_t</span> <span style="color: #eedd82;">ac_uid</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Real user ID.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">u_int16_t</span> <span style="color: #eedd82;">ac_gid</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Real group ID.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">u_int16_t</span> <span style="color: #eedd82;">ac_tty</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Controlling terminal.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">u_int32_t</span> <span style="color: #eedd82;">ac_btime</span>;       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Beginning time.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_utime</span>;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">User time.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_stime</span>;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">System time.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_etime</span>;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Elapsed time.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_mem</span>;        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Average memory usage.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_io</span>;         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Chars transferred.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_rw</span>;         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Blocks read or written.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_minflt</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Minor pagefaults.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_majflt</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Major pagefaults.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">comp_t</span> <span style="color: #eedd82;">ac_swaps</span>;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Number of swaps.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">u_int32_t</span> <span style="color: #eedd82;">ac_exitcode</span>;    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Process exitcode.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">ac_comm</span>[ACCT_COMM+1];    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Command name.  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">ac_pad</span>[10];      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">Padding bytes.  </span><span style="color: #ff4500;">*/</span>
};
</pre>
</div>
<p>
其中ac_flag记录了进程执行期间的某些事件。这些事件见下表：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boade">
<caption class="t-above"><span class="table-number">Table 6:</span> 会计记录中的ac_flag值</caption>

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">ac_flag</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">AFORK</td>
<td class="left">进程是由fork产生的，但从未调用exec</td>
</tr>

<tr>
<td class="left">ASU</td>
<td class="left">进程使用超级用户优先权</td>
</tr>

<tr>
<td class="left">ACOMPAT</td>
<td class="left">进程使用兼容方式(仅VAX)</td>
</tr>

<tr>
<td class="left">ACORE</td>
<td class="left">进程转储core(不在SVR4)</td>
</tr>

<tr>
<td class="left">AXSIG</td>
<td class="left">进程由信号消灭(不在SVR4)</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1">会记记录的缺陷</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核保存在进程表中，并在一个新进程被创建时置初值(例如fork之后在子进程中)。进程终止时写一个会计记录。这就意味着在会计文件中记录的顺序对应于进程终止的顺序，而不是它们起动的顺序。为了确定起动顺序，需要读全部会计文件，并按起动日历时间进行排序
</p>

<p>
会计记录对应于进程而不是程序。在fork之后内核为子进程初始化一个记录，而不是在一个新程序被执行时。虽然exec并不创建一个新的会计记录，但相应记录中的命令名改变了，AFORK标志则被清除。这意味着：如果一个进程顺序执行了三个程序(A exec B，B exec C，最后C exit)，但只写一个会计记录。在该记录中的命令名对应于程序C，但CPU时间是程序A、B、C之和
</p>

<p>
会记记录并不是POSIX标准，各个系统实现都不一样，建议谨慎使用！
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">用户标识</h3>
<div class="outline-text-3" id="text-6-2">
<p>
在实际的Unix系统中，uid和gid是标志一个用户的方式，但是用户不需要以数字标志的形式管理系统，所以就有了以英文形式提供的用户标识，系统也提供了对应的映射
</p>

<p>
getlogin：获取用户登录名
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#21462;&#29992;&#25143;&#30331;&#24405;&#21517;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#25351;&#21521;&#30331;&#24405;&#21517;&#23383;&#31526;&#20018;&#30340;&#25351;&#38024;&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;NULL</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">getlogin</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">进程时间</h3>
<div class="outline-text-3" id="text-6-3">
<p>
times：获得某个进程各个时间
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/times.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   &#33719;&#24471;&#36827;&#31243;&#30340;&#31995;&#32479;cpu&#26102;&#38388;&#65292;&#29992;&#25143;cpu&#26102;&#38388;&#65292;&#32456;&#27490;&#23376;&#36827;&#31243;&#31995;&#32479;cpu&#26102;&#38388;&#24635;&#21644;&#65292;&#32456;&#27490;&#23376;&#36827;&#31243;&#29992;&#25143;cpu&#26102;&#38388;&#24635;&#21644;</span>

<span style="color: #ffa07a;">   buffer&#65306;&#36827;&#31243;&#26102;&#38388;&#32467;&#26500;&#25351;&#38024;&#65292;&#22635;&#20889;&#36827;&#31243;&#30456;&#20851;&#26102;&#38388;</span>

<span style="color: #ffa07a;">   return&#65306;&#33509;&#25104;&#21151;&#21017;&#20026;&#32463;&#36807;&#30340;&#22681;&#19978;&#26102;&#38047;&#26102;&#38388;(&#21333;&#20301;:&#28404;&#31572;)&#65292;&#33509;&#20986;&#38169;&#21017;&#20026;-1</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #98fb98;">clock_t</span> <span style="color: #87cefa;">times</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tms</span> *<span style="color: #eedd82;">buffer</span>);
</pre>
</div>
<p>
填写由buf指向的tms结构，该结构定义如下: 
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tms</span> {
    <span style="color: #98fb98;">clock_t</span> <span style="color: #eedd82;">tms_utime</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#29992;&#25143;CPU&#26102;&#38388;</span>
    <span style="color: #98fb98;">clock_t</span> <span style="color: #eedd82;">tms_stime</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#31995;&#32479;CPU&#26102;&#38388;</span>
    <span style="color: #98fb98;">clock_t</span> <span style="color: #eedd82;">tms_cutime</span>; <span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#32456;&#27490;&#30340;&#23376;&#36827;&#31243;&#29992;&#25143;CPU&#26102;&#38388;&#24635;&#21644;</span>
    <span style="color: #98fb98;">clock_t</span> <span style="color: #eedd82;">tms_cstime</span>;<span style="color: #ff4500;">//</span><span style="color: #ff4500;">&#32456;&#27490;&#30340;&#23376;&#36827;&#31243;&#31995;&#32479;CPU&#26102;&#38388;&#24635;&#21644;</span>
};
</pre>
</div>
<p>
注意：此结构没有包含墙上时钟时间。作为代替times函数返回墙上时钟时间作为函数值。此值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值。例如调用times保存其返回值。在以后某个时间再次调用times，从新返回的值中减去以前返回的值，此差值就是墙上时钟时间
</p>
</div>

<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1">打印进程时间实例</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
将每个命令行参数作为shell命令串执行，对每个命令计时并打印：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">"apue.h"</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/times.h&gt;</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pr_times</span>(<span style="color: #98fb98;">clock_t</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tms</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tms</span> *);
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">do_cmd</span>(<span style="color: #98fb98;">char</span> *);

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">i</span>;

    setbuf(stdout, <span style="color: #7fffd4;">NULL</span>);
    <span style="color: #00ffff;">for</span> (i = 1; i &lt; argc; i++)
        do_cmd(argv[i]);    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">once for each command-line arg </span><span style="color: #ff4500;">*/</span>
    exit(0);
}

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">do_cmd</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">cmd</span>)       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">execute and time the "cmd" </span><span style="color: #ff4500;">*/</span>
{
    <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tms</span>  <span style="color: #eedd82;">tmsstart</span>, <span style="color: #eedd82;">tmsend</span>;
    <span style="color: #98fb98;">clock_t</span>     <span style="color: #eedd82;">start</span>, <span style="color: #eedd82;">end</span>;
    <span style="color: #98fb98;">int</span>         <span style="color: #eedd82;">status</span>;

    printf(<span style="color: #ffa07a;">"\ncommand: %s\n"</span>, cmd);

    <span style="color: #00ffff;">if</span> ((start = times(&amp;tmsstart)) == -1)   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">starting values </span><span style="color: #ff4500;">*/</span>
        err_sys(<span style="color: #ffa07a;">"times error"</span>);

    <span style="color: #00ffff;">if</span> ((status = system(cmd)) &lt; 0)     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">execute command </span><span style="color: #ff4500;">*/</span>
        err_sys(<span style="color: #ffa07a;">"system() error"</span>);

    <span style="color: #00ffff;">if</span> ((end = times(&amp;tmsend)) == -1)       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ending values </span><span style="color: #ff4500;">*/</span>
        err_sys(<span style="color: #ffa07a;">"times error"</span>);

    pr_times(end-start, &amp;tmsstart, &amp;tmsend);
    pr_exit(status);
}

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pr_times</span>(<span style="color: #98fb98;">clock_t</span> <span style="color: #eedd82;">real</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tms</span> *<span style="color: #eedd82;">tmsstart</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tms</span> *<span style="color: #eedd82;">tmsend</span>)
{
    <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">long</span>     <span style="color: #eedd82;">clktck</span> = 0;

    <span style="color: #00ffff;">if</span> (clktck == 0)    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">fetch clock ticks per second first time </span><span style="color: #ff4500;">*/</span>
        <span style="color: #00ffff;">if</span> ((clktck = sysconf(_SC_CLK_TCK)) &lt; 0)
            err_sys(<span style="color: #ffa07a;">"sysconf error"</span>);
    printf(<span style="color: #ffa07a;">"  real:  %7.2f\n"</span>, real / (<span style="color: #98fb98;">double</span>) clktck);
    printf(<span style="color: #ffa07a;">"  user:  %7.2f\n"</span>,
           (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime) / (<span style="color: #98fb98;">double</span>) clktck);
    printf(<span style="color: #ffa07a;">"  sys:   %7.2f\n"</span>,
           (tmsend-&gt;tms_stime - tmsstart-&gt;tms_stime) / (<span style="color: #98fb98;">double</span>) clktck);
    printf(<span style="color: #ffa07a;">"  child user:  %7.2f\n"</span>,
           (tmsend-&gt;tms_cutime - tmsstart-&gt;tms_cutime) / (<span style="color: #98fb98;">double</span>) clktck);
    printf(<span style="color: #ffa07a;">"  child sys:   %7.2f\n"</span>,
           (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime) / (<span style="color: #98fb98;">double</span>) clktck);
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">$ ./src/process/timesExample <span style="color: #ffa07a;">"cd /usr/include; grep _POSIX_SOURCE */*.h &gt;/dev/null 2&gt;/dev/null"</span>   

<span style="color: #b0c4de;">command</span>: cd /usr/include; grep _POSIX_SOURCE */*.h &gt;/dev/null 2&gt;/dev/null
  real:     0.04
  user:     0.00
  sys:      0.00
  child user:     0.02
  child sys:      0.01
normal termination, exit status = 2
</pre>
</div>
<p>
在child user和child sys行中显示的时间分别是执行shell和命令的子进程所使用的CPU时间
</p>

<p>
<a href="proc_group.html">Next：进程关系</a>
</p>

<p>
<a href="env.html">Previous：进程环境</a>
</p>

<p>
<a href="apue.html">Home：目录</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
