<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>规则</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="save_restore.html"> UP </a>
 |
 <a accesskey="H" href="iptables.html"> HOME </a>
</div><div id="content">
<h1 class="title">规则</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">基础</a></li>
<li><a href="#sec-2">Tables</a>
<ul>
<li><a href="#sec-2-1">nat</a></li>
<li><a href="#sec-2-2">mangle</a></li>
<li><a href="#sec-2-3">filter</a></li>
</ul>
</li>
<li><a href="#sec-3">Commands</a>
<ul>
<li><a href="#sec-3-1">命令</a>
<ul>
<li><a href="#sec-3-1-1">append</a></li>
<li><a href="#sec-3-1-2">delete</a></li>
<li><a href="#sec-3-1-3">replace</a></li>
<li><a href="#sec-3-1-4">insert</a></li>
<li><a href="#sec-3-1-5">list</a></li>
<li><a href="#sec-3-1-6">flush</a></li>
<li><a href="#sec-3-1-7">zero</a></li>
<li><a href="#sec-3-1-8">new-chain</a></li>
<li><a href="#sec-3-1-9">delete-chain</a></li>
<li><a href="#sec-3-1-10">policy</a></li>
<li><a href="#sec-3-1-11">rename-chain</a></li>
</ul>
</li>
<li><a href="#sec-3-2">选项</a>
<ul>
<li><a href="#sec-3-2-1">verbose</a></li>
<li><a href="#sec-3-2-2">exact</a></li>
<li><a href="#sec-3-2-3">numeric</a></li>
<li><a href="#sec-3-2-4">line-numbers</a></li>
<li><a href="#sec-3-2-5">set-counters</a></li>
<li><a href="#sec-3-2-6">modprobe</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Matches</a>
<ul>
<li><a href="#sec-4-1">通用匹配</a>
<ul>
<li><a href="#sec-4-1-1">protocol</a></li>
<li><a href="#sec-4-1-2">source</a></li>
<li><a href="#sec-4-1-3">destination</a></li>
<li><a href="#sec-4-1-4">in-interface</a></li>
<li><a href="#sec-4-1-5">out-interface</a></li>
<li><a href="#sec-4-1-6">fragment</a></li>
</ul>
</li>
<li><a href="#sec-4-2">隐含匹配</a>
<ul>
<li><a href="#sec-4-2-1">TCP</a>
<ul>
<li><a href="#sec-4-2-1-1">source-port</a></li>
<li><a href="#sec-4-2-1-2">destination-port</a></li>
<li><a href="#sec-4-2-1-3">tcp-flags</a></li>
<li><a href="#sec-4-2-1-4">syn</a></li>
<li><a href="#sec-4-2-1-5">tcp-option</a></li>
</ul>
</li>
<li><a href="#sec-4-2-2">UDP</a>
<ul>
<li><a href="#sec-4-2-2-1">source-port</a></li>
<li><a href="#sec-4-2-2-2">destination-port</a></li>
</ul>
</li>
<li><a href="#sec-4-2-3">ICMP</a>
<ul>
<li><a href="#sec-4-2-3-1">icmp-type</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4-3">显示匹配</a>
<ul>
<li><a href="#sec-4-3-1">Limit</a>
<ul>
<li><a href="#sec-4-3-1-1">limit</a></li>
<li><a href="#sec-4-3-1-2">limit-burst</a></li>
</ul>
</li>
<li><a href="#sec-4-3-2">MAC</a>
<ul>
<li><a href="#sec-4-3-2-1">mac-source</a></li>
</ul>
</li>
<li><a href="#sec-4-3-3">Mark</a>
<ul>
<li><a href="#sec-4-3-3-1">mark</a></li>
</ul>
</li>
<li><a href="#sec-4-3-4">Multiport</a>
<ul>
<li><a href="#sec-4-3-4-1">source-port</a></li>
<li><a href="#sec-4-3-4-2">destination-port</a></li>
<li><a href="#sec-4-3-4-3">port</a></li>
</ul>
</li>
<li><a href="#sec-4-3-5">Owner</a>
<ul>
<li><a href="#sec-4-3-5-1">uid-owner</a></li>
<li><a href="#sec-4-3-5-2">gid-owner</a></li>
<li><a href="#sec-4-3-5-3">pid-owner</a></li>
<li><a href="#sec-4-3-5-4">sid-owner</a></li>
</ul>
</li>
<li><a href="#sec-4-3-6">State</a>
<ul>
<li><a href="#sec-4-3-6-1">state</a></li>
</ul>
</li>
<li><a href="#sec-4-3-7">TOS</a>
<ul>
<li><a href="#sec-4-3-7-1">tos</a></li>
</ul>
</li>
<li><a href="#sec-4-3-8">TTL</a>
<ul>
<li><a href="#sec-4-3-8-1">ttl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4-4">非正常包的匹配</a></li>
</ul>
</li>
<li><a href="#sec-5">Target/Jump</a></li>
</ul>
</div>
</div>
<p>
在内核看来，规则就是决定如何处理一个包的语句
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">基础</h2>
<div class="outline-text-2" id="text-1">
<p>
如果一个包符合所有的条件（就是符合matche语句），就运行target或jump指令。书写规则的语法格式是：
</p>

<pre class="example">
iptables [-t table] command [match] [target/jump]
</pre>

<ul class="org-ul">
<li><span class="underline">table</span> ：指定表名
<ul class="org-ul">
<li>一般情况下没有必要指定使用的表，iptables默认使用 <b>filter</b> 表来执行所有的命令
</li>
<li>没有必要非得在这里指定表名，当然 <span class="underline">把表名在开始处已经是约定俗成的标准</span>
</li>
</ul>
</li>
<li><span class="underline">command</span> : 告诉程序该做什么
<ul class="org-ul">
<li>插入一个规则
</li>
<li>在链的末尾增加一个规则
</li>
<li>删除一个规则
</li>
</ul>
</li>
<li><span class="underline">match</span> : 细致地描述了包的某个特点，以使这个包区别于其它所有的包
<ul class="org-ul">
<li><span class="underline">来源IP地址</span>
</li>
<li><span class="underline">网络接口</span>
</li>
<li><span class="underline">端口</span>
</li>
<li><span class="underline">协议类型</span> 或者其他什么
</li>
</ul>
</li>
<li><span class="underline">target</span> : 数据包的目标所在。 <b>若数据包符合所有的match，内核就用target来处理它</b> ，或者说把包发往 target 
<ul class="org-ul">
<li>让内核把包发送到当前表中的其他链（可能是自己建立的）
</li>
<li>丢弃这个包而没有什么处理
</li>
<li>向发送者返回某个特殊的应答
</li>
</ul>
</li>
</ul>

<p>
注意： <span class="underline">target</span> 指令必须在最后。为了易读，一般用这种语法。大部分规则都是按这种语法写的
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Tables</h2>
<div class="outline-text-2" id="text-2">
<p>
选项 <span class="underline">-t</span> 用来指定使用哪个表，它可以是下面介绍的表中的任何一个，默认的是 <b>filter</b> 表
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">nat</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<b>网络地址转换</b> ，即 <span class="underline">Network Address Translation</span> ，缩写为 <b>NAT</b> 。做过NAT操作的数据包的地址就被改变了，当然这种改变是根据定义的规则进行的 
</p>

<p>
<b>属于一个流的包只会经过这个表一次。如果第一个包被允许做NAT或Masqueraded，那么余下的包都会自动地被做相同的操作</b> 。也就是说，余下的包不会再通过这个表，一个一个的被NAT，而是自动地完成。这就是为什么 <span class="underline">不应该在这个表中做任何过滤的主要原因</span> 。
</p>

<ul class="org-ul">
<li><span class="underline">PREROUTING</span> 链：在包刚刚到达防火墙时改变它的目的地址，如果需要的话
</li>
<li><span class="underline">OUTPUT</span> 链：改变本地产生的包的目的地址
</li>
<li><span class="underline">POSTROUTING</span> 链：包就要离开防火墙之前改变其源地址
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">mangle</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<b>改变不同的包及包头的内容</b> ：
</p>
<ul class="org-ul">
<li><span class="underline">TTL</span>
</li>
<li><span class="underline">TOS</span>
</li>
<li><span class="underline">MARK</span> 
</li>
</ul>

<pre class="example">
MARK并没有真正地改动数据包，它只是在内核空间为包设了一个标记

防火墙内的其他的规则或程序可以使用这种标记对包进行过滤或高级路由
</pre>

<p>
这个表有五个内建的链： 
</p>
<ul class="org-ul">
<li><span class="underline">PREROUTING</span> : 包进入防火墙之后、路由判断之前改变包
</li>
<li><span class="underline">POSTROUTING</span> : 在所有路由判断之后
</li>
<li><span class="underline">OUTPUT</span> : 在确定包的目的之前更改数据包
</li>
<li><span class="underline">INPUT</span> : 在包被路由到本地之后，但在用户空间的程序看到它之前改变包
</li>
<li><span class="underline">FORWARD</span> : 在最初的路由判断之后、最后一次更改包的目的之前mangle包
</li>
</ul>

<pre class="example">
mangle表不能做任何NAT，它只是改变数据包的 TTL，TOS或MARK，而不是其源目地址
</pre>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">filter</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<b>专门过滤包</b> 的，可以毫无问题地对包进行 
</p>
<ul class="org-ul">
<li><span class="underline">DROP</span>
</li>
<li><span class="underline">LOG</span>
</li>
<li><span class="underline">ACCEPT</span>
</li>
<li><span class="underline">REJECT</span>  
</li>
</ul>

<p>
内建三个链：
</p>
<ul class="org-ul">
<li><span class="underline">FORWARD</span>  :  过滤所有不是本地产生的并且目的地不是本地（所谓本地就是防火墙了）的包
</li>
<li><span class="underline">INPUT</span> : 针对那些目的地是本地的包
</li>
<li><span class="underline">OUTPUT</span> : 过滤所有本地生成的包的
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Commands</h2>
<div class="outline-text-2" id="text-3">
<p>
<span class="underline">command</span> 指定iptables对 <b>提交的规则要做什么样的操作</b> 
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">命令</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">append</h4>
<div class="outline-text-4" id="text-3-1-1">
<pre class="example">
-A, --append
</pre>

<p>
在所选择的链末添加规则。当源地址或目的地址是以名字而不是ip地址的形式出现时，若这些名字可以被解析为多个地址，则这条规则会和所有可用的地址结合
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT ...
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">delete</h4>
<div class="outline-text-4" id="text-3-1-2">
<pre class="example">
-D, --delete
</pre>

<p>
从所选链中删除规则。有两种方法指定要删除的规则：
</p>
<ol class="org-ol">
<li>把规则完完整整地写出来
</li>
<li>指定规则在所选链中的序号：每条链的规则都各自从1被编号
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -D INPUT --dport 80 -j DROP

iptables -D INPUT 1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3">replace</h4>
<div class="outline-text-4" id="text-3-1-3">
<pre class="example">
-R, --replace
</pre>

<p>
在所选中的链里指定的行上（每条链的规则都各自从1被编号）替换规则
</p>

<p>
主要的用处是 <span class="underline">试验不同的规则</span> 。当源地址或目的地址是以名字而不是ip地址的形式出现时，若这些名字可以被解析为多个地址，则 <b>这条command会失败</b> 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -R INPUT 1 -s 192.168.0.1 -j DROP
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4">insert</h4>
<div class="outline-text-4" id="text-3-1-4">
<pre class="example">
-I, --insert
</pre>

<p>
根据给出的规则序号向所选链中插入规则。 <b>如果序号为1， 规则会被插入链的头部</b> ， 默认序号就是1 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -I INPUT 1 --dport 80 -j ACCEPT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5">list</h4>
<div class="outline-text-4" id="text-3-1-5">
<pre class="example">
-L, --list
</pre>

<p>
显示所选链的所有规则：
</p>
<ul class="org-ul">
<li>如果没有指定链，则显示指定表中的所有链
</li>
<li>如果什么都没有指定，就显示默认表所有的链
</li>
</ul>

<p>
精确输出受其它参数影响，如 <span class="underline">-n</span> 和 <span class="underline">-v</span> 等参数
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -L INPUT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-6" class="outline-4">
<h4 id="sec-3-1-6">flush</h4>
<div class="outline-text-4" id="text-3-1-6">
<pre class="example">
-F, --flush
</pre>

<p>
清空所选的链：
</p>
<ul class="org-ul">
<li>如果没有指定链，则清空指定表中的所有 链
</li>
<li>如果什么都没有指定，就清空默认表所有的链
</li>
</ul>

<p>
也可以一条一条地删，但用这个command会快些
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -F INPUT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-7" class="outline-4">
<h4 id="sec-3-1-7">zero</h4>
<div class="outline-text-4" id="text-3-1-7">
<pre class="example">
-Z, --zero
</pre>

<p>
把指定链（如未指定，则认为是所有链）的所有计数器归零
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -Z INPUT
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-8" class="outline-4">
<h4 id="sec-3-1-8">new-chain</h4>
<div class="outline-text-4" id="text-3-1-8">
<pre class="example">
-N, --new-chain
</pre>

<p>
根据用户指定的名字建立新的链
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -N allowed
</pre>
</div>

<p>
注意：所用的名字不能和已有的链、target同名
</p>
</div>
</div>

<div id="outline-container-sec-3-1-9" class="outline-4">
<h4 id="sec-3-1-9">delete-chain</h4>
<div class="outline-text-4" id="text-3-1-9">
<pre class="example">
-X, --delete-chain
</pre>

<p>
删除指定的用户自定义链：
</p>
<ul class="org-ul">
<li>如果没有给出参数，这条命令将会 <b>删除默认表所有非内建的链</b> 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -X allowed
</pre>
</div>

<p>
注意： <b>这个链必须没有被引用</b> ，如果被引用，在删除之前你必须删除或者替换与之有关的规则
</p>
</div>
</div>

<div id="outline-container-sec-3-1-10" class="outline-4">
<h4 id="sec-3-1-10">policy</h4>
<div class="outline-text-4" id="text-3-1-10">
<pre class="example">
-P, --policy
</pre>

<p>
为链设置默认的target（可用的是DROP 和ACCEPT），这个target称作策略
</p>
<div class="org-src-container">

<pre class="src src-sh">iptables -P INPUT DROP
</pre>
</div>

<ul class="org-ul">
<li>所有不符合规则的包都被强制使用这个策略
</li>
<li>只有内建的链才可以使用规则
</li>
<li>但内建的链和用户自定义链都不能被作为策略使用，也就是说不能象这样使用： 
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -P INPUT allowed&#65288;&#25110;&#32773;&#26159;&#20869;&#24314;&#30340;&#38142;&#65289;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-11" class="outline-4">
<h4 id="sec-3-1-11">rename-chain</h4>
<div class="outline-text-4" id="text-3-1-11">
<pre class="example">
-E, --rename-chain
</pre>

<p>
对自定义的链进行重命名，原来的名字在前，新名字在后
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -E allowed disallowed
</pre>
</div>

<p>
把 <span class="underline">allowed</span> 改为 <span class="underline">disallowed</span> 。这仅仅是改变链的名字，对整个表的结构、工作没有任何影响
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">选项</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">verbose</h4>
<div class="outline-text-4" id="text-3-2-1">
<pre class="example">
-v, --verbose
</pre>

<p>
这个选项使输出详细化，常与 <span class="underline">&#x2013;list</span> 连用: 
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;list</span> 连用时：输出中包括
<ul class="org-ul">
<li>网络接口的地址
</li>
<li>规则的选项
</li>
<li>TOS掩码
</li>
<li>字节和包计数器: 
<ul class="org-ul">
<li>计数器是以K、M、G（这里用的是10的幂而不是2的幂哦）为单位的
</li>
</ul>
</li>
</ul>
</li>
<li>和 <span class="underline">&#x2013;append</span> 、 <span class="underline">&#x2013;insert</span> 、 <span class="underline">&#x2013;delete</span>  或 <span class="underline">&#x2013;replace</span> 连用，iptables会输出详细的信息告诉规则是如何被解释的、是否正确地插入等等
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">exact</h4>
<div class="outline-text-4" id="text-3-2-2">
<pre class="example">
-X --exact
</pre>

<p>
使 <span class="underline">&#x2013;list</span> 输出中的计数器显示准确的数值，而不用K、M、G等估值
</p>

<p>
注意：此选项只能和&#x2013;list连用
</p>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">numeric</h4>
<div class="outline-text-4" id="text-3-2-3">
<pre class="example">
-n, --numeric
</pre>

<p>
使输出中的IP地址和端口以数值的形式显示，而不是默认的名字：
</p>
<ul class="org-ul">
<li>主机名
</li>
<li>网络名
</li>
<li>程序名等
</li>
</ul>

<p>
注意：此选项也只能和 <span class="underline">&#x2013;list</span> 连用
</p>
</div>
</div>

<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4">line-numbers</h4>
<div class="outline-text-4" id="text-3-2-4">
<pre class="example">
--line-numbers
</pre>

<p>
显示出每条规则在相应链中的序号。这样可以知道序号了，这对插入新规则很有用
</p>

<p>
注意：此选项也只能和 <span class="underline">&#x2013;list</span> 连用
</p>
</div>
</div>

<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5">set-counters</h4>
<div class="outline-text-4" id="text-3-2-5">
<pre class="example">
-c, --set-counters
</pre>

<p>
在创建或更改规则时设置计数器
</p>

<div class="org-src-container">

<pre class="src src-sh">--set-counters 20 4000
</pre>
</div>

<p>
让内核把包计数器设为20，把字节计数器设为4000
</p>

<p>
可以搭配的命令：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;insert</span> 
</li>
<li><span class="underline">&#x2013;append</span>
</li>
<li><span class="underline">&#x2013;replace</span>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2-6" class="outline-4">
<h4 id="sec-3-2-6">modprobe</h4>
<div class="outline-text-4" id="text-3-2-6">
<pre class="example">
--modprobe
</pre>

<p>
告诉iptables探测并装载要使用的模块。万一modprobe命令不在搜索路径中，就要用到了。有了这个选项， 在装载模块时，即使有一个需要用到的模块没装载上，iptables也知道要去搜索
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Matches</h2>
<div class="outline-text-2" id="text-4">
<p>
可以把匹配归为五类：
</p>
<ol class="org-ol">
<li><b>通用</b> 匹配 ：适用于所有的规则
</li>
<li><b>TCP</b> 匹配 : 只能用于TCP包
</li>
<li><b>UDP</b> 匹配 : 只能用在UDP包上了
</li>
<li><b>ICMP</b> 匹配：针对ICMP包的
</li>
<li><b>特殊</b> 匹配：针对
<ul class="org-ul">
<li>状态（ <span class="underline">state</span> ）
</li>
<li>所有者（ <span class="underline">owner</span> ）
</li>
<li>访问的频率限制（ <span class="underline">limit</span> ）等
</li>
</ul>
</li>
</ol>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">通用匹配</h3>
<div class="outline-text-3" id="text-4-1">
<p>
无论使用的是何种协议，也不管装入了匹配的何种扩展，通用匹配都使可用的。也就是说， 它们可以直接使用，而不需要什么前提条件
</p>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">protocol</h4>
<div class="outline-text-4" id="text-4-1-1">
<pre class="example">
-p, --protocol
</pre>

<p>
匹配 <b>指定的协议</b> 。指定协议的形式有以下几种：
</p>
<ol class="org-ol">
<li>名字，不分大小写，但必须是在 <span class="underline">/etc/protocols</span> 中定义的
</li>
<li>可以使用它们相应的整数值。例如
<ul class="org-ul">
<li><span class="underline">ICMP</span> : 1
</li>
<li><span class="underline">TCP</span> : 6
</li>
<li><span class="underline">UDP</span> : 17
</li>
</ul>
</li>
<li>缺省设置， <b>ALL</b> ，相应数值是 <span class="underline">0</span> ，但要注意这只代表匹配TCP、UDP、ICMP，而不是/etc/protocols中定义的所有协议
</li>
<li>可以是协议列表，以英文逗号为分隔符，如： <span class="underline">udp,tcp</span>
</li>
<li>可以在协议前加英文的感叹号表示取反，注意 <b>有空格</b> ，如: 
<ul class="org-ul">
<li><span class="underline">&#x2013;protocol ! tcp</span>  表示非tcp协议，也就是 <span class="underline">UDP和ICMP</span> 。可以看出这个取反的范围只是TCP、UDP和ICMP
</li>
</ul>
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">source</h4>
<div class="outline-text-4" id="text-4-1-2">
<pre class="example">
-s, --src, --source
</pre>

<p>
以 <b>IP源地址</b> 匹配包。地址的形式如下：
</p>
<ol class="org-ol">
<li>单个地址，如 
<ul class="org-ul">
<li><span class="underline">192.168.1.1</span>
</li>
<li><span class="underline">192.168.1.1/255.255.255.255</span>
</li>
<li><span class="underline">192.168.1.1/32</span>
</li>
</ul>
</li>
<li>网络，如
<ul class="org-ul">
<li><span class="underline">192.168.0.0/24</span>
</li>
<li><span class="underline">192.168.0.0/255.255.255.0</span> 
</li>
</ul>
</li>
<li>在地址前加 <span class="underline">感叹号</span> 表示取反，注意 <span class="underline">空格</span> 
<ul class="org-ul">
<li><span class="underline">&#x2013;source ! 192.168.0.0/24</span>  表示除此地址外的所有地址
</li>
</ul>
</li>
<li>缺省: <b>所有地址</b>
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -s 192.168.1.1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3">destination</h4>
<div class="outline-text-4" id="text-4-1-3">
<pre class="example">
-d, --dst, --destination
</pre>

<p>
以 <b>IP目的地址</b> 匹配包。地址的形式和 <span class="underline">&#x2013;source</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -d 192.168.1.1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4">in-interface</h4>
<div class="outline-text-4" id="text-4-1-4">
<pre class="example">
-i, --in-interface
</pre>

<p>
以 <b>包进入本地所使用的网络接口</b> 来匹配包。这个匹配操作只能用于 <span class="underline">INPUT</span> ， <span class="underline">FORWARD</span> 和 <span class="underline">PREROUTING</span> 这三个链，用在其他任何地方都会提示错误信息。指定接口有以下方法：
</p>
<ol class="org-ol">
<li>指定接口名称，如：
<ul class="org-ul">
<li>eth0
</li>
<li>ppp0等
</li>
</ul>
</li>
<li>使用 <b>通配符</b> ，即 <span class="underline">加号，它代表字符数字串</span> 
<ul class="org-ul">
<li><span class="underline">iptables -A INPUT -i +</span> : 匹配所有的包，而不考虑使用哪个接口。这也是不指定接口的默认行为
</li>
<li><span class="underline">eth+</span> : 所有Ethernet接口，也就是说，匹配所有从Ethernet接口进入的包
</li>
</ul>
</li>
<li>在接口前加 <span class="underline">感叹号</span> 表示取反，注意 _空格<sub>，</sub>
<ul class="org-ul">
<li><span class="underline">-i ! eth0</span> ：匹配来自除eth0外的所有包
</li>
</ul>
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -i eth0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5">out-interface</h4>
<div class="outline-text-4" id="text-4-1-5">
<pre class="example">
-o, --out-interface
</pre>

<p>
以 <b>包离开本地所使用的网络接口</b> 来匹配包。指定接口的方法与 <span class="underline">&#x2013;in-interface</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A FORWARD -o eth0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-6" class="outline-4">
<h4 id="sec-4-1-6">fragment</h4>
<div class="outline-text-4" id="text-4-1-6">
<pre class="example">
-f, --fragment
</pre>

<p>
用来匹配 <b>一个被分片的包的第二片或及以后的部分</b> 。因为它们不包含源或目的地址，或ICMP类型等信息，其他规则无法匹配到它，所以才有这个匹配操作：
</p>
<ul class="org-ul">
<li>防止碎片攻击
</li>
<li>可以加 <span class="underline">感叹号</span> 表示取反，但注意 <span class="underline">位置</span> 
<ul class="org-ul">
<li><span class="underline">! -f</span>  :  只能匹配到没有分片的包或者是被分片的包的第一个碎片，其后的片都不行
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -f
</pre>
</div>

<pre class="example">
  现在内核有完善的碎片重组功能，可以防止碎片攻击，所以不必使用取反的功能来防止碎片通过

  如果使用连接跟踪，是不会看到任何碎片的，因为在它们到达任何链之前就被处理过了
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">隐含匹配</h3>
<div class="outline-text-3" id="text-4-2">
<p>
这种匹配操作是 <b>自动地或隐含地</b> 装载入内核的。例如使用 <span class="underline">&#x2013;protocol tcp</span> 时，不需再装入任何东西就可以匹配只有IP包才有的一些特点。现在有三种隐含的匹配针对三种不同的协 议，即 
</p>
<ul class="org-ul">
<li>TCP
</li>
<li>UDP 
</li>
<li>ICMP 
</li>
</ul>

<p>
它们分别包括一套只适用于相应协议的判别标准
</p>
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">TCP</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
TCP matches只能匹配 <b>TCP包或流</b> 的细节，必须有 <span class="underline">&#x2013;protocol tcp</span> 作为前提条件
</p>
</div>

<div id="outline-container-sec-4-2-1-1" class="outline-5">
<h5 id="sec-4-2-1-1">source-port</h5>
<div class="outline-text-5" id="text-4-2-1-1">
<pre class="example">
--sport, --source-port
</pre>

<p>
基于TCP包的 <b>源端口</b> 来匹配包，端口的指定形式如下：
</p>
<ol class="org-ol">
<li>不指定此项: 默认 <b>所有端口</b> 
</li>
<li>使用 <b>服务名或端口号</b> ，但名字必须是在 <span class="underline">/etc/services</span>  中定义的，因为iptables从这个文件里查找相应的端口号。从这可以看出，使用端口号会使规则装入快一点 儿，当然，可读性就差些了
</li>
<li>使用 <b>连续的端口</b> ，
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port 22:80</span> : 从22到80的所有端 口，包括22和80。如果两个号的顺序反了也没关系， <span class="underline">&#x2013;source-port 80:22</span> 这和 <span class="underline">&#x2013;source-port 22:80</span> 的效果一样
</li>
</ul>
</li>
<li>省略第一个号， <span class="underline">默认第一个是0</span>  
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port :80</span> :  从0到80的 所有端口
</li>
</ul>
</li>
<li>省略第二个号， <span class="underline">默认是65535</span> 
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port 22:</span> :  从22到 65535的所有端口
</li>
</ul>
</li>
<li>在端口号前加 <span class="underline">感叹号</span> 表示取反，注意 <span class="underline">空格</span> 
<ul class="org-ul">
<li><span class="underline">&#x2013;source-port ! 22</span> : 除22号之外的所有端口
</li>
<li><span class="underline">&#x2013;source-port ! 22:80</span> :  从22到80（包括22和80）之外的所有端口
</li>
</ul>
</li>
</ol>


<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp --sport 22
</pre>
</div>
<p>
注意：这个匹配操作不能识别不连续的端口列表，如： <span class="underline">&#x2013;source-port ! 22, 36, 80</span> 这样的操作
</p>
</div>
</div>

<div id="outline-container-sec-4-2-1-2" class="outline-5">
<h5 id="sec-4-2-1-2">destination-port</h5>
<div class="outline-text-5" id="text-4-2-1-2">
<pre class="example">
--dport, --destination-port
</pre>

<p>
基于TCP包的 <b>目的端口</b> 来匹配包，端口的指定形式和 <span class="underline">&#x2013;sport</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp --dport 22
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-1-3" class="outline-5">
<h5 id="sec-4-2-1-3">tcp-flags</h5>
<div class="outline-text-5" id="text-4-2-1-3">
<pre class="example">
--tcp-flags
</pre>

<p>
匹配 <b>指定的TCP标记</b> 。有两个参数，它们都是列表，列表内部用 <span class="underline">逗号作分隔符，这两个列表之间用空格分开</span> 
</p>
<ul class="org-ul">
<li>第一个参数： 要 <span class="underline">检查的标记</span>  ，作用就象掩码。提供 <b>检查范围</b>  
</li>
<li>第二个参数： <span class="underline">在第一个列表中出现过的且必须被设为1 （即状态是打开的）标记（第一个列表中其他的标记必须置0）</span> 。提供被 <b>设置的条件</b> , 就是哪些位置为设置
</li>
</ul>

<p>
这个匹配操作可以识别以下标记：
</p>
<ul class="org-ul">
<li>SYN
</li>
<li>ACK
</li>
<li>FIN
</li>
<li>RST
</li>
<li>URG
</li>
<li>PSH
</li>
<li>ALL : 选定所有的标记
</li>
<li>NONE : 未选定任何标记
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --tcp-flags SYN,FIN,ACK SYN
</pre>
</div>
<p>
匹配那些 <b>SYN标记被设置而FIN和ACK标记没有设置</b> 的包
</p>

<p>
注意： 标记之间只有一个逗号而没有空格
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables --tcp-flags ALL NONE
</pre>
</div>

<p>
匹配所有标记都未置1的包
</p>

<p>
也可在参数前加 <span class="underline">感叹号</span> 表示取反。例如： 
</p>
<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --tcp-flags ! SYN,FIN,ACK SYN
</pre>
</div>
<p>
匹配那些 <b>FIN和ACK标记被设置而SYN标记没有设置</b> 的包
</p>
</div>
</div>

<div id="outline-container-sec-4-2-1-4" class="outline-5">
<h5 id="sec-4-2-1-4">syn</h5>
<div class="outline-text-5" id="text-4-2-1-4">
<pre class="example">
--syn

这个匹配或多或少算是ipchains时代的遗留物，之所以还保留它，是为了向后兼容，也是为了方便规则在iptables和ipchains间的转换
</pre>

<p>
<b>匹配那些SYN标记被设置而ACK和RST标记没有设置的包</b> ，这和 <span class="underline">iptables -p tcp &#x2013;tcp-flags SYN,RST,ACK SYN</span> 的作用毫无二样。主要用在 <b>TCP连接初始化时发出请求</b> 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --syn
</pre>
</div>

<pre class="example">
     如果你阻止了这样的包，也就阻止了所有由外向内的连接企图，这在一定程度上防止了一些攻击
     
     但外出的连接不受影响，恰恰现在有很多攻击就利用这一点
     
     比如有些攻击黑掉服务器之后安装会一些软件，它们能够利用已存的连接到达你的机子，而不要再新开一个端口
</pre>

<p>
这个匹配也可用 <span class="underline">感叹号</span> 取反： 
</p>
<ul class="org-ul">
<li><span class="underline">! &#x2013;syn</span> : 那些RST或ACK被置位的包，就是 <b>状态为已建立的连接</b> 的包
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2-1-5" class="outline-5">
<h5 id="sec-4-2-1-5">tcp-option</h5>
<div class="outline-text-5" id="text-4-2-1-5">
<pre class="example">
--tcp-option
</pre>

<p>
<b>TCP选项</b> 是TCP头中的特殊部分，有三个不同的 部分
</p>
<ul class="org-ul">
<li>第一个8位组： <b>选项的类型</b>
</li>
<li>第二个8位组： <b>选项的长度</b> （这个长度是整个选项的长度，但不包含填充部分所占的字节，而且要注意不是每个TCP选项都有这一部分的）
</li>
<li>第三部分： <b>选项的内容</b> 
</li>
</ul>

<p>
为了适应标准，不必执行所有的选项，但可以查看选项的类型，如果不是所支持的，那就只是看看长度然后跳过数据部分。这个操作是根据 <span class="underline">选项的十进制值</span> 来匹配的，它也可以用 <span class="underline">感叹号</span> 取反
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -p tcp --tcp-option 16
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">UDP</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
UDP matches是在指定 <span class="underline">&#x2013;protocol UDP</span> 时自动装入的。UDP是一种 <b>无连接协议</b> ，所以在它打开、关闭连接以及在发送数据时没有多少标记要设置，它也不需要任何类型的确认。数据丢失了， 就丢失了（不会发送ICMP错误信息的）。这就说明UDP matches要比TCP matches少多了。 <span class="underline">即使UDP和ICMP是无连接协议，状态机制也可以很好的工作</span> ，就象在TCP上一样
</p>
</div>

<div id="outline-container-sec-4-2-2-1" class="outline-5">
<h5 id="sec-4-2-2-1">source-port</h5>
<div class="outline-text-5" id="text-4-2-2-1">
<pre class="example">
--sport, --source-port
</pre>

<p>
基于 <b>UDP包的源端口</b> 来匹配包，端口的指定形式和TCP matches中的 <span class="underline">&#x2013;sport</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p udp --sport 53
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2-2" class="outline-5">
<h5 id="sec-4-2-2-2">destination-port</h5>
<div class="outline-text-5" id="text-4-2-2-2">
<pre class="example">
--dport, --destination-port
</pre>

<p>
基于 <b>UDP包的目的端口</b> 来匹配包，端口的指定形式和TCP matches中的 <span class="underline">&#x2013;sport</span> 完全一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p udp --dport 53
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3">ICMP</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
ICMP协议也是无连接协议，ICMP包更是短命鬼，比UDP的还短。ICMP协议不是IP协议的下属协议，而是它的辅助者，其主要作用是 <b>报告错误和连接控制</b> 。ICMP包的头和IP的很相似，但又有很多不同。这个协议最主要的特点是它有很多类型，以应对不同的情况。比如，想访问一个无法访问的地址，就会收到一个ICMP host unreachable信息，它的意思是主机无法到达。虽然有这么多类型，但只有一个 ICMP matche，这就足够对付它们了。这个matche是在指定 <span class="underline">&#x2013;protocol ICMP</span> 时自动 装入的。注意所有的通用匹配都可以使用，这样就可以匹配 <b>ICMP包的源、目地址</b>
</p>
</div>

<div id="outline-container-sec-4-2-3-1" class="outline-5">
<h5 id="sec-4-2-3-1">icmp-type</h5>
<div class="outline-text-5" id="text-4-2-3-1">
<pre class="example">
--icmp-type
</pre>

<p>
根据 <b>ICMP类型</b> 匹配包，类型的指定可以使用 <span class="underline">十进制数值</span> 或 <span class="underline">相应的名字</span> ：
</p>
<ul class="org-ul">
<li>数值：在 <span class="underline">RFC792</span> 中有定义
</li>
<li>名字：用 <span class="underline">iptables &#x2013;protocol icmp &#x2013;help</span> 查看
</li>
</ul>

<p>
这个匹配也可用 <span class="underline">感叹号</span> 取反
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;icmp-type ! 8</span> : 匹配除类型8之外的所有ICMP包
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p icmp --icmp-type 8
</pre>
</div>

<pre class="example">
  有些ICMP类型已经废弃不用了

  还有一些可能会对无防护的主机带来危险，因为它们可能把包重定向到错误的地方
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">显示匹配</h3>
<div class="outline-text-3" id="text-4-3">
<p>
显式匹配必须用 <span class="underline">-m</span> 或 <span class="underline">&#x2013;match</span> 装载，比如要使用状态匹配就必须使用 <span class="underline">-m state</span> 
</p>

<p>
有些匹配还需要指定协议，有些就不需要，比如连接状态就不要。这些状态是
</p>
<ul class="org-ul">
<li>NEW : 还未建立好的连接的第一个包
</li>
<li>ESTABLISHED: 已建立的连接，也就是已经在内核里注册过的
</li>
<li>RELATED: 已经存在的、处于已建立状态的连接生成的新连接
</li>
</ul>

<p>
隐含匹配和显式匹配最大的区别就是 <b>一个是跟随协议匹配自动装载的，一个是显式装载的</b> 
</p>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Limit</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
这个匹配操作必须由 <span class="underline">-m limit</span> 明确指定才能使用：
</p>
<ul class="org-ul">
<li>对指定的规则的日志数量加以限制，以免你被信息的洪流淹没哦。比如，你可以事先设定一个限定值，当符合条件的包的数量不超过它时，就记录；超过了，就不记录了
</li>
<li>可以控制某条规则在一段时间内的匹配次数 （也就是可以匹配的包的数量），这样就能够减少 <span class="underline">DoS syn flood</span> 攻击的影响
</li>
</ul>

<p>
imit match也可以用 <span class="underline">感叹号</span> 取反：
<span class="underline">-m limit ! &#x2013;limit 5/s</span> ： 表示在数量超过限定值后，所有的包都会被匹配
</p>

<pre class="example">
limit match的工作方式就像一个单位大门口的保安，当有人要进入时，需要找他办理通行证

早上上班时，保安手里有一定数量的通行证，来一个人，就签发一个，当通行证用完后，再来人就进不去了，但他们不会等，而是到别的地方去

在iptables里，这相当于一个包不符合某条规则，就会由后面的规则来处理，如果都不符合，就由缺省的策略处理

但有个规定，每隔一段时间保安就要签发一个新的通行证。这样，后面来的人如果恰巧赶上，也就可以进去了

如果没有人来，那通行证就保留下来，以备来的人用

如果一直没人来，可用的通行证的数量就增加了，但不是无限增大的，最多也就是刚开始时保安手里有的那个数量

也就是说，刚开始时，通行证的数量是有限的，但每隔一段时间就有新的通行证可用
</pre>

<p>
limit match有两个参数就对应这种情况：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;limit-burst</span> ：刚开始时有多少通行证可用
</li>
<li><span class="underline">&#x2013;limit</span> ：要隔多长时间才能签发一个新的通行证
</li>
</ul>

<p>
这里强调的是 <span class="underline">签发一个新的通行证</span> ，这是 <b>以iptables的角度</b> 考虑的。在自己写规则时，就要从这个角度考虑。比如，指定了 <span class="underline">&#x2013;limit 3/minute &#x2013;limit-burst 5</span>  : 
</p>
<ul class="org-ul">
<li>iptables的角度：开始时有5个通行证，用完之后每20秒增加一个
</li>
<li>以用户的角度看：说法就是每一分钟增加三个或者每分钟只能过三个
</li>
</ul>

<p>
要是想每20分钟过一个，只能写成 <span class="underline">&#x2013;limit 3/hour &#x2013;limit-burst 5</span> ，也就是说 <b>要把时间单位凑成整</b>
</p>
</div>
<div id="outline-container-sec-4-3-1-1" class="outline-5">
<h5 id="sec-4-3-1-1">limit</h5>
<div class="outline-text-5" id="text-4-3-1-1">
<pre class="example">
--limit
</pre>

<p>
<b>为limit match设置最大平均匹配速率</b> ，也就是单位时间内limit match可以匹配几个包。它的形式是 <b>一个数值加一个时间单位</b> : 
</p>
<ul class="org-ul">
<li>/second
</li>
<li>/minute
</li>
<li>/hour
</li>
<li>/day 
</li>
</ul>

<p>
默认值是 <b>每小时3次</b> （用户角度），即 <span class="underline">3/hour</span> ，也就是 <b>每20分钟一次</b> （iptables角度）
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m limit --limit 3/hour
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-1-2" class="outline-5">
<h5 id="sec-4-3-1-2">limit-burst</h5>
<div class="outline-text-5" id="text-4-3-1-2">
<pre class="example">
--limit-burst
</pre>

<p>
定义的是 <b>limit match的峰值</b> ， 就是在单位时间（这个时间由上面的&#x2013;limit指定）内最多可匹配几个包（&#x2013;limit-burst的值要比&#x2013;limit的大）。默认值是5 
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m limit --limit-burst 5
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">MAC</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
基于 <b>包的MAC源地址</b> 匹配包
</p>

<pre class="example">
    这个match是由-m mac装入的，而不是一些人想当然的-m mac-source，后者只是前者的选项而已
</pre>
</div>

<div id="outline-container-sec-4-3-2-1" class="outline-5">
<h5 id="sec-4-3-2-1">mac-source</h5>
<div class="outline-text-5" id="text-4-3-2-1">
<pre class="example">
--mac-source
</pre>

<p>
基于包的MAC源地址匹配包，地址格式只能是 <span class="underline">XX:XX:XX:XX:XX:XX</span> ，当然也可以用 <span class="underline">感叹号</span> 取反
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;mac- source ! 00:00:00:00:00:01</span> : 除此之外的地址都可接受嘛
</li>
<li>MAC addresses只用于 <span class="underline">Ethernet</span> 类型的网络，所以这个match只能用于Ethernet接口。而且，它还只能在
<ul class="org-ul">
<li><span class="underline">PREROUTING</span>
</li>
<li><span class="underline">FORWARD</span>
</li>
<li><span class="underline">INPUT</span> 链里使用
</li>
</ul>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m mac --mac-source 00:00:00:00:00:01
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3">Mark</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
以 <b>包被设置的mark</b> 来匹配包，这个值只能由内核更改
</p>

<pre class="example">
mark比较特殊，它不是包本身的一部分，而是在包穿越计算机的过程中由内核分配的和它相关联的一个字段

它可能被用来改变包的传输路径或过滤

时至今日，在linux里只有一种方法能设置mark，即iptables的MARK target

以前在ipchains里是FWMARK target。这就是为什么在高级路由里仍要参照FWMARK的原因
</pre>

<p>
mark字段的值是一个 <b>无符号的整数</b> ， 在32位系统上最大可以是 <span class="underline">4294967296</span> ，就是2的32次方
</p>
</div>

<div id="outline-container-sec-4-3-3-1" class="outline-5">
<h5 id="sec-4-3-3-1">mark</h5>
<div class="outline-text-5" id="text-4-3-3-1">
<pre class="example">
--mark value[/mask]
</pre>


<div class="org-src-container">

<pre class="src src-sh">iptables -t mangle -A INPUT -m mark --mark 1
</pre>
</div>

<p>
以包被设置的mark值来匹配包，这个值是通过 <span class="underline">MARK target</span> 来设置的，它是一个无符号的整数。上面的例子是没有掩码的，如果指定了掩码：
</p>
<ul class="org-ul">
<li><span class="underline">&#x2013;mark 1/1</span> ：先把 <span class="underline">mark值和掩码取逻辑与</span> ，然后再和包的mark值比较
</li>
</ul>

<pre class="example">
  所有通过Netfilter的包都会被分配一个相关联的mark field

  但是mark值可不是在任何情况下都能使用的，它只能在分配给它值的那台机子里使用

  因为它只是由内核在内存里分配的和包相关的几个字节，并不属于包本身，所以不能在本机之外的路由器上使用
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4" class="outline-4">
<h4 id="sec-4-3-4">Multiport</h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
<b>多端口匹配</b> 扩展能够在一条规则里指定不连续的多个端口，如果没有这个扩展，只能按端口来写规则了
</p>

<pre class="example">
    不能在一条规则里同时使用标准端口匹配和多端口匹配，如--sport 1024:63353 -m multiport --dport 21,23,80
    
    这条规则并不能想你想象的那样工作，但也不是不能工作，iptables会使用第一个合法的条件，那么这里多端口匹配就白写了
</pre>
</div>

<div id="outline-container-sec-4-3-4-1" class="outline-5">
<h5 id="sec-4-3-4-1">source-port</h5>
<div class="outline-text-5" id="text-4-3-4-1">
<pre class="example">
--source-port
</pre>

<p>
<b>源端口多端口</b> 匹配：
</p>
<ul class="org-ul">
<li>最多可以指定 <span class="underline">15</span> 个端口
</li>
<li>以 <span class="underline">逗号</span> 分隔
</li>
<li><span class="underline">没有空格</span>
</li>
<li>必须有 <b>-p tcp</b> 或 <b>-p udp</b> 为前提条件
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m multiport --source-port 22,53,80,110
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4-2" class="outline-5">
<h5 id="sec-4-3-4-2">destination-port</h5>
<div class="outline-text-5" id="text-4-3-4-2">
<pre class="example">
--destination-port
</pre>

<p>
<b>目的端口多端口</b> 匹配，使用方法和 <span class="underline">源端口多端口</span> 匹配一样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m multiport --destination-port 22,53,80,110
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-4-3" class="outline-5">
<h5 id="sec-4-3-4-3">port</h5>
<div class="outline-text-5" id="text-4-3-4-3">
<pre class="example">
--port
</pre>
<p>
<b>同端口多端口</b> 匹配，意思就是它匹配的是那种 <b>源端口和目的端口是同一个端口</b> 的包，比如： <span class="underline">端口80到端口80</span> 的包。使用方法和 <span class="underline">源端口多端口</span> 匹配一 样
</p>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m multiport --port 22,53,80,110
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-5" class="outline-4">
<h4 id="sec-4-3-5">Owner</h4>
<div class="outline-text-4" id="text-4-3-5">
<p>
基于 <b>包的生成者</b> （ <span class="underline">owner</span> ）的ID来匹配包，owner可以是：
</p>
<ul class="org-ul">
<li><span class="underline">启动进程的用户的ID</span>
</li>
<li><span class="underline">用户所在的组的ID</span>
</li>
<li><span class="underline">进程的ID</span>
</li>
<li><span class="underline">会话的ID</span> 
</li>
</ul>

<pre class="example">
  只能用在OUTPUT中

  原因显而易见：几乎不可能得到发送端例程的ID的任何信息，或者在去往真正目的地的路上哪儿有路由

  甚至在 OUTPUT链里，这也不是十分可靠，因为有些包根本没有owner，比如 ICMP responses，所以它们从不会被这个match抓到
</pre>
</div>

<div id="outline-container-sec-4-3-5-1" class="outline-5">
<h5 id="sec-4-3-5-1">uid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-1">
<pre class="example">
--uid-owner
</pre>

<p>
按 <b>生成包的用户的ID</b> 来匹配外出的包。使用这个匹配可以做这样一些事：
</p>
<ul class="org-ul">
<li>阻止除root外的用户向防火墙外建立新连接
</li>
<li>阻止除用户http外的任何人使用HTTP端口发送数据
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --uid-owner 500
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-5-2" class="outline-5">
<h5 id="sec-4-3-5-2">gid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-2">
<pre class="example">
--gid-owner
</pre>

<p>
按 <b>生成包的用户所在组的ID</b> 来匹配外出的包：
</p>
<ul class="org-ul">
<li>可以只让属于network组的用户上Internet，而其他用户都不 行
</li>
<li>只允许http组的成员能从HTTP端口发送数据
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --gid-owner 0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-5-3" class="outline-5">
<h5 id="sec-4-3-5-3">pid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-3">
<pre class="example">
--pid-owner
</pre>

<p>
按 <b>生成包的进程的ID</b> 来匹配外出的包：
</p>
<ul class="org-ul">
<li>可以只允许PID为94的进程（http进程当然不能是多线程的）使用http端口
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --pid-owner 78
</pre>
</div>
<p>
这个匹配使用起来有一点难度，因为要知道进程的ID号。当然，也可以写一个小小的脚本，先从ps的输出中得到PID，再添加相应的规则
</p>
</div>
</div>

<div id="outline-container-sec-4-3-5-4" class="outline-5">
<h5 id="sec-4-3-5-4">sid-owner</h5>
<div class="outline-text-5" id="text-4-3-5-4">
<pre class="example">
--sid-owner
</pre>

<p>
按 <b>生成包的会话的ID</b> 来匹配外出的包。 <span class="underline">一个进程以及它的子进程或它的多个线程都有同一个SID</span> ：
</p>
<ul class="org-ul">
<li>所有的HTTPD进程的SID和它的父进程一样（最初的 httpd进程），即使httpd是多线程的也一样
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m owner --sid-owner 100
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-6" class="outline-4">
<h4 id="sec-4-3-6">State</h4>
<div class="outline-text-4" id="text-4-3-6">
<p>
状态匹配扩展要有 <b>内核里的连接跟踪代码的协助</b> ，因为它是从连接跟踪机制中得到包的状态的。这样就可以了解连接所处的状态。它几乎适用于所有的协议，包括那些无状态的协议，如ICMP和UDP。针对每个连接都有一个 <span class="underline">缺省的超时值</span> ，如果连接的时间超过了这个值，那么这个连接的记录就被会从连接跟踪的记录数据库中删除，也就是说连接就不再存在了。这个match必须有 <b>-m state</b> 作为前提才能使用
</p>
</div>

<div id="outline-container-sec-4-3-6-1" class="outline-5">
<h5 id="sec-4-3-6-1">state</h5>
<div class="outline-text-5" id="text-4-3-6-1">
<pre class="example">
--state
</pre>

<p>
指定要匹配 <b>包的状态</b> ，当前有4种状态可用：
</p>
<ul class="org-ul">
<li>INVALID
</li>
<li>ESTABLISHED
</li>
<li>NEW
</li>
<li>RELATED
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -m state --state RELATED,ESTABLISHED
</pre>
</div>

<p>
注意： NEW状态并不在试图建立新连接的TCP包里寻找SYN标 记，因此它不应该不加修改地用在只有一个防火墙或在不同的防火墙之间没有启用负载平衡的地方
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-3-7" class="outline-4">
<h4 id="sec-4-3-7">TOS</h4>
<div class="outline-text-4" id="text-4-3-7">
<p>
根据TOS字段匹配包，必须使用 <b>-m tos</b> 才能装 入。TOS是IP头的一部分，其含义是Type Of Service，由8个二进制位组成：
</p>
<ul class="org-ul">
<li>3 bit： <b>优先权</b> 子字段，现在已被忽略
</li>
<li>4 bit： <b>TOS子字段</b> 
</li>
<li>1 bit： 未用位，必须置 <span class="underline">0</span> 
</li>
</ul>

<pre class="example">
  一般用来把当前流的优先权和需要的服务（比如，最小延时、最大吞吐量 等）通知路由器

  但路由器和管理员对这个值的处理相差很大，有的根本就不理会，而有的就会尽量满足要求
</pre>
</div>
<div id="outline-container-sec-4-3-7-1" class="outline-5">
<h5 id="sec-4-3-7-1">tos</h5>
<div class="outline-text-5" id="text-4-3-7-1">
<pre class="example">
--tos
</pre>

<p>
根据 <b>TOS字段</b> 匹配包。它的参数可以是：
</p>
<ul class="org-ul">
<li><span class="underline">16进制数</span>
</li>
<li><span class="underline">十进制数</span>
</li>
<li><span class="underline">相应的名字</span> : 用 <b>iptables -m tos -h</b> 能查到
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A INPUT -p tcp -m tos --tos 0x16
</pre>
</div>

<p>
这个match常被 <b>用来mark</b> 包，以便后用，还常和iproute2或高级路由功能一起使用：
</p>
<ul class="org-ul">
<li><span class="underline">Minimize-Delay 16 (0x10)</span>  : 要求找一条路径使延时最小，一些标准服务如telnet、SSH、FTP-control 就需要这个选项
</li>
<li><span class="underline">Maximize-Throughput 8 (0x08)</span> : 要求找一条路径能使吞吐量最大，标准服务FTP-data能用到这个
</li>
<li><span class="underline">Maximize-Reliability 4 (0x04)</span> : 要求找一条路径能使可靠性最高，使用它的有BOOTP和TFTP
</li>
<li><span class="underline">Minimize-Cost 2 (0x02)</span> : 要求找一条路径能使费用最低，一般情况下使用这个选项的是一些视频音频流协议，如RTSP
</li>
<li><span class="underline">Normal-Service 0 (0x00)</span> : 一般服务，没有什么特殊要求
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4-3-8" class="outline-4">
<h4 id="sec-4-3-8">TTL</h4>
<div class="outline-text-4" id="text-4-3-8">
<p>
根据 <b>IP头里的TTL ( <span class="underline">Time To Live</span> )字段</b> 来匹配包，此必须由 <b>-m ttl</b> 装入
</p>
<pre class="example">
TTL field是一个字节（8个二进制位），一旦经过一个处理它的路由器，它的值就减去1它的值

当该字段的值减为0时，报文就被认为是不可转发的，数据报就被丢弃，并发送ICMP报文通知源主机，不可转发的报文被丢弃

这也有两种情况，一是传输期间生存时间为0，使用类型为11代码是0的ICMP报文
                         二是在数据报重组期间生存时间为0，使用类型 为11代码是1的ICMP报文
</pre>
<p>
这个match只是根据TTL匹配包，而对其不做任何更改，所以在它之后可使用任何类型的match
</p>
</div>

<div id="outline-container-sec-4-3-8-1" class="outline-5">
<h5 id="sec-4-3-8-1">ttl</h5>
<div class="outline-text-5" id="text-4-3-8-1">
<pre class="example">
--ttl
</pre>

<p>
根据TTL的值来匹配包，参数的形式只有一种，就是 <span class="underline">十进制</span> 数值：
</p>
<ul class="org-ul">
<li>它可以被用来调试你的局域网，比如解决LAN内的主机到Internet上的主机的连接问题
</li>
<li>找出 <b>Trojan</b> 可能的入口
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">iptables -A OUTPUT -m ttl --ttl 60
</pre>
</div>

<p>
这个match的用处相对有限，但它其实是很有用的，这就看你的想象力如何了：
</p>
<ul class="org-ul">
<li>可以用它来发现那些TTL具有错误缺省值的机子：这可能是实现TCP/IP栈功能的那个程序本身的错误，或者是配置有问题
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">非正常包的匹配</h3>
<div class="outline-text-3" id="text-4-4">
<p>
这个匹配没有任何参数，也不需要显式地装载：
</p>
<ul class="org-ul">
<li>一个实验性的匹配，它不总是能正常工作的，对有些不正常的包（unclean package，就是所谓的脏包）或问题，它是视而不见的
</li>
<li>试图匹配那些好象畸形或不正常的包，比如包头错或校验和错，等等
</li>
</ul>

<p>
它可能常用来：
</p>
<ul class="org-ul">
<li>DROP错误的连接
</li>
<li>检查有错的流
</li>
</ul>

<p>
但要知道这样做也可能会中断合法的连接
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Target/Jump</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
