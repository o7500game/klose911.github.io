<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>zuul网关客户化</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">zuul网关客户化</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org914b23f">服务注册和发现</a>
<ul>
<li><a href="#org281432f">配置文件</a></li>
<li><a href="#org5896b34">自动注册</a></li>
<li><a href="#org5ba9610">swagger文件导入</a></li>
</ul>
</li>
<li><a href="#orgd216a98">自定义ZuulFilter</a>
<ul>
<li><a href="#org31e2b81">pre</a>
<ul>
<li><a href="#orgb5f9705">CorsPreFlightFilter</a></li>
<li><a href="#orgb49a96d">AuthCheckFilter</a></li>
<li><a href="#orgf62d50f">LogMDCFilter</a></li>
<li><a href="#orgd3d5bb6">RedisRateLimitFilter</a></li>
<li><a href="#org2f4e4ac">RequestCacheFilter</a></li>
<li><a href="#org58e865a">APIPermissionCheckFilter</a></li>
<li><a href="#org2f88298">TenantCheckFilter</a></li>
<li><a href="#org6fb6f00">RequestHeaderFilter</a></li>
<li><a href="#org515db19">APIFactoryRequestFilter</a></li>
</ul>
</li>
<li><a href="#orga58d3b8">post</a>
<ul>
<li><a href="#org81148b0">CorsReponseFilte</a></li>
<li><a href="#org567c207">APIFactoryResponseFilter</a></li>
<li><a href="#org7e5dda0">ResponseHeaderFilter</a></li>
</ul>
</li>
<li><a href="#org4b3af41">error  类型</a>
<ul>
<li><a href="#org25dcbf9">CustomErrorFilter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org95e593a">配置信息</a>
<ul>
<li><a href="#org37546b6">限流和熔断</a></li>
<li><a href="#orga1303aa">超时</a></li>
<li><a href="#orga1252f6">重试</a></li>
<li><a href="#orge112d04">httptrace</a></li>
<li><a href="#org4d8a6cd">misc</a></li>
</ul>
</li>
<li><a href="#org1b7d7a9">常见报错</a></li>
<li><a href="#org5724858">问题和改进</a></li>
</ul>
</div>
</div>

<div id="outline-container-org914b23f" class="outline-2">
<h2 id="org914b23f">服务注册和发现</h2>
<div class="outline-text-2" id="text-org914b23f">
</div>
<div id="outline-container-org281432f" class="outline-3">
<h3 id="org281432f">配置文件</h3>
<div class="outline-text-3" id="text-org281432f">
<p>
zuul本身是通过配置文件来初始化zuul的路由映射：
</p>
<div class="org-src-container">
<pre class="src src-sh">zuul.routes.kibana.path=/logcenter/**
zuul.routes.kibana.url=http://172.25.17.74:5621/
</pre>
</div>
<pre class="example">
  假如http://172.25.17.74:7070 是网关地址

  那么访问http://172.25.17.74:7070/logcenter/ 会路由到http://172.25.17.74:5621/
</pre>
</div>
</div>

<div id="outline-container-org5896b34" class="outline-3">
<h3 id="org5896b34">自动注册</h3>
<div class="outline-text-3" id="text-org5896b34">
<ol class="org-ol">
<li>Java的微服务依赖的 ebao-spring-boot-starter-discoveryendpoint 这个starter插件，微服务启动后，往redis发布一条消息</li>
<li>redis收到消息后，会广播给所有也依赖这个插件的服务</li>
<li>zuul网关收到redis的广播，更新zuul的路由映射</li>
</ol>

<pre class="example">
  未来会不用这种服务注册方式，k8s提供了对每个service的dns支持

  每个service的路由信息，可以通过配置写在application.properties文件中
</pre>
</div>
</div>

<div id="outline-container-org5ba9610" class="outline-3">
<h3 id="org5ba9610">swagger文件导入</h3>
<div class="outline-text-3" id="text-org5ba9610">
<ol class="org-ol">
<li>通过swagger文件把服务导入到admin-service的数据库内：这个功能不在网关服务内</li>
<li>网关定时调用admin-service的rest接口，把数据库的API信息更新到zuul网关
<ul class="org-ul">
<li>admin-service提供的rest接口： /rest/v1/vendor/service/list/all</li>
<li>网关同步API信息：com.ebao.cloud.gateway.route.RefreshVendorRunner#refresh 
<ul class="org-ul">
<li>com.ebao.cloud.gateway.integration.VenderPath中比较重要的字段：
<ul class="org-ul">
<li>frompath:  API注册到网关后，别人调用网关的路径</li>
<li>toPath: API在后台服务器上真实的路径</li>
<li>vendorCode：把API注册到网关的租户</li>
<li>version：API的版本号</li>
<li>enableAuth：是否需要网关做安全认证</li>
<li>enableCors：是否需要网关支持跨域访问</li>
<li>routeNodes：后台服务器的地址</li>
<li>attributes: 支持可扩展字段的Map</li>
</ul></li>
</ul></li>
<li>API信息转换成Zuul路由信息： 把VendorPath 转换成 VenderRoute
<ul class="org-ul">
<li>VendorRoute继承于org.springframework.cloud.netflix.zuul.filters.Route， 这是Zuul网关中的一个路由对象</li>
<li>需要注意的是 Route对象的location字段
<ul class="org-ul">
<li>如果值是一个域名，请求会被通过SimpleHostRoutingFilter基于dns做路由</li>
<li>反之则会调用RibbonRoutingFilter基于客户端的负载均衡器做路由</li>
</ul></li>
</ul></li>
<li>把VendorRoute放入到com.ebao.cloud.gateway.route.TenantRouteLocator#cachedVenderRoutes这个Map</li>
</ul></li>
<li>当请求到来时，路径信息和http方法匹配后，把请求路由到后台服务器
<ul class="org-ul">
<li>某个服务暴露在网关的url是： $ {gw-url}/$ {vendorCode}/$ {version}/$ {fromPath} 
<ul class="org-ul">
<li>$ {gw-url} 是网关的域名：比如 <a href="https://dev-gw.ebaocloud.com">https://dev-gw.ebaocloud.com</a> ， 也可以是 <a href="https://dev.ebaocloud.com/api">https://dev.ebaocloud.com/api</a></li>
</ul></li>
<li>路由匹配的入口： com.ebao.cloud.gateway.route.TenantRouteLocator#getMatchingRoute 
<ul class="org-ul">
<li>路由匹配支持通配符和path变量：匹配器使用的是spring提供的AntPathMatcher
<ul class="org-ul">
<li>注意：通配符path变量匹配成功后，因为数据库保存的是类似于/aaa/${id} 这种形式，实际路由请求的后台路径需要做变量替换</li>
<li>可以从VenderRouteUtilsTest这个ut类开始阅读</li>
<li>这里算法实现应该有很大的优化空间</li>
</ul></li>
</ul></li>
<li>后台服务器地址保存在admin-service的t_maf_vendor_service.route_nodes字段</li>
</ul></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgd216a98" class="outline-2">
<h2 id="orgd216a98">自定义ZuulFilter</h2>
<div class="outline-text-2" id="text-orgd216a98">
<p>
外部http请求到达api网关服务的时候：
</p>
<ul class="org-ul">
<li>首先它会进入第一个阶段pre，在这里它会被pre类型的过滤器进行处理
<ul class="org-ul">
<li>该类型过滤器的主要目的是在进行请求路由之前做一些前置加工，比如请求的校验等</li>
</ul></li>
<li>在完成了pre类型的过滤器处理之后，请求进入第二个阶段routing，也就是之前说的路由请求转发阶段，请求将会被routing类型的处理器处理。这里的具体处理内容就是将外部请求转发到具体服务实例上去的过程</li>
<li>当服务实例请求结果都返回之后，routing阶段完成，请求进入第三个阶段post
<ul class="org-ul">
<li>在post类型的过滤器中，可以对处理结果进行一些加工或转换等内容</li>
</ul></li>
<li>还有一个特殊的阶段error，该阶段只有在上述三个阶段中发生异常的时候才会触发
<ul class="org-ul">
<li>但是它的最后流向还是post类型的过滤器，因为它需要通过post过滤器将最终结果返回给请求客户端</li>
</ul></li>
</ul>

<pre class="example">
  对于error过滤器的处理，在spring cloud zuul的过滤链中实际上有一些不同
</pre>

<p>
每个Filter实际上都要定义一个优先级的数值，值越低表示优先级越高
</p>
</div>

<div id="outline-container-org31e2b81" class="outline-3">
<h3 id="org31e2b81">pre</h3>
<div class="outline-text-3" id="text-org31e2b81">
</div>
<div id="outline-container-orgb5f9705" class="outline-4">
<h4 id="orgb5f9705">CorsPreFlightFilter</h4>
<div class="outline-text-4" id="text-orgb5f9705">
<p>
处理跨域访问Options请求：
</p>
<ul class="org-ul">
<li>优先级：10</li>
<li>生效条件： 同时满足下面几个 
<ol class="org-ol">
<li>注册上来的服务根据enableCors标志位判断，其他API默认都生效</li>
<li>请求的origin头不为空</li>
<li>请求是Options方法</li>
<li>请求的"Access-Control-Request-Method不为空</li>
</ol></li>
<li>处理逻辑：响应中添加 Access-Control-Allow-Origin， Access-Control-Allow-Methods， Access-Control-Allow-Headers头</li>
</ul>
</div>
</div>

<div id="outline-container-orgb49a96d" class="outline-4">
<h4 id="orgb49a96d">AuthCheckFilter</h4>
<div class="outline-text-4" id="text-orgb49a96d">
<p>
做安全认证
</p>

<ul class="org-ul">
<li>优先级：20</li>
<li>不生效条件：满足下面任一一个
<ul class="org-ul">
<li>某些http方法不需要校验，比如Options</li>
<li>ebao.gateway.security.ignore.urls 配置变量中包含的路径不需要校验</li>
<li>admin-service中注册的API，如果enableAuth为false不需要检验</li>
</ul></li>
<li>处理逻辑：
<ul class="org-ul">
<li>如果是token的安全认证（basic，jwt，oauth2），先从redis中取缓存</li>
<li>缓存无法取到或者不是基于token的安全认证，则调用auth服务的rest接口，并把认证结果放入到redis做缓存</li>
<li>如果认证成功，获得用户名，把用户名，租户代码，以及用户对象缓存到Zuul的RequestContext中（RequestContext相当于请求级别的缓存区）</li>
<li>如果认证失败，响应返回码401，内容："auth check failed"</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf62d50f" class="outline-4">
<h4 id="orgf62d50f">LogMDCFilter</h4>
<div class="outline-text-4" id="text-orgf62d50f">
<p>
把缓存在RequestContext中的租户代码等信息放入logback的MDC中，这样日志中就能体现这些信息
</p>

<ul class="org-ul">
<li>优先级：25</li>
</ul>
</div>
</div>

<div id="outline-container-orgd3d5bb6" class="outline-4">
<h4 id="orgd3d5bb6">RedisRateLimitFilter</h4>
<div class="outline-text-4" id="text-orgd3d5bb6">
<p>
检查用户和租户调用API的速率是否超过预设的阀值 
</p>
<ul class="org-ul">
<li>优先级：27</li>
<li>生效条件：配置参数ebao.gateway.limit.api-rate-limit-enable是否为真</li>
<li>业务逻辑：把相关租户，用户的调用统计放到redis中，过期时间是一个窗口
<ul class="org-ul">
<li>租户和用户的页面上有相关配置信息，具体可以看网关的使用手册</li>
<li>如果校验结果超出预设的阀值：中断请求，返回状态码429</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org2f4e4ac" class="outline-4">
<h4 id="org2f4e4ac">RequestCacheFilter</h4>
<div class="outline-text-4" id="text-org2f4e4ac">
<p>
把用户，租户等信息放入到ThreadLocal中
</p>

<pre class="example">
  接下来如果网关要调用其他微服务的时候，netflixext这个starter能够从ThreadLocal获取到这些信息，并放入到http请求的相关头部中

  这样一来整个链路的应用都能获取到租户，用户等信息

  其实前面已经把这部分信息放入到RequestContext中，但是netflixext starter是面向所有应用编写的，没有为网关做定制

  当然网关中也可以用RequestContext来改写netflixext starter中客户化Feign，RestTemplate的获取信息的逻辑，似乎这样做更合理
</pre>

<p>
优先级：28
</p>
</div>
</div>

<div id="outline-container-org58e865a" class="outline-4">
<h4 id="org58e865a">APIPermissionCheckFilter</h4>
<div class="outline-text-4" id="text-org58e865a">
<p>
检查调用者是否有权限调用注册在网关上的API（仅限于admin-service注册的服务） 
</p>
<ul class="org-ul">
<li>优先级：30</li>
<li>生效条件：满足下面所有的条件才生效
<ol class="org-ol">
<li>某些http方法不需要做权限认证，这个和安全认证中逻辑类似</li>
<li>调用者租户代码不为空
<ul class="org-ul">
<li>如果为空，实际上是后台服务器去做安全认证，网关如果不做安全认证，就不知道调用者是谁，所以也没法做权限认证</li>
</ul></li>
<li>注册在admin-service的服务</li>
</ol></li>
<li>权限认证不通过，中断请求，返回状态码403，报错信息："api permission check failed"</li>
</ul>
</div>
</div>

<div id="outline-container-org2f88298" class="outline-4">
<h4 id="org2f88298">TenantCheckFilter</h4>
<div class="outline-text-4" id="text-org2f88298">
<p>
校验用户手动从http请求头传的tenantCode和安全认证token对应的用户的租户代码是否一致
</p>

<ul class="org-ul">
<li>优先级：40</li>
<li>生效条件：请求头中的x-ebao-tenant-id不为空，并且安全认证获得的账户名不为空</li>
<li>如果两者校验不匹配，中断请求，返回状态码403, 报错信息："tenant check failed"</li>
</ul>
</div>
</div>
<div id="outline-container-org6fb6f00" class="outline-4">
<h4 id="org6fb6f00">RequestHeaderFilter</h4>
<div class="outline-text-4" id="text-org6fb6f00">
<p>
路由http请求前，把租户，用户等信息放到请求头内，后台服务器可以获得这些信息 
</p>

<ul class="org-ul">
<li>优先级：55</li>
<li>生效条件： 通过前面的所有的校验</li>
</ul>
</div>
</div>

<div id="outline-container-org515db19" class="outline-4">
<h4 id="org515db19">APIFactoryRequestFilter</h4>
<div class="outline-text-4" id="text-org515db19">
<p>
转发请求给apifactory服务 
</p>
<ul class="org-ul">
<li>优先级：60</li>
<li>生效条件：VendorRoute对象的isVirtual属性为真（admin-service数据库里面的swagger扩展字段中有这么一个标志位）</li>
<li>业务逻辑：根据apifactory-service 的invoke rest接口来创建http请求，手动调用apifacory-service的invoke接口</li>
</ul>

<pre class="example">
  接下来会重构APIFactoryService，所以这个Filter可能要完全改写，所以没必要去细究细节
</pre>
</div>
</div>
</div>

<div id="outline-container-orga58d3b8" class="outline-3">
<h3 id="orga58d3b8">post</h3>
<div class="outline-text-3" id="text-orga58d3b8">
</div>
<div id="outline-container-org81148b0" class="outline-4">
<h4 id="org81148b0">CorsReponseFilte</h4>
<div class="outline-text-4" id="text-org81148b0">
<p>
跨域访问的reponse的header中都必须加上“Access-Control-Allow-Origin”
</p>
<ul class="org-ul">
<li>优先级: -10</li>
<li>过滤条件：请求是跨域访问</li>
<li>处理逻辑：如果response的header中没有“Access-Control-Allow-Origin”字段，那么在其中设置Access-Control-Allow-Origin为 *</li>
</ul>

<pre class="example">
  注意：reponse的header中的Access-Control-Allow-Origin不能有多个值叠加，浏览器会报错

  这种情况主要出现在：网关做了跨域支持，后台服务器也做了跨域支持，

  从后台服务器返回的响应中已经加入了Access-Control-Allow-Origin字段，所以需要校验是否已经存在这个字段
</pre>
</div>
</div>

<div id="outline-container-org567c207" class="outline-4">
<h4 id="org567c207">APIFactoryResponseFilter</h4>
<div class="outline-text-4" id="text-org567c207">
<pre class="example">
apifactory service的invoke返回的响应是一个json的body，这个body包含了返回给客户的状态码，请求头，body

所以网关需要重新组装返回给真实客户的响应
</pre>

<ul class="org-ul">
<li>优先级: 990</li>
</ul>
</div>
</div>

<div id="outline-container-org7e5dda0" class="outline-4">
<h4 id="org7e5dda0">ResponseHeaderFilter</h4>
<div class="outline-text-4" id="text-org7e5dda0">
<p>
把租户，用户，以及调用者IP等信息写入到响应的请求头中
</p>
<pre class="example">
  主要目的是：tomcat 的access log可以方便的打印出请求头中的这些信息

  未来如果不靠tomcat的access log日志来做统计，这个Filter可以删除掉
</pre>
<ul class="org-ul">
<li>优先级：995</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4b3af41" class="outline-3">
<h3 id="org4b3af41">error  类型</h3>
<div class="outline-text-3" id="text-org4b3af41">
</div>
<div id="outline-container-org25dcbf9" class="outline-4">
<h4 id="org25dcbf9">CustomErrorFilter</h4>
<div class="outline-text-4" id="text-org25dcbf9">
<p>
这里的逻辑和ResponseHeaderFilter一样
</p>

<pre class="example">
zuul 的post类型中有一个SendErrorFilter，它的优先级是0，在那里就会直接把错误响应发送给客户端，所以ResponseHeaderFilter的逻辑根本走不到

这也就是为什么CorsReponseFilter的优先级被定义为-10， 它必须在SendErrorFilter之前被执行，才能兼容出错的情况

没有把ResponseHeaderFilter的优先级也定义成负数的原因是：

后面的APIFactoryResponseFilter会重新生成响应，这种情况下，哪怕前面加了，也会丢失。因此是把它放到了最后去做

当然也可以把它和CorsReponseFilter一样处理，然后在APIFactoryResponseFilter中手动增加这部分逻辑
</pre>

<pre class="example">
  这个filter实际上还有一个作用是分析错误堆栈，找出真正的有意义的出错原因返回给客户

  以前这部分代码经常出错，后来我就手动注释掉了，保证可用
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org95e593a" class="outline-2">
<h2 id="org95e593a">配置信息</h2>
<div class="outline-text-2" id="text-org95e593a">
</div>
<div id="outline-container-org37546b6" class="outline-3">
<h3 id="org37546b6">限流和熔断</h3>
<div class="outline-text-3" id="text-org37546b6">
<pre class="example">
zuul.host.max-per-route-connections=500 # 每个后台服务器最多建立500个socket连接
zuul.host.max-total-connections=1000 # 整个zuul服务器最多建立1000个socket连接

hystrix.command.default.execution.isolation.strategy=SEMAPHORE # hystrix 基于信号量做限流
hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests=100000 # 每个请求需要获得一个信号量，当信号量用完了也就无法响应请求

hystrix.command.default.circuitBreaker.enabled=false # 没有开启熔断
hystrix.command.default.fallback.enabled=false # 也没有开启熔断后的fallback处理机制

ribbon.circuit.enabled=false # ribbon 客户端负载均衡关闭熔断
</pre>

<p>
实际生产运行时hystrix几乎没有限流和熔断
</p>

<pre class="example">
feign.hystrix.enabled=false # 通过feign调用rest请求，不使用hystrix
</pre>

<p>
原因：如果feign使用hystrix，可能会开启新的线程，导致通过ThreadLocal传递租户代码失败
</p>

<pre class="example">
ebao.gateway.limit.user-api-interval-seconds=60 # 每个用户的统计时间窗口是60秒
ebao.gateway.limit.user-api-throttle=1200  # 限制每个用户在一个时间窗口调用的阀值是1200次
ebao.gateway.limit.tenant-api-interval-seconds=60 # 每个租户的统计时间窗口是60秒
ebao.gateway.limit.tenant-api-throttle=6000 # 每个租户在一个时间窗口调用的阀值是6000次
</pre>

<p>
这些是对于每个用户/租户的默认值，可以在用户/租户配置页面对一个特定用户/租户手动修改
</p>
</div>
</div>
<div id="outline-container-orga1303aa" class="outline-3">
<h3 id="orga1303aa">超时</h3>
<div class="outline-text-3" id="text-orga1303aa">
<pre class="example">
zuul.host.socket-timeout-millis=120000 # SimpleHostRoutingFilter的超时是120000ms，2分钟
ribbon.ReadTimeout=120000 # 基于RibbonRoutingFilter的超时也是120000ms，2分钟

hystrix.command.default.execution.timeout.enabled=false # hystrix的超时被关闭
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=120000 # hystrix线程级别的超时，实际上没用
</pre>

<p>
每个生产环境可能在配置中心有自己的客户化配置
</p>
</div>
</div>
<div id="outline-container-orga1252f6" class="outline-3">
<h3 id="orga1252f6">重试</h3>
<div class="outline-text-3" id="text-orga1252f6">
<pre class="example">
zuul.retryable=true # zuul 支持重试
ribbon.MaxAutoRetries=0 # 每个服务器重试的次数
ribbon.MaxAutoRetriesNextServer=3 # 重试下一个服务器的次数
</pre>

<p>
支持基于ribbon的出错重试机制
</p>
</div>
</div>
<div id="outline-container-orge112d04" class="outline-3">
<h3 id="orge112d04">httptrace</h3>
<div class="outline-text-3" id="text-orge112d04">
<pre class="example">
ebao.platform.httptrace.enableTrace=true

ebao.platform.httptrace.traceViewBaseUrl=${platform.domainname}
ebao.platform.httptrace.traceViewPath=/pinpoint_web/trace/${traceid}.pinpoint
</pre>
</div>
</div>

<div id="outline-container-org4d8a6cd" class="outline-3">
<h3 id="org4d8a6cd">misc</h3>
<div class="outline-text-3" id="text-org4d8a6cd">
<pre class="example">
zuul.sslHostnameValidationEnabled=true # 后台服务器如果是https，是否要校验证书的有效性
</pre>

<p>
注意：这个参数对SimpleRoutingFilter有效，对RibbonRoutingFilter路由方式无效
</p>

<pre class="example">
zuul.sensitive-headers= # 发送给网关请求中的header里面哪些字段不用传递给后台服务器
</pre>

<p>
比如：网关做了安全认证后，请求中的Authorization头就不应该再继续传递给后台服务器
</p>

<p>
这里留空的原因：有些后台服务自己做安全认证，这里不能一刀切地把Authorization头禁了。万一有这方面的要求，可以在创建路由对象时设置相应的ignoreHeaders字段来满足需求： 
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00bfff; font-weight: bold;">public</span> <span style="color: #98f5ff;">VenderRoute</span> <span style="color: #daa520; font-weight: bold;">convert</span>(<span style="color: #98f5ff;">VenderPath</span> <span style="color: #4eee94;">venderPath</span>) {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">route fields</span>
    <span style="color: #98f5ff;">VenderRoute</span> <span style="color: #4eee94;">route</span> = <span style="color: #00bfff; font-weight: bold;">new</span> <span style="color: #98f5ff;">VenderRoute</span>(
        String.valueOf(venderPath.getId()),
        buildPath(venderPath),
        venderPath.getNodes(),
        <span style="color: #deb887;">""</span>,
        <span style="color: #ffd700;">true</span>,
        venderPath.getIgnoreHeaders());
<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">.......</span>
}
</pre>
</div>
<p>
venderPath对象的ignoreHeaders信息来自于注册在admin-service数据库里swagger文件的扩展字段
</p>
</div>
</div>
</div>

<div id="outline-container-org1b7d7a9" class="outline-2">
<h2 id="org1b7d7a9">常见报错</h2>
<div class="outline-text-2" id="text-org1b7d7a9">
<ol class="org-ol">
<li>路由请求时报出connection timeout ： 一般是和后台服务器建立socket连接超时（默认是2秒）</li>
<li>路由请求时报出read timeout：得到后台服务器响应时间超时（默认是120秒）</li>
<li>路由请求是报出 connection reset : 后台服务器已经关闭了socket连接，网关不知道，一般是后台服务器不支持http长连接导致</li>
<li>请求返回401 auth check failed: 身份认证未通过</li>
<li>请求返回403 api permission check failed：权限校验未通过</li>
<li>请求返回403 tenant check failed: 请求中的x-ebao-tenant-id和authorization头对应的租户不匹配</li>
<li>如果注册在网关上的api是文件上传这种multipart的服务，body超过2M，会报错，这个时候需要在路径里加上zuul前缀
<ul class="org-ul">
<li>比如：<a href="https://dev.ebaocloud.com/api/data-collection-service/upload">https://dev.ebaocloud.com/api/data-collection-service/upload</a> 需要写成 <a href="https://dev.ebaocloud.com/api/zuul/data-collection-service/upload">https://dev.ebaocloud.com/api/zuul/data-collection-service/upload</a></li>
</ul></li>
<li>后台服务器的https证书会有问题</li>
</ol>
</div>
</div>

<div id="outline-container-org5724858" class="outline-2">
<h2 id="org5724858">问题和改进</h2>
<div class="outline-text-2" id="text-org5724858">
<ul class="org-ul">
<li>去掉自定义的服务注册和发现机制：这些服务的路由信息可以暂时通过配置文件来获取</li>
<li>权限校验应该基于用户，而不是租户</li>
<li>并发的效率不高，测试结果显示单节点同时处理50个请求时候效率最高，200个并发请求再往上，响应变得非常慢</li>
</ul>
<pre class="example">
  升级到支持nio的zuul2试试，或选择基于go的网关中间件
</pre>

<ul class="org-ul">
<li>出错时报错信息很不直观</li>
</ul>
<pre class="example">
CustomErrorFilter应该自己组装对应的报错响应

但从一大堆的异常堆栈检索到真正有用的报错信息不好做
</pre>

<ul class="org-ul">
<li>ebao.gateway.security.ignore.urls 现在的值已经太长了，应该改成列表的形式</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
