<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>TCP：连接的建立和终止</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tcp.html"> UP </a>
 |
 <a accesskey="H" href="tii.html"> HOME </a>
</div><div id="content">
<h1 class="title">TCP：连接的建立和终止</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">连接的建立与终止</a>
<ul>
<li><a href="#sec-1-1">tcpdump的输出</a></li>
<li><a href="#sec-1-2">时序图</a></li>
<li><a href="#sec-1-3">建立连接</a></li>
<li><a href="#sec-1-4">连接终止</a></li>
<li><a href="#sec-1-5">正常的tcpdump输出</a></li>
</ul>
</li>
<li><a href="#sec-2">连接建立的超时</a>
<ul>
<li><a href="#sec-2-1">服务类型字段</a></li>
</ul>
</li>
<li><a href="#sec-3">最大报文段长度</a>
<ul>
<li><a href="#sec-3-1">实例</a></li>
</ul>
</li>
<li><a href="#sec-4">TCP的半关闭</a></li>
</ul>
</div>
</div>
<p>
TCP是一个面向连接的协议： <b>无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接</b> 
</p>

<pre class="example">
  这种两端间连接的建立与无连接协议如UDP不同，一端使用UDP向另一端发送数据报时，无需任何预先的握手
</pre>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">连接的建立与终止</h2>
<div class="outline-text-2" id="text-1">
<p>
为了了解一个TCP连接在建立及终止时发生了什么，在系统svr4上键入下列命令：
</p>


<div class="figure">
<p><img src="pic/tcp-telnet.png" alt="tcp-telnet.png" width="70%" />
</p>
</div>

<p>
telnet命令在与丢弃(discard)服务对应的端口上与主机bsdi建立一条TCP连接。这服务类型正是需要观察的一条连接建立与终止的服务类型，而不需要服务器发起任何数据交换
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">tcpdump的输出</h3>
<div class="outline-text-3" id="text-1-1">
<p>
图18-1显示了这条命令产生TCP报文段的tcpdump输出：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-dump.png" alt="tcp-connection-dump.png" width="90%" />
</p>
</div>

<p>
这7个TCP报文段仅包含TCP首部，没有任何数据。对于TCP段，每个输出行开始按如下格式显示：
</p>

<pre class="example">
   源 &gt; 目的 : 标志
</pre>

<p>
这里的标志代表TCP首部中6个标志比特中的4个。下表显示了标志的5个字符的含义：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> tcpdump对TCP首部中部分标志比特的字符表示</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">标志</td>
<td class="left">3字符缩写</td>
<td class="left">描述</td>
</tr>

<tr>
<td class="left">S</td>
<td class="left">SYN</td>
<td class="left">同步序号</td>
</tr>

<tr>
<td class="left">F</td>
<td class="left">FIN</td>
<td class="left">发送方完成数据发送</td>
</tr>

<tr>
<td class="left">R</td>
<td class="left">RST</td>
<td class="left">复位连接</td>
</tr>

<tr>
<td class="left">P</td>
<td class="left">PSH</td>
<td class="left">尽可能快地将数据发往接收进程</td>
</tr>

<tr>
<td class="left">.</td>
<td class="left">&#xa0;</td>
<td class="left">以上4个标志皆为0</td>
</tr>
</tbody>
</table>

<p>
在这个例子中，看到了 <b>S</b> 、 <b>F</b> 和 <b>.</b> 标志符。以后看到其他的两个标志（ <b>R</b> 和 <b>P</b> ）。TCP首部中的其他两个标志比特 <b>ACK</b> 和 *URG*，tcpdump将作特殊显示。表中4个标志比特中的多个可能同时出现在一个报文段中，但通常一次只见到一个
</p>

<pre class="example">
RFC 1025将一种报文段称为Kamikaze分组Θ，在这样的报文段中有最大数量的标志比特同时被置为1（SYN,URG,PSH,FIN和1字节的数据）。这样的报文段也叫作nastygram,圣诞树分组，灯测试报文段
</pre>

<ul class="org-ul">
<li>在第1行 <b>1415531521:1415531521(0)</b> : 分组的序号是1415531521，而报文段中数据字节数为0
<ul class="org-ul">
<li>tcpdump显示这个字段的格式：
<ul class="org-ul">
<li>开始的序号
</li>
<li>一个冒号
</li>
<li>隐含的结尾序号
</li>
<li>圆括号内的数据字节数
</li>
</ul>
</li>
<li>优点：便于了解数据字节数大于0时的隐含结尾序号
</li>
<li><b>隐含的结尾序号只有在满足下面条件之一才显示</b> ：
<ol class="org-ol">
<li>报文段中至少包含一个数据字节
</li>
<li>SYN、FIN或RST被设置为1时才显示
</li>
</ol>
</li>
</ul>
</li>

<li>在第2行中 <b>ack 1415531522</b> ：确认序号， <b>它只有在首部中的ACK标志比特被设置1时才显示</b> 
</li>

<li>每行显示的字段 <b>win 4096</b> : 发送端通告的窗口大小。例子中没有交换任何数据，所以窗口大小就维持默认情况下的4096
</li>

<li>最后一个字段 <b>&lt;mss1024&gt;</b> ：由发送端指明的最大报文段长度选项。发送端将不接收超过这个长度的TCP报文段。这通常是为了避免分段
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">时序图</h3>
<div class="outline-text-3" id="text-1-2">
<p>
图18-3显示了这些分组序列的时间系列，这个图显示出哪一端正在发送分组：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-sequence.png" alt="tcp-connection-sequence.png" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">建立连接</h3>
<div class="outline-text-3" id="text-1-3">
<p>
为了建立一条TCP连接：
</p>
<ol class="org-ol">
<li>报文段1：请求端（通常称为客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，在这个例子中为1415531521）
</li>
<li>报文段2：服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时， <b>将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认，而且一个SYN将占用一个序号</b> 
</li>
<li>报文段3：客户必须 <b>将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认</b>
</li>
</ol>

<p>
发送第一个SYN的一端将执行主动打开。接收这个SYN并发回下一个SYN的另一端执行被动打开
</p>

<p>
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。RFC 793指出ISN可看作是一个32比特的计数器，每4ms加1。这样选择序号的目的在于 <b>防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释</b> 
</p>

<pre class="example">
  如何进行序号选择？

  在4.4BSD（和多数的伯克利的实现版）中，系统初始化时初始的发送序号被初始化为1

  这个变量每0.5秒增加64000，并每隔9.5小时又回到0（对应这个计数器每8 ms加1，而不是每4 ms加1）

  另外，每次建立一个连接后，这个变量将增加64000
</pre>

<p>
报文段3与报文段4之间4.1秒的时间间隔是建立TCP连接到向telnet键入quit命令来中止该连接的时间
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">连接终止</h3>
<div class="outline-text-3" id="text-1-4">
<p>
建立一个连接需要三次握手，而终止一个连接要经过4次握手，这由TCP的半关闭造成的。 <b>因为一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭</b>  。这原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须通知应用层另一端已经终止了那个方向的数据传送。 <b>发送FIN通常是应用层进行关闭的结果</b> 
</p>

<pre class="example">
   收到一个FIN只意味着在这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据
   
   而这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的TCP应用程序这样做
</pre>

<p>
首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭，但也可能双方都执行主动关闭
</p>

<p>
正常关闭过程如图18-3所示：
</p>
<ol class="org-ol">
<li>报文段4：发起终止连接，它由Telnet客户端关闭连接时发出。这在键入quit命令后发生。它将导致TCP客户端发送一个FIN，用来关闭从客户到服务器的数据传送
</li>
<li>报文段5：当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。 <b>和SYN一样，一个FIN将占用一个序号</b> 
<ul class="org-ul">
<li>TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符
</li>
</ul>
</li>
<li>报文段6：这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN
</li>
<li>报文段7：客户必须发回一个确认，并将确认序号设置为收到序号加1
</li>
</ol>

<p>
图18-4显示了终止一个连接的典型握手顺序。在这个图中，发送FIN将导致应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-close.png" alt="tcp-connection-close.png" width="70%" />
</p>
</div>

<p>
连接通常是由客户端发起的，这样第一个SYN从客户传到服务器。每一端都能主动关闭这个连接（即首先发送FIN）。然而，一般由客户端决定何时终止连接，因为客户进程通常由用户交互控制，用户会键入诸如“quit”一样的命令来终止进程。在图18-4中，我们能改变上边的标识，将左方定为服务器，右方定为客户，一切仍将像显示的一样工作
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">正常的tcpdump输出</h3>
<div class="outline-text-3" id="text-1-5">
<p>
对所有的数值很大的序号进行排序是很麻烦的，因此默认情况下tcpdump只在显示SYN报文段时显示完整的序号，而对其后的序号则显示它们与初始序号的相对偏移值
</p>

<p>
除非我们需要显示完整的序号，否则将在以下的例子中使用这种形式的输出显示：
</p>


<div class="figure">
<p><img src="pic/tcp-normal-dump.png" alt="tcp-normal-dump.png" width="70%" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">连接建立的超时</h2>
<div class="outline-text-2" id="text-2">
<p>
有很多情况导致无法建立连接。一种情况是服务器主机没有处于正常状态。为了模拟这种情况，我们断开服务器主机的电缆线，然后向它发出telnet命令。图18-6显示了tcpdump的输出:
</p>


<div class="figure">
<p><img src="pic/tcp-connection-timeout.png" alt="tcp-connection-timeout.png" width="70%" />
</p>
</div>


<p>
在这个输出中有趣的一点是客户间隔多长时间发送一个SYN，试图建立连接。第2个SYN与第1个的间隔是5.8秒，而第3个与第2个的间隔是24秒
</p>

<pre class="example">
  这个例子运行38分钟后客户重新启动。这对应初始序号为291008001（约为38×60×64000×2）
  
  曾经介绍过使用典型的伯克利实现版的系统将初始序号初始化为1，然后每隔0.5秒就增加64000
  
  另外，因为这是系统启动后的第一个TCP连接，因此客户的端口号是1024
</pre>

<p>
图18-6中没有显示客户端在放弃建立连接尝试前进行SYN重传的时间。为了了解它我们必须对telnet命令进行计时：
</p>


<div class="figure">
<p><img src="pic/telnet-timeout.png" alt="telnet-timeout.png" width="70%" />
</p>
</div>

<p>
时间差值是76秒，这是因为大多数伯克利系统将建立一个新连接的最长时间限制为75秒
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">服务类型字段</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在图18-6中，出现了符号 [tos 0x10]。这是IP数据报内的服务类型（TOS）字段。BSD/386中的Telnet客户进程将这个字段设置为最小时延
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">最大报文段长度</h2>
<div class="outline-text-2" id="text-3">
<p>
最大报文段长度(MSS)：TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。已经见过MSS都是1024。这导致IP数据报通常是40字节长：20字节的TCP首部和20字节的IP首部
</p>

<p>
它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（ <b>MSS选项只能出现在SYN报文段中</b> ）。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报）
</p>

<p>
一般说来，如果没有分段发生，MSS还是越大越好（这也并不总是正确）。报文段越大允许每个报文段传送的数据就越多，相对IP和TCP首部有更高的网络利用率。当TCP发送一个SYN时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它将MSS值设置为 <b>外出接口上的MTU长度减去固定的IP首部和TCP首部长度</b> 。对于一个以太网，MSS值可达 <b>1460字节</b> 。使用IEEE 802.3的封装，它的MSS可达 <b>1452字节</b> 
</p>

<pre class="example">
  在本章见到的涉及BSD/386和SVR4的MSS为1024，这是因为许多BSD的实现版本需要MSS为512的倍数
  
  其他的系统，如SunOS 4.1.3、Solaris 2.2和AIX 3.2.2，当双方都在一个本地以太网上时都规定MSS为1460
  
  以太网上1460的MSS在性能上比1024的MSS更好
</pre>

<p>
如果目的IP地址为“非本地的”，MSS通常的默认值为 <b>536</b> 。而区分地址是本地还是非本地是简单的，如果目的IP地址的网络号与子网号都和我们的相同，则是本地的；如果目的IP地址的网络号与我们的完全不同，则是非本地的；如果目的IP地址的网络号与我们的相同而子网号与我们的不同，则可能是本地的，也可能是非本地的。大多数TCP实现版都提供了一个配置选项，让系统管理员说明不同的子网是属于本地还是非本地。这个选项的设置将 <b>确定MSS可以选择尽可能的大（达到外出接口的MTU长度）或是默认值536</b> 
</p>

<p>
MSS让主机限制另一端发送数据报的长度。加上主机也能控制它发送数据报的长度，这将使以较小MTU连接到一个网络上的主机避免分段
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">实例</h3>
<div class="outline-text-3" id="text-3-1">
<p>
考虑主机slip，通过MTU为296的SLIP链路连接到路由器bsdi上。图18-8显示这些系统和主机sun：
</p>


<div class="figure">
<p><img src="pic/mss-sample.png" alt="mss-sample.png" width="70%" />
</p>
</div>

<p>
从sun向slip发起一个TCP连接，并使用tcpdump来观察报文段。图18-9显示这个连接的建立：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-mss.png" alt="tcp-connection-mss.png" width="70%" />
</p>
</div>

<p>
在这个例子中，sun发送的报文段不能超过256字节的数据，因为它收到的MSS选项值为256。此外，由于slip知道它外出接口的MTU长度为296，即使sun已经通告它的MSS为1460，但为避免将数据分段，它不会发送超过256字节数据的报文段。系统允许发送的数据长度小于另一端的MSS值
</p>

<p>
<b>只有当一端的主机以小于576字节的MTU直接连接到一个网络中，避免这种分段才会有效</b> 。如果两端的主机都连接到以太网上，都采用536的MSS，但中间网络采用296的MTU，也将会出现分段。使用路径上的MTU发现机制是关于这个问题的唯一方法
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">TCP的半关闭</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
