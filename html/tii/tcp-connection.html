<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>TCP：连接的建立和终止</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tcp.html"> UP </a>
 |
 <a accesskey="H" href="tii.html"> HOME </a>
</div><div id="content">
<h1 class="title">TCP：连接的建立和终止</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">连接的建立与终止</a>
<ul>
<li><a href="#sec-1-1">tcpdump的输出</a></li>
<li><a href="#sec-1-2">时序图</a></li>
<li><a href="#sec-1-3">建立连接</a></li>
<li><a href="#sec-1-4">连接终止</a></li>
<li><a href="#sec-1-5">正常的tcpdump输出</a></li>
</ul>
</li>
<li><a href="#sec-2">连接建立的超时</a>
<ul>
<li><a href="#sec-2-1">服务类型字段</a></li>
</ul>
</li>
<li><a href="#sec-3">最大报文段长度</a>
<ul>
<li><a href="#sec-3-1">实例</a></li>
</ul>
</li>
<li><a href="#sec-4">TCP的半关闭</a>
<ul>
<li><a href="#sec-4-1">用途</a></li>
</ul>
</li>
<li><a href="#sec-5">TCP的状态变迁图</a>
<ul>
<li><a href="#sec-5-1">TIME_WAIT状态</a>
<ul>
<li><a href="#sec-5-1-1">2MSL实例</a></li>
<li><a href="#sec-5-1-2">平静时间</a></li>
</ul>
</li>
<li><a href="#sec-5-2">FIN_WAIT_2状态</a></li>
<li><a href="#sec-5-3">复位报文段</a></li>
<li><a href="#sec-5-4">同时打开</a></li>
<li><a href="#sec-5-5">同时关闭</a></li>
</ul>
</li>
<li><a href="#sec-6">TCP选项</a></li>
<li><a href="#sec-7">TCP服务器设计</a></li>
</ul>
</div>
</div>
<p>
TCP是一个面向连接的协议： <b>无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接</b> 
</p>

<pre class="example">
  这种两端间连接的建立与无连接协议如UDP不同，一端使用UDP向另一端发送数据报时，无需任何预先的握手
</pre>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">连接的建立与终止</h2>
<div class="outline-text-2" id="text-1">
<p>
为了了解一个TCP连接在建立及终止时发生了什么，在系统svr4上键入下列命令：
</p>


<div class="figure">
<p><img src="pic/tcp-telnet.png" alt="tcp-telnet.png" width="70%" />
</p>
</div>

<p>
telnet命令在与丢弃(discard)服务对应的端口上与主机bsdi建立一条TCP连接。这服务类型正是需要观察的一条连接建立与终止的服务类型，而不需要服务器发起任何数据交换
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">tcpdump的输出</h3>
<div class="outline-text-3" id="text-1-1">
<p>
图18-1显示了这条命令产生TCP报文段的tcpdump输出：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-dump.png" alt="tcp-connection-dump.png" width="90%" />
</p>
</div>

<p>
这7个TCP报文段仅包含TCP首部，没有任何数据。对于TCP段，每个输出行开始按如下格式显示：
</p>

<pre class="example">
   源 &gt; 目的 : 标志
</pre>

<p>
这里的标志代表TCP首部中6个标志比特中的4个。下表显示了标志的5个字符的含义：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> tcpdump对TCP首部中部分标志比特的字符表示</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">标志</td>
<td class="left">3字符缩写</td>
<td class="left">描述</td>
</tr>

<tr>
<td class="left">S</td>
<td class="left">SYN</td>
<td class="left">同步序号</td>
</tr>

<tr>
<td class="left">F</td>
<td class="left">FIN</td>
<td class="left">发送方完成数据发送</td>
</tr>

<tr>
<td class="left">R</td>
<td class="left">RST</td>
<td class="left">复位连接</td>
</tr>

<tr>
<td class="left">P</td>
<td class="left">PSH</td>
<td class="left">尽可能快地将数据发往接收进程</td>
</tr>

<tr>
<td class="left">.</td>
<td class="left">&#xa0;</td>
<td class="left">以上4个标志皆为0</td>
</tr>
</tbody>
</table>

<p>
在这个例子中，看到了 <b>S</b> 、 <b>F</b> 和 <b>.</b> 标志符。以后看到其他的两个标志（ <b>R</b> 和 <b>P</b> ）。TCP首部中的其他两个标志比特 <b>ACK</b> 和 *URG*，tcpdump将作特殊显示。表中4个标志比特中的多个可能同时出现在一个报文段中，但通常一次只见到一个
</p>

<pre class="example">
RFC 1025将一种报文段称为Kamikaze分组Θ，在这样的报文段中有最大数量的标志比特同时被置为1（SYN,URG,PSH,FIN和1字节的数据）。这样的报文段也叫作nastygram,圣诞树分组，灯测试报文段
</pre>

<ul class="org-ul">
<li>在第1行 <b>1415531521:1415531521(0)</b> : 分组的序号是1415531521，而报文段中数据字节数为0
<ul class="org-ul">
<li>tcpdump显示这个字段的格式：
<ul class="org-ul">
<li>开始的序号
</li>
<li>一个冒号
</li>
<li>隐含的结尾序号
</li>
<li>圆括号内的数据字节数
</li>
</ul>
</li>
<li>优点：便于了解数据字节数大于0时的隐含结尾序号
</li>
<li><b>隐含的结尾序号只有在满足下面条件之一才显示</b> ：
<ol class="org-ol">
<li>报文段中至少包含一个数据字节
</li>
<li>SYN、FIN或RST被设置为1时才显示
</li>
</ol>
</li>
</ul>
</li>

<li>在第2行中 <b>ack 1415531522</b> ：确认序号， <b>它只有在首部中的ACK标志比特被设置1时才显示</b> 
</li>

<li>每行显示的字段 <b>win 4096</b> : 发送端通告的窗口大小。例子中没有交换任何数据，所以窗口大小就维持默认情况下的4096
</li>

<li>最后一个字段 <b>&lt;mss1024&gt;</b> ：由发送端指明的最大报文段长度选项。发送端将不接收超过这个长度的TCP报文段。这通常是为了避免分段
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">时序图</h3>
<div class="outline-text-3" id="text-1-2">
<p>
图18-3显示了这些分组序列的时间系列，这个图显示出哪一端正在发送分组：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-sequence.png" alt="tcp-connection-sequence.png" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">建立连接</h3>
<div class="outline-text-3" id="text-1-3">
<p>
为了建立一条TCP连接：
</p>
<ol class="org-ol">
<li>报文段1：请求端（通常称为客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，在这个例子中为1415531521）
</li>
<li>报文段2：服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时， <b>将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认，而且一个SYN将占用一个序号</b> 
</li>
<li>报文段3：客户必须 <b>将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认</b>
</li>
</ol>

<p>
发送第一个SYN的一端将执行主动打开。接收这个SYN并发回下一个SYN的另一端执行被动打开
</p>

<p>
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。RFC 793指出ISN可看作是一个32比特的计数器，每4ms加1。这样选择序号的目的在于 <b>防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释</b> 
</p>

<pre class="example">
  如何进行序号选择？

  在4.4BSD（和多数的伯克利的实现版）中，系统初始化时初始的发送序号被初始化为1

  这个变量每0.5秒增加64000，并每隔9.5小时又回到0（对应这个计数器每8 ms加1，而不是每4 ms加1）

  另外，每次建立一个连接后，这个变量将增加64000
</pre>

<p>
报文段3与报文段4之间4.1秒的时间间隔是建立TCP连接到向telnet键入quit命令来中止该连接的时间
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">连接终止</h3>
<div class="outline-text-3" id="text-1-4">
<p>
建立一个连接需要三次握手，而终止一个连接要经过4次握手，这由TCP的半关闭造成的。 <b>因为一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭</b>  。这原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须通知应用层另一端已经终止了那个方向的数据传送。 <b>发送FIN通常是应用层进行关闭的结果</b> 
</p>

<pre class="example">
   收到一个FIN只意味着在这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据
   
   而这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的TCP应用程序这样做
</pre>

<p>
首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭，但也可能双方都执行主动关闭
</p>

<p>
正常关闭过程如图18-3所示：
</p>
<ol class="org-ol">
<li>报文段4：发起终止连接，它由Telnet客户端关闭连接时发出。这在键入quit命令后发生。它将导致TCP客户端发送一个FIN，用来关闭从客户到服务器的数据传送
</li>
<li>报文段5：当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。 <b>和SYN一样，一个FIN将占用一个序号</b> 
<ul class="org-ul">
<li>TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符
</li>
</ul>
</li>
<li>报文段6：这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN
</li>
<li>报文段7：客户必须发回一个确认，并将确认序号设置为收到序号加1
</li>
</ol>

<p>
图18-4显示了终止一个连接的典型握手顺序。在这个图中，发送FIN将导致应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-close.png" alt="tcp-connection-close.png" width="70%" />
</p>
</div>

<p>
连接通常是由客户端发起的，这样第一个SYN从客户传到服务器。每一端都能主动关闭这个连接（即首先发送FIN）。然而，一般由客户端决定何时终止连接，因为客户进程通常由用户交互控制，用户会键入诸如“quit”一样的命令来终止进程。在图18-4中，我们能改变上边的标识，将左方定为服务器，右方定为客户，一切仍将像显示的一样工作
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">正常的tcpdump输出</h3>
<div class="outline-text-3" id="text-1-5">
<p>
对所有的数值很大的序号进行排序是很麻烦的，因此默认情况下tcpdump只在显示SYN报文段时显示完整的序号，而对其后的序号则显示它们与初始序号的相对偏移值
</p>

<p>
除非我们需要显示完整的序号，否则将在以下的例子中使用这种形式的输出显示：
</p>


<div class="figure">
<p><img src="pic/tcp-normal-dump.png" alt="tcp-normal-dump.png" width="70%" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">连接建立的超时</h2>
<div class="outline-text-2" id="text-2">
<p>
有很多情况导致无法建立连接。一种情况是服务器主机没有处于正常状态。为了模拟这种情况，我们断开服务器主机的电缆线，然后向它发出telnet命令。图18-6显示了tcpdump的输出:
</p>


<div class="figure">
<p><img src="pic/tcp-connection-timeout.png" alt="tcp-connection-timeout.png" width="70%" />
</p>
</div>


<p>
在这个输出中有趣的一点是客户间隔多长时间发送一个SYN，试图建立连接。第2个SYN与第1个的间隔是5.8秒，而第3个与第2个的间隔是24秒
</p>

<pre class="example">
  这个例子运行38分钟后客户重新启动。这对应初始序号为291008001（约为38×60×64000×2）
  
  曾经介绍过使用典型的伯克利实现版的系统将初始序号初始化为1，然后每隔0.5秒就增加64000
  
  另外，因为这是系统启动后的第一个TCP连接，因此客户的端口号是1024
</pre>

<p>
图18-6中没有显示客户端在放弃建立连接尝试前进行SYN重传的时间。为了了解它我们必须对telnet命令进行计时：
</p>


<div class="figure">
<p><img src="pic/telnet-timeout.png" alt="telnet-timeout.png" width="70%" />
</p>
</div>

<p>
时间差值是76秒，这是因为大多数伯克利系统将建立一个新连接的最长时间限制为75秒
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">服务类型字段</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在图18-6中，出现了符号 [tos 0x10]。这是IP数据报内的服务类型（TOS）字段。BSD/386中的Telnet客户进程将这个字段设置为最小时延
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">最大报文段长度</h2>
<div class="outline-text-2" id="text-3">
<p>
最大报文段长度(MSS)：TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。已经见过MSS都是1024。这导致IP数据报通常是40字节长：20字节的TCP首部和20字节的IP首部
</p>

<p>
它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（ <b>MSS选项只能出现在SYN报文段中</b> ）。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报）
</p>

<p>
一般说来，如果没有分段发生，MSS还是越大越好（这也并不总是正确）。报文段越大允许每个报文段传送的数据就越多，相对IP和TCP首部有更高的网络利用率。当TCP发送一个SYN时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它将MSS值设置为 <b>外出接口上的MTU长度减去固定的IP首部和TCP首部长度</b> 。对于一个以太网，MSS值可达 <b>1460字节</b> 。使用IEEE 802.3的封装，它的MSS可达 <b>1452字节</b> 
</p>

<pre class="example">
  在本章见到的涉及BSD/386和SVR4的MSS为1024，这是因为许多BSD的实现版本需要MSS为512的倍数
  
  其他的系统，如SunOS 4.1.3、Solaris 2.2和AIX 3.2.2，当双方都在一个本地以太网上时都规定MSS为1460
  
  以太网上1460的MSS在性能上比1024的MSS更好
</pre>

<p>
如果目的IP地址为“非本地的”，MSS通常的默认值为 <b>536</b> 。而区分地址是本地还是非本地是简单的，如果目的IP地址的网络号与子网号都和我们的相同，则是本地的；如果目的IP地址的网络号与我们的完全不同，则是非本地的；如果目的IP地址的网络号与我们的相同而子网号与我们的不同，则可能是本地的，也可能是非本地的。大多数TCP实现版都提供了一个配置选项，让系统管理员说明不同的子网是属于本地还是非本地。这个选项的设置将 <b>确定MSS可以选择尽可能的大（达到外出接口的MTU长度）或是默认值536</b> 
</p>

<p>
MSS让主机限制另一端发送数据报的长度。加上主机也能控制它发送数据报的长度，这将使以较小MTU连接到一个网络上的主机避免分段
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">实例</h3>
<div class="outline-text-3" id="text-3-1">
<p>
考虑主机slip，通过MTU为296的SLIP链路连接到路由器bsdi上。图18-8显示这些系统和主机sun：
</p>


<div class="figure">
<p><img src="pic/mss-sample.png" alt="mss-sample.png" width="70%" />
</p>
</div>

<p>
从sun向slip发起一个TCP连接，并使用tcpdump来观察报文段。图18-9显示这个连接的建立：
</p>


<div class="figure">
<p><img src="pic/tcp-connection-mss.png" alt="tcp-connection-mss.png" width="70%" />
</p>
</div>

<p>
在这个例子中，sun发送的报文段不能超过256字节的数据，因为它收到的MSS选项值为256。此外，由于slip知道它外出接口的MTU长度为296，即使sun已经通告它的MSS为1460，但为避免将数据分段，它不会发送超过256字节数据的报文段。系统允许发送的数据长度小于另一端的MSS值
</p>

<p>
<b>只有当一端的主机以小于576字节的MTU直接连接到一个网络中，避免这种分段才会有效</b> 。如果两端的主机都连接到以太网上，都采用536的MSS，但中间网络采用296的MTU，也将会出现分段。使用路径上的MTU发现机制是关于这个问题的唯一方法
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">TCP的半关闭</h2>
<div class="outline-text-2" id="text-4">
<p>
TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的 <b>半关闭</b> 。正如早些时候提到的只有很少的应用程序使用它
</p>

<p>
为了使用这个特性，编程接口必须为应用程序提供一种方式来说明： <b>我已经完成了数据传送，因此发送一个文件结束（FIN）给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束（FIN）</b> 
</p>

<pre class="example">
  如果应用程序不调用close而调用shutdown，且第2个参数值为1，则插口的API支持半关闭
  
  然而，大多数的应用程序通过调用close终止两个方向的连接
</pre>

<p>
图18-10显示了一个半关闭的典型例子：
</p>

<div class="figure">
<p><img src="pic/tcp-half-close.png" alt="tcp-half-close.png" width="70%" />
</p>
</div>

<p>
让左方的客户端开始半关闭，当然也可以由另一端开始。开始的两个报文段和图18-4是相同的：
</p>
<ol class="org-ol">
<li>初始端发出的FIN
</li>
<li>另一端对这个FIN的ACK报文段，但后面就和图18-4不同，因为接收半关闭的一方仍能发送数据
</li>
<li>一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段
</li>
<li>当收到半关闭的一端（右边）在完成它的数据传送后，将发送一个FIN关闭这个方向的连接， <b>这将传送一个文件结束符给发起这个半关闭的应用进程</b> （左边）
</li>
<li>当对第二个FIN进行确认后，这个连接便彻底关闭了
</li>
</ol>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">用途</h3>
<div class="outline-text-3" id="text-4-1">
<p>
一个典型的例子是Unix中的rsh(1)命令，它将完成在另一个系统上执行一个命令
</p>

<div class="org-src-container">

<pre class="src src-sh">sun$ rsh bsdi sort &lt; datafile
</pre>
</div>

<p>
这将在主机bsdi上执行sort排序命令，rsh命令的标准输入来自文件datafile。rsh将在它与在另一主机上执行的程序间建立一个TCP连接。rsh的操作很简单：它将标准输入（datafile）复制给TCP连接，发送给bsdi主机，并将bsdi上的执行结果从TCP连接中复制给标准输出（sun主机的终端）。图18-11显示了这个建立过程：
</p>


<div class="figure">
<p><img src="pic/tcp-rsh-example.png" alt="tcp-rsh-example.png" width="70%" />
</p>
</div>

<p>
在远端主机bsdi上，rshd服务器将执行sort程序，它的标准输入和标准输出都是TCP连接
</p>

<pre class="example">
   请牢记TCP连接是全双工的，两边都可以互相发送数据
</pre>

<p>
sort程序只有读取到所有输入数据后才能产生输出。所有的原始数据通过TCP连接从rsh客户端传送到sort服务器进行排序。当输入(datafile)到达文件尾时，rsh客户端执行这个TCP连接的半关闭。接着sort服务器在它的标准输入（TCP连接）上收到一个文件结束符，对数据进行排序，并将结果写在它的标准输出上（TCP连接）。rsh客户端继续接收来自TCP连接另一端的数据，并将排序的文件复制到它的标准输出上
</p>

<pre class="example">
   没有半关闭，需要其他的一些技术让客户通知服务器，客户端已经完成了它的数据传送，但仍要接收来自服务器的数据
   
   使用两个TCP连接也可作为一个选择，但使用半关闭的单连接更好
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">TCP的状态变迁图</h2>
<div class="outline-text-2" id="text-5">
<p>
已经介绍了许多有关发起和终止TCP连接的规则。这些规则都能从图18-12所示的状态变迁图中得出：
</p>


<div class="figure">
<p><img src="pic/tcp-state-machine.png" alt="tcp-state-machine.png" width="70%" />
</p>
</div>

<ul class="org-ul">
<li>图中显示了一个典型的状态变迁的子集：用粗的实线箭头表示正常的客户端状态变迁，用粗的虚线箭头表示正常的服务器状态变迁
</li>
<li>两个导致进入ESTABLISHED状态的变迁对应打开一个连接，而两个导致从ESTABLISHED状态离开的变迁对应关闭一个连接。 <b>ESTABLISHED状态是连接双方能够进行双向数据传递的状态</b> 
</li>
<li>图中左下角4个状态放在一个虚线框内，并标为 <b>主动关闭</b>
</li>
<li>右下角两个状态(CLOSE_WAIT和LAST_ACK)也用虚线框住，并标为 <b>被动关闭</b>
</li>
<li>图中11个状态(CLOSED，LISTEN，SYN_SENT等)是有意与netstat命令显示的状态名称一致：
</li>
</ul>

<pre class="example">
CLOSED状态不是一个真正的状态，而是这个状态图的假想起点和终点。
</pre>

<ul class="org-ul">
<li>从LISTEN到SYN_SENT的变迁是正确的，但伯克利版的TCP软件并不支持它
</li>
<li>只有当SYN_RCVD状态是从LISTEN状态（正常情况）进入，而不是从SYN_SENT状态（同时打开）进入时，从SYN_RCVD回到LISTEN的状态变迁才是有效的。这意味着 <b>如果收到一个SYN，发送一个带ACK的SYN（进入SYN_RCVD），然后收到一个RST，而不是一个ACK，便又回到LISTEN状态并等待另一个连接请求的到来</b> 
</li>
</ul>

<p>
图18-13显示了在正常的TCP连接的建立与终止过程中，客户与服务器所经历的不同状态。它是图18-3的再现，不同的是仅显示了一些状态：
</p>


<div class="figure">
<p><img src="pic/tcp-state-change.png" alt="tcp-state-change.png" width="70%" />
</p>
</div>

<pre class="example">
假定在图18-13中左边的客户执行主动打开，而右边的服务器执行被动打开。尽管图中显示出由客户端执行主动关闭，但和我们提到的一样，另一端也能执行主动关闭
</pre>

<p>
可以使用图18-12的状态图来跟踪图18-13的状态变化过程，以便明白每个状态的变化
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">TIME_WAIT状态</h3>
<div class="outline-text-3" id="text-5-1">
<p>
TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL。它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段
</p>

<pre class="example">
RFC 793指出MSL为2分钟。然而，实现中的常用值是30秒，1分钟，或2分钟
</pre>

<p>
对一个具体实现所给定的MSL值，处理的原则是： <b>当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失，被动关闭的另一端超时并重发最后的FIN</b>  
</p>

<p>
这种2MSL等待的结果： <b>这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用</b> 。这个连接只能在2MSL结束后才能再被使用
</p>

<pre class="example">
  遗憾的是，大多数TCP实现强加了更为严格的限制。在2MSL等待期间，插口中使用的本地端口在默认情况下不能再被使用

  某些实现和API提供了一种避开这个限制的方法：使用socket API时，可说明其中的SO_REUSEADDR选项

  它将让调用者对处于2MSL等待的本地端口进行赋值，但TCP原则上仍将避免使用仍处于2MSL连接中的端口
</pre>

<p>
在连接处于2MSL等待时，任何迟到的报文段将被丢弃。因为处于2MSL等待的、由该插口对定义的连接在这段时间内不能被再用，因此当要建立一个有效的连接时，来自该连接的一个较早替身的迟到报文段作为新连接的一部分不可能不被曲解（一个连接由一个插口对来定义。一个连接的新的实例称为该连接的替身）。
</p>

<p>
图18-13中客户执行主动关闭并进入TIME_WAIT是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。这暗示 <b>如果终止一个客户程序，并立即重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口。这不会带来什么问题，因为客户使用本地端口，而并不关心这个端口号是什么</b> 
</p>

<p>
然而，对于服务器，情况就有所不同，因为服务器使用熟知端口。 <b>如果终止一个已经建立连接的服务器程序，并试图立即重新启动这个服务器程序，服务器程序将不能把它的这个熟知端口赋值给它的端点，因为那个端口是处于2MSL连接的一部分。在重新启动服务器程序前，它需要在1~4分钟</b> 
</p>
</div>

<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">2MSL实例</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
可以通过sock程序看到这一切。我们启动服务器程序，从一个客户程序进行连接，然后停止这个服务器程序：
</p>

<div class="figure">
<p><img src="pic/socket-time-wait-example.png" alt="socket-time-wait-example.png" width="70%" />
</p>
</div>

<p>
当重新启动服务器程序时，程序报告一个差错信息说明不能绑定它的熟知端口，因为该端口已被使用，实际上它处于 <b>2MSL等待</b>
</p>

<pre class="example">
  如果我们一直试图重新启动服务器程序，并测量它直到成功所需的时间，就能确定出2MSL值

  对于SunOS 4.1.3、SVR4、BSD/386和AIX 3.2.2，它需要1分钟才能重新启动服务器程序，这意味着它们的MSL值为30秒

  对于Solaris 2.2，它需要4分钟才能重新启动服务器程序，这表示它的MSL值为2分钟
</pre>

<p>
如果一个客户程序试图申请一个处于2MSL等待的端口（客户程序通常不会这么做），就会出现同样的差错：
</p>


<div class="figure">
<p><img src="pic/socket-time-wait-example-2.png" alt="socket-time-wait-example-2.png" width="70%" />
</p>
</div>

<ul class="org-ul">
<li>第1次执行客户程序时采用 <b>-v</b> 选项来查看它使用的本地端口为1162
</li>
<li>第2次执行客户程序时则采用 <b>-b</b> 选项来选择端口1162为它的本地端口
</li>
</ul>

<p>
正如所预料的那样，客户程序无法那么做，因为那个端口是一个还处于2MSL等待连接的一部分
</p>

<p>
需要再次强调2MSL等待的一个效果： <b>和以前介绍的一样，一个插口对（即包含本地IP地址、本地端口、远端IP地址和远端端口的4元组）在它处于2MSL等待时，将不能再被使用</b> 。尽管许多具体的实现中允许一个进程重新使用仍处于2MSL等待的端口（通常是设置选项SO_REUSEADDR），但TCP不能允许一个新的连接建立在相同的插口对上。可通过下面的试验来看到这一点：
</p>


<div class="figure">
<p><img src="pic/socket-time-wait-example-3.png" alt="socket-time-wait-example-3.png" width="70%" />
</p>
</div>

<ul class="org-ul">
<li>第1次运行sock程序中，将它作为服务器程序，端口号为6666，并从主机bsdi上的一个客户程序与它连接，这个客户程序使用的端口为1098。我们终止服务器程序，因此它将执行主动关闭。这将导致4元组140.252.13.33（本地IP地址）、6666（本地端口号）、140.252.13.35（另一端IP地址）和1098（另一端的端口号）在服务器主机进入2MSL等待
</li>
<li>在第2次运行sock程序时，我们将它作为客户程序，并试图将它的本地端口号指明为6666，同时与主机bsdi在端口1098上进行连接。但这个程序在试图将它的本地端口号赋值为6666时产生了一个差错，因为这个端口是处于2MSL等待4元组的一部
</li>
<li>为了避免这个差错，再次运行这个程序，并使用选项 <b>-A</b> 来设置前面提到的 <b>SO_REUSEADDR</b> 。这将让sock程序能将它的本地端口号设置为6666，但当我们试图进行主动打开时，又出现了一个差错。即使它能将它的本地端口设置为6666， <b>但它仍不能和主机bsdi在端口1098上进行连接，因为定义这个连接的插口对仍处于2MSL等待状态</b> 
</li>
</ul>

<p>
如果试图从其他主机来建立这个连接会如何？首先我们必须在sun上以 <b>-A</b> 标记来重新启动服务器程序，因为它需要的端口6666是还处于2MSL等待连接的一部分：
</p>
<div class="org-src-container">

<pre class="src src-sh">sun$ sock -A -s 6666 <span style="color: #ff4500;">#</span><span style="color: #ff4500;">&#21551;&#21160;&#26381;&#21153;&#22120;&#31243;&#24207;&#65292;&#22312;&#31471;&#21475;6666&#30417;&#21548;</span>
</pre>
</div>

<p>
接着，在2MSL等待结束前，我们在bsdi上启动客户程序：
</p>
<div class="org-src-container">

<pre class="src src-sh">bsdi$ sock -b1098 sun 6666

connected on 140.252.13.35.1098 to 140.252.13.33.6666
</pre>
</div>

<p>
不幸的是它成功了！这违反了TCP规范，但被大多数的伯克利版实现所支持。这些实现允许一个新的连接请求到达仍处于TIME_WAIT状态的连接，只要新的序号大于该连接前一个替身的最后序号。在这个例子中，新替身的ISN被设置为前一个替身最后序号与128000的和
</p>

<p>
对于同一连接的前一个替身，这个具体实现中的特性让客户程序和服务器程序能连续地重用每一端的相同端口号，但这只有在服务器执行主动关闭才有效
</p>
</div>
</div>

<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2">平静时间</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
对于来自某个连接的较早替身的迟到报文段，2MSL等待可防止将它解释成使用相同插口对的新连接的一部分。但这只有在处于2MSL等待连接中的主机处于正常工作状态时才有效
</p>

<p>
如果使用处于2MSL等待端口的主机出现故障，它会在MSL秒内重新启动，并立即使用故障前仍处于2MSL的插口对来建立一个新的连接吗？如果是这样，在故障前从这个连接发出而迟到的报文段会被错误地当作属于重启后新连接的报文段。无论如何选择重启后新连接的初始序号，都会发生这种情况
</p>

<p>
为了防止这种情况，RFC 793指出 <b>TCP在重启动后的MSL秒内不能建立任何连接。这就称为平静时间</b> 
</p>

<p>
只有极少的实现版遵守这一原则，因为大多数主机重启动的时间都比MSL秒要长
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">FIN_WAIT_2状态</h3>
<div class="outline-text-3" id="text-5-2">
<p>
在FIN_WAIT_2状态已经发出了FIN，并且另一端也已对它进行确认。除非我们在实行半关闭，否则将等待另一端的应用层意识到它已收到一个文件结束符说明，并向我们发一个FIN来关闭另一方向的连接。只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。
</p>

<p>
这意味着 <b>我们这端可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭</b> 
</p>

<pre class="example">
许多伯克利实现采用如下方式来防止这种在FIN_WAIT_2状态的无限等待：

如果执行主动关闭的应用层将进行全关闭，而不是半关闭来说明它还想接收数据，就设置一个定时器。如果这个连接空闲10分钟75秒，TCP将进入CLOSED状态
</pre>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">复位报文段</h3>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">同时打开</h3>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">同时关闭</h3>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">TCP选项</h2>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">TCP服务器设计</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
