<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>UDP：用户数据报协议</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="traceroute.html"> UP </a>
 |
 <a accesskey="H" href="tii.html"> HOME </a>
</div><div id="content">
<h1 class="title">UDP：用户数据报协议</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">UDP报文</a>
<ul>
<li><a href="#sec-1-1">UDP首部</a>
<ul>
<li><a href="#sec-1-1-1">UDP检验和</a>
<ul>
<li><a href="#sec-1-1-1-1">tcpdump输出</a></li>
<li><a href="#sec-1-1-1-2">统计结果</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-2">示例</a></li>
</ul>
</li>
<li><a href="#sec-2">IP分片</a>
<ul>
<li><a href="#sec-2-1">分片字段</a></li>
<li><a href="#sec-2-2">分片实例</a></li>
<li><a href="#sec-2-3">ICMP不可达差错（需要分片）</a>
<ul>
<li><a href="#sec-2-3-1">实例</a></li>
</ul>
</li>
<li><a href="#sec-2-4">MTU发现</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系
</p>

<p>
UDP数据报封装成一份IP数据报的格式如图11-1所示：
</p>


<div class="figure">
<p><img src="pic/udp-packet.png" alt="udp-packet.png" width="40%" />
</p>
</div>

<p>
UDP不提供 <b>可靠性</b> ：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，似乎觉得要避免使用UDP而使用一种可靠协议如TCP
</p>

<p>
应用程序必须关心IP数据报的长度。如果它超过网络的MTU，那么就要对IP数据报进行分片。如果需要，源端到目的端之间的每个网络都要进行分片，并不只是发送端主机连接第一个网络才这样做，本章也将讨论IP分片机制
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">UDP报文</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">UDP首部</h3>
<div class="outline-text-3" id="text-1-1">
<p>
UDP首部的各字段如图11-2所示：
</p>


<div class="figure">
<p><img src="pic/udp-header.png" alt="udp-header.png" width="40%" />
</p>
</div>

<ul class="org-ul">
<li>端口号：标识发送进程和接收进程。由于IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的

<pre class="example">
       尽管相互独立，如果TCP和UDP同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本身的要求
</pre>
</li>

<li>UDP长度字段：UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是OK）。事实上这个UDP长度是冗余的。IP数据报长度指的是数据报全长，因此UDP数据报长度是全长减去IP首部的长度（该值在IP首部长度字段中指定）
</li>
</ul>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">UDP检验和</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部，并不覆盖IP数据报中的任何数据。
</p>

<p>
UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的
</p>

<p>
尽管UDP检验和的基本计算方法与以前描述的IP首部检验和计算方法相类似（16bit字的二进制反码和），但是它们之间存在不同的地方：
</p>
<ul class="org-ul">
<li>UDP数据报的长度可以为奇数字节，但是检验和算法是把若干个16bit字相加。解决方法是必要时在最后增加填充字节0，这只是为了检验和的计算（这意味着可能增加的填充字节不被传送）
</li>
<li>UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）。UDP数据报中的伪首部格式如图11-3所示：


<div class="figure">
<p><img src="pic/udp-header.png" alt="udp-header.png" width="60%" />
</p>
</div>
</li>
</ul>

<p>
在该图中，特地举了一个奇数长度的数据报例子，因而在计算检验和时需要加上填充字节。注意，UDP数据报的长度在检验和计算过程中出现两次
</p>

<p>
如果检验和的计算结果为0，则存入的值为全1（65535），这在二进制反码计算中是等效的。如果传送的检验和为0，说明发送端没有计算检验和
</p>

<p>
如果发送端没有计算检验和而接收端检测到检验和有差错，那么UDP数据报就要被悄悄地丢弃。不产生任何差错报文
</p>

<p>
UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动
</p>

<p>
尽管UDP检验和是可选的，但是它们应该总是在用。在80年代，一些计算机产商在默认条件下关闭UDP检验和的功能，以提高使用UDP协议的NFS（Network File System）的速度。在单个局域网中这可能是可以接受的，但是在数据报通过路由器时，通过对链路层数据帧进行循环冗余检验（如以太网或令牌环数据帧）可以检测到大多数的差错，导致传输失败。不管相信与否，路由器中也存在软件和硬件差错，以致于修改数据报中的数据。如果关闭端到端的UDP检验和功能，那么这些差错在UDP数据报中就不能被检测出来。另外，一些数据链路层协议（如SLIP）没有任何形式的数据链路检验和
</p>
</div>

<div id="outline-container-sec-1-1-1-1" class="outline-5">
<h5 id="sec-1-1-1-1">tcpdump输出</h5>
<div class="outline-text-5" id="text-1-1-1-1">
<p>
很难知道某个特定系统是否打开了UDP检验和选项。应用程序通常不可能得到接收到的UDP首部中的检验和。为了得到这一点，我们在tcpdump程序中增加了一个选项，以打印出接收到的UDP检验和。如果打印出的值为0，说明发送端没有计算检验和
</p>

<p>
测试网络上三个不同系统的输出如图11-4所示。运行自编的sock程序，发送一份包含9个字节数据的UDP数据报给标准回显服务器：
</p>


<div class="figure">
<p><img src="pic/udp-dump.png" alt="udp-dump.png" width="60%" />
</p>
</div>

<p>
从这里可以看出，三个系统中有两个打开了UDP检验和选项
</p>

<p>
还要注意的是，在这个简单例子中，送出的数据报与收到的数据报具有相同的检验和值（第3和第4行，第5和第6行）。从图11-3可以看出，两个IP地址进行了交换，正如两个端口号一样。伪首部和UDP首部中的其他字段都是相同的，就像数据回显一样。这再次表明UDP检验和（事实上，TCP/IP协议簇中所有的检验和）是简单的16bit和。它们检测不出交换两个16bit的差错
</p>
</div>
</div>

<div id="outline-container-sec-1-1-1-2" class="outline-5">
<h5 id="sec-1-1-1-2">统计结果</h5>
<div class="outline-text-5" id="text-1-1-1-2">
<p>
文献[Mogul 1992]提供了在一个繁忙的NFS服务器上所发生的不同检验和差错的统计结果，时间持续了40天。统计数字结果如图11-5所示：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> 检测到不同检验和差错的分组统计结果</caption>

<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">层次</td>
<td class="right">校验和差错数</td>
<td class="right">近似总分组数</td>
</tr>

<tr>
<td class="left">以太网</td>
<td class="right">446</td>
<td class="right">170000000</td>
</tr>

<tr>
<td class="left">IP</td>
<td class="right">14</td>
<td class="right">170000000</td>
</tr>

<tr>
<td class="left">UDP</td>
<td class="right">5</td>
<td class="right">140000000</td>
</tr>

<tr>
<td class="left">TCP</td>
<td class="right">350</td>
<td class="right">30000000</td>
</tr>
</tbody>
</table>

<p>
最后一列是每一行的大概总数，因为太网和IP层还使用其他的协议。例如，不是所有的以太网数据帧都是IP数据报，至少以太网还要使用ARP协议。不是所有的IP数据报都是UDP或TCP数据，因为ICMP也用IP传送数据
</p>

<p>
注意：TCP发生检验和差错的比例与UDP相比要高得多。这很可能是因为在该系统中的TCP连接经常是“远程”连接（经过许多路由器和网桥等中间设备），而UDP一般为本地通信
</p>

<pre class="example">
       从最后一行可以看出，不要完全相信数据链路（如以太网，令牌环等）的CRC检验。应该始终打开端到端的检验和功能。而且，如果你的数据很有价值，也不要完全相信UDP或TCP的检验和，因为这些都只是简单的检验和，不能检测出所有可能发生的差错
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">示例</h3>
<div class="outline-text-3" id="text-1-2">
<p>
用我们自己编写的sock程序生成一些可以通过tcpdump观察的UDP数据报：
</p>

<div class="org-src-container">

<pre class="src src-sh">bsdi $ sock -v -u -i -n4 svr4 discard
</pre>
</div>

<pre class="example">
connected on 140.252.13.35.1108 to 140.252.13.34.9
</pre>
<p>
第1次执行这个程序时，指定verbose模式(-v)来观察ephemeral端口号，指定UDP(-u)而不是默认的TCP，并且指定源模式(-i)来发送数据，而不是读写标准的输入和输出。-n4选项指明输出4份数据报（默认条件下为1024），目的主机为svr4。discard丢弃服务。每次写操作的输出长度取默认值1024
</p>

<div class="org-src-container">

<pre class="src src-sh">bsdi $ sock -v -u -i -n4 -w0 svr4 discard
</pre>
</div>

<pre class="example">
connected on 140.252.13.35.1110 to 140.252.13.34.9
</pre>
<p>
第2次运行该程序时我们指定-w0，意思是写长度为0的数据报。两个命令的tcpdump输出结果如图11-6所示：
</p>

<div class="figure">
<p><img src="pic/sock-dump.png" alt="sock-dump.png" width="60%" />
</p>
</div>

<ul class="org-ul">
<li>输出显示有四份1024字节的数据报，接着有四份长度为0的数据报。每份数据报间隔几毫秒
</li>
<li>在发送第1份数据报之前，发送端和接收端之间没有任何通信（TCP在发送数据的第1个字节之前必须与另一端建立连接）。另外，当收到数据时，接收端没有任何确认。在这个例子中，发送端并不知道另一端是否已经收到这些数据报
</li>
<li>最后要指出的是，每次运行程序时，源端的UDP端口号都发生变化。第一次是1108，然后是1110。客户程序使用ephemeral端口号一般在1024～5000之间，正如现在看到的这样
</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">IP分片</h2>
<div class="outline-text-2" id="text-2">
<p>
正如以前描述的那样，物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上
</p>

<p>
把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。IP首部中包含的数据为分片和重新组装提供了足够的信息
</p>

<pre class="example">
     尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报。因为IP层本身没有超时重传的机制（由更高层来负责超时和重传，TCP有超时和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。当来自TCP报文段的某一片丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。因此经常要避免分片
</pre>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">分片字段</h3>
<div class="outline-text-3" id="text-2-1">
<p>
回忆IP首部，下面这些字段用于分片过程：
</p>
<ul class="org-ul">
<li>标识字段：对于发送端发送的每份IP数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中
</li>
<li>标志字段：
<ul class="org-ul">
<li>一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1
</li>
<li>一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。相反把数据报丢弃并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”）给起始端
</li>
</ul>
</li>
<li>片偏移字段：该片偏移原始数据报开始处的位置。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值
</li>
</ul>

<p>
当IP数据报被分片后，每一片都成为一个分组，具有自己的IP首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在IP首部中有足够的信息让接收端能正确组装这些数据报片
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">分片实例</h3>
<div class="outline-text-3" id="text-2-2">
<p>
使用UDP很容易导致IP分片（TCP试图避免分片，但对于应用程序来说几乎不可能强迫TCP发送一个需要进行分片的长报文段）。我们可以用sock程序来增加数据报的长度，直到分片发生。在一个以太网上，数据帧的最大长度是1500字节，其中1472字节留给数据，假定IP首部为20字节，UDP首部为8字节。我们分别以数据长度为1471,1472,1473和1474字节运行sock程序。最后两次应该发生分片：
</p>

<div class="org-src-container">

<pre class="src src-sh">bsdi $ sock -u -i -nl -w1471 svr4 discard
bsdi $ sock -u -i -nl -w1472 svr4 discard
bsdi $ sock -u -i -nl -w1473 svr4 discard
bsdi $ sock -u -i -nl -w1474 svr4 discard
</pre>
</div>

<p>
相应的tcpdump输出如下图所示：
</p>

<div class="figure">
<p><img src="pic/udp-fragment-dump.png" alt="udp-fragment-dump.png" width="60%" />
</p>
</div>

<p>
前两份UDP数据报（第1行和第2行）能装入以太网数据帧，没有被分片。但是对应于写1473字节的IP数据报长度为1501，就必须进行分片（第3行和第4行）。同理，写1474字节产生的数据报长度为1502，它也需要进行分片（第5行和第6行）
</p>

<p>
当IP数据报被分片后，tcpdump打印出其他的信息：
</p>
<ul class="org-ul">
<li>frag26304（第3行和第4行）和frag26313（第5行和第6行）指的是IP首部中标识字段的值
</li>
<li>分片信息中的下一个数字，即第3行中位于冒号和@号之间的1480，是除IP首部外的片长。两份数据报第一片的长度均为1480：UDP首部占8字节，用户数据占1472字节（加上IP首部的20字节分组长度正好为1500字节）。第1份数据报的第2片（第4行）只包含1字节数据(剩下的用户数据)。第2份数据报的第2片（第6行）包含剩下的2字节用户数据
</li>
<li>在分片时，除最后一片外，其他每一片中的数据部分（除IP首部外的其余部分）必须是8字节的整数倍，本例中1480是8的整数倍
</li>
<li>位于@符号后的数字是从数据报开始处计算的片偏移值。两份数据报第1片的偏移值均为0(第3行和第5行)，第2片的偏移值为1480（第4行和第6行）。跟在偏移值后面的加号对应于IP首部中3bit标志字段中的“更多片”比特。设置这一比特的目的是让接收端知道在什么时候完成所有的分片组装
</li>
<li>注意第4行和第6行（不是第1片）省略了协议名（UDP）、源端口号和目的端口号。协议名是可以打印出来的，因为它在IP首部并被复制到各个片中。但是， <b>端口号</b> 在UDP首部，只能在第1片中被发现
</li>
</ul>

<p>
发送的第3份数据报（用户数据为1473字节）分片情况如图11-8所示：需要重申的是， <b>任何运输层(UDP/TCP)首部</b> 只出现在第1片数据中：
</p>


<div class="figure">
<p><img src="pic/udp-fragment-packet.png" alt="udp-fragment-packet.png" width="60%" />
</p>
</div>

<p>
IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">ICMP不可达差错（需要分片）</h3>
<div class="outline-text-3" id="text-2-3">
<p>
发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小MTU是多少（路径MTU发现机制），那么这个差错就可以被该程序使用
</p>

<p>
这种情况下的ICMP不可达差错报文格式如图11-9所示，这里的格式与图6-10不同，因为在第2个32bit字中，16~31bit可以提供下一站的MTU，而不再是0：
</p>


<div class="figure">
<p><img src="pic/icmp-need-fragment.png" alt="icmp-need-fragment.png" width="60%" />
</p>
</div>

<p>
如果路由器没有提供这种新的ICMP差错报文格式，那么下一站的MTU就设为0
</p>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">实例</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
ICMP差错试图判断从路由器netb到主机sun之间的拨号SLIP链路的MTU。我们知道从sun到netb的链路的MTU：当SLIP被安装到主机sun时，这是SLIP配置过程中的一部分。以前已经通过netstat命令观察过。现在，我们想从另一个方向来判断它的MTU。在点到点的链路中，不要求两个方向的MTU为相同值
</p>

<p>
从主机solaris上运行ping程序到主机bsdi，增加数据分组长度，直到看见进入的分组被分片为止。如图11-10所示：
</p>


<div class="figure">
<p><img src="pic/sun-netb-mtu.png" alt="sun-netb-mtu.png" width="70%" />
</p>
</div>

<p>
在主机sun上运行tcpdump，观察SLIP链路，看什么时候发生分片。开始没有观察到分片，一切都很正常直到ping分组的数据长度从500增加到600字节。可以看到接收到的回显请求（仍然没有分片），但不见回显应答
</p>

<p>
为了跟踪下去，也在主机bsdi上运行tcpdump，观察它接收和发送的报文。输出如图11-11所示：
</p>


<div class="figure">
<p><img src="pic/bsdi-fragement-dump.png" alt="bsdi-fragement-dump.png" width="70%" />
</p>
</div>

<ul class="org-ul">
<li>每行中的标记（DF）说明在IP首部中设置了不分片比特。这意味着Solaris 2.2一般把不分片比特置1，作为实现路径MTU发现机制的一部分
</li>
<li>第1行显示的是回显请求通过路由器netb到达sun主机，没有进行分片，并设置了DF比特，因此可以知道还没有达到netb的SLIP MTU
</li>
<li>在第2行注意到DF标志被复制到回显应答报文中。这就带来了问题。回显应答与回显请求报文长度相同（超过600字节），但是sun外出的SLIP接口MTU为552。因此回显应答需要进行分片，但是DF标志比特又被设置了。这样，sun就产生一个ICMP不可达差错报文返回给bsdi（报文在bsdi处被丢弃）
</li>
</ul>

<p>
这就是我们在主机solaris上没有看到任何回显应答的原因。这些应答永远不能通过sun。分组的路径如图11-12所示：
</p>


<div class="figure">
<p><img src="pic/sun-netb-fragment.png" alt="sun-netb-fragment.png" width="70%" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">MTU发现</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
