<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>TCP：交互数据流</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tcp-connection.html"> UP </a>
 |
 <a accesskey="H" href="tii.html"> HOME </a>
</div><div id="content">
<h1 class="title">TCP：交互数据流</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">交互式输入</a></li>
<li><a href="#sec-2">经受时延的确认</a></li>
<li><a href="#sec-3">Nagle算法</a></li>
</ul>
</div>
</div>
<p>
前一章介绍了TCP连接的建立与释放，现在来介绍使用TCP进行数据传输的有关问题
</p>

<p>
一些有关TCP通信量的研究发现，如果按照分组数量计算，约有一半的TCP报文段包含成块数据（如FTP、电子邮件和Usenet新闻），另一半则包含交互数据（如telnet和rlogin）。如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度的（通常为512字节的用户数据），而交互数据则小得多（上述研究表明telnet和rlogin分组中通常约90%左右的用户数据小于10个字节）
</p>

<p>
很明显，TCP需要同时处理这两类数据，但使用的处理算法则有所不同。本章将以rlogin应用为例来观察交互数据的传输过程。将揭示经受时延的确认是如何工作的以及Nagle算法怎样减少了通过广域网络传输的小分组的数目，这些算法也同样适用于telnet应用。下一章将介绍成块数据的传输问题
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">交互式输入</h2>
<div class="outline-text-2" id="text-1">
<p>
首先来观察在一个rlogin连接上键入一个交互命令时所产生的数据流。许多TCP/IP的初学者很吃惊地发现通常每一个交互按键都会产生一个数据分组，也就是说 <b>每次从客户传到服务器的是一个字节的按键（而不是每次一行!）</b> 。而且rlogin需要远程系统（服务器）回显我们（客户）键入的字符。这样就会产生4个报文段：
</p>
<ol class="org-ol">
<li>来自客户的交互按键
</li>
<li>来自服务器的按键确认
</li>
<li>来自服务器的按键回显
</li>
<li>来自客户的按键回显确认
</li>
</ol>

<p>
图19-1表示了这个数据流：
</p>


<div class="figure">
<p><img src="pic/rlogin-tcp-sequences.png" alt="rlogin-tcp-sequences.png" width="70%" />
</p>
</div>

<p>
然而，一般可以将报文段2和3进行合并： <b>按键确认与按键回显一起发送</b> 。下一节将描述这种合并的技术 <b>经受时延的确认</b> 
</p>

<p>
本章我们特意使用rlogin作为例子，因为它每次总是从客户发送一个字节到服务器。以后讲到telnet的时候，将会发现它有一个选项允许客户发送一行到服务器，通过使用这个选项可以减少网络的负载
</p>

<p>
图19-2显示的是键入5个字符date\n时的数据流（没有显示连接建立的过程，并且去掉了所有的服务类型输出。BSD/386通过设置一个rlogin连接的TOS来获得最小时延）
</p>


<div class="figure">
<p><img src="pic/rlogin-tcp-dump.png" alt="rlogin-tcp-dump.png" width="70%" />
</p>
</div>

<ul class="org-ul">
<li>与字符d有关的
<ul class="org-ul">
<li>第1行：客户发送字符d到服务器
</li>
<li>第2行：该字符的确认及回显
</li>
<li>第3行：回显字符的确认
</li>
</ul>
</li>
<li>第4～6行：与字符a有关的
</li>
<li>第7～9行：与字符t有关的
</li>
<li>第10~12行：与字符e有关
</li>
</ul>

<pre class="example">
第3~4、6~7、9~10和12~13行之间半秒左右的时间差是键入两个字符之间的时延
</pre>

<ul class="org-ul">
<li>第13~15行：从客户发送到服务器的是一个字符，而回显的则是两个字符
<ul class="org-ul">
<li>客户端发送到服务器的是：按下RETURN键后产生的 <b>UNIX系统中的换行符</b>
</li>
<li>服务器发送给客户端的是：回车和换行字符( <b>CR/LF</b> )，它们的作用是将光标回移到左边并移动到下一行
</li>
</ul>
</li>
<li>第16行：来自服务器的date命令的输出
<ul class="org-ul">
<li>这30个字节由28个字符与最后的CR/LF组成
</li>
</ul>
</li>
<li>第18行：服务器发往客户的7个字符
<ul class="org-ul">
<li>服务器主机上的客户提示符： <b>svr4 %</b>
</li>
</ul>
</li>
<li>第19行：客户端确认了这7个字符
</li>
</ul>

<p>
请注意：TCP是怎样进行确认的
</p>
<ul class="org-ul">
<li>第1行以序号0发送数据字节，第2行通过将确认序号设为1，也就是 <b>最后成功收到的字节的序号加1，来对其进行确认</b> ，也就是所谓的 <b>下一个期望数据的序号</b> 
</li>
<li>第2行中服务器还向客户发送了一序号为1的数据，客户在第3行中通过设置确认序号为2来对该数据进行确认
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">经受时延的确认</h2>
<div class="outline-text-2" id="text-2">
<p>
图19-3表示了图19-2中数据交换的时间系列（在该时间系列中，去掉了所有的窗口通告，并增加了一个记号来表明正在传输何种数据）：
</p>


<div class="figure">
<p><img src="pic/rlogin-tcp-late-ack-sequences.png" alt="rlogin-tcp-late-ack-sequences.png" width="70%" />
</p>
</div>

<p>
把从bsdi发送到srv4的7个ACK标记为 <b>经受时延的ACK</b> 。通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带ACK）。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送
</p>

<p>
如果观察bsdi接收到数据和发送ACK之间的时间差，就会发现它们似乎是随机的：123.5、65.6、109.0、132.2、42.0、140.3和195.8ms。相反，观察到发送ACK的实际时间（从0开始）为：139.9、539.3、940.1、1339.9、1739.9、1940.1和2140.1ms（在图中用星号标出）。这些时间之间的差则是200ms的整数倍，这里所发生的情况是因为 <b>TCP使用了一个200ms的定时器，该定时器以相对于内核引导的200ms固定时间溢出</b> 。由于将要确认的数据是随机到达的（在时刻16.4,474.3,831.1等），TCP在内核的200ms定时器的下一次溢出时得到通知。这有可能是将来1~200ms中的任何一刻
</p>

<p>
如果观察svr4为产生所收到的每个字符的回显所使用的时间，则这些时间分别为16.5、16.3、16.5、16.4和17.3ms。由于这个时间小于200ms，因此我们在另一端从来没有观察到一个经受时延的ACK。在经受时延的定时器溢出前总是有数据需要发送（如果有一个约为16ms等待时间越过了内核的200ms时钟滴答的边界，则仍可以看到一个经受时延的ACK。在本例中我们一个也没有看到）
</p>

<p>
在图18-7中，当为检测超时而使用500ms的TCP定时器时，会看到同样的情况。这两个200ms和500ms的定时器都在相对于内核引导的时间处溢出。 <b>不论TCP何时设置一个定时器，该定时器都可能在将来1~200ms和1~500ms的任一处溢出</b> 
</p>

<pre class="example">
RFC声明TCP需要实现一个经受时延的ACK，但时延必须小于500ms
</pre>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Nagle算法</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
