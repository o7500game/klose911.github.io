<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Docker基础技术</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Docker基础技术</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Namespace</a>
<ul>
<li><a href="#sec-1-1">系统调用</a>
<ul>
<li><a href="#sec-1-1-1">clone</a></li>
</ul>
</li>
<li><a href="#sec-1-2">UTS Namespace</a></li>
<li><a href="#sec-1-3">IPC Namespace</a></li>
<li><a href="#sec-1-4">PID Namespace</a></li>
<li><a href="#sec-1-5">Mount Namespace</a>
<ul>
<li><a href="#sec-1-5-1">Docker的 Mount Namespace</a></li>
</ul>
</li>
<li><a href="#sec-1-6">User Namespace</a>
<ul>
<li><a href="#sec-1-6-1">实例</a></li>
</ul>
</li>
<li><a href="#sec-1-7">Network Namespace</a></li>
</ul>
</li>
<li><a href="#sec-2">Cgroup</a></li>
<li><a href="#sec-3">Aufs</a></li>
<li><a href="#sec-4">DeviceMapper</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Namespace</h2>
<div class="outline-text-2" id="text-1">
<p>
Linux Namespace是Linux提供的一种内核级别环境隔离的方法。很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制 
</p>

<p>
Linux Namespace 有如下种类：
</p>
<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> Linux Namespace种类</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">分类</td>
<td class="left">系统调用</td>
<td class="left">内核版本</td>
</tr>

<tr>
<td class="left">Mount namespaces</td>
<td class="left">CLONE_NEWNS</td>
<td class="left">Linux 2.4.19</td>
</tr>

<tr>
<td class="left">UTS namespaces</td>
<td class="left">CLONE_NEWUTS</td>
<td class="left">Linux 2.6.19</td>
</tr>

<tr>
<td class="left">IPC namespaces</td>
<td class="left">CLONE_NEWIPC</td>
<td class="left">Linux 2.6.19</td>
</tr>

<tr>
<td class="left">PID namespaces</td>
<td class="left">CLONE_NEWPID</td>
<td class="left">Linux 2.6.24</td>
</tr>

<tr>
<td class="left">Network namespaces</td>
<td class="left">CLONE_NEWNET</td>
<td class="left">始于Linux 2.6.24 完成于 Linux 2.6.29</td>
</tr>

<tr>
<td class="left">User namespaces</td>
<td class="left">CLONE_NEWUSER</td>
<td class="left">始于 Linux 2.6.23 完成于 Linux 3.8</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">系统调用</h3>
<div class="outline-text-3" id="text-1-1">
<p>
主要是三个系统调用：
</p>
<ul class="org-ul">
<li>clone()：实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离
</li>
<li>unshare()：使某进程脱离某个namespace
</li>
<li>setns()：把某进程加入到某个namespace
</li>
</ul>

<p>
unshare() 和 setns() 都比较简单 
</p>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">clone</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
首先，我们来看一下一个最简单的clone()系统调用的示例：
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">_GNU_SOURCE</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sched.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#23450;&#20041;&#19968;&#20010;&#32473; clone &#29992;&#30340;&#26632;&#65292;&#26632;&#22823;&#23567;1M </span><span style="color: #ff4500;">*/</span>
<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STACK_SIZE</span> (1024 * 1024)
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">container_stack</span>[STACK_SIZE];

<span style="color: #98fb98;">char</span>* <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">container_args</span>[] = {
    <span style="color: #ffa07a;">"/bin/bash"</span>,
    <span style="color: #7fffd4;">NULL</span>
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container - inside the container!\n"</span>);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#30452;&#25509;&#25191;&#34892;&#19968;&#20010;shell&#65292;&#20197;&#20415;&#25105;&#20204;&#35266;&#23519;&#36825;&#20010;&#36827;&#31243;&#31354;&#38388;&#37324;&#30340;&#36164;&#28304;&#26159;&#21542;&#34987;&#38548;&#31163;&#20102; </span><span style="color: #ff4500;">*/</span>
    execv(container_args[0], container_args); 
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent - start a container!\n"</span>);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#35843;&#29992;clone&#20989;&#25968;&#65292;&#20854;&#20013;&#20256;&#20986;&#19968;&#20010;&#20989;&#25968;&#65292;&#36824;&#26377;&#19968;&#20010;&#26632;&#31354;&#38388;&#30340;&#65288;&#20026;&#20160;&#20040;&#20256;&#23614;&#25351;&#38024;&#65292;&#22240;&#20026;&#26632;&#26159;&#21453;&#30528;&#30340;&#65289; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#31561;&#24453;&#23376;&#36827;&#31243;&#32467;&#26463; </span><span style="color: #ff4500;">*/</span>
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
从上面的程序，可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">UTS Namespace</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container - inside the container!\n"</span>);
    sethostname(<span style="color: #ffa07a;">"container"</span>,10); <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#35774;&#32622;hostname </span><span style="color: #ff4500;">*/</span>
    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent - start a container!\n"</span>);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | SIGCHLD, <span style="color: #7fffd4;">NULL</span>); <span style="color: #ff4500;">/*</span><span style="color: #ff4500;">&#21551;&#29992;CLONE_NEWUTS Namespace&#38548;&#31163; </span><span style="color: #ff4500;">*/</span>
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
运行上面的程序你会发现（需要root权限）
</p>

<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./uts
Parent - start a container!
Container - inside the container!

root@container:~$ hostname
container

root@container:~$ uname -n
container
</pre>
</div>

<p>
子进程的hostname变成了 container。
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">IPC Namespace</h3>
<div class="outline-text-3" id="text-1-3">
<p>
IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到
</p>

<p>
要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
              CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
</pre>
</div>

<p>
首先，我们先创建一个IPC的Queue：
</p>
<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ ipcmk -Q 
Message queue id: 0

klose@gentoo:~$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0
</pre>
</div>

<p>
如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue：
</p>

<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./uts
Parent - start a container!
Container - inside the container!

root@container:~$ ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0
</pre>
</div>

<p>
但是，如果我们运行加上了CLONE_NEWIPC的程序，就会看到下面的结果：
</p>
<div class="org-src-container">

<pre class="src src-sh">root@ubuntu:~$ sudo./ipc
Parent - start a container!
Container - inside the container!

root@container:~/linux_namespace$ ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</pre>
</div>

<p>
这说明IPC已经被隔离
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">PID Namespace</h3>
<div class="outline-text-3" id="text-1-4">
<p>
继续修改上面的程序：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#26597;&#30475;&#23376;&#36827;&#31243;&#30340;PID&#65292;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;&#20854;&#36755;&#20986;&#23376;&#36827;&#31243;&#30340; pid &#20026; 1 </span><span style="color: #ff4500;">*/</span>
    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);
    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());
    <span style="color: #ff4500;">/*</span><span style="color: #ff4500;">&#21551;&#29992;PID namespace - CLONE_NEWPID</span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, <span style="color: #7fffd4;">NULL</span>); 
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
运行结果如下，可以看到，子进程的pid是1了：
</p>
<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./pid
Parent [ 3474] - start a container!
Container [    1] - inside the container!

root@container:~$  echo $<span style="color: #eedd82;">$</span> 1
</pre>
</div>
<p>
在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1
</p>

<p>
但是，我们会发现，在子进程的shell里输入ps, top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的.。因此我们还需要对文件系统进行隔离
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Mount Namespace</h3>
<div class="outline-text-3" id="text-1-5">
<p>
下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统：
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#37325;&#26032;mount proc&#25991;&#20214;&#31995;&#32479;&#21040; /proc&#19979; </span><span style="color: #ff4500;">*/</span>
    system(<span style="color: #ffa07a;">"mount -t proc proc /proc"</span>);
    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#21551;&#29992;Mount Namespace - &#22686;&#21152;CLONE_NEWNS&#21442;&#25968; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
运行结果如下：
</p>
<div class="org-src-container">

<pre class="src src-sh">klose@gentoo:~$ sudo ./pid.mnt
Parent [ 3502] - start a container!
Container [    1] - inside the container!

root@container:~$ ps -elf 
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash
0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf
</pre>
</div>

<p>
我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：
</p>
<div class="org-src-container">

<pre class="src src-sh">root@container:~$ ls /proc
1          dma          key-users   net            sysvipc
16         driver       kmsg        pagetypeinfo   timer_list
acpi       execdomains  kpagecount  partitions     timer_stats
asound     fb           kpageflags  sched_debug    tty
buddyinfo  filesystems  loadavg     schedstat      uptime
bus        fs           locks       scsi           version
cgroups    interrupts   mdstat      self           version_signature
cmdline    iomem        meminfo     slabinfo       vmallocinfo
consoles   ioports      misc        softirqs       vmstat
cpuinfo    irq          modules     stat           zoneinfo
crypto     kallsyms     mounts      swaps
devices    kcore        mpt         sys
diskstats  keys         mtrr        sysrq-trigger
</pre>
</div>
<p>
下图，我们也可以看到在子进程中的top命令只看得到两个进程了：
</p>

<div class="figure">
<p><img src="pic/mount-namespace.jpg" alt="mount-namespace.jpg" width="90%" />
</p>
</div>

<p>
注意：在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离
</p>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Docker的 Mount Namespace</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
首先，需要一个rootfs，也就是需要把要做的镜像中的那些命令什么的copy到一个rootfs的目录下，模仿Linux构建如下的目录：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls
bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var
</pre>
</div>

<p>
然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin

./bin:
bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount
chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname
chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which

./usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</pre>
</div>

<p>
注意：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs/bin$ ldd bash

    linux-vdso.so.1 =&gt;  (0x00007fffd33fc000)
    libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)
</pre>
</div>

<p>
下面是我的rootfs中的一些so文件：
</p>

<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:
ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:
libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
libdl.so.2       libnss_compat.so.2     libpthread.so.0
libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
</pre>
</div>

<p>
包括这些命令依赖的一些配置文件：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~/rootfs$ ls ./etc
bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
resolv.conf  shadow
</pre>
</div>

<p>
你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中：
</p>

<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ ls ./conf
hostname     hosts     resolv.conf
</pre>
</div>

<p>
这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。
</p>

<p>
好了，终于到了我们的程序：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">_GNU_SOURCE</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/mount.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sched.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STACK_SIZE</span> (1024 * 1024)

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">container_stack</span>[STACK_SIZE];
<span style="color: #98fb98;">char</span>* <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">container_args</span>[] = {
    <span style="color: #ffa07a;">"/bin/bash"</span>,
    <span style="color: #ffa07a;">"-l"</span>,
    <span style="color: #7fffd4;">NULL</span>
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{
    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">set hostname</span>
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">remount "/proc" to make sure the "top" and "ps" show container's information</span>
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"proc"</span>, <span style="color: #ffa07a;">"rootfs/proc"</span>, <span style="color: #ffa07a;">"proc"</span>, 0, <span style="color: #7fffd4;">NULL</span>) !=0 ) {
        perror(<span style="color: #ffa07a;">"proc"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"sysfs"</span>, <span style="color: #ffa07a;">"rootfs/sys"</span>, <span style="color: #ffa07a;">"sysfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"sys"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"none"</span>, <span style="color: #ffa07a;">"rootfs/tmp"</span>, <span style="color: #ffa07a;">"tmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"tmp"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"udev"</span>, <span style="color: #ffa07a;">"rootfs/dev"</span>, <span style="color: #ffa07a;">"devtmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"dev"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"devpts"</span>, <span style="color: #ffa07a;">"rootfs/dev/pts"</span>, <span style="color: #ffa07a;">"devpts"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"dev/pts"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"shm"</span>, <span style="color: #ffa07a;">"rootfs/dev/shm"</span>, <span style="color: #ffa07a;">"tmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"dev/shm"</span>);
    }
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"tmpfs"</span>, <span style="color: #ffa07a;">"rootfs/run"</span>, <span style="color: #ffa07a;">"tmpfs"</span>, 0, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"run"</span>);
    }
    <span style="color: #ff4500;">/* </span>
<span style="color: #ff4500;">     * &#27169;&#20223;Docker&#30340;&#20174;&#22806;&#21521;&#23481;&#22120;&#37324;mount&#30456;&#20851;&#30340;&#37197;&#32622;&#25991;&#20214; </span>
<span style="color: #ff4500;">     * &#20320;&#21487;&#20197;&#26597;&#30475;&#65306;/var/lib/docker/containers/&lt;container_id&gt;/&#30446;&#24405;&#65292;</span>
<span style="color: #ff4500;">     * &#20320;&#20250;&#30475;&#21040;docker&#30340;&#36825;&#20123;&#25991;&#20214;&#30340;&#12290;</span>
<span style="color: #ff4500;">     </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"conf/hosts"</span>, <span style="color: #ffa07a;">"rootfs/etc/hosts"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0 ||
        mount(<span style="color: #ffa07a;">"conf/hostname"</span>, <span style="color: #ffa07a;">"rootfs/etc/hostname"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0 ||
        mount(<span style="color: #ffa07a;">"conf/resolv.conf"</span>, <span style="color: #ffa07a;">"rootfs/etc/resolv.conf"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0 ) {
        perror(<span style="color: #ffa07a;">"conf"</span>);
    }
    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#27169;&#20223;docker run&#21629;&#20196;&#20013;&#30340; -v, --volume=[] &#21442;&#25968;&#24178;&#30340;&#20107; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> (mount(<span style="color: #ffa07a;">"/tmp/t1"</span>, <span style="color: #ffa07a;">"rootfs/mnt"</span>, <span style="color: #ffa07a;">"none"</span>, MS_BIND, <span style="color: #7fffd4;">NULL</span>)!=0) {
        perror(<span style="color: #ffa07a;">"mnt"</span>);
    }

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">chroot &#38548;&#31163;&#30446;&#24405; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> ( chdir(<span style="color: #ffa07a;">"./rootfs"</span>) != 0 || chroot(<span style="color: #ffa07a;">"./"</span>) != 0 ){
        perror(<span style="color: #ffa07a;">"chdir/chroot"</span>);
    }

    execv(container_args[0], container_args);
    perror(<span style="color: #ffa07a;">"exec"</span>);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
sudo运行上面的程序，会看到下面的挂载信息以及一个所谓的“镜像”：
</p>
<div class="org-src-container">

<pre class="src src-sh">hchen@ubuntu:~$ sudo ./mount
Parent [ 4517] - start a container!
Container [    1] - inside the container!

root@container:/$ mount
proc on /proc type proc (rw,relatime)
sysfs on /sys type sysfs (rw,relatime)
none on /tmp type tmpfs (rw,relatime)
udev on /dev type devtmpfs (rw,relatime,<span style="color: #eedd82;">size</span>=493976k,<span style="color: #eedd82;">nr_inodes</span>=123494,<span style="color: #eedd82;">mode</span>=755)
devpts on /dev/pts type devpts (rw,relatime,<span style="color: #eedd82;">mode</span>=600,<span style="color: #eedd82;">ptmxmode</span>=000)
tmpfs on /run type tmpfs (rw,relatime)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,<span style="color: #eedd82;">errors</span>=remount-ro,<span style="color: #eedd82;">data</span>=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,<span style="color: #eedd82;">errors</span>=remount-ro,<span style="color: #eedd82;">data</span>=ordered)
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,<span style="color: #eedd82;">errors</span>=remount-ro,<span style="color: #eedd82;">data</span>=ordered)

root@container:/$ ls /bin /usr/bin
/bin:
bash   chmod  echo  hostname  less  more    mv   ping  rm   sleep  tail  test     top    truncate  uname
cat    chown  grep  ip        ln    mount   nc   ps    sed  tabs   tar   timeout  touch  tty       which
chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe      tr     umount

/usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</pre>
</div>
<p>
关于如何做一个chroot的目录，有个工具叫DebootstrapChroot
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">User Namespace</h3>
<div class="outline-text-3" id="text-1-6">
<p>
User Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）
</p>

<p>
要把容器中的uid和真实系统的uid给映射在一起，需要修改 /proc/&lt;pid&gt;/uid_map 和 /proc/&lt;pid&gt;/gid_map 这两个文件，这两个文件的格式为：
</p>

<pre class="example">
ID-inside-ns ID-outside-ns length
</pre>
<ul class="org-ul">
<li>ID-inside-ns：表示在容器显示的UID或GID
</li>
<li>ID-outside-ns：表示容器外映射的真实的UID或GID
</li>
<li>length：表示映射的范围，一般填1，表示一一对应
</li>
</ul>

<p>
比如，把真实的uid=1000映射成容器内的uid=0：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ cat /proc/2465/uid_map

0       1000          1
</pre>
</div>

<p>
再比如，把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ cat /proc/$<span style="color: #eedd82;">$</span>/uid_map

0          0          4294967295
</pre>
</div>

<p>
需要注意的是：
</p>
<ul class="org-ul">
<li>写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限
</li>
<li>写入的进程必须是此user namespace的父或子的user namespace进程
</li>
<li>另外需要满如下条件之一：
<ol class="org-ol">
<li>父进程将effective uid/gid映射到子进程的user namespace中
</li>
<li>父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid
</li>
</ol>
</li>
</ul>
</div>

<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">实例</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
我们用了一个pipe来对父子进程进行同步，这是因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">_GNU_SOURCE</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sys/mount.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;linux/capability.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;sched.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;signal.h&gt;</span>
<span style="color: #7fffd4;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>

<span style="color: #7fffd4;">#define</span> <span style="color: #eedd82;">STACK_SIZE</span> (1024 * 1024)

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">container_stack</span>[STACK_SIZE];
<span style="color: #98fb98;">char</span>* <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">container_args</span>[] = {
    <span style="color: #ffa07a;">"/bin/bash"</span>,
    <span style="color: #7fffd4;">NULL</span>
};

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pipefd</span>[2];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_map</span>(<span style="color: #98fb98;">char</span>* <span style="color: #eedd82;">file</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">outside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
    <span style="color: #98fb98;">FILE</span>* <span style="color: #eedd82;">mapfd</span> = fopen(file, <span style="color: #ffa07a;">"w"</span>);
    <span style="color: #00ffff;">if</span> (<span style="color: #7fffd4;">NULL</span> == mapfd) {
        perror(<span style="color: #ffa07a;">"open file error"</span>);
        <span style="color: #00ffff;">return</span>;
    }
    fprintf(mapfd, <span style="color: #ffa07a;">"%d %d %d"</span>, inside_id, outside_id, len);
    fclose(mapfd);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_uid_map</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">outside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">file</span>[256];
    sprintf(file, <span style="color: #ffa07a;">"/proc/%d/uid_map"</span>, pid);
    set_map(file, inside_id, outside_id, len);
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">set_gid_map</span>(<span style="color: #98fb98;">pid_t</span> <span style="color: #eedd82;">pid</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">inside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">outside_id</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>) {
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">file</span>[256];
    sprintf(file, <span style="color: #ffa07a;">"/proc/%d/gid_map"</span>, pid);
    set_map(file, inside_id, outside_id, len);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">container_main</span>(<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">arg</span>)
{

    printf(<span style="color: #ffa07a;">"Container [%5d] - inside the container!\n"</span>, getpid());

    printf(<span style="color: #ffa07a;">"Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n"</span>,
           (<span style="color: #98fb98;">long</span>) geteuid(), (<span style="color: #98fb98;">long</span>) getegid(), (<span style="color: #98fb98;">long</span>) getuid(), (<span style="color: #98fb98;">long</span>) getgid());

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#31561;&#24453;&#29238;&#36827;&#31243;&#36890;&#30693;&#21518;&#20877;&#24448;&#19979;&#25191;&#34892;&#65288;&#36827;&#31243;&#38388;&#30340;&#21516;&#27493;&#65289; </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">ch</span>;
    close(pipefd[1]);
    read(pipefd[0], &amp;ch, 1);

    printf(<span style="color: #ffa07a;">"Container [%5d] - setup hostname!\n"</span>, getpid());
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">set hostname</span>
    sethostname(<span style="color: #ffa07a;">"container"</span>,10);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">remount "/proc" to make sure the "top" and "ps" show container's information</span>
    mount(<span style="color: #ffa07a;">"proc"</span>, <span style="color: #ffa07a;">"/proc"</span>, <span style="color: #ffa07a;">"proc"</span>, 0, <span style="color: #7fffd4;">NULL</span>);

    execv(container_args[0], container_args);
    printf(<span style="color: #ffa07a;">"Something's wrong!\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gid</span>=getgid(), <span style="color: #eedd82;">uid</span>=getuid();

    printf(<span style="color: #ffa07a;">"Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n"</span>,
           (<span style="color: #98fb98;">long</span>) geteuid(), (<span style="color: #98fb98;">long</span>) getegid(), (<span style="color: #98fb98;">long</span>) getuid(), (<span style="color: #98fb98;">long</span>) getgid()); 
    pipe(pipefd);
    printf(<span style="color: #ffa07a;">"Parent [%5d] - start a container!\n"</span>, getpid());

    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">container_pid</span> = clone(container_main, container_stack+STACK_SIZE, 
                  CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, <span style="color: #7fffd4;">NULL</span>);
    printf(<span style="color: #ffa07a;">"Parent [%5d] - Container [%5d]!\n"</span>, getpid(), container_pid);

    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">To map the uid/gid, </span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span>
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">The file format is</span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">ID-inside-ns   ID-outside-ns   length</span>
    <span style="color: #ff4500;">//</span><span style="color: #ff4500;">if no mapping, </span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">the uid will be taken from /proc/sys/kernel/overflowuid</span>
    <span style="color: #ff4500;">//   </span><span style="color: #ff4500;">the gid will be taken from /proc/sys/kernel/overflowgid</span>
    set_uid_map(container_pid, 0, uid, 1);
    set_gid_map(container_pid, 0, gid, 1);

    printf(<span style="color: #ffa07a;">"Parent [%5d] - user/group mapping done!\n"</span>, getpid());

    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">&#36890;&#30693;&#23376;&#36827;&#31243; </span><span style="color: #ff4500;">*/</span>
    close(pipefd[1]);

    waitpid(container_pid, <span style="color: #7fffd4;">NULL</span>, 0);
    printf(<span style="color: #ffa07a;">"Parent - container stopped!\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
整个程序的运行效果如下：
</p>

<div class="org-src-container">

<pre class="src src-sh">klose@ubuntu16-188 ~/$ id
<span style="color: #eedd82;">uid</span>=1002(klose) <span style="color: #eedd82;">gid</span>=1002(klose) <span style="color: #eedd82;">groups</span>=1002(klose),100(users),999(docker)

klose@ubuntu16-188 ~/ $ ./user_namespace
Parent: eUID = 1002;  eGID = 1002, <span style="color: #eedd82;">UID</span>=1002, <span style="color: #eedd82;">GID</span>=1002
Parent [ 5994] - start a container!
Parent [ 5994] - Container [ 5996]!
Container [    1] - inside the container!
Container: eUID = 0;  eGID = 65534, <span style="color: #eedd82;">UID</span>=0, <span style="color: #eedd82;">GID</span>=65534
Parent [ 5994] - user/group mapping done!
Container [    1] - setup hostname!

container namespace <span style="color: #ff4500;"># </span><span style="color: #ff4500;">id</span>
<span style="color: #eedd82;">uid</span>=0(root) <span style="color: #eedd82;">gid</span>=65534(nogroup) <span style="color: #eedd82;">groups</span>=65534(nogroup)
</pre>
</div>
<p>
虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，容器的安全性会得到提高。
</p>

<p>
User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Network Namespace</h3>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Cgroup</h2>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Aufs</h2>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">DeviceMapper</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>
