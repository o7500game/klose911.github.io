#+TITLE: 寄存器机器
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 

前面研究了计算和用Lisp过程描述计算的相关问题，提出了几个 *解释器* 求值模型：
+ _代换_ 模型
+ _环境_ 模型
+ _元循环_ 模型

#+BEGIN_EXAMPLE
  元循环模型表现出求值过程的许多细节，但仍然有一些遗漏，主要是没解释 Lisp 系统里的基本控制动作。例如：

  在子表达式求出值之后，如何把值送给使用值的表达式？
  为什么有些递归过程会产生迭代型计算过程（只需常量空间），而另一些却产生递归型计算过程（需要线性以上的空间）？
#+END_EXAMPLE

原因： *求值器本身是 Lisp 程序* ，继承并利用了基础系统的结构。要进一步理解 Lisp 求值器的控制，必须转到更低的层面，研究更多实现细节

* 寄存器机器
  寄存器机器的功能是 *顺序执行一条条指令* ， *操作一组存储单元* （寄存器）。一般包含：
  + _数据通路_ ：寄存器和操作
  + _控制器_ ：确定操作顺序

  GCD 算法：
  #+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
	a
	(gcd b (remainder a b))))
  #+END_SRC

  执行本算法的机器必须维护 _a_ 和 _b_ 的轨迹，假定两个值存于 *寄存器* a 和 b 。所需操作：
  + 判断 b 是否 0，计算 a 除以 b 的余数（假定有计算设备）
  + 每一次循环迭代需要同时更新 a 和 b。由于一条简单指令只能更新一个寄存器，因此引进了 *辅助寄存器* _t_ 

  它的 _数据通路_ 如图：
  #+ATTR_HTML: image :width 30% 
  [[file:pic/gcd_data_flow.gif]] 

  为了寄存器机器能正确工作，必须 *正确控制* 其中各 *按钮的开闭顺序* 。下图是 GCD 机器的 _控制器_ ，用流程图表示：
  + 方框是动作
  + 菱形框是判断
  + 控制按箭头方向运行，进入判断后的流向由数据通路图中的检测决定
    + 控制到达 done 时工作结束，寄存器 a 里存放着计算结果

    #+ATTR_HTML: image :width 30% 
    [[file:pic/gcd_controller.gif]] 

** 寄存器机器描述语言
   #+BEGIN_EXAMPLE
     用这种图形描述很小的机器还可以，但难用于描述大型机器

     为方便使用，可以考虑一种描述寄存器机器的文本语言
   #+END_EXAMPLE

   一种设计是提供两套描述方式，分别用于描述 _数据通路_ 和 _控制器_ ：
   + 数据通路描述： *寄存器* 和 *操作* 
     + _寄存器命名_ 
     + 寄存器赋值的 _按钮命名_ 
       + 受其控制的数据传输的 *数据源* （寄存器/常量/操作）。也需给 _操作命名_ ，并说明其输入
   + 控制器是 *指令序列* ，加上一些 *表示控制入口点* 的 _标号_ 
     + 指令可为：
       + 数据通路的一个 _按钮_ ： 指定 *寄存器赋值* 动作
       + _test_ 指令：完成 *检测* 
       + _branch_ 指令:  *条件转跳* 指令，基于前面检测结果
	 + 检测为 _真_ ：  *跳转* 到 _指定标号_ 的指令
	 + 检测为 _假_ ： *继续* 下一条指令
       + _goto_ 指令： *无条件跳转* 到 _指定标号_ 
     + 标号：branch 和 goto 的 *目标* 

*** GCD 语言描述
    数据通路：
    #+BEGIN_SRC scheme
  (data-paths
   (registers
    ((name a)
     (buttons ((name a<-b) (source (register b)))))
    ((name b)
     (buttons ((name b<-t) (source (register t)))))
    ((name t)
     (buttons ((name t<-r) (source (operation rem))))))

   (operations
    ((name rem)
     (inputs (register a) (register b)))
    ((name =)
     (inputs (register b) (constant 0)))))
    #+END_SRC
    控制器：
    #+BEGIN_SRC scheme
  (controller
   test-b                           ; label
   (test =)                       ; test
   (branch (label gcd-done))      ; conditional branch
   (t<-r)                         ; button push
   (a<-b)                         ; button push
   (b<-t)                         ; button push
   (goto (label test-b))          ; unconditional branch
   gcd-done)                        ; label
    #+END_SRC

    #+BEGIN_EXAMPLE
      这种描述很难读：要理解控制器里的指令，必须仔细对照数据通路的按钮和操作的名字
    #+END_EXAMPLE
    一种改进是把 *数据通路描述融入控制器描述* ，在指令里直接说做什么

    #+BEGIN_SRC scheme
  (controller
   test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
   gcd-done)
    #+END_SRC

    #+BEGIN_EXAMPLE
      改造后语言清晰多了，但还有缺点，如：

      1. 较罗嗦，如果指令里多次提到某数据通路元素，就要多次写出其完整描述（上例简单，无此情况）。重复出现使实际数据通路结构不
      够清晰，看不清有多少寄存器操作按钮，及其互连关系

      2. 虽然指令用 Lisp 表达式表示，但实际上这里只能写合法指令
    #+END_EXAMPLE
    虽然有这些缺点，下面还是准备用这套寄存器机器语言
    #+BEGIN_EXAMPLE
      在这里比起数据通路的内部结构来说我们更关心控制器的

      反过来如果设计一台真实的计算机，最核心的部分却是如何设计数据通路
    #+END_EXAMPLE

*** GCD 机器扩展
    作为例子，现在想修改前面的 GCD 机器，使得能给它 *输入* 想求 GCD 的数，并能 *打印* 出计算结果
    #+BEGIN_EXAMPLE
      这里不准备研究读入或输出的实现
    #+END_EXAMPLE
    只假定有两个基本操作：
    + _read_ :  *产生可存入寄存器的值* ，值来自机器之外
    + _print_ :  *给环境产生某种效果* 
      + 图形上给 print 关联一个按钮，按压导致 print 执行。指令形式：

    #+BEGIN_SRC scheme
  (perform (op print) (reg a))
    #+END_SRC

    #+BEGIN_EXAMPLE
      print 和前面讨论的操作不同，它并不会把任何的计算结果保存到寄存器

      因此这里新增一个特殊的指令 perform 来标识触发 print 这样的动作
    #+END_EXAMPLE

    扩充后的 GCD 机器控制器的工作过程：
    1. 反复读入一对对数值
    2. 求出两个数的 GCD
    3. 输出

    扩充后的 GCD 寄存器模型：
    #+ATTR_HTML: image :width 30% 
    [[file:pic/gcd_extended.gif]] 

    扩充后的 GCD 控制器指令序列：
    #+BEGIN_SRC scheme
  (controller
   gcd-loop
   (assign a (op read))
   (assign b (op read))
   test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
   gcd-done
   (perform (op print) (reg a))
   (goto (label gcd-loop)))
    #+END_SRC

** 机器语言设计抽象
   #+BEGIN_EXAMPLE
     一部机器的定义总是基于一组基本操作，有些操作本身很复杂

     可能考虑把 Scheme 环境提供的操作作为基本操作
   #+END_EXAMPLE
   基于复杂操作定义机器，可以将注意力集中到某些关键方面，隐藏不关注的细节。必要时再 *基于更基本的操作构造这些操作* ，说明它们可实现。例如，
   GCD 机器的一个操作是计算 a 除以 b 的余数赋给 t。如果希望机器不以它作为基本操作，需考虑 _基于更简单的操作计算余数_ ，可以只用减法写出求余数过程：

   #+BEGIN_SRC scheme
  (define (remainder n d)
    (if (< n d)
	n
	(remainder (- n d) d)))
   #+END_SRC

   #+BEGIN_EXAMPLE
     可以用一个减法操作和一个比较代替前面机器里的求余数
   #+END_EXAMPLE

   新GCD 控制器代码（用减法实现求余）：
   #+BEGIN_SRC scheme
  (controller
   test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (reg a))
   rem-loop
   (test (op <) (reg t) (reg b))
   (branch (label rem-done))
   (assign t (op -) (reg t) (reg b))
   (goto (label rem-loop))
   rem-done
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
   gcd-done)
   #+END_SRC

   新 GCD 的数据通路和控制器：

   #+ATTR_HTML: image :width 30% 
   [[file:pic/gcd_substraction.gif]] 

   #+BEGIN_EXAMPLE
     这里是把原来的 (assign t (op rem) (reg a) (reg b)) 替换成下面的循环：

     rem-loop
	(test (op <) (reg t) (reg b))
	(branch (label rem-done))
	(assign t (op -) (reg t) (reg b))
	(goto (label rem-loop))
      rem-done
   #+END_EXAMPLE

** 子程序
   #+BEGIN_EXAMPLE
     用基于更基本操作的结构代替原复杂操作后，得到的控制器将更复杂

     下面希望能做某种安排，使相同的计算不必重复构造（以简化机器结构）
   #+END_EXAMPLE

   如果机器两次用 GCD，分别算 _a 与 b_ 和 _c 与 d_ 的 GCD，数据通路将包含两个 GCD 块，控制器也包含两段类似代码 :-( 

   #+BEGIN_SRC scheme
  gcd-1
   (test (op =) (reg b) (const 0))
   (branch (label after-gcd-1))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label gcd-1))
  after-gcd-1
    
  gcd-2
   (test (op =) (reg d) (const 0))
   (branch (label after-gcd-2))
   (assign s (op rem) (reg c) (reg d))
   (assign c (reg d))
   (assign d (reg s))
   (goto (label gcd-2))
  after-gcd-2
   #+END_SRC

   两台 GCD 的机器模型如下：

   #+ATTR_HTML: image :width 30% 
   [[file:pic/two_gcds.gif]] 

   #+BEGIN_EXAMPLE
     多次出现同样部分不经济

     现在考虑如何只用一个 GCD 部件实现
   #+END_EXAMPLE

   计算 c 和 d 的GCD时，寄存器中 a 和 b 里 的值没有用（如有用可以把它们移到其他寄存器），因此可以修改机器：
   1. 计算 c 和 d 的GCD时，先把c 和 d 的值分别移到 a 和 b
   2. 用第一个GCD通路完成计算

   这就删去了一个算GCD 的通路，控制器代码如下：

   #+BEGIN_SRC scheme
  gcd-1
  (test (op =) (reg b) (const 0))
  (branch (label after-gcd-1))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd-1))
  after-gcd-1
  ;; 这里把求 GCD 的数据 c 和 d 移入 a 和b 
  gcd-2
  (test (op =) (reg b) (const 0))
  (branch (label after-gcd-2))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd-2))
  after-gcd-2
   #+END_SRC

   #+BEGIN_EXAMPLE
     现在两个代码片段基本相同，只是入口和出口标号不同

     这里还有一些重复的控制器代码，下面考虑如何消去它们
   #+END_EXAMPLE

   1. 调用在进入 GCD 代码前把一个 _continue 寄存器_ 设为不同值
   2. 在 GCD 代码出口根据 continue 寄存器 *跳到正确执行位置* 

   得到的代码如下所示，其中只有一段计算 GCD 的代码：

   #+BEGIN_SRC scheme
  gcd
  (test (op =) (reg b) (const 0))
  (branch (label gcd-done))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd))
  gcd-done
  (test (op =) (reg continue) (const 0))       
  (branch (label after-gcd-1))
  (goto (label after-gcd-2))

  ;; 在第一次调用 gcd 之前，把 continue 寄存器设置为 0 
  (assign continue (const 0))
  (goto (label gcd))
  after-gcd-1

  ;; 在第二次调用 gcd 之前，把 continue 寄存器设置为 1 
  (assign continue (const 1))
  (goto (label gcd))
  after-gcd-2
   #+END_SRC

   #+BEGIN_EXAMPLE
     这种技术可满足本程序需要（一段代码，正确返回）

     但如果程序里有许多GCD 计算，代码会很复杂，难写也难维护

     需要考虑更一般的实现模式
   #+END_EXAMPLE

   新的思路是基于 _代码指针_ ，也就是在寄存器里 *保存控制信息* ：
   + 用一个寄存器 continue 保存 *返回地址* ，GCD 代码最后按它的内容跳转
   + 扩充 _goto_ 指令功能：
     + 参数是 _标号_ ：（直接）跳
     + 参数是 _寄存器_ ： *跳到寄存器中保存的标号* （寄存器间接跳）

   #+BEGIN_SRC scheme
  gcd
  (test (op =) (reg b) (const 0))
  (branch (label gcd-done))
  (assign t (op rem) (reg a) (reg b))
  (assign a (reg b))
  (assign b (reg t))
  (goto (label gcd))
  gcd-done
  (goto (reg continue)) ;; 间接跳转到寄存器中保存的标号

  ;; continue 寄存器保存标号
  (assign continue (label after-gcd-1)) 
  (goto (label gcd))
  after-gcd-1

  (assign continue (label after-gcd-2)) 
  (goto (label gcd))
  after-gcd-2
   #+END_SRC

   这样就实现了子程序和子程序调用
   #+BEGIN_EXAMPLE
     多个子程序调用相互无关时可以共用一个 continue 寄存器

     如果子程序里还有子程序调用，就需要多个continue 寄存器，否则会丢失外层调用的返回标号
   #+END_EXAMPLE

** 递归
   考虑阶乘过程：
   #+BEGIN_SRC scheme
  (define (factorial n)
    (if (= n 1)
	1
	(* (factorial (- n 1)) n)))
   #+END_SRC

   粗看这和计算 gcd 类似： 

   #+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
	a
	(gcd b (remainder a b))))
   #+END_SRC

   但两者有重要的区别：
   + 最后一次调用 gcd 的结果就是最终需要的结果
   + 阶乘子问题的结果并不是原问题的结果，返回后还要乘以 n

   #+BEGIN_EXAMPLE
     如采用前面设计，减值后求 n-1 的阶乘，原来的 n 值就丢了，没办法再找回来求乘积

     另外做一个机器解决子问题也不行：
     子问题还可能有子问题，初始时 n 为任意整数，因此子问题可以有任意层嵌套，
     有穷个部件无法构造出所需要的机器

     计算阶乘需要做一种安排，使所有计算能通过同一机器完成。
   #+END_EXAMPLE

   表面看需要嵌套的无穷多部机器，但任何时刻实际上只用一部，因此可以在遇到子问题时 *挂起当前计算* ，解决子问题后回来继续原计算。注意：
   + 进入 *子问题时的状态与原问题不同* （如 n 变成 n-1）
   + 为了以后能继续做中断的计算，必须 *保存状态* （当时n 的值）

   #+BEGIN_EXAMPLE
     还有控制问题，子程序结束后返回哪里？

     continue 保存返回位置，但是递归使用同一机器时又需要用这个寄存器，赋以新值就会丢掉将来要返回的位置
   #+END_EXAMPLE

   由于不知道递归的深度，需要准备保存任意多个寄存器值：
   + 这些值的 *使用顺序* 与 *保存顺序* 相反， *后存先用*
   + 用一个 *后进先出* 数据结构 *栈* 

   为保证正确返回，调用前也要把 _continue_  的值 *入栈* 

*** 阶乘递归机器
    假定有栈操作 _save_ / _restore_ ，就可以重用同一阶乘机器，完成所有子阶乘计算：
    #+BEGIN_SRC scheme
  (controller
   (assign continue (label fact-done))     ; 设置最终返回的执行地址
   fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ;; 为了执行递归，保存 continue 和 n 的值
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact)) ;; fact-loop 子程序返回后恢复，使计算可以继续执行 after-fact 
   (goto (label fact-loop))
   after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val))   ; val now contains n(n - 1)!
   (goto (reg continue))                   ; return to caller 持续调用 after-fact 最后一次调用 fact-done 
   base-case
   (assign val (const 1))                  ; base case: 1! = 1
   (goto (reg continue))                   ; return to caller 递归调用前保存返回的位置 after-fact
   fact-done)
    #+END_SRC

    #+ATTR_HTML: image :width 50% 
    [[file:pic/fact_recursive_machine.gif]] 

    #+BEGIN_EXAMPLE
      原则上说，实现递归计算需要无穷机器。这里用有穷机器实现

      但其中还是有无穷的东西：栈的存储空间没有上界
      实际机器里栈的规模有限，这就限制了机器递归的深度，也限制了能求解的阶乘的大小
    #+END_EXAMPLE

    处理递归的一般方法：
    + 用一部常规寄存器机器加一个 *栈*
    + 遇到递归调用时，把从 _子程序返回_ 后还 _需要的寄存器的值_ 存 *入栈* 
      + 特别是必须保存当时continue 寄存器的值，将来返回一定需要 

    #+BEGIN_EXAMPLE
	    可以把所有子程序调用都统一到这一模式

	    前面说的在子程序里调用子程序的麻烦也一起解决了
    #+END_EXAMPLE

*** 斐波纳契数递归机器
    考虑双递归，以过程 fib 为例：
    #+BEGIN_SRC scheme
  (define (fib n)
    (if (< n 2)
	n
	(+ (fib (- n 1) (fib (- n 2)))))) 
    #+END_SRC

    斐波纳契数计算可以实现为寄存器机器：两个递归调用都用同一机器完成。调用前设置 continue 寄存器，指明完成计算后返回的位置
    #+BEGIN_SRC scheme
  (controller
   (assign continue (label fib-done))
   fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   ;; set up to compute Fib(n - 1)
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                           ; save old value of n
   (assign n (op -) (reg n) (const 1)); clobber n to n - 1
   (goto (label fib-loop))            ; perform recursive call
   afterfib-n-1                         ; upon return, val contains Fib(n - 1)
   (restore n)
   (restore continue)
   ;; set up to compute Fib(n - 2)
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                         ; save Fib(n - 1)
   (goto (label fib-loop))
   afterfib-n-2                         ; upon return, val contains Fib(n - 2)
   (assign n (reg val))               ; n now contains Fib(n - 2)
   (restore val)                      ; val now contains Fib(n - 1)
   (restore continue)
   (assign val                        ;  Fib(n - 1) +  Fib(n - 2)
	   (op +) (reg val) (reg n)) 
   (goto (reg continue))              ; return to caller, answer is in val
   immediate-answer
   (assign val (reg n))               ; base case:  Fib(n) = n
   (goto (reg continue))
   fib-done)
    #+END_SRC

    #+BEGIN_EXAMPLE
      调用 afterfib-n-1 前必须保存 n 寄存器，因为计算 fib(n -2) 需要 n

      调用 afterfib-n-2 前必须保存 val 寄存器，此时 val 寄存器中的值是 fib(n -1)
      因为计算完 fib(n - 2) 以后需要 fib(n - 1) 做加法
    #+END_EXAMPLE


** 指令总结
