#+TITLE: 寄存器机器
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 

前面研究了计算和用Lisp过程描述计算的相关问题，提出了几个 *解释器* 求值模型：
+ _代换_ 模型
+ _环境_ 模型
+ _元循环_ 模型

#+BEGIN_EXAMPLE
  元循环模型表现出求值过程的许多细节，但仍然有一些遗漏，主要是没解释 Lisp 系统里的基本控制动作。例如：

  在子表达式求出值之后，如何把值送给使用值的表达式？
  为什么有些递归过程会产生迭代型计算过程（只需常量空间），而另一些却产生递归型计算过程（需要线性以上的空间）？
#+END_EXAMPLE

原因： *求值器本身是 Lisp 程序* ，继承并利用了基础系统的结构。要进一步理解 Lisp 求值器的控制，必须转到更低的层面，研究更多实现细节

* 寄存器机器
  寄存器机器的功能是 *顺序执行一条条指令* ， *操作一组存储单元* （寄存器）。一般包含：
  + _数据通路_ ：寄存器和操作
  + _控制器_ ：确定操作顺序

  GCD 算法：
  #+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
	a
	(gcd b (remainder a b))))
  #+END_SRC

执行本算法的机器必须维护 _a_ 和 _b_ 的轨迹，假定两个值存于 *寄存器* a 和 b 。所需操作：
+ 判断 b 是否 0，计算 a 除以 b 的余数（假定有计算设备）
+ 每一次循环迭代需要同时更新 a 和 b。由于一条简单指令只能更新一个寄存器，因此引进了 *辅助寄存器* _t_ 

它的 _数据通路_ 如图：
  #+ATTR_HTML: image :width 30% 
  [[file:pic/gcd_data_flow.gif]] 

为了寄存器机器能正确工作，必须 *正确控制* 其中各 *按钮的开闭顺序* 。下图是 GCD 机器的 _控制器_ ，用流程图表示：
+ 方框是动作
+ 菱形框是判断
+ 控制按箭头方向运行，进入判断后的流向由数据通路图中的检测决定
    + 控制到达 done 时工作结束，寄存器 a 里存放着计算结果

  #+ATTR_HTML: image :width 30% 
  [[file:pic/gcd_controller.gif]] 

** 寄存器机器描述语言
