#+TITLE: 寄存求值器
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 
用 _寄存器语言_ 实现 _求值器_ 是低层次的工作，能揭示 Scheme 程序解释中的许多前面无法涉及的控制细节，包括：
+ 过程调用时 *参数值的传递* 和 *结果返回* 
+ *尾递归* 的实现

#+BEGIN_EXAMPLE
  这里还可以继续用前面求值器的基本数据结构和语法过程

  完全可以用更基本的操作实现，做出一个可以直接对应到常规高级语言或常规机器语言的求值器
#+END_EXAMPLE
* 内存管理
  为简化讨论，先假定有一个 *表结构* 的内存， _表操作_ 都是基本操作
  #+BEGIN_EXAMPLE
    这种抽象使人能集中精力考虑求值器的关键特征

    但表存储是 Scheme 的基础，不理解它，对系统的理解有缺陷

    为完整起见，下面先讨论怎样在常规的内存上实现表存储结构
  #+END_EXAMPLE

  表结构的实现要考虑两个问题：
  1. 表示： 如何只用典型计算机的 _存储单元_ 和 _寻址_ 功能，把 *序对* 的 _指针盒子_ 结构映射到常规计算机的连续内存
  2. 实现： 把管理内存的工作实现为一个计算过程
  #+BEGIN_EXAMPLE
    要支持 Scheme 程序的执行，系统必须能随时创建对象，包括：

    程序里用的序对和其他对象
    支持程序执行而隐式创建的对象，如环境、框架和参数表等

    程序执行中可能创建很多对象，创建的数量并没有限制
  #+END_EXAMPLE

  如果计算机的存储无穷大，就可以创建任意多个对象。但 *实际计算机的存储总有限* ，因此需要有一种自动机制：利用有限的存储制造一种无穷假象， *当已分配的对象不再需要时自动将其回收* 。这就是 _垃圾回收_ 
** 向量模拟内存
   常规计算机的内存是一串很小的单元：
   + 每个单元里可保存一点信息，有一个唯一的名字称为 _地址_
   + 典型操作：
     + *读特定单元的内容*
     + *给特定单元赋新值* 
   + 通过 _地址增量_ 操作可以 *顺序地访问* 一批单元
   #+BEGIN_EXAMPLE
     有些操作（指针）要求把地址作为数据，将其存入内存单元，或在寄存器里对地址做各种运算

     “表处理”是指针运算的典型实例
   #+END_EXAMPLE

   为模拟计算机内存，下面介绍一种新数据结构称为 *向量* 。向量是一种复合数据对象，其元素可通过 *整数下标* 访问，访问所需时间与元素位置无关。用两个过程描述向量操作：
   1. _(vector-ref <vector> <n>)_ : 返回向量里的第 n 个元素
   2.  _(vector-set! <vector> <n> <value>)_ : 向量里第 n 个元素赋值为 <v>

   对计算机内存单元的访问可以通过 *地址算术* 实现（用 _向量基址_ 加 _特定元素的偏移量_ ） 

   #+BEGIN_EXAMPLE
     新型计算机内存已很难用简单向量表现

     它们有复杂的缓存系统，复杂的缓存一致性算法
     多核的加入使情况进一步复杂化，理解其细节行为变得更加困难，需要通过复杂的模拟

     但这种抽象模型仍反映了它的一部分情况和性质
   #+END_EXAMPLE
*** Scheme 序对的表示
    用向量实现表存储器所需的序对结构：
    1. 设想两个向量 _the-cars_ 和 _the-cdrs_ 
    2. _指向序对的指针_ 用 *向量的下标* 表示， _序对的 car_ 就是 _向量 the-cars_ 里 *特定元素的内容* ，cdr 类似

    #+ATTR_HTML: image :width 60% 
    [[file:pic/pair-representaion.gif]] 

    非序对数据用 *带类型指针* 表示。为此要扩充指针增加类型信息：
    + 可以在指针里加 _标志位_ 
    + 如果有带标志位的硬件机器，也可利用地址中不用的位 

    #+BEGIN_EXAMPLE
    eq? 就是比较指向序对的指针的值是否相同
    #+END_EXAMPLE
    *符号* 用 _带类型指针_ 表示：
    + 实际的 Scheme 系统里有一个 *符号表* ，称为 _对象表_ 
      + 读入遇到新符号时 _创建表项_ ，取得 _符号指针_ 
*** 基本表操作实现
    #+BEGIN_EXAMPLE
      有了序对的上述表示，基本表操作都可以“代换”为向量操作
    #+END_EXAMPLE
    下面假定有 _向量访问_ 和 _赋值_ ， _指针算术运算_ ： 

    寄存器机器支持的 _赋值_  指令 ：

    #+BEGIN_EXAMPLE
      ;;; reg2 寄存器中存放了一个序对在向量数组的下标，把这个序对的car内容放入到 reg1 寄存器
      (assign <reg1> (op car) (reg <reg2>))

      ;;; reg2 寄存器中存放了一个序对在向量数组的下标，把这个序对的car内容放入到 reg1 寄存器
      (assign <reg1> (op cdr) (reg <reg2>))
    #+END_EXAMPLE 

    可以实现为： 

    #+BEGIN_SRC scheme
  ;;; 类似于调用 (vector-ref the-cars reg2)
  ;;; the-cars 寄存器:  cars 向量的基础地址
  ;;; reg2 寄存器: 序对在向量数组的下标
  (assign <reg1> (op vector-ref) (reg the-cars) (reg <reg2>))

  ;;; 类似于调用 (vector-ref the-cdrs reg2)
  ;;; the-cdrs 寄存器:  cdrs 向量的基础地址
  ;;; reg2 寄存器: 序对在向量数组的下标
  (assign <reg1> (op vector-ref) (reg the-cdrs) (reg <reg2>))
    #+END_SRC

    寄存器机器的 _执行_ 指令：

    #+BEGIN_EXAMPLE
      ;;; 把 reg1 寄存器的内容 赋值给 reg2寄存器对应的序对的car上
      (perform (op set-car!) (reg <reg1>) (reg <reg2>))

      ;;; 把 reg1 寄存器的内容 赋值给 reg2寄存器对应的序对的cdr上
      (perform (op set-cdr!) (reg <reg1>) (reg <reg2>))
    #+END_EXAMPLE 

    实现为： 
    #+BEGIN_SRC scheme
  ;;; 这里调用 (vector-set! the-cars reg2 reg1)
  ;;; the-cars 寄存器：cars向量的基础地址
  ;;; reg1 寄存器: 赋值内容
  ;;; reg2 寄存器: 序对下标
  (perform
   (op vector-set!) (reg the-cars) (reg <reg1>) (reg <reg2>))

  ;;; 这里调用 (vector-set! the-cdrs reg2 reg1)
  ;;; the-cdrs 寄存器：cdrs向量的基础地址
  ;;; reg1 寄存器: 赋值内容
  ;;; reg2 寄存器: 序对下标
  (perform
   (op vector-set!) (reg the-cdrs) (reg <reg1>) (reg <reg2>))
    #+END_SRC

    执行 cons 时 *创建* 新序对单元，分别存入相应的 _car_ 和 _cdr_ 。假定特殊寄存器 *free*  总指向一个空闲下标，增加其值可得到下一可用下标（要
    求空闲位置连续）。这时 _cons_ 指令 可以实现为： 

    #+BEGIN_SRC scheme
  ;;; (vector-set! the-cars free reg2) 
  (perform
   (op vector-set!) (reg the-cars) (reg free) (reg <reg2>))

  ;;; (vector-set! the-cdrs free reg3) 
  (perform
   (op vector-set!) (reg the-cdrs) (reg free) (reg <reg3>))

  ;;; free 赋值给 reg1  
  (assign <reg1> (reg free))

  ;;; free 的值增加 1 
  (assign free (op +) (reg free) (const 1))
    #+END_SRC

    _eq?_ 操作只是简单比较 reg1 和 reg2 的值是否相同（向量中的下标值是否相同） 
    #+BEGIN_EXAMPLE
      (op eq?) (reg <reg1>) (reg <reg2>) 
    #+END_EXAMPLE

    _pair?_ ,  _null?_ ,  _symbol?_ ,  _number?_ 等操作还必须检查 *指针的类型* 是否相同
*** 栈实现
    寄存器机器需要的 _栈_ 可以用 *表* 模拟， _栈头序对_ 在 _向量中的下标_ （栈顶地址）用一个特殊寄存器 *the-stack* 来存放

    #+BEGIN_EXAMPLE
      这些操作都可以基于前面使用向量模拟的内存

      实际系统里考虑实现效率，常另用一个向量来实现栈，压栈和出栈操作用改变栈顶寄存器的指针值来实现
    #+END_EXAMPLE

    压栈    _(save <reg>)_ 可以实现为： 
    #+BEGIN_SRC scheme
  ;;; (cons reg the-stack) 
  ;;; reg 寄存器: 序对的下标
  ;;; the stack 寄存器: 栈顶对应的下标
  ;;; cons返回的新的序对的下标会被赋值给 the-stack 寄存器，这相当于修改了栈顶指针
  (assign the-stack (op cons) (reg <reg>) (reg the-stack))
    #+END_SRC

    出栈    _(restore <reg>)_ 实现为： 

    #+BEGIN_SRC scheme
  ;;; 从栈顶读取值
  (assign <reg> (op car) (reg the-stack))

  ;;; “栈顶寄存器”赋值为“当前栈顶序对的cdr”的“向量下标”
  (assign the-stack (op cdr) (reg the-stack))
    #+END_SRC

    初始化栈    _(perform (op initialize-stack))_ 实现为：
    #+BEGIN_SRC scheme
  (assign the-stack (const ()))
    #+END_SRC

** 垃圾回收机制
   #+BEGIN_EXAMPLE
     表结构的实现问题已经解决了，但有前提：保证执行 cons 时总有可用的自由空间，为此需要无穷大的存储

     而在实际计算中不断执行 cons，最终将用尽整个序对空间
   #+END_EXAMPLE

   观察到： 所建立的序对里的很多都是用于保存各种 *临时* 数据
   + 中间结果
   + 临时建立的环境框架
   + ......
   相关数据用过后可以被丢弃，其存储也没有必要继续保留 

   #+BEGIN_EXAMPLE
     (accumulate + 0 (filter odd? (enumerate-interval 0 n)))

     执行过程中构造了两个表：枚举表和奇数表，求和完成后都不再需要了
   #+END_EXAMPLE

   系统需要做出一种安排， _周期性_ 地 *回收* _已分配但不再有用_ 的内存。如果回收与分配的速度相当，而且程序每个时刻实际使用的单元不多于可供应的单元，系统就可以永远运转。这造成了一种无穷大存储的假象

   #+BEGIN_EXAMPLE
     要回收不用的序对，需要确定那些需对确实没用了，也就是说，其（内容）存在与否对后面的计算没有任何影响
   #+END_EXAMPLE
   下面提出的方法称为 *垃圾收集* ，其基本思想：
   1. 确定所有的有用单元：从 _当前所有寄存器的内容_ 出发，通过一系列的 _car/cdr 操作_  *可以到达* 的单元
   2. 不可达的单元都可以回收

   #+BEGIN_EXAMPLE
     典型的基本垃圾回收方法有两类，后来有许多发展：
     包括分代式垃圾回收，并行垃圾回收，以及各种更复杂的环境里的垃圾回收等

     垃圾回收已经成为支持软件系统运行的基本技术
   #+END_EXAMPLE

   简单的垃圾回收工作周期性地进行：
   + 当时工作存储区满时中断计算，启动新一轮垃圾回收
   + 回收完成后重启暂停的计算工作

*** 垃圾回收算法
    最早的技术称为“标记和清扫”(mark and sweep)，工作方式：
    1. 从寄存器出发沿car 和 cdr 指针周游单元存储区，给单元加标记
    2. 扫描整个存储器，回收无标记单元
    #+BEGIN_EXAMPLE
      标记清除算法最主要的缺点是会形成内存碎片
    #+END_EXAMPLE
    另一种技术 (stop-and-move)，基于复制有用对象（搬迁有用的对象），基本想法：把一片存储区里的有用对象都搬走，使得整个存储区都可以重用了
    + 存储区分为相等的两个半区 _工作存储区_ 和 _自由存储区_
    + cons 总在 _工作存储区_ 里顺序分配，每次分配下一位置
    + _工作存储区_ 满时做垃圾收集，把 所有 *有用序对* 搬到 _自由存储区_ 
      + 从所有寄存器出发追踪 _car_  和 _cdr_ 指针
    + 如果工作存储区里存在无用单元，搬迁完成后自由存储区应 *剩下可用于分配的空闲单元*
    + 完成一次搬迁后 *交换* _工作存储区_ 和 _自由存储区_ 的地位

    #+BEGIN_EXAMPLE
      复制算法的优点是效率更高，缺点是可用内存减少为一半
    #+END_EXAMPLE

**** 复制垃圾回收算法的实现
     + 假定寄存器 root 值为一个指针，从所指的结构可以到达所有在用单元
     + _the-cars_ 和 _the-cdrs_ 指向的两个向量是 *工作区*
     + _new-cars_ 和 _new-cdrs_ 指的两个向量是 *自由区*
     + _free_ 指向 _工作区里第一个空闲单元_ ，它的值随着分配移动，到达存储器右端时：空闲单元已用完
     + 废料收集前后情况如图 
     + 收集完成后 *交换两对向量指针* ，实现存储区的 _切换_ 

       #+ATTR_HTML: image :width 70% 
       [[file:pic/stop-and-move.gif]] 

     收集过程维护两个指针 *free* 和 *scan* ，收集的 _初始化_ 操作：
     1. 把 free 和 scan 设置为指向 _自由区起点_ 
     2. 把 _root 所指单元_ 复制到 _自由区的第一个单元_ 
     3. _root 所指单元的 car_ 设一个 *特殊标志* ， _root 所指单元的 cdr_  设为 *free*  (单元新位置)
     4. _root_  指向 *新位置* ，更新 free 使之指向 *下一空单元* 

     #+BEGIN_EXAMPLE
       注意：scan 指向已移入新区(收集前的 自由区 ) 的单元，但其 car 和 cdr 所指单元可能还在老的工作区
     #+END_EXAMPLE

     收集过程: 若scan < free，反复做： 
     + 若 scan 所指单元的 car 还在老区就将它搬到新区 free 处。设置原单元的 car 为特殊标志，cdr 为 free，将 free 增加一个单元
     + 若 scan 所指单元的 cdr还在老区就将它搬到新区free 处。置原单元的 car 为特殊标志，cdr 为 free，将 free 增加一个单元
     + 若发现被 scan 所指单元的 car/cdr 所指的老区单元有特殊标志，则更新这个 car/cdr，使之正确指向该单元的新位置
     + 反复上述操作至 _scan_ 和 _free_  *相等时* 收集完成

**** 寄存器语言实现垃圾回收
     用寄存器机器语言描述算法。关键代码段 *relocate-old-result-in-new* 给表单元确定新位置，被移对象由寄存器 _old_ 当时的值确定，新位置由
     寄存器 _free_ 当前值确定。将新位置存入寄存器 _new_ 并更新 *free* 。最后根据寄存器 _relocate-continue_ 的值转跳返回

     启动垃圾收集后首先设置 _scan_ 和 _free_ ，而后调用上述子程序先为 root 所指单元重新分配位置

     #+BEGIN_SRC scheme
  begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root)) ;; 让 old 指向老工作区里被处理的单元 
  (assign relocate-continue (label reassign-root)) 
  (goto (label relocate-old-result-in-new)) ;; 将 root 单元搬到新区

  reassign-root
  (assign root (reg new)) ;; 让 root 指向结点的新位置
  (goto (label gc-loop)) ;;  调用基本 gc 循环
     #+END_SRC

     gc-loop 主循环：
     #+BEGIN_SRC scheme
  gc-loop
  ;; 检查是否还有未扫描单元 (scan 不等于 free)
  (test (op =) (reg scan) (reg free)) 
  (branch (label gc-flip)) ;; 基本收集循环结束，最后收尾
  ;; 将 old 设为新区中 scan 指向的单元的 car 所指的单元（可能是需要搬迁的下一个老区单元，也可能已经搬过来了）
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  ;; 将 relocate-continue 寄存器设置为 update-car ：因为复制完老的car后，还必须更新序对的car的值（新工作区的下标值）
  (assign relocate-continue (label update-car))
  ;; 执行 relocate-old-result-in-new 标号位置的代码：实际处理scan指向的car单元的搬迁工作
  (goto (label relocate-old-result-in-new)) 
     #+END_SRC

     update-car 操作： 
     #+BEGIN_SRC scheme
  update-car
  ;; 将 scan 所指单元的 car 设置为 new
  (perform (op vector-set!) (reg new-cars) (reg scan) (reg new)) ;;  寄存器 new 里是 car 所指单元的新位置
  ;;  将 old 设为新区中 scan 指向的单元的 cdr 所指的单元（可能是需要搬迁的下一个老区单元，也可能已经搬过来了）
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  ;; 将 relocate-continue 寄存器设置为 update-cdr ：因为复制完老的cdr后，还必须更新序对的cdr的值（新工作区的下标值）
  (assign relocate-continue (label update-cdr))
  ;; 处理scan指向的cdr单元的搬迁工作
  (goto (label relocate-old-result-in-new)) 
     #+END_SRC

     update-cdr 操作：
     #+BEGIN_SRC scheme
  update-cdr
    ;; 将 scan 所指单元的 cdr 设置为 new
    (perform (op vector-set!) (reg new-cdrs) (reg scan) (reg new)) ;; 寄存器 new 里是 car 所指单元的新位置
    (assign scan (op +) (reg scan) (const 1)) ;; scan 自增 1 
    (goto (label gc-loop)) ;; 重启垃圾收集主循环
     #+END_SRC

     relocate-old-result-in-new 核心过程：
     #+BEGIN_SRC scheme
  relocate-old-result-in-new
  ;; 测试指针类型是否是“序对”
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue)) ;; 非序对对象，直接返回 

  pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr)) ;; 这个对象是否已经回收过？ 
  (branch (label already-moved))
  (assign new (reg free)) ; new 寄存器设置为 free 寄存器的值
  (assign free (op +) (reg free) (const 1)) ;; free 寄存器自增 1 
  ;; 将这个单元的 car 和 cdr 拷贝到新位置
  (perform (op vector-set!)
	   (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
	   (reg new-cdrs) (reg new) (reg oldcr)) 
  ;; 构建 broken heart：在原位置设置的 car 设搬迁标志，cdr 设索引指针
  (perform (op vector-set!)
	   (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))

  already-moved
  ;; 单元已在新区，直接设置 new 后返回
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
     #+END_SRC

     收尾工作 gc-flip ：交换两个（半）存储区的地位
     #+BEGIN_SRC scheme
  gc-flip
    (assign temp (reg the-cdrs))
    (assign the-cdrs (reg new-cdrs))
    (assign new-cdrs (reg temp))
    (assign temp (reg the-cars))
    (assign the-cars (reg new-cars))
    (assign new-cars (reg temp))
     #+END_SRC

* 寄存求值器
