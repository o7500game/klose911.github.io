#+TITLE: 寄存求值器
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 
用 _寄存器语言_ 实现 _求值器_ 是低层次的工作，能揭示 Scheme 程序解释中的许多前面无法涉及的控制细节，包括：
+ 过程调用时 *参数值的传递* 和 *结果返回* 
+ *尾递归* 的实现

#+BEGIN_EXAMPLE
  这里还可以继续用前面求值器的基本数据结构和语法过程

  完全可以用更基本的操作实现，做出一个可以直接对应到常规高级语言或常规机器语言的求值器
#+END_EXAMPLE
* 内存管理
为简化讨论，先假定有一个 *表结构* 的内存， _表操作_ 都是基本操作
#+BEGIN_EXAMPLE
  这种抽象使人能集中精力考虑求值器的关键特征

  但表存储是 Scheme 的基础，不理解它，对系统的理解有缺陷

  为完整起见，下面先讨论怎样在常规的内存上实现表存储结构
#+END_EXAMPLE

表结构的实现要考虑两个问题：
1. 表示： 如何只用典型计算机的 _存储单元_ 和 _寻址_ 功能，把 *序对* 的 _指针盒子_ 结构映射到常规计算机的连续内存
2. 实现： 把管理内存的工作实现为一个计算过程
#+BEGIN_EXAMPLE
  要支持 Scheme 程序的执行，系统必须能随时创建对象，包括：

  程序里用的序对和其他对象
  支持程序执行而隐式创建的对象，如环境、框架和参数表等

  程序执行中可能创建很多对象，创建的数量并没有限制
#+END_EXAMPLE

如果计算机的存储无穷大，就可以创建任意多个对象。但 *实际计算机的存储总有限* ，因此需要有一种自动机制：利用有限的存储制造一种无穷假象， *当已分配的对象不再需要时自动将其回收* 。这就是 _垃圾回收_ 
** 向量模拟内存

** 垃圾回收机制
