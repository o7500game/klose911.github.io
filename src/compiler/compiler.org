#+TITLE: 求值器编译
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 

#+BEGIN_EXAMPLE
  显式控制求值器是一部寄存器机器，其控制器能解释 Scheme 程序
#+END_EXAMPLE
下面研究如何在控制器不是 Scheme 解释器的寄存器机器上运行 Scheme 程序

#+BEGIN_EXAMPLE
  显式控制求值器是解释 Scheme 程序的通用机器：

  其控制器与数据通路配合，可执行任何计算过程
  其数据通路也是通用的
#+END_EXAMPLE

普通计算机也都是通用寄存器机器，基于：
+ 一组 *寄存器*
+ 一组 _操作_ ：高效方便的 *数据通路* 
  + _控制器_ ：一个 _寄存器机器语言_ （本机语言） *解释器* 
  + _程序_ ： 使用 *机器的数据通路的指令序列* 

#+BEGIN_EXAMPLE
  可以把显式控制求值器的指令序列看作一台通用计算机的机器语言程序，而不看作一部特定解释器机器的控制器
#+END_EXAMPLE

要在寄存器机器上运行高级语言程序，就要在 _高级语言_ 和 _寄存器机器语言_ 间架一座桥梁。有两种策略： *解释* 和 *编译* 
* 解释和编译
  #+BEGIN_EXAMPLE
    显式控制求值器采用的是解释策略：

    用本机语言写一个解释器，它配置该机器使之能执行源语言（与本机语言完全不同）的程序

    源语言的基本过程采用本机语言写出的子程序库实现。被解释程序（源程序）用数据结构表示

    解释器遍历表示程序的数据结构，分析源程序的情况，模拟其行为（需要利用库里的子程序）
  #+END_EXAMPLE
  另一种策略是 *编译* ：针对给定 _源语言_ 和 _给定机器_ 的编译器，将 _源程序_  *翻译* 为 _本机语言的等价程序_ （目标程序），然后就可以让目标程序自己运行了

  + 编译策略可能大大 *提高程序执行效率*
  + 解释器能为程序的 *开发和排错* 提供强大帮助
    + 被执行源代码在运行期间可用，可以方便地检查和修改
    + 由于所有基本操作的库都在，因此可以支持在修改程序和排错过程中构造新程序，并将新程序随时加入系统

  #+BEGIN_EXAMPLE
    编译和解释优势互补，现代开发环境推崇混合策略。Lisp 解释器一般都允许解释性程序和编译性程序相互调用：

    这样已完成的部分可以通过编译取得效率优势；正在开发而不断变化的部分通过解释执行
  #+END_EXAMPLE

  下面实现的编译器把 _Scheme 写的程序_ （源程序）翻译为 _显式控制求值器的数据通路_ 能执行的 _指令序列_ （目标程序）。编译器的做完后，还要说明如何将它与解释器连接，形成一个集成的编译器-解释器开发环境
* 机制
  编译器分析表达式的机制与解释器类似。为使编译代码能与解释代码互连，生成代码遵循同样寄存器规则：
  + 执行环境在 env
  + 实参表在 argl 里积累
  + 被应用过程在 proc
  + 过程值通过 val 返回
  + 过程将要用的返回地址放在 continue

  #+BEGIN_EXAMPLE
    从一个源程序生成的目标程序在执行中所做的寄存器操作，本质上就是解释器求值同一个源程序时执行的那些操作
  #+END_EXAMPLE

  编译器在技术上与前面 _分析型求值器_ 类似，遍历表达式：遇到解释器求值表达式时 _执行一条寄存器指令_ 的情况，它将 *这条指令放到一个序列* 里。最终得到的 _指令序列_ 就是所需 *目标代码* 

  #+BEGIN_EXAMPLE
    以求值 (f 84 96) 为例：

    解释器每次求值表达式时都要做表达式分类（发现是过程应用），并检查表示表达式的表是否结束（弄清有两个运算对象）

    编译器只在编译源程序并生成指令序列时做一次表达式分析：
    产生的目标代码里只有对运算符和运算对象求值的指令，以及将过程（保存在 proc）应用于实参（保存在 argl）的指令
  #+END_EXAMPLE

  + 解释器必须考虑处理 *所有* 表达式
  + 编译结果代码完成 *特定* 表达式
  #+BEGIN_EXAMPLE
    以保存寄存器为例：

    解释器要准备处理所有可能，求值子表达式前必须把后来可能用的所有寄存器进栈（不知道子表达式会做什么）
    编译器可以根据具体表达式的情况，只生成必要的栈操作

    考虑对 (f 84 96)  的处理：

    解释器求值 f 前后保存恢复运算对象和环境寄存器 (都可能有用)，最后把 val 的值移到 proc （先放到 val 再移到 proc）

    由于运算符就是 f （编译时候就能确定这是一个变量表达式，而不是一个过程表达式），求值由机器操作 lookup-variable-value 完成，不修改寄存器
    编译代码只需要一条指令做运算符求值：
    (assign proc (op lookup-variable-value) (const f) (reg env)) 
    不需要保存和恢复，值直接赋给 proc
  #+END_EXAMPLE

  在很多情况时候编译可以 *优化环境访问* ：
  + 通过分析代码，许多情况时候可以确定特定值所在框架，然后直接访问该框架，不需要用 lookup-variable-value 搜索
  + 直接处理某些基本操作，而不通过通用的 apply

  #+BEGIN_EXAMPLE
    这里并不准备特别强调各种优化，主要目标是在一个简化（但仍然很有意思）的上下文中展示编译过程的各种情况
  #+END_EXAMPLE
* 框架
  + 工作方式类似 _分析求值器_ ，但生成的是能在 _寄存器机器_ 上运行的 *指令序列* 
  + _表达式的语法过程_ 就是 _元循环求值器_ 用的 *Scheme过程* 
  + _显式控制求值器_ 假定语法过程是 *寄存器机器操作* 

  *compile* 做最高层分派（对应 eval 或 analyze），按 _表达式语法类型_ 指派 _特定代码生成器_ ：
  #+BEGIN_SRC scheme
    (define (compile exp target linkage)
      (cond ((self-evaluating? exp)
	     (compile-self-evaluating exp target linkage))
	    ((quoted? exp) (compile-quoted exp target linkage))
	    ((variable? exp)
	     (compile-variable exp target linkage))
	    ((assignment? exp)
	     (compile-assignment exp target linkage))
	    ((definition? exp)
	     (compile-definition exp target linkage))
	    ((if? exp) (compile-if exp target linkage))
	    ((lambda? exp) (compile-lambda exp target linkage))
	    ((begin? exp)
	     (compile-sequence (begin-actions exp)
			       target
			       linkage))
	    ((cond? exp) (compile (cond->if exp) target linkage))
	    ((application? exp)
	     (compile-application exp target linkage))
	    (else
	     (error "Unknown expression type -- COMPILE" exp))))
  #+END_SRC
** 目标寄存器和连接描述符
   compile 及其调用的代码生成器都另有两个参数：
   1. target :  所 _生成代码段_ 将 _表达式的值_ 存入的 _寄存器_
   2. linkage : 连接描述符，描述表达式的编译结果代码完成后如何继续，有几种可能动作：
      + 连接描述符 *next* ：继续序列里的下一条指令
      + 连接描述符 *return* ：从被编译的过程返回
      + *指定标号* 作为连接描述符：跳到一个命名入口点

   #+BEGIN_EXAMPLE
     以 val 寄存器为目标以 next 为连接描述符编译表达式 '5' 产生：
     (assign val (const 5)) ;; 接着执行下一指令

     以 return 作为连接描述符，则生成：
     (assign val (const 5))
     (goto (reg continue)) ;; 要求从一个过程返回
   #+END_EXAMPLE
** 指令序列和堆栈使用
   代码生成器返回由 _被编译表达式_ 生成的 _目标代码_ 的 _指令序列_ 

   复合表达式的代码是通过 *组合* _子表达式的代码_ 建立的。组合指令序列的最简单方式是调用 _append-instruction-sequences_ 过程：直接 *顺序* 拼接任意数目的参数指令序列，返回组合指令序列

   #+BEGIN_EXAMPLE
     如果 <seq1> 和 <seq2> 都是指令序列

     那么 (append-instruction-sequences <seq1> <seq2>) 产生的序列是：
     <seq1>
     <seq2>
   #+END_EXAMPLE

   如果执行中有可能需要保存寄存器，就用 _preserving_ 实现精细组合。过程的参数：
   + R : *寄存器集合*
   + <seq1>,<seq2> : 两个 *顺序执行的指令序列* 

   #+BEGIN_EXAMPLE
     preserving 保证如果 R 中任一寄存器 s 的值在 <seq2>里用，其值就不会受到 <seq1>的影响，如：

     <seq1>修改 s 而 <seq2> 需要 s 的原值，preserving 会在 <seq1>外面包上对 s 的 save  和 restore
     没这种情况时就 简单连接
   #+END_EXAMPLE
   因此 _(preserving (list <reg1><reg2>) <seq1><seq2>)_ 可能产生四种结果：

   #+ATTR_HTML: :border 1 :rules all :frame boader
   | <seq1> | (save <reg1>)    | (save <reg2>)    | (save <reg1>)    |
   | <seq2> | <seq1>           | <seq1>           | (save <reg2>)    |
   |        | (restore <reg1>) | (restore <reg2>) | <seq1>           |
   |        | <seq2>           | <seq2>           | (restore <reg2>) |
   |        |                  |                  | (restore <reg1>) |
   |        |                  |                  | <seq2>           |

   用 preserving 组合指令序列：
   + 避免不必要的堆栈操作
   + 把生成 save 和 restore 的细节封装在preserving内部，与代码生成的具体情况分离。所有代码生成器都不显式生成 save 和 restore

*** 指令序列的构造
    #+BEGIN_EXAMPLE
      如果用表表示指令序列，append-instruction-sequences 就是 append

      但 preserving会很复杂：要分析并确定寄存器使用情况
      低效：需分析每个指令序列，即使前面由 preserving构造时已分析过
    #+END_EXAMPLE
    为避免重复分析，给 _每个指令序列_ *关联*  _寄存器使用_ 信息：
    + 简单指令序列：直接确定
    + 组合指令： *推导* 出组合的使用信息

    指令序列要包含三部分信息：
    1. 使用的寄存器：序列中指令 *执行前必须初始化* 的 _寄存器集合_ 
    2. 这一序列 *执行时修改* 的 _寄存器的集合_ 
    3. 语句：序列里的实际指令

    因此把指令序列表示为包含这三个部分的表，构造函数：
    #+BEGIN_SRC scheme
  ;;; 指令序列构造函数
  ;;; needs: 需要使用的寄存器集合
  ;;; modifies: 执行是修改的寄存器集合
  ;;; statements: 语句 
  (define (make-instruction-sequence needs modifies statements)
    (list needs modifies statements))
    #+END_SRC

    下面是一个包含两条指令的序列，它找出变量 x 的值赋给 val 后返回，要求执行前初始化寄存器 env 和 continue，并修改寄存器 val：
    #+BEGIN_SRC scheme
  (make-instruction-sequence '(env continue) '(val)
			     '((assign val
				       (op lookup-variable-value) (const x) (reg env))
			       (goto (reg continue))))
    #+END_SRC

    有时需要构造 _不含语句_ 的指令序列：
    #+BEGIN_SRC scheme
  (define (empty-instruction-sequence)
    (make-instruction-sequence '() '() '()))
    #+END_SRC

    组合指令序列的各种过程下面讨论

* 表达式编译
  下面考虑各种表达式的编译，实现由 compile 分派的各种代码生成器

  其中会用到反引号表达式 _`(...)_  。与 _引号表达式_ 类似，被引表达式不求值。但表达式里的 *,exp* 情况特殊，需要 *把 exp 求出的值* 放在该位置
  #+BEGIN_EXAMPLE
    例如：设 place 的值是 (China Beijing)，howlong 的值是 (5 years)

    `(I live in ,place for ,howlong) 的值是 (l live in (China Beijing) for (5 years))
  #+END_EXAMPLE

  这种表达式提供了一个框架，其中 _,e_ 的内容用 *e 求出的值* 填充

** 连接代码
   生成代码最后总是 _compile-linkage_ 生成的 *连接指令* ：
   + _return_ :  生成 *(goto(regcontinue))* ，不修改寄存器
   + next: 不生成指令
   + 标号: 生成 *goto指令* ，不需要也不修改寄存器

   #+BEGIN_SRC scheme
     ;;; 编译连接代码
     ;;; linkage: 连接，return, next, 或者标号
     (define (compile-linkage linkage)
       (cond ((eq? linkage 'return) ;; 过程返回
	      (make-instruction-sequence '(continue) '() ;; 需要 continue 寄存器，不修改任何寄存器
					 '((goto (reg continue))))) ;; 产生 (goto (reg continue)) 指令
	     ((eq? linkage 'next) ;; 下一条语句
	      (empty-instruction-sequence)) ;; 不产生任何指令，不需要，也不修改任何寄存器
	     (else ;; 连接为标号
	      (make-instruction-sequence '() '() ;; 不需要，也不修改任何寄存器
					 `((goto (label ,linkage))))))) ;; 产生跳转到标号的指令
   #+END_SRC

   把连接代码附在指令序列后需要维持 _continue_ ，因为 return 连接要用。如果 *指令序列修改 continue*  而 *连接代码需要它* ，就应 *保存和恢复* 

   #+BEGIN_SRC scheme
     ;;; 把连接代码加入到指令序列最后
     ;;; linkage: 连接代码
     ;;; instruction-sequence: 指令序列
     (define (end-with-linkage linkage instruction-sequence)
       (preserving '(continue) ;; comile-linkage 产生的指令可能需要 continue
		   instruction-sequence
		   (compile-linkage linkage)))
   #+END_SRC

** 简单表达式 
   对 _自求值_ 表达式、 _引用_ 表达式和 _变量_ 表达式，代码生成器构造的指令序列将  _所需值_ *赋给* 指定 _目标寄存器_ ，而后根据 _连接描述符_ 继续 

   #+BEGIN_SRC scheme
  ;;; 编译自求值语句
  ;;; exp 自求值表达式
  ;;; target : 目标寄存器
  ;;; linkage: 连接目标
  (define (compile-self-evaluating exp target linkage)
    (end-with-linkage linkage
		      (make-instruction-sequence '() (list target)
						 `((assign ,target (const ,exp))))))
  ;;; 编译引用语句
  ;;; exp: 引用表达式
  ;;; target : 目标寄存器
  ;;; linkage: 连接目标
  (define (compile-quoted exp target linkage)
    (end-with-linkage linkage
		      (make-instruction-sequence '() (list target)
						 `((assign ,target (const ,(text-of-quotation exp)))))))

  ;;; 编译变量语句
  ;;; exp: 引用表达式
  ;;; target : 目标寄存器
  ;;; linkage: 连接目标
  (define (compile-variable exp target linkage)
    (end-with-linkage linkage
		      (make-instruction-sequence '(env) (list target)
						 `((assign ,target
							   (op lookup-variable-value) (const ,exp) (reg env))))))
   #+END_SRC

*** 赋值和定义表达式 
    赋值的处理与解释器类似：
    1. 递归 *生成计算值（准备赋给变量）的代码* 
       + 递归编译要用 _目标 val_ 和 _连接 next_ ，生成的代码逻辑里会把计算出来的值放入 val 寄存器
    2. 拼接两条指令的序列完成 _赋值_ 并把 _ok_ 赋给 _target 目标寄存器_ 
       + 所用拼接方式要求维持 _env_  ，因为 *设置或定义变量都需要当时环境* ，而产生变量值的代码可能是复杂表达式的编译结果，其中完全可能修改 env 寄存器（可能需要 save 和 restore） 

    #+BEGIN_SRC scheme
  ;;; 编译赋值语句
  (define (compile-assignment exp target linkage)
    (let ((var (assignment-variable exp)) ;; 获取 赋值表达式的变量
	  (get-value-code ;; 编译”赋值表达式的求值表达式“为”指令序列“ 
	   (compile (assignment-value exp) 'val 'next))) ;; 目标寄存器 val：生成代码把值放入 val ，连接方式 next : 执行随后的语句
      (end-with-linkage linkage
			(preserving '(env) ;; 所用拼接方式要求维持 env，因为设置变量都需要当时环境，而产生变量值的代码可能是复杂表达式的编译结果，其中完全可能修改 env 寄存器
				    get-value-code
				    (make-instruction-sequence '(env val) (list target)
							       `((perform (op set-variable-value!) ;; 执行真实的赋值操作
									  (const ,var)
									  (reg val)
									  (reg env)) ;; 把,var 作为变量名，把 val寄存器的值（求值表达式计算的结果），绑定在 env 寄存器指向的环境中  
								 (assign ,target (const ok)))))))) ;; 常量 ok 放入 target 目标寄存器 ，作为返回值
    #+END_SRC

    #+BEGIN_EXAMPLE
      拼接两指令序列时需要 env 和 val，修改 target 目标寄存器

      这个序列只保留 env 但却不保留 val，因为 get-value-code 将把返回值放入 val 供序列里的指令用
      维护 val 是不对的，因为这将导致 get-value-code 运行后又恢复 val 的原来内容！！！
    #+END_EXAMPLE

    定义的处理和赋值类似：
    #+BEGIN_SRC scheme
  (define (compile-definition exp target linkage)
    (let ((var (definition-variable exp))
	  (get-value-code
	   (compile (definition-value exp) 'val 'next)))
      (end-with-linkage linkage
			(preserving '(env)
				    get-value-code
				    (make-instruction-sequence '(env val) (list target)
							       `((perform (op define-variable!) ;; 这里调用 define-variable! 
									  (const ,var)
									  (reg val)
									  (reg env))
								 (assign ,target (const ok))))))))
    #+END_SRC

** 条件表达式
   给定目标和连接，编译 if 表达式生成的指令序列形式：
   #+BEGIN_EXAMPLE
     <编译 predicate 部分的结果, 目标在 val, 连接在 next>
     (test (op false?) (reg val))
     (branch (label false-branch))
     true-branch
     <用给定 target, linkage 和 after-if 编译 consequence 部分的结果>
     false-branch
     <用给定 target 和 linkage 编译 alternative 的结果>
     after-if
   #+END_EXAMPLE

   + 生成前需要编译 _if 的三个子部分_ 。将得到的代码与 _检查谓词结果的代码_ 组合时需生成 *标识真假分支* 和 *条件表达式结束的新标号* 。谓词为假时跳过真分支：  
     + 如果 if 的连接是 _return_ 或 _标号_ ：真/假分支都使用 *该连接* 
     + 如果连接是 _next_ ： _真分支_ 最后应加入 *跳过假分支* 的指令
   + 不能直接用标号 true-branch, false-branch 和 after-if ，因程序里可能有多个 if
     + *make-label* 生成 *新标号* ：它以一个符号为参数返回一个新符号作为标号，用与查询语言中 _生成唯一变量名_ 类似的方式实现

   #+BEGIN_SRC scheme
  (define (compile-if exp target linkage)
    ;;; 生成三个新标号
    (let ((t-branch (make-label 'true-branch))
	  (f-branch (make-label 'false-branch))                    
	  (after-if (make-label 'after-if)))
      (let ((consequent-linkage
	     (if (eq? linkage 'next) after-if linkage))) ;; 根据连接确定 then 最后的连接
	(let ((p-code (compile (if-predicate exp) 'val 'next)) ;; 编译谓词表达式代码，求值的结果放入到 val寄存器，连接的方式：next 
	      (c-code 
	       (compile
		(if-consequent exp) target consequent-linkage)) ;; 编译谓词为真时候的表达式，目标寄存器是target，使用计算出来的 consequent-linkage作为连接方式
	      (a-code
	       (compile (if-alternative exp) target linkage))) ;; 编译谓词为假时候的表达式，目标寄存器仍为target，连接方式和条件表达式的一样: linkage
	  (preserving '(env continue) ;; 求谓次条件的值，前后 env,  continue两个寄存器
		      p-code 
		      (append-instruction-sequences
		       ;; 产生如下指令序列：检查 val 寄存器（谓词计算结果存放在此）是否为假，如果为假则执行 f-branch 对应的标号
		       (make-instruction-sequence '(val) '() 
						  `((test (op false?) (reg val))
						    (branch (label ,f-branch)))) 
		       (parallel-instruction-sequences ;; 拼接两段不会同时执行的代码
			(append-instruction-sequences t-branch c-code) 
			(append-instruction-sequences f-branch a-code))
		       after-if))))))
   #+END_SRC

** 序列表达式
   对表达式序列（过程体或 begin表达式），先分别 *编译* _子表达式_ ：
   + 最后一个子表达式用 _整个序列的连接_ 
   + 其他表达式用 _next连接_ （执行序列剩下部分）
   + 结果序列由 *拼接子表达式的指令序列* 得到
   + 需要保留 _env_ （序列其余部分可能用它）和 _continue_ （最后的连接可能用它）

   #+BEGIN_SRC scheme
  ;;; 编译序列表达式
  (define (compile-sequence seq target linkage)
    (if (last-exp? seq) ;; 测试是否是最后一个子表达式
	(compile (first-exp seq) target linkage) ;; 编译最后一个子表达式，目标寄存器：target，连接：整个序列的连接
	(preserving '(env continue) ;; 需要保留 env (下一个子表达式求值需要)， continue（最后一个拼接需要）
		    (compile (first-exp seq) target 'next) ;; 编译下一个子表达式，目标寄存器：target，连接: next 
		    (compile-sequence (rest-exps seq) target linkage)))) ;; 递归编译余下的子表达式，目标寄存器：target，连接：整个序列的linkage
   #+END_SRC

** lambda 表达式
   lambda 表达式 *构造过程对象* ，目标代码具有下面形式：
   #+BEGIN_EXAMPLE
     <构造过程对象并将其赋给 target 寄存器>
     <linkage>
   #+END_EXAMPLE

   编译 lambda 表达式时要生成过程体的代码。虽然构造过程时不执行过程体，但需要找地方安置其目标代码。lambda的代码后是合适的位置：
   + 如果 lambda 表达式的连接是 _标号_ 或  _return_ ，这样正合适
   + 如果连接是 next : 就用 *转跳连接* 跳过过程体代码，相应标号放在过程体后面

   #+BEGIN_EXAMPLE
     <构造过程对象并将其赋给 target寄存器
     >
     <给定 linkage 的代码>or (goto (label after-lambda))
     <构成体的编译结果>
     after-lambda
   #+END_EXAMPLE

   _compile-lambda_ 生成 *构造过程对象* 的代码，随后是 _过程体_ 代码：
   + 过程对象将在 *运行时* 构造，其中组合 _当时环境_ 和 _编译后过程体的入口点_ 
   #+BEGIN_SRC scheme
  ;;; 编译 lambda 表达式
  (define (compile-lambda exp target linkage)
    ;; 生成 2个新的标号： proc-entry 和 after-lambda 
    (let ((proc-entry (make-label 'entry))
	  (after-lambda (make-label 'after-lambda)))
      ;; 计算 lambda表达式的连接
      (let ((lambda-linkage
	     (if (eq? linkage 'next) after-lambda linkage)))
	(append-instruction-sequences
	 (tack-on-instruction-sequence
	  ;; 组合操作，直接把过程体代码放在 lambda 表达式 代码之后。它们相互无关，只是放在这里合适
	  (end-with-linkage lambda-linkage
			    (make-instruction-sequence '(env) (list target)
						       `((assign ,target
								 (op make-compiled-procedure)
								 (label ,proc-entry)
								 (reg env))))) ;; 构建一个过程对象，标号是 proc-entry的值，环境是 env, 把这个对象赋值到 target 寄存器
	  (compile-lambda-body exp proc-entry)) ;; 编译 lambda 过程体
	 after-lambda)))) ;; after-lambda 标号
   #+END_SRC

   _compile-lambda-body_ ： *构造过程体代码* （运行时构造）
   + 入口点标号后的指令把 _运行时环境_ 转到 _求值过程体的定义环境_ （过程的定义环境）并做 *环境扩充* 
   + _过程体表达式序列_ 的编译代码
     + 序列用 _连接 return_ 和 _目标 val_ 编译：从过程返回，过程的执行结果放在 val
   #+BEGIN_SRC scheme
  (define (compile-lambda-body exp proc-entry)
    (let ((formals (lambda-parameters exp))) ;; 获得形参表
      (append-instruction-sequences
       (make-instruction-sequence '(env proc argl) '(env) ;; 构造过程体需要的寄存器是 env, proc, argl , 构造完成后：修改的寄存器是 env 
				  `(,proc-entry ;; 过程体对应的标号
				    (assign env (op compiled-procedure-env) (reg proc)) ;; 调用lambda表达式时候的环境
				    (assign env 
					    (op extend-environment) ;; 扩充环境
					    (const ,formals) ;; 把实参和形参在环境中绑定
					    (reg argl)
					    (reg env))))
       (compile-sequence (lambda-body exp) 'val 'return)))) ;; 编译过程体的指令，执行过程体的目标寄存器是 val, 连接方式: return（直接返回）
   #+END_SRC
