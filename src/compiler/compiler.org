#+TITLE: 求值器编译
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 

#+BEGIN_EXAMPLE
  显式控制求值器是一部寄存器机器，其控制器能解释 Scheme 程序
#+END_EXAMPLE
下面研究如何在控制器不是 Scheme 解释器的寄存器机器上运行 Scheme 程序

#+BEGIN_EXAMPLE
  显式控制求值器是解释 Scheme 程序的通用机器：

  其控制器与数据通路配合，可执行任何计算过程
  其数据通路也是通用的
#+END_EXAMPLE

普通计算机也都是通用寄存器机器，基于：
+ 一组 *寄存器*
+ 一组 _操作_ ：高效方便的 *数据通路* 
  + _控制器_ ：一个 _寄存器机器语言_ （本机语言） *解释器* 
  + _程序_ ： 使用 *机器的数据通路的指令序列* 

#+BEGIN_EXAMPLE
  可以把显式控制求值器的指令序列看作一台通用计算机的机器语言程序，而不看作一部特定解释器机器的控制器
#+END_EXAMPLE

要在寄存器机器上运行高级语言程序，就要在 _高级语言_ 和 _寄存器机器语言_ 间架一座桥梁。有两种策略： *解释* 和 *编译* 
* 解释和编译
#+BEGIN_EXAMPLE
  显式控制求值器采用的是解释策略：

  用本机语言写一个解释器，它配置该机器使之能执行源语言（与本机语言完全不同）的程序

  源语言的基本过程采用本机语言写出的子程序库实现。被解释程序（源程序）用数据结构表示

  解释器遍历表示程序的数据结构，分析源程序的情况，模拟其行为（需要利用库里的子程序）
#+END_EXAMPLE
另一种策略是 *编译* ：针对给定 _源语言_ 和 _给定机器_ 的编译器，将 _源程序_  *翻译* 为 _本机语言的等价程序_ （目标程序），然后就可以让目标程序自己运行了

+ 编译策略可能大大 *提高程序执行效率*
+ 解释器能为程序的 *开发和排错* 提供强大帮助
  + 被执行源代码在运行期间可用，可以方便地检查和修改
  + 由于所有基本操作的库都在，因此可以支持在修改程序和排错过程中构造新程序，并将新程序随时加入系统

#+BEGIN_EXAMPLE
  编译和解释优势互补，现代开发环境推崇混合策略。Lisp 解释器一般都允许解释性程序和编译性程序相互调用：

  这样已完成的部分可以通过编译取得效率优势；正在开发而不断变化的部分通过解释执行
#+END_EXAMPLE

下面实现的编译器把 _Scheme 写的程序_ （源程序）翻译为 _显式控制求值器的数据通路_ 能执行的 _指令序列_ （目标程序）。编译器的做完后，还要说明如何将它与解释器连接，形成一个集成的编译器-解释器开发环境
* 机制
编译器分析表达式的机制与解释器类似。为使编译代码能与解释代码互连，生成代码遵循同样寄存器规则：
+ 执行环境在 env
+ 实参表在 argl 里积累
+ 被应用过程在 proc
+ 过程值通过 val 返回
+ 过程将要用的返回地址放在 continue

#+BEGIN_EXAMPLE
  从一个源程序生成的目标程序在执行中所做的寄存器操作，本质上就是解释器求值同一个源程序时执行的那些操作
#+END_EXAMPLE

编译器在技术上与前面 _分析型求值器_ 类似，遍历表达式：遇到解释器求值表达式时 _执行一条寄存器指令_ 的情况，它将 *这条指令放到一个序列* 里。最终得到的 _指令序列_ 就是所需 *目标代码* 

#+BEGIN_EXAMPLE
  以求值 (f 84 96) 为例：

  解释器每次求值表达式时都要做表达式分类（发现是过程应用），并检查表示表达式的表是否结束（弄清有两个运算对象）

  编译器只在编译源程序并生成指令序列时做一次表达式分析：
  产生的目标代码里只有对运算符和运算对象求值的指令，以及将过程（保存在 proc）应用于实参（保存在 argl）的指令
#+END_EXAMPLE

+ 解释器必须考虑处理 *所有* 表达式
+ 编译结果代码完成 *特定* 表达式
#+BEGIN_EXAMPLE
  以保存寄存器为例：

  解释器要准备处理所有可能，求值子表达式前必须把后来可能用的所有寄存器进栈（不知道子表达式会做什么）
  编译器可以根据具体表达式的情况，只生成必要的栈操作

  考虑对 (f 84 96)  的处理：

  解释器求值 f 前后保存恢复运算对象和环境寄存器 (都可能有用)，最后把 val 的值移到 proc （先放到 val 再移到 proc）

  由于运算符就是 f （编译时候就能确定这是一个变量表达式，而不是一个过程表达式），求值由机器操作 lookup-variable-value 完成，不修改寄存器
  编译代码只需要一条指令做运算符求值：
  (assign proc (op lookup-variable-value) (const f) (reg env)) 
  不需要保存和恢复，值直接赋给 proc
#+END_EXAMPLE

在很多情况时候编译可以 *优化环境访问* ：
+ 通过分析代码，许多情况时候可以确定特定值所在框架，然后直接访问该框架，不需要用 lookup-variable-value 搜索
+ 直接处理某些基本操作，而不通过通用的 apply

#+BEGIN_EXAMPLE
  这里并不准备特别强调各种优化，主要目标是在一个简化（但仍然很有意思）的上下文中展示编译过程的各种情况
#+END_EXAMPLE
* 结构

