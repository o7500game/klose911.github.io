#+TITLE: 优雅的python代码
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil

* 循环
** 遍历一个范围内的数字 
  #+BEGIN_SRC python
    for i in [0, 1, 2, 3, 4, 5]:
        print(i ** 2)
  #+END_SRC

更好的代码：
  #+BEGIN_SRC python
    for i in xrange(6):
        print(i ** 2)
  #+END_SRC

+ xrange 会返回一个迭代器，用来一次一个值地遍历一个范围。这种方式会比 range 更省内存
+ xrange 在 Python 3 中已经改名为 range

** 遍历一个集合

  #+BEGIN_SRC python
    colors = [ 'red',  'green',  'blue',  'yellow' ]

    for i in range(len(colors)):
        print(colors[i])
  #+END_SRC

更好的写法：

#+BEGIN_SRC python
  colors = [ 'red',  'green',  'blue',  'yellow' ]

  for color in colors:
      print(color)
#+END_SRC

** 反向遍历一个集合

  #+BEGIN_SRC python
    colors = [ 'red',  'green',  'blue',  'yellow' ]

    for i in range(len(colors) - 1,  -1,  -1):
            print (colors[i]) 
  #+END_SRC

更好的写法：

  #+BEGIN_SRC python
    colors = [ 'red',  'green',  'blue',  'yellow' ]

    for  color in reversed(colors):
        print (color) 
  #+END_SRC

这种写法效率高，优雅，而且帮你省去亲自创建和自增下标。当你发现你在操作集合的下标时，你很有可能在做错事

** 遍历两个集合

  #+BEGIN_SRC python
    names = ['raymond', 'rachel', 'matthew']
    colors = ['red', 'green', 'blue', 'yellow']

    n = min(len(names), len(colors))

    for i in range(n):
        print (names[i], '->', colors[i])
  #+END_SRC

更好的写法：

#+BEGIN_SRC python
  for name, color in zip(names, colors):
      print (name, '->', color)
#+END_SRC

zip 在内存中生成一个新的列表，需要更多的内存。izip 比 zip 效率更高

注意：在 Python 3 中，izip 改名为 zip，并替换了原来的 zip 成为内置函数

** 有序地遍历
+ 顺序遍历：

  #+BEGIN_SRC python
    colors = [ 'red',  'green',  'blue',  'yellow' ]

    for color in sorted(colors):
        print (color)
  #+END_SRC

+ 倒序遍历：

  #+BEGIN_SRC python
    for color in sorted(colors, reverse=True):
        print (color)
  #+END_SRC

*** 自定义排序顺序 

   #+BEGIN_SRC python
     def compare_length(c1, c2):
         if len(c1) < len(c2):
             return -1
         if len(c1) > len(c2):
             return 1
         return 0

     for color in sorted(colors, cmp=compare_length):
         print (color)
   #+END_SRC

更好的写法：
#+BEGIN_SRC python
  print (sorted(colors, key=len)) 
#+END_SRC

** 调用一个函数直到遇到标记值

  #+BEGIN_SRC python
    blocks = []

    while True:
        block = f.read(32)
        if block == '':
            break
        blocks.append(block)
  #+END_SRC

更好的写法：
  #+BEGIN_SRC python
    blocks = []

    for block in iter(partial(f.read, 32),  ''):
        blocks.append(block)
  #+END_SRC

iter 接受两个参数：第一个是你反复调用的函数，第二个是标记值。第二种写法的优势：
+ iter 的返回值是个迭代器，迭代器能用在各种地方，set，sorted，min，max，heapq，sum等

** 在循环内识别多个退出点

  #+BEGIN_SRC python
    seq = [0, 1, 2, 3, 4, 5, 6]

    def find(seq, target):
        found = False

        for i, value in enumerate(seq):
            if value == target:
                found = True
                break
            
        if not found:
            return -1

        return i

    print (find(seq, 3)) # 3 
    print (find(seq, 8)) # -1 
  #+END_SRC

更好的写法，for 执行完所有的循环后就会执行 else：
#+BEGIN_SRC python
  def find(seq, target):
      for i, value in enumerate(seq):
          if value == target:
              break
          
      else:
          return -1
      
      return i
#+END_SRC

有两种方法去理解 for-else：
+ 传统的方法是把 for 看作 if，当 for 后面的条件为 False 时执行 else。其实条件为 False 时，就是 for 循环没被 break 出去，把所有循环都跑完的时候
+ 另一种方法就是把 else 记成 nobreak，当 for 没有被 break，那么循环结束时会进入到 else

* 字典

** 遍历字典的 key 

   #+BEGIN_SRC python
     d = {'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'}

     for k in d:
         print (k)
   #+END_SRC

在迭代中修改容器是非常危险的： 
   #+BEGIN_SRC python
     d = {'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'}

          for k in list(d.keys()):
              if k.startswith('r'):
                  del (d[k])

     # >>> matthew
   #+END_SRC

 list(d.keys()): 把字典里所有的 key 都复制到一个列表里。然后就可以修改字典

** 遍历一个字典的 key 和 value

   #+BEGIN_SRC python
     d = {'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'}

     # 并不快，每次必须要重新哈希并做一次查找 
     for k in d:
         print (k, '->', d[k]) 
         # >>> matthew -> blue
         # rachel -> green
         # raymond -> red
   #+END_SRC
更好的写法：

#+BEGIN_SRC python
  # for k, v in d.iteritems():
  #     print (k, '->', v) 

  for k, v in d.items():
      print (k, '->', v)
#+END_SRC

注意：Python 3 已经没有 iteritems() 了，items() 的行为和 iteritems() 很接近，返回一个迭代器

** 用 key-value 对构建字典
   #+BEGIN_SRC python
     names = ['raymond', 'rachel', 'matthew']
     colors = ['red', 'green', 'blue']
     # d = dict(izip(names, colors))

     d = dict(zip(names, colors)) 
     print (d)
     # >>> {'raymond': 'red', 'rachel': 'green', 'matthew': 'blue'}
   #+END_SRC

** 用字典计数
简单，基本的计数方法。适合初学者起步时学习：
   #+BEGIN_SRC python
     colors = ['red', 'green', 'red', 'blue', 'green', 'red']

     d = {}
     for color in colors:
         if color not in d:
             d[color] = 0
         d[color] += 1

     # >>>{'red': 3, 'green': 2, 'blue': 1} 
   #+END_SRC

更好的写法，使用初始值：

#+BEGIN_SRC python
  d = {}

  for color in colors:
      d[color] = d.get(color, 0) + 1
  # >>> {'red': 3, 'green': 2, 'blue': 1}
#+END_SRC

更新潮的方法：

#+BEGIN_SRC python
  from collections import defaultdict

  d = defaultdict(int)
  # >>> defaultdict(<class 'int'>, {})

  for color in colors:
      d[color] += 1
  # >>> defaultdict(<class 'int'>, {'red': 3, 'green': 2, 'blue': 1})
#+END_SRC

** 用字典分组 
按 name 的长度分组：
   #+BEGIN_SRC python
     names = ['raymond', 'rachel', 'matthew', 'roger',
              'betty', 'melissa', 'judith', 'charlie']

     d = {}

     for name in names:
         key = len(name)
         if key not in d:
             d[key] = []
         d[key].append(name)
     # >>> {7: ['raymond', 'matthew', 'melissa', 'charlie'], 6: ['rachel', 'judith'], 5: ['roger', 'betty']}
   #+END_SRC

更好的写法：
#+BEGIN_SRC python
  d = {}

  for name in names:
      key = len(name)
      d.setdefault(key, []).append(name)
  # >>> {7: ['raymond', 'matthew', 'melissa', 'charlie'], 6: ['rachel', 'judith'], 5: ['roger', 'betty']}
#+END_SRC

更新潮的写法：
#+BEGIN_SRC python
  from collections import defaultdict

  d = defaultdict(list)
  #>>> defaultdict(<class 'list'>, {})

  for name in names:
      key = len(name)
      d[key].append(name)
  #defaultdict(<class 'list'>, {7: ['raymond', 'matthew', 'melissa', 'charlie'], 6: ['rachel', 'judith'], 5: ['roger', 'betty']})
#+END_SRC

** 原子操作popitem
popitem 是原子的，所以多线程的时候没必要用锁包着它：
   #+BEGIN_SRC python
     d = {'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'}

     while d:
         key, value = d.popitem()
         print(key, '->', value)

     # raymond -> red
     # rachel -> green
     # matthew -> blue

     print(d)
     # {} 
   #+END_SRC

** 连接字典
处理配置参数： 默认使用第一个字典（从配置文件读取），接着用环境变量覆盖它，最后用命令行参数覆盖它，不幸的是，这种方法拷贝数据太疯狂！
   #+BEGIN_SRC python
     defaults = {'color': 'red',
                 'USERNAME': 'guest'}

     d = defaults.copy()
     for k, v in d.items():
         print(k, '->', v)
     # color -> red
     # USERNAME -> guest

     d.update(os.environ)
     for k, v in d.items():
         print(k, '->', v)
     # color -> red
     # USERNAME -> klose.wu
     # .......
     # TMP -> C:\Users\klose.wu\AppData\Local\Temp
     # TMPDIR -> C:\Users\klose.wu\AppData\Local\Temp
     # USERDNSDOMAIN -> EBAOTECH.COM
     # USERDOMAIN -> EBAOTECH
     # USERPROFILE -> C:\Users\klose.wu
     # WINDIR -> C:\Windows

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument('-u', '-user')
     parser.add_argument('-c', '-color')

     namespace = parser.parse_args([])
     command_line_args = {k: v for k, v in vars(namespace).items() if v}

     d.update(command_line_args)
     for k, v in d.items():
         print(k, '->', v)
   #+END_SRC

更高效优雅的写法：
#+BEGIN_SRC python
  d = ChainMap(command_line_args, os.environ, defaults)
  for k, v in d.items():
      print(k, '->', v) 
#+END_SRC

* 可读性
位置参数和下标很漂亮，但关键字和名称更好：
+ 第一种方法对计算机来说很便利
+ 第二种方法和人类思考方式一致

** 用关键字参数提高函数调用的可读性
   #+BEGIN_SRC python
     twitter_search('@obama', False, 20, True) 
   #+END_SRC

更好地做法：

#+BEGIN_SRC python
  twitter_search('@obama', retweets=False, numtweets=20, popular=True)
#+END_SRC
第二种方法稍微慢一点，但为了代码的可读性和开发时间，值得。

** 用 namedtuple 提高多个返回值的可读性
测试结果是好是坏？你看不出来，因为返回值不清晰：
   #+BEGIN_SRC python
     doctest.testmod()
     # (0, 4) 
   #+END_SRC

更好的写法，使用一个 namedtuple 作为返回值：
#+BEGIN_SRC python
  doctest.testmod()
  # TestResults(failed=0, attempted=4)
#+END_SRC

namedtuple 是 tuple 的子类，所以仍适用正常的元组操作，但它更友好 

*** 创建namedtuple

    #+BEGIN_SRC python
      from collections import namedtuple

      TestResults = namedtuple('TestResults', ['failed', 'attempted'])
      testResult = TestResults(failed=0, attempted=4)
      #TestResults(failed=0, attempted=4)
    #+END_SRC

** unpack 序列 

** 更新多个变量的状态

** 同时状态更新

* 效率

** 连接字符串

** 更新序列

* 装饰器和上下文管理

** 使用装饰器分离出管理逻辑

** 分离临时上下文

** 文件操作

** 使用锁

* 简洁的单句表达 

** 列表解析和生成器
