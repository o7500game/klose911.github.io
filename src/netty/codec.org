#+TITLE: Codec 编码
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: channel.html   
#+HTML_LINK_HOME: netty.html
#+OPTIONS: num:nil timestamp:nil  ^:nil

本章介绍：
+ Decoder(解码器)
+ Encoder(编码器)
+ Codec(编解码器)
  
在前面的章节中，我们讨论了连接到拦截操作或数据处理链的不同方式，展示了如何使用 ChannelHandler 及其相关的类来实现几乎任何一种应用程序所需的逻辑。但正如标准架构模式通常有专门的框架，通用处理模式很适合使用目标实现，可以节省我们大量的开发时间和精力

在这一章，我们将研究编码和解码： *数据从一种特定协议格式到另一种格式的转换* 。这种处理模式是由通常被称为 *codecs* 的组件来处理的。Netty提供了一些组件，利用它们可以很容易地为各种不同协议编写编解码器。例如，如果您正在构建一个基于 Netty 的邮件服务器，你可以使用POP3, IMAP 和 SMTP的现成的实现

* Codec
  编写一个网络应用程序需要实现某种 codec (编解码器)，codec的作用就是 *将原始字节数据与目标程序数据格式进行互转* 。网络中都是以字节码的数据形式来传输数据的，codec 由两部分组成：
+ decoder: 解码器
+ encoder: 编码器
  
编码器和解码器一个字节序列转换为另一个业务对象。一个 *消息* 是一个结构化的字节序列，语义为一个特定的应用程序的 *数据* 。encoder 是组件，转换消息格式适合传输(就像字节流)，而相应的 decoder 转换传输数据回到程序的消息格式。逻辑上,  *从* 消息转换来是当作操作  *outbound（出站）* 数据,而转换， *到* 消息是处理  *inbound（入站）* 数据

** Decoder
   Netty 提供了丰富的解码器抽象基类，可以很容易的实现这些基类来自定义解码器。主要分两类：
+ 解码字节到消息
   + ByteToMessageDecoder
   + ReplayingDecoder
+ 解码消息到消息
  +MessageToMessageDecoder
  
decoder 负责将 *入站* 数据从一种格式转换到另一种格式，Netty的解码器是一种 ChannelInboundHandler 的抽象实现。实践中使用解码器很简单，就是将入站数据转换格式后传递到 ChannelPipeline 中的下一个ChannelInboundHandler 进行处理

这样的处理是很灵活的，可以将解码器放在 ChannelPipeline 中，重用逻辑

*** ByteToMessageDecoder
    ByteToMessageDecoder 是用于将字节转为消息（或其他字节序列）
    
    不能确定远端是否会一次发送完一个完整的信息，因此这个类会缓存入站的数据，直到准备好了用于处理。表7.1说明了它的两个最重要的方法：
    
    #+CAPTION: ByteToMessageDecoder 方法
    #+ATTR_HTML: :border 1 :frame boader  :rules all 
    | 方法       | 描述                                                                                                                                                                                                                                                                                                          |
    | decode     | This is the only abstract method you need to implement. It is called with a ByteBuf having the incoming bytes and a List into which decoded messages are added. decode() is called repeatedly until the List is empty on return. The contents of the List are then passed to the next handler in the pipeline |
    | decodeLast | The default implementation provided simply calls decode().This method is called once, when the Channel goes inactive. Override to provide special handling     |
    
    假设我们接收一个包含简单整数的字节流，每个都单独处理。在本例中，将从入站 ByteBuf 读取每个整数并将其传递给 pipeline 中的下一个ChannelInboundHandler。扩展ByteToMessageDecoder来实现解码字节流成整数，如图7.1所示：
    #+ATTR_HTML: image :width 70% 
    [[file:pic/to-integer-decoder.jpg]]
    
    每次从入站的 ByteBuf 读取四个字节，解码成整形，并添加到一个 List ，当不能再添加数据到 List 时，它所包含的内容就会被发送到下个 ChannelInboundHandler：
    
    #+BEGIN_SRC java
  public class ToIntegerDecoder extends ByteToMessageDecoder {  //1 实现继承了 ByteToMessageDecode 用于将字节解码为消息
          @Override
          public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
                  throws Exception {
                  if (in.readableBytes() >= 4) {  //2 检查可读的字节是否至少有4个 ( int 是4个字节长度)
                          out.add(in.readInt());  //3 从入站 ByteBuf 读取 int ， 添加到解码消息的 List 中
                  }
          }
  }
    #+END_SRC
    
    尽管 ByteToMessageDecoder 简化了这个模式，你会发现它还是有点烦人。在实际的读操作(readInt)之前，必须要验证输入的 ByteBuf 要有足够的数据。在下一节中将看看 ReplayingDecoder，一个特殊的解码器
    
    引用计数对于编码器和解码器来说，这个过程非常简单。一旦一个消息被编码或解码它自动被调用ReferenceCountUtil.release(message) 。如果你稍后还需要用到这个引用而不是马上释放，你可以调用 *ReferenceCountUtil.retain(message)* 。这将 *增加引用计数防止消息被释放*
    
*** ReplayingDecoder
    ReplayingDecoder 是 byte-to-message 解码的一种特殊的抽象基类，读取缓冲区的数据之前需要检查缓冲区是否有足够的字节，使用ReplayingDecoder就无需自己检查：
+ 若ByteBuf中有足够的字节，则会正常读取
+ 若没有足够的字节则会停止解码
  
**** ByteToMessageDecoder VS ReplayingDecoder
     ReplayingDecoder 继承自 ByteToMessageDecoder ，所以两者 API 是相同的。也正因为这样的包装使得 ReplayingDecoder 带有一定的局限性：
+ 不是所有的标准 ByteBuf 操作都被支持，如果调用一个不支持的操作会抛出 UnreplayableOperationException
+ ReplayingDecoder 略慢于 ByteToMessageDecoder
  
如果这些限制是可以接受你可能更喜欢使用 ReplayingDecoder。下面是一个简单的准则：
#+BEGIN_EXAMPLE
如果不引入过多的复杂性 使用 ByteToMessageDecoder ，否则使用ReplayingDecoder
#+END_EXAMPLE

使用 ReplayingDecoder 更简单：
#+BEGIN_SRC java
  public class ToIntegerDecoder2 extends ReplayingDecoder<Void> {   //1 实现继承自 ReplayingDecoder 用于将字节解码为消息

          @Override
          public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
                  throws Exception {
                  out.add(in.readInt());  //2 从入站 ByteBuf 读取整型，并添加到解码消息的 List 中
          }
  }
#+END_SRC

**** 更多 Decoder
+ io.netty.handler.codec.LineBasedFrameDecoder: 通过结束控制符( *\n* 或 *\r\n* )解析入站数据
+ io.netty.handler.codec.http.HttpObjectDecoder: 用于 HTTP 数据解码
  
*** MessageToMessageDecoder
    用于从一种消息解码为另外一种消息（例如 POJO 到 POJO），下表展示了方法：
    
    #+CAPTION: ByteToMessageDecoder 方法
    #+ATTR_HTML: :border 1 :frame boader  :rules all 
    | 方法       | 描述                                                                                                                                                                                                                                                                                                          |
    | decode     | decode is the only abstract method you need to implement. It is called for each inbound message to be decoded to another format . The decoded messages are then passed to the next ChannelInboundHandler in the pipeline |
    | decodeLast | The default implementation provided simply calls decode().This method is called once, when the Channel goes inactive. Override to provide special handling |
    
    将 Integer 转为 String，提供了 IntegerToStringDecoder，继承自 MessageToMessageDecoder。因为这是一个参数化的类，所以实现的签名是：
    
    #+BEGIN_SRC java
  public class IntegerToStringDecoder extends MessageToMessageDecoder<Integer>
    #+END_SRC
    
    decode() 方法的签名是：
    
    #+BEGIN_SRC java
  protected void decode( ChannelHandlerContext ctx,
                         Integer msg, List<Object> out ) throws Exception
    #+END_SRC
    
    也就是说，入站消息是按照在 *类定义中声明的参数类型* (Integer) 而不是 ByteBuf来解析的。 *解码消息* (String)将被添加到List，并传递到下个 ChannelInboundHandler。 这是如图7.2所示：
    
    #+ATTR_HTML: image :width 70% 
    [[file:pic/integer-to-string-decoder.jpg]]
    
    实现如下：
    
    #+BEGIN_SRC java
  public class IntegerToStringDecoder extends
                                      MessageToMessageDecoder<Integer> { //1 实现继承自 MessageToMessageDecoder 

          @Override
          public void decode(ChannelHandlerContext ctx, Integer msg, List<Object> out)
                  throws Exception {
                  out.add(String.valueOf(msg)); //2 通过 String.valueOf() 转换 Integer 消息字符串
          }
  }
    #+END_SRC
    
    正如上面指出的：decode()方法的消息参数的类型是由给这个类指定的泛型的类型(Integer)确定的
    
**** HttpObjectAggregator
     更多复杂的示例，请查看类 io.netty.handler.codec.http.HttpObjectAggregator，继承自MessageToMessageDecoder
     
*** 在解码时处理太大的帧
    Netty 是异步框架需要缓冲区字节在内存中，直到能够解码它们。因此，不能让你的解码器缓存太多的数据以免耗尽可用内存。为了解决这个共同关心的问题， Netty 提供了一个 TooLongFrameException ，通常由解码器在帧太长时抛出
    
    为了避免这个问题，可以在你的解码器里设置一个最大字节数阈值。如果超出，将导致 TooLongFrameException 抛出(并由 ChannelHandler.exceptionCaught() 捕获)。然后由译码器的用户决定如何处理它。虽然一些协议,比如 HTTP、允许这种情况下有一个特殊的响应,有些可能没有，事件唯一的选择可能就是关闭连接
    
    如下所示 ByteToMessageDecoder 可以利用 TooLongFrameException 通知其他 ChannelPipeline 中的 ChannelHandler：
    
    #+BEGIN_SRC java
  public class SafeByteToMessageDecoder extends ByteToMessageDecoder {  //1 实现继承 ByteToMessageDecoder 来将字节解码为消息
          private static final int MAX_FRAME_SIZE = 1024;

          @Override
          public void decode(ChannelHandlerContext ctx, ByteBuf in,
                             List<Object> out) throws Exception {
                  int readable = in.readableBytes();
                  if (readable > MAX_FRAME_SIZE) { //2 检测缓冲区数据是否大于 MAX_FRAME_SIZE
                          in.skipBytes(readable);        //3 忽略所有可读的字节，并抛出 TooLongFrameException 来通知 ChannelPipeline 中的 ChannelHandler
                          throw new TooLongFrameException("Frame too big!");
                  }
                  // do something
          }
  }
    #+END_SRC
    
    这种保护是很重要的，尤其是当你解码一个有可变帧大小的协议的时候 
    
** Encoder

** 抽象 Codec 类
