#+TITLE: 引导
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: embedded.html   
#+HTML_LINK_HOME: netty.html
#+OPTIONS: num:nil timestamp:nil  ^:nil

本章介绍：
+ 引导客户端和服务器
+ 从Channel引导客户端
+ 添加 ChannelHandler
+ 使用 ChannelOption 和属性
  
通过 ChannelPipeline 、ChannelHandler和编解码器提供工具，可以处理一个广泛的数据处理需求。但是可能会问,“我创建了组件后,如何将其组装形成一个应用程序?”

答案是 *bootstrapping* 。到目前为止使用这个词有点模糊,时间可以来定义它。在最简单的条件下,引导就是配置应用程序的过程。但我们看到的,不仅仅如此； *Netty的引导客户端和服务器的类从网络基础设施使应用程序代码在后台可以连接和启动所有的组件* 。简而言之，引导使 Netty 应用程序完整

* Bootstrap 类型
  
  Netty包括两种不同类型的引导：不仅仅是 *服务器* 和 *客户* 的引导，更有用的是考虑他们的目的是支持的应用程序功能。从这个意义上讲, *服务器* 应用程序把一个 *父* 管道接受连接和创建 *子* 管道,而 *客户端* 很可能只需要一个单一的、非 *父* 对所有网络交互的管道（对于无连接的比如 UDP 协议也是一样）
  
  如图9.1所示,两个引导实现自一个名为 *AbstractBootstrap* 的超类：
  
  #+ATTR_HTML: image :width 40% 
  [[file:pic/bootstrap-hierarchy.jpg]]
  
  前面介绍了许多共同关注的话题,同样适用于客户端和服务器。这些都是由 AbstractBootstrap 处理,从而防止重复的功能和代码。专业引导类可以完全专注于它们独特的需要关心的地方
  
** 克隆引导类
   经常需要创建多个通道具有相似或相同的设置。支持这种模式而不需要为每个通道创建和配置一个新的引导实例, AbstractBootstrap 已经被标记为 Cloneable。调用 clone() 在一个已经配置引导将返回另一个引导实例并且是立即可用
   
   #+BEGIN_EXAMPLE
   因为这将创建只是 EventLoopGroup 浅拷贝,后者将会共享所有的克隆管道
   
   这是可以接受的,因为往往是克隆的管道是短暂的，典型示例是管道创建用于 HTTP 请求
   #+END_EXAMPLE
   
* 引导客户端
  当需要引导客户端或一些无连接协议时，需要使用Bootstrap类。 在本节中,将回顾可用的各种方法引导客户端,引导线程,和可用的管道实现
  
** Bootstap常用方法
   下表是 *Bootstrap* 的常用方法，其中很多是继承自 AbstractBootstrap：
   
   #+CAPTION: Boostrap 方法
   #+ATTR_HTML: :border 1 :frame boader  :rules all    
   | 名称                   | 描述                                                                                                                                                                                                                                                |
   | group                  | 设置 EventLoopGroup 用于处理所有的 Channel 的事件                                                                                                                                                                                                   |
   | channel channelFactory | channel() 指定Channel的实现类。如果类没有提供一个默认的构造函数,你可以调用channelFactory()来指定一个工厂类被bind()调用                                                                                                                              |
   | localAddress           | 指定应该绑定到本地地址Channel。如果不提供,将由操作系统创建一个随机的。或者,您可以使用bind()或connect()指定localAddress                                                                                                                              |
   | option                 | 设置ChannelOption应用于新创建Channel的ChannelConfig。这些选项将被bind或connect设置在通道,这取决于哪个被首先调用。这个方法在创建管道后没有影响。所支持ChannelOption取决于使用的管道类型。请参考9.6节和 ChannelConfig 的 API 文档 的 Channel 类型使用 |
   | attr                   | 这些选项将被bind或connect设置在通道,这取决于哪个被首先调用。这个方法在创建管道后没有影响。请参考9.6节                                                                                                   |
   | handler                | 设置添加到 ChannelPipeline 中的 ChannelHandler 接收事件通知                                                                                                                                               |
   | clone                  | 创建一个当前 Bootstrap的克隆拥有原来相同的设置                                                                                                                                                                                   |
   | remoteAddress          | 设置远程地址。此外可以通过connect()指定                                                                                                                                                                                             |
   | connect                | 连接到远端，返回一个ChannelFuture, 用于通知连接操作完成                                                                                                                                                                         |
   | bind                   | 将通道绑定并返回一个 ChannelFuture,用于通知绑定操作完成后,必须调用 Channel.connect() 来建立连接                                                                                                                      |
   
** 过程
   Bootstrap 类负责创建管道给客户或应用程序，利用无连接协议和在调用 bind() 或 connect() 之后
   下图展示了如何工作：
   #+ATTR_HTML: image :width 70% 
   [[file:pic/bootstrap-process.jpg]]
   
1. 当 bind() 调用时，Bootstrap 将创建一个新的管道, 当 connect() 调用在 Channel 来建立连接
2. Bootstrap 将创建一个新的管道, 当 connect() 调用时
3. 新的 Channel
   
*** 实例
    
    #+BEGIN_SRC java
      EventLoopGroup group = new NioEventLoopGroup();
      Bootstrap bootstrap = new Bootstrap(); //1 创建一个新的 Bootstrap 来创建和连接到新的客户端管道
      bootstrap.group(group) //2 指定 EventLoopGroup
      .channel(NioSocketChannel.class) //3 指定 Channel 实现来使用
      .handler(new SimpleChannelInboundHandler<ByteBuf>() { //4 设置处理器给 Channel 的事件和数据
                      @Override
                      protected void channeRead0(
                              ChannelHandlerContext channelHandlerContext,
                              ByteBuf byteBuf) throws Exception {
                              System.out.println("Received data");
                              byteBuf.clear();
                      }
              });
      ChannelFuture future = bootstrap.connect(
              new InetSocketAddress("www.manning.com", 80)); //5 连接到远端主机
      future.addListener(new ChannelFutureListener() {
                      @Override
                      public void operationComplete(ChannelFuture channelFuture)
                              throws Exception {
                              if (channelFuture.isSuccess()) {
                                      System.out.println("Connection established");
                              } else {
                                      System.err.println("Connection attempt failed");
                                      channelFuture.cause().printStackTrace();
                              }
                      }
              });
    #+END_SRC
    
    #+BEGIN_EXAMPLE
    Bootstrap 提供了一个fluent语法
    
    示例中使用的方法(除了connect()) 由 Bootstrap 返回实例本身的引用链接他们
    #+END_EXAMPLE
    
*** 兼容性
    Channel 的实现和 EventLoop 的处理过程在 EventLoopGroup 中必须兼容．哪些 Channel 兼容哪些 EventLoopGroup 可以查看 API 文档。经验显示，相兼容的实现一般在同一个包下面，例如使用NioEventLoop，NioEventLoopGroup 和 NioServerSocketChannel 在一起。请注意，这些都是前缀 *Nio* ，然后 *不会用这些代替另一个实现和另一个前缀* ，如“Oio”，也就是说 OioEventLoopGroup 和NioServerSocketChannel 是不相容的
    
    *Channel 和 EventLoopGroup 的 EventLoop 也必须兼容* ，例如NioEventLoop、NioEventLoopGroup、NioServerSocketChannel是相容的，但是 OioEventLoopGroup 和 NioServerSocketChannel 是不相容的。从类名可以看出前缀是 *Nio* 的只能和 *Nio* 的一起使用
    
    #+BEGIN_EXAMPLE
    EventLoop 分配给该 Channel 负责处理 Channel 的所有操作。 当执行一个方法,该方法返回一个 ChannelFuture ，它将在分配给 Channel 的 EventLoop 执行
    
    EventLoopGroup 包含许多 EventLoops 和分配一个 EventLoop 通道时注册 
    #+END_EXAMPLE
    
**** 实例
     下面代码所示的结果,试图使用一个 Channel 类型与一个 EventLoopGroup 兼容：
     
     #+BEGIN_SRC java :results output :exports result
  EventLoopGroup group = new NioEventLoopGroup();
  Bootstrap bootstrap = new Bootstrap(); //1 创建新的 Bootstrap 来创建新的客户端管道
  bootstrap.group(group) //2 注册 EventLoopGroup 用于获取 EventLoop
  .channel(OioSocketChannel.class) //3 指定要使用的 Channel 类。通知我们使用 NIO 版本用于 EventLoopGroup ， OIO 用于 Channel
  .handler(new SimpleChannelInboundHandler<ByteBuf>() { //4 设置处理器用于管道的 I/O 事件和数据
                  @Override
                  protected void channelRead0(
                          ChannelHandlerContext channelHandlerContext,
                          ByteBuf byteBuf) throws Exception {
                          System.out.println("Reveived data");
                          byteBuf.clear();
                  }
          });
  ChannelFuture future = bootstrap.connect(
          new InetSocketAddress("www.manning.com", 80)); //5 尝试连接到远端。当 NioEventLoopGroup 和 OioSocketChannel 不兼容时，会抛出 IllegalStateException 异常
  future.syncUninterruptibly();
     #+END_SRC
     
     #+RESULTS:
#+BEGIN_EXAMPLE
  Exception in thread "main" java.lang.IllegalStateException: incompatible event loop
  type: io.netty.channel.nio.NioEventLoop
  at
  io.netty.channel.AbstractChannel$AbstractUnsafe.register(AbstractChannel.java:5
  71)
  ...
#+END_EXAMPLE


出现 IllegalStateException 的其他情况是，在 bind() 或 connect() 调用前 调用需要设置参数的方法调用失败时，包括：
+ group()
+ channel() 或 channnelFactory()
+ handler()

handler() 方法尤为重要,因为这些 ChannelPipeline 需要适当配置。 一旦提供了这些参数,应用程序将充分利用 Netty 的能力
