#+TITLE: Netty 多线程模型
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil  ^:nil

* 背景

** Java线程模型的演进

*** 单线程
时间回到十几年前，那时主流的CPU都还是单核（除了商用高性能的小机），CPU的核心频率是机器最重要的指标之一

在Java领域当时比较流行的是单线程编程，对于CPU密集型的应用程序而言， *频繁的通过多线程进行协作和抢占时间片反而会降低性能* 

*** 多线程
随着硬件性能的提升，CPU的核数越来越越多，很多服务器标配已经达到32或64核。通过多线程并发编程，可以充分利用多核CPU的处理能力，提升系统的处理效率和并发性能

从2005年开始，随着多核处理器的逐步普及，java的多线程并发编程也逐渐流行起来，当时商用主流的JDK版本是1.4，用户可以通过 *new Thread() 的方式创建新的线程* 

由于JDK1.4并没有提供类似线程池这样的线程管理容器，多线程之间的同步、协作、创建和销毁等工作都需要用户自己实现。由于 *创建和销毁线程是个相对比较重量级的操作，因此，这种原始的多线程编程效率和性能都不高* 

*** 线程池
为了提升Java多线程编程的效率和性能，降低用户开发难度。JDK1.5推出了 *java.util.concurrent* 并发编程包。在并发编程类库中，提供了 *线程池、线程安全容器、原子类* 等新的类库，极大的提升了Java多线程编程的效率，降低了开发难度

从JDK1.5开始， *基于线程池的并发编程已经成为Java多核编程的主流* 

** Reactor模型
无论是C++还是Java编写的网络框架，大多数都是基于Reactor模式进行设计和开发，Reactor模式 *基于事件驱动，特别适合处理海量的I/O事件* 

*** 单线程模型
Reactor单线程模型，指的是所有的IO操作都在同一个NIO线程上面完成，NIO线程的职责如下：
1. 作为NIO服务端，接收客户端的TCP连接
2. 作为NIO客户端，向服务端发起TCP连接
3. 读取通信对端的请求或者应答消息
4. 向通信对端发送消息请求或者应答消息

Reactor单线程模型示意图如下所示：

  #+ATTR_HTML: image :width 70% 
  [[file:pic/reactor-single-thread.png]]

由于Reactor模式使用的是异步非阻塞IO，所有的IO操作都不会导致阻塞，理论上一个线程可以独立处理所有IO相关的操作。从架构层面看，一个NIO线程确实可以完成其承担的职责。例如，通过Acceptor类接收客户端的TCP连接请求消息，链路建立成功之后，通过Dispatch将对应的ByteBuffer派发到指定的Handler上进行消息解码。用户线程可以通过消息编码通过NIO线程将消息发送给客户端

对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用场景却不合适，主要原因如下：
+ 一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送
+ 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈
+ 可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障

为了解决这些问题，演进出了 *Reactor多线程模型* 

*** 多线程模型
Rector多线程模型与单线程模型最大的区别就是有一组NIO线程处理IO操作，它的原理图如下：

  #+ATTR_HTML: image :width 70% 
  [[file:pic/reactor-multi-threads.png]]

Reactor多线程模型的特点：
+ 有专门一个NIO线程 *Acceptor线程* 用于监听服务端，接收客户端的TCP连接请求
+ 网络IO操作读、写等由 *一个NIO线程池* 负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送
+ *1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程* ，防止发生并发操作问题

在绝大多数场景下，Reactor多线程模型都可以满足性能需求。但是，在极个别特殊场景中， *一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题* 。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型 *主从Reactor多线程模型* 

*** 主从Reactor多线程模型
主从Reactor线程模型的特点是：
+ 服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池
+ Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到IO线程池（sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作
+ Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作

它的线程模型如下图所示：

  #+ATTR_HTML: image :width 70% 
  [[file:pic/reactor-prim-sub-threads.png]]

#+BEGIN_EXAMPLE
利用主从NIO线程模型，可以解决1个服务端监听线程无法有效处理所有客户端连接的性能不足问题
#+END_EXAMPLE

它的工作流程总结如下：
1. 从主线程池中随机选择一个Reactor线程作为Acceptor线程，用于绑定监听端口，接收客户端连接
2. Acceptor线程接收客户端连接请求之后创建新的SocketChannel，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作
3. 业务层的链路正式建立，将SocketChannel从主线程池的Reactor线程的多路复用器上摘除，重新注册到Sub线程池的线程上，用于处理I/O的读写操作

* Netty线程模型

* 总结
