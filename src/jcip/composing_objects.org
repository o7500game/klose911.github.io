#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+TITLE: 对象组合
#+OPTIONS: num:nil timestamp:nil
* 设计线程安全的类　
1. 确定组成对象状态的变量
2. 确定约束对象状态的不变式
3. 建立并发访问对象状态的规则
** 后置条件
    某些变量的取值是有限制范围的, 改变状态变量之后需要检查改变后的状态是否合法, 需要额外同步
** 前置条件
    满足一定的条件操作才能继续进行, 使用wait/notfiy, blocking queue, semaphore
    
* 对象限制
1. 对象限制在类范围内(作为类的私有成员) 
2. 对象限制在方法内部(作为方法的局部变量)　
3. 对象限制在线程范围内(只能在特定线程中访问该对象)　
   
** monitor模式
    #+BEGIN_SRC java
      public class PrivateLock {
              private final Object myLock = new Object();
              @GuardedBy("myLock") Widget widget;
              void someMethod() {
                      synchronized(myLock) {
                      // Access or modify the state of widget
                      }
              }
      }
    #+END_SRC
    使用一个额外对象加锁比使用java内置锁更灵活
    
* 委托线程安全
1. 如果类只包含一个状态变量, 那么类是否是线程安全的, 取决于该状态变量是否是线程安全
2. 如果类中的多个状态变量之间是相互独立的, 那么线程安全的责任仍可以委托给状态变量
3. 如果类中的多个状态变量参与不变式，那需要额外的同步
   
* 对现有类添加线程安全
   
** 继承现有类
    
    #+BEGIN_SRC java
      public class BetterVector<E> extends Vector<E> {
              public synchronized boolean putIfAbsent(E x) {
                      boolean absent = !contains(x);
                      if (absent)
                              add(x);
                      return absent;
              }
      }
    #+END_SRC
    如果父类修改了，就可能破坏子类的同步性，比如contains的含义变化了　
    
** 客户端加锁　
    
    #+BEGIN_SRC java
      public class ListHelper<E> {
              public List<E> list =
                      Collections.synchronizedList(new ArrayList<E>());
              ...
              public boolean putIfAbsent(E x) {
                      synchronized (list) {
                              boolean absent = !list.contains(x);
                              if (absent)
                                      list.add(x);
                              return absent;
                      }
              }
      }
    #+END_SRC 
    客户端加锁更糟糕，因为客户端加锁的策略很可能和被加锁的类自身的锁管理策略相违背　
    
** 对象组合
    #+BEGIN_SRC java
      @ThreadSafe
      public class ImprovedList<T> implements List<T> {
              private final List<T> list;
              public ImprovedList(List<T> list) { this.list = list; }
              public synchronized boolean putIfAbsent(T x) {
                      boolean contains = list.contains(x);
                      if (contains)
                              list.add(x);
                      return !contains;
              }
              public synchronized void clear() { list.clear(); }
      // ... similarly delegate other List methods
      }
    #+END_SRC
    继承父类，把父类对象放进子类的一个final instance, 使用子类的内置锁进行同步
    
    
[[file:build_blocks.org][Next:基础模块]]　[[file:sharing_objects.org][Previous:对象分享]]　[[file:jcip.org][Up:目录]]
