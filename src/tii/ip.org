#+TITLE: IP网际协议
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: tii.html   
#+HTML_LINK_HOME: tii.html
#+OPTIONS: num:nil timestamp:nil  ^:nil *:nil

在本章，将要简要介绍IP首部中的各个字段，讨论IP路由选择和子网的有关内容。还要介绍两个有用的命令：ifconfig和netstat。关于IP首部中一些字段的细节，将留在以后使用这些字段的时候再进行讨论

* IP协议
  IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输：
+ 不可靠(unreliable)：它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，比如某个路由器暂时用完了缓冲区， IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）
+ 无连接(connection less)：IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达
  
** IP首部
普通的IP首部长为20个字节（除非含有选项字段），IP数据报文的格式如图3-1所示：

#+ATTR_HTML: image :width 70% 
[[file:pic/ip-header.png]]

*** 网络字节序
最高位在左边，记为0bit，最低位在右边，记为31bit。4个字节的32bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序

*** 协议版本号
目前的协议版本号是4，因此IP协议有时也称作IPv4协议

*** 首部长度
首部长度指的是首部占32bit(4字节)的数目，包括任何选项。由于它是一个4比特字段，因此首部最长为60个字节(15X4=60)。普通IP数据报（没有任何选择项）字段的值是5(5X4=20个字节)

*** TOS
服务类型（TOS）字段：
+ 一个3bit的优先权子字段（现在已被忽略）
+ 4bit的TOS子字段，4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务：
  + 最小时延
  + 最大吞吐量
  + 最高可靠性
  + 最小费用
+ 1bit未用位但必须置0

下表列出了对不同应用建议的TOS值。在最后一列中给出的是十六进制值，因为这就是在后面将要看到的tcpdump命令输出：
#+CAPTION: 服务类型字段推荐值
#+ATTR_HTML: :border 1 :rules all :frame boader
| 应用程序      | 最小时延 | 最大吞吐量 | 最高可靠性 | 最小费用 | 16机制值 |
| Telnet/Rlogin | 1        | 0          | 0          | 0        | 0x10     |
| FTP控制       | 1        | 0          | 0          | 0        | 0x10     |
| FTP数据       | 0        | 1          | 0          | 0        | 0x08     |
| 任意数据块    | 0        | 1          | 0          | 0        | 0x08     |
| TFTP          | 1        | 0          | 0          | 0        | 0x10     |
| SMTP命令阶段  | 1        | 0          | 0          | 0        | 0x10     |
| SMTP数据阶段 | 0        | 1          | 0          | 0        | 0x08     |
| DNS-UDP查询   | 1        | 0          | 0          | 0        | 0x10     |
| DNS-TCP查询 | 0        | 0          | 0          | 0        | 0x00     |
| DNS-区域传输 | 0        | 1          | 0          | 0        | 0x08     |
| ICMP差错    | 0        | 0          | 0          | 0        | 0x00     |
| ICMP查询    | 0        | 0          | 0          | 0        | 0x00     |
| ICMP-任何IGP | 0        | 0          | 1          | 0        | 0x04     |
| SNMP          | 0        | 0          | 0          | 0        | 0x00     |
| BOOTP         | 0        | 0          | 1          | 0        | 0x04     |
| NNTP          | 0        | 0          | 0          | 1        | 0x02     |

Telnet和Rlogin这两个交互应用要求最小的传输时延，因为人们主要用它们来传输少量的交互数据。另一方面，FTP文件传输则要求有最大的吞吐量。最高可靠性被指明给网络管理（SNMP）和路由选择协议。用户网络新闻（Usenet news, NNTP）是唯一要求最小费用的应用

现在大多数的TCP/IP实现都不支持TOS特性，但是自4.3BSDReno以后的新版系统都对它进行了设置。另外，新的路由协议如OSPF和IS-IS都能根据这些字段的值进行路由决策

*** 总长度
总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节

尽管可以传送一个长达65535字节的IP数据报，但是大多数的链路层都会对它进行分片。当数据报被分片时，该字段的值也随着变化。由于TCP把用户数据分成若干片，因此一般来说这个限制不会影响TCP。比如大量使用UDP的应用（RIP，TFTP，BOOTP，DNS，以及SNMP），它们都限制用户数据报长度为512字节，小于576字节。但是事实上现在大多数的实现（特别是那些支持网络文件系统NFS的实现）允许超过8192字节的IP数据报

总长度字段是IP首部中必要的内容，因为一些数据链路（如以太网）需要填充一些数据以达到最小长度。尽管以太网的最小帧长为46字节，但是IP数据可能会更短。如果没有总长度字段，那么IP层就不知道46字节中有多少是IP数据报的内容

*** 标识，标志，片偏移
标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。以后会介绍分片和重组时再详细讨论它。同样在讨论分片时再来分析标志字段和片偏移字段。

有人认为标识字段应该由让IP发送数据报的上层来选择。假设有两个连续的IP数据报，其中一个是由TCP生成的，而另一个是由UDP生成的，那么它们可能具有相同的标识字段。尽管这也可以照常工作（由重组算法来处理），但是在大多数从伯克利派生出来的系统中，每发送一个IP数据报，IP层都要把一个内核变量的值加1，不管交给IP的数据来自哪一层。内核变量的初始值根据系统引导时的时间来设置

*** TTL
TTL生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机

*** 协议
第1章讨论了协议字段，并在图1-8中示出了它如何被IP用来对数据报进行分用。根据它可以识别是哪个协议向IP传送数据

*** 首部校验和
首部检验和字段是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。

为了计算一份数据报的IP检验和，首先把检验和字段置为0。然后，对首部中每个16bit进行二进制反码求和（整个首部看成是由一串16bit的字组成），结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传

ICMP、IGMP、UDP和TCP都采用相同的检验和算法，尽管TCP和UDP除了本身的首部和数据外，在IP首部中还包含不同的字段。由于路由器经常只修改TTL字段（减1），因此当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算。但是标准的BSD实现在转发数据报时并不是采用这种增加的办法

*** 源IP地址，目的IP地址
它们都是32bit的值

*** 选项
数据报中的一个可变长的可选信息。目前，这些任选项定义如下：
+ 安全和处理限制（用于军事领域）
+ 记录路径（让每个路由器都记下它的IP地址）
+ 时间戳（让每个路由器都记下它的IP地址和时间）
+ 宽松的源站选路（为数据报指定一系列必须经过的IP地址）
+ 严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址）

这些选项很少被使用，并非所有的主机和路由器都支持这些选项。选项字段一直都是以32bit作为界限，在必要的时候插入值为0的填充字节。这样就保证IP首部始终是32bit的整数倍（这是首部长度字段所要求的）

** 路由
从概念上说， IP路由选择是简单的，特别对于主机来说。如果目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。大多数的主机都是采用这种简单机制

当今的大多数多用户系统，包括几乎所有的Unix系统，都可以配置成一个路由器。可以为它指定主机和路由器都可以使用的简单路由算法。本质上的区别在于主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。内含路由器功能的主机应该从不转发数据报，除非它被设置成那样

IP可以从TCP、UDP、ICMP和IGMP接收数据报（在本地生成的数据报）并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查：
+ 如果目的IP地址是否为本机的IP地址之一或者IP广播地址，数据报就被送到由IP首部协议字段所指定的协议模块进行处理
+ 如果数据报的目的不是这些地址，那么：
  1. 如果IP层被设置为路由器的功能，那么就对数据报进行转发
  2. 否则数据报被丢弃

*** 路由表
路由表中的每一项都包含下面这些信息：
+ 目的IP地址：它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）
+ 下一跳路由器的IP地址，或者有直接连接的网络IP地址：指一个在直接相连网络上的路由器，通过它可以转发数据报。下一跳路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的
+ 标志：一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口
+ 为数据报的传输指定一个网络接口

*** 路由选择
IP路由选择是逐跳地进行的。从这个路由表信息可以看出，IP并不知道到达任何目的的完整路径（除了那些与主机直接相连的目的）。所有的IP路由选择只为数据报传输提供下一站路由器的I P地址。它假定下一站路由器比发送数据报的主机更接近目的，而且下一站路由器与该主机是直接相连的

IP路由选择主要完成以下这些功能：
1. 搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）
2. 搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑可能的子网掩码
3. 搜索路由表，寻找标为“默认（default）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器

如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误

完整主机地址匹配在网络号匹配之前执行。只有当它们都失败后才选择默认路由。默认路由，以及下一站路由器发送的ICMP间接报文（如果我们为数据报选择了错误的默认路由），是IP路由选择机制中功能强大的特性。为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模，比如Internet上的路由器有只有几千个表目，而不会是超过100万个表目

*** 路由实例
首先看个简单的例子：主机bsdi有一个IP数据报要发送给主机sun。双方都在同一个以太网上。数据报的传输过程如图3-3所示：

#+ATTR_HTML: image :width 70% 
[[file:pic/simple-route.png]]

当IP从某个上层收到这份数据报后，它搜索路由表，发现目的IP地址(140.252.13.33)在一个直接相连的网络上（以太网140.252.13.0）。于是，在表中找到匹配网络地址（在下一节中，我们将看到，由于以太网的子网掩码的存在，实际的网络地址是140.252.13.32，但是这并不影响这里所讨论的路由选择）

数据报被送到以太网驱动程序，然后作为一个以太网数据帧被送到sun主机上。IP数据报中的目的地址是sun的IP地址(140.252.13.33)，而在链路层首部中的目的地址是48bit的sun主机的以太网接口地址。这个48bit的以太网地址是用ARP协议获得的

现在来看另一个更复杂的例子，主机bsdi有一份IP数据报要发送到ftp.uu.net主机上，它的IP地址是192.48.96.9。经过的前三个路由器如下图所示：

#+ATTR_HTML: image :width 70% 
[[file:pic/complex-route.png]]

1. 首先主机bsdi搜索路由表，但是没有找到与主机地址或网络地址相匹配的表目，因此只能使用默认的表目，把数据报发送给下一站路由器，即sun
2. 当sun收到数据报后，它发现数据报的目的IP地址并不是本机的任一地址，而sun已被设置成具有路由器的功能，因此它把数据报进行转发。经过搜索路由表，选用了默认表目。根据sun的默认表目，它把数据报转发到下一站路由器netb，该路由器的地址是140.252.1.183。数据报是经过点对点SLIP链路被传送的，这里没有给出像以太网链路层数据帧那样的首部，因为在SLIP链路中没有那样的首部
3. 当netb收到数据报后，它执行与sun主机相同的步骤：数据报的目的地址不是本机地址，而netb也被设置成具有路由器的功能，于是它也对该数据报进行转发。采用的也是默认路由表目，把数据报送到下一站路由器gateway（140.252.1.4）。位于以太网140.252.1上的主机netb用ARP获得对应于140.252.1.4的48bit以太网地址。这个以太网地址就是链路层数据帧头上的目的地址
4. 路由器gateway也执行与前面两个路由器相同的步骤。它的默认路由表目所指定的下一站路由器IP地址是140.252.104.2

对于这个例子需要指出一些关键点：
+ 所有主机和路由器都使用了默认路由。事实上大多数主机和一些路由器可以用默认路由来处理任何目的，除非它在本地局域网上
+ 数据报中的目的IP地址始终不发生任何变化（只有使用源路由选项时，目的IP地址才有可能被修改，但这种情况很少出现）。所有的路由选择决策都是基于这个目的IP地址
+ 每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址。在例子中，两个以太网封装了含有下一站以太网地址的链路层首部，但是SLIP链路没有这样做。以太网地址一般通过ARP获得

在描述了ICMP之后将再次讨论IP路由选择问题。这时将看到一些更具体的路由表的例子，以及如何用它们来进行路由决策的

** IP地址格式
