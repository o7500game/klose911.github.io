#+TITLE: TCP：超时和重传
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: tcp-bucket-transmission.html   
#+HTML_LINK_HOME: tii.html
#+OPTIONS: num:nil timestamp:nil  ^:nil

TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时 *设置一个定时器* 来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于 *超时和重传的策略* ，即怎样决定超时间隔和如何确定重传的频率

已经看到过两个超时和重传的例子：
+ ICMP端口不能到达的例子中，看到TFTP客户使用UDP实现了一个简单的超时和重传机制：假定5秒是一个适当的时间间隔，并每隔5秒进行重传
+ 在向一个不存在的主机发送ARP的例子中，当TCP试图建立连接的时候，在每个重传之间使用一个较长的时延来重传SYN
  
对每个连接，TCP管理4个不同的定时器：
1. *重传* 定时器：当希望收到另一端的确认。在本章将详细讨论这个定时器以及一些相关的问题，如拥塞避免
2. *坚持* 定时器：使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口
3. *保活* 定时器：可检测到一个空闲连接的另一端何时崩溃或重启
4. *2MSL* 定时器：测量一个连接处于TIME_WAIT状态的时间，已经介绍过了
   
本章以一个简单的TCP超时和重传的例子开始，然后转向一个更复杂的例子。该例子可以观察到TCP时钟管理的所有细节。看到TCP的典型实现是怎样测量TCP报文段的往返时间以及TCP如何使用这些测量结果来为下一个将要传输的报文段建立重传超时时间。接着将研究TCP的 *拥塞避免* ：当分组丢失时TCP所采取的动作，并提供一个分组丢失的实际例子。最后将介绍较新的 *快速重传* 和 *快速恢复* 算法，并介绍该算法如何使TCP检测分组丢失比等待时钟超时更快

* 简单例子
  首先观察TCP所使用的重传机制，先将建立一个连接，发送一些分组来证明一切正常，然后拔掉电缆，发送更多的数据，再观察TCP的行为：
  
  #+ATTR_HTML: image :width 70% 
  [[file:pic/tcp-retransmission-simple-example.png]]
  
  图21-1表示的是tcpdump的输出结果：
  
  #+ATTR_HTML: image :width 70% 
  [[file:pic/tcp-retransmission-simple-dump.png]]
  
+ 第1、2和3行：正常的TCP连接建立的过程
+ 第4行："hello,world"（12个字符加上回车和换行）的传输过程
+ 第5行：其确认
+ svr4拔掉了以太网电缆
+ 第6行："and hi"将被发送
+ 第7~18行：这个报文段的 *12次重传* 
+ 第19行：发送方的TCP最终放弃并发送一个 *RST信号*
  
** 指数退避
   检查连续重传之间不同的时间差，它们取整后分别为1、3、6、12、24、48和多个64秒。后面将看到当第一次发送后所设置的超时时间实际上为1.5秒（它在首次发送后的1.0136秒而不是精确的1.5秒后，发生的原因已经解释过），此后该时间在每次重传时增加1倍并直至64秒
   
   这个倍乘关系被称为 *指数退避* 。可以将该例子与TFTP例子比较，在那里每次重传总是在前一次的5秒后发生 
   
   首次分组传输（第6行，24.480秒）与复位信号传输（第19行，566.488秒）之间的时间差约为 *9分钟* 
   
* 往返时间测量
