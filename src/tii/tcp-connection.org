#+TITLE: TCP：连接的建立和终止
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: tcp.html   
#+HTML_LINK_HOME: tii.html
#+OPTIONS: num:nil timestamp:nil  ^:nil

TCP是一个面向连接的协议： *无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接* 

#+BEGIN_EXAMPLE
  这种两端间连接的建立与无连接协议如UDP不同，一端使用UDP向另一端发送数据报时，无需任何预先的握手
#+END_EXAMPLE

* 连接的建立与终止
  为了了解一个TCP连接在建立及终止时发生了什么，在系统svr4上键入下列命令：
  
  #+ATTR_HTML: image :width 70% 
  [[file:pic/tcp-telnet.png]]
  
  telnet命令在与丢弃(discard)服务对应的端口上与主机bsdi建立一条TCP连接。这服务类型正是需要观察的一条连接建立与终止的服务类型，而不需要服务器发起任何数据交换
  
** tcpdump的输出
   图18-1显示了这条命令产生TCP报文段的tcpdump输出：
   
   #+ATTR_HTML: image :width 90% 
   [[file:pic/tcp-connection-dump.png]]
   
   这7个TCP报文段仅包含TCP首部，没有任何数据。对于TCP段，每个输出行开始按如下格式显示：
   
   #+BEGIN_EXAMPLE
   源 > 目的 : 标志
   #+END_EXAMPLE
   
   这里的标志代表TCP首部中6个标志比特中的4个。下表显示了标志的5个字符的含义：
   
   #+CAPTION: tcpdump对TCP首部中部分标志比特的字符表示
   #+ATTR_HTML: :border 1 :rules all :frame boader
   | 标志 | 3字符缩写 | 描述               |
   | S    | SYN       | 同步序号           |
   | F    | FIN       | 发送方完成数据发送 |
   | R    | RST       | 复位连接       |
   | P    | PSH       | 尽可能快地将数据发往接收进程 |
   | .    |           | 以上4个标志皆为0          |
   
   在这个例子中，看到了 *S* 、 *F* 和 *.* 标志符。以后看到其他的两个标志（ *R* 和 *P* ）。TCP首部中的其他两个标志比特 *ACK* 和 *URG*，tcpdump将作特殊显示。表中4个标志比特中的多个可能同时出现在一个报文段中，但通常一次只见到一个
   
   #+BEGIN_EXAMPLE
   RFC 1025将一种报文段称为Kamikaze分组Θ，在这样的报文段中有最大数量的标志比特同时被置为1（SYN,URG,PSH,FIN和1字节的数据）。这样的报文段也叫作nastygram,圣诞树分组，灯测试报文段
   #+END_EXAMPLE
   
+ 在第1行 *1415531521:1415531521(0)* : 分组的序号是1415531521，而报文段中数据字节数为0
  + tcpdump显示这个字段的格式：
    + 开始的序号
    + 一个冒号
    + 隐含的结尾序号
    + 圆括号内的数据字节数
  + 优点：便于了解数据字节数大于0时的隐含结尾序号
  + *隐含的结尾序号只有在满足下面条件之一才显示* ：
    1. 报文段中至少包含一个数据字节
    2. SYN、FIN或RST被设置为1时才显示
       
+ 在第2行中 *ack 1415531522* ：确认序号， *它只有在首部中的ACK标志比特被设置1时才显示* 
  
+ 每行显示的字段 *win 4096* : 发送端通告的窗口大小。例子中没有交换任何数据，所以窗口大小就维持默认情况下的4096
  
+ 最后一个字段 *<mss1024>* ：由发送端指明的最大报文段长度选项。发送端将不接收超过这个长度的TCP报文段。这通常是为了避免分段
  
** 时序图
   图18-3显示了这些分组序列的时间系列，这个图显示出哪一端正在发送分组：
   
   #+ATTR_HTML: image :width 70% 
   [[file:pic/tcp-connection-sequence.png]]
   
** 建立连接
   为了建立一条TCP连接：
1. 报文段1：请求端（通常称为客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，在这个例子中为1415531521）
2. 报文段2：服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时， *将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认，而且一个SYN将占用一个序号* 
3. 报文段3：客户必须 *将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认*
   
发送第一个SYN的一端将执行主动打开。接收这个SYN并发回下一个SYN的另一端执行被动打开

当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。RFC 793指出ISN可看作是一个32比特的计数器，每4ms加1。这样选择序号的目的在于 *防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释* 

#+BEGIN_EXAMPLE
  如何进行序号选择？

  在4.4BSD（和多数的伯克利的实现版）中，系统初始化时初始的发送序号被初始化为1

  这个变量每0.5秒增加64000，并每隔9.5小时又回到0（对应这个计数器每8 ms加1，而不是每4 ms加1）

  另外，每次建立一个连接后，这个变量将增加64000
#+END_EXAMPLE

报文段3与报文段4之间4.1秒的时间间隔是建立TCP连接到向telnet键入quit命令来中止该连接的时间

** 连接终止
   建立一个连接需要三次握手，而终止一个连接要经过4次握手，这由TCP的半关闭造成的。 *因为一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭*  。这原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须通知应用层另一端已经终止了那个方向的数据传送。 *发送FIN通常是应用层进行关闭的结果* 
   
   #+BEGIN_EXAMPLE
   收到一个FIN只意味着在这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据
   
   而这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的TCP应用程序这样做
   #+END_EXAMPLE
   
   首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭，但也可能双方都执行主动关闭
   
   正常关闭过程如图18-3所示：
1. 报文段4：发起终止连接，它由Telnet客户端关闭连接时发出。这在键入quit命令后发生。它将导致TCP客户端发送一个FIN，用来关闭从客户到服务器的数据传送
2. 报文段5：当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。 *和SYN一样，一个FIN将占用一个序号* 
   + TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符
3. 报文段6：这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN
4. 报文段7：客户必须发回一个确认，并将确认序号设置为收到序号加1
   
图18-4显示了终止一个连接的典型握手顺序。在这个图中，发送FIN将导致应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的：

#+ATTR_HTML: image :width 70% 
[[file:pic/tcp-connection-close.png]]

连接通常是由客户端发起的，这样第一个SYN从客户传到服务器。每一端都能主动关闭这个连接（即首先发送FIN）。然而，一般由客户端决定何时终止连接，因为客户进程通常由用户交互控制，用户会键入诸如“quit”一样的命令来终止进程。在图18-4中，我们能改变上边的标识，将左方定为服务器，右方定为客户，一切仍将像显示的一样工作

** 正常的tcpdump输出
   对所有的数值很大的序号进行排序是很麻烦的，因此默认情况下tcpdump只在显示SYN报文段时显示完整的序号，而对其后的序号则显示它们与初始序号的相对偏移值
   
   除非我们需要显示完整的序号，否则将在以下的例子中使用这种形式的输出显示：
   
   #+ATTR_HTML: image :width 70% 
   [[file:pic/tcp-normal-dump.png]]
   
* 连接建立的超时
  有很多情况导致无法建立连接。一种情况是服务器主机没有处于正常状态。为了模拟这种情况，我们断开服务器主机的电缆线，然后向它发出telnet命令。图18-6显示了tcpdump的输出:
  
  #+ATTR_HTML: image :width 70% 
  [[file:pic/tcp-connection-timeout.png]]
  
  
  在这个输出中有趣的一点是客户间隔多长时间发送一个SYN，试图建立连接。第2个SYN与第1个的间隔是5.8秒，而第3个与第2个的间隔是24秒
  
  #+BEGIN_EXAMPLE
  这个例子运行38分钟后客户重新启动。这对应初始序号为291008001（约为38×60×64000×2）
  
  曾经介绍过使用典型的伯克利实现版的系统将初始序号初始化为1，然后每隔0.5秒就增加64000
  
  另外，因为这是系统启动后的第一个TCP连接，因此客户的端口号是1024
  #+END_EXAMPLE
  
  图18-6中没有显示客户端在放弃建立连接尝试前进行SYN重传的时间。为了了解它我们必须对telnet命令进行计时：
  
  #+ATTR_HTML: image :width 70% 
  [[file:pic/telnet-timeout.png]]
  
  时间差值是76秒，这是因为大多数伯克利系统将建立一个新连接的最长时间限制为75秒
  
** 服务类型字段
   在图18-6中，出现了符号 [tos 0x10]。这是IP数据报内的服务类型（TOS）字段。BSD/386中的Telnet客户进程将这个字段设置为最小时延
   
* 最大报文段长度
  
  最大报文段长度(MSS)：TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。已经见过MSS都是1024。这导致IP数据报通常是40字节长：20字节的TCP首部和20字节的IP首部
  
  它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（ *MSS选项只能出现在SYN报文段中* ）。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报）
  
  一般说来，如果没有分段发生，MSS还是越大越好（这也并不总是正确）。报文段越大允许每个报文段传送的数据就越多，相对IP和TCP首部有更高的网络利用率。当TCP发送一个SYN时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它将MSS值设置为 *外出接口上的MTU长度减去固定的IP首部和TCP首部长度* 。对于一个以太网，MSS值可达 *1460字节* 。使用IEEE 802.3的封装，它的MSS可达 *1452字节* 
  
  #+BEGIN_EXAMPLE
  在本章见到的涉及BSD/386和SVR4的MSS为1024，这是因为许多BSD的实现版本需要MSS为512的倍数
  
  其他的系统，如SunOS 4.1.3、Solaris 2.2和AIX 3.2.2，当双方都在一个本地以太网上时都规定MSS为1460
  
  以太网上1460的MSS在性能上比1024的MSS更好
  #+END_EXAMPLE
  
  如果目的IP地址为“非本地的”，MSS通常的默认值为 *536* 。而区分地址是本地还是非本地是简单的，如果目的IP地址的网络号与子网号都和我们的相同，则是本地的；如果目的IP地址的网络号与我们的完全不同，则是非本地的；如果目的IP地址的网络号与我们的相同而子网号与我们的不同，则可能是本地的，也可能是非本地的。大多数TCP实现版都提供了一个配置选项，让系统管理员说明不同的子网是属于本地还是非本地。这个选项的设置将 *确定MSS可以选择尽可能的大（达到外出接口的MTU长度）或是默认值536* 
  
  MSS让主机限制另一端发送数据报的长度。加上主机也能控制它发送数据报的长度，这将使以较小MTU连接到一个网络上的主机避免分段
  
** 实例
   考虑主机slip，通过MTU为296的SLIP链路连接到路由器bsdi上。图18-8显示这些系统和主机sun：
   
   #+ATTR_HTML: image :width 70% 
   [[file:pic/mss-sample.png]]
   
   从sun向slip发起一个TCP连接，并使用tcpdump来观察报文段。图18-9显示这个连接的建立：
   
   #+ATTR_HTML: image :width 70% 
   [[file:pic/tcp-connection-mss.png]]
   
   在这个例子中，sun发送的报文段不能超过256字节的数据，因为它收到的MSS选项值为256。此外，由于slip知道它外出接口的MTU长度为296，即使sun已经通告它的MSS为1460，但为避免将数据分段，它不会发送超过256字节数据的报文段。系统允许发送的数据长度小于另一端的MSS值
   
   *只有当一端的主机以小于576字节的MTU直接连接到一个网络中，避免这种分段才会有效* 。如果两端的主机都连接到以太网上，都采用536的MSS，但中间网络采用296的MTU，也将会出现分段。使用路径上的MTU发现机制是关于这个问题的唯一方法
   
* TCP的半关闭
