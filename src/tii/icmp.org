#+TITLE: ICMP控制报文协议
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: rarp.html   
#+HTML_LINK_HOME: tii.html
#+OPTIONS: num:nil timestamp:nil  ^:nil *:nil

* ICMP协议
  ICMP经常被认为是IP层的一个组成部分。它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（TCP或UDP）使用。一些ICMP报文把差错报文返回给用户进程。ICMP报文是在IP数据报内部被传输的，如图6-1所示：
  
  #+ATTR_HTML: image :width 40% 
  [[file:pic/icmp-encapsulation.png]]
  
** 报文
   ICMP报文的格式如图6-2所示：
   
   #+ATTR_HTML: image :width 40% 
   [[file:pic/icmp-packet.png]]
   
   所有报文的前4个字节都是一样的：
+ 类型字段可以有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件
+ 检验和字段覆盖整个ICMP报文。使用的算法与在3.2节中介绍的IP首部检验和算法相同。ICMP的检验和是必需的
  
剩下的其他字节则互不相同 

*** 报文类型
    各种类型的ICMP报文如下表所示，不同类型由报文中的类型字段和代码字段来共同决定：
    
    #+CAPTION: ICMP报文类型
    #+ATTR_HTML: :border 1 :frame boader
    | 类型 | 代码 | 描述                           | 查询 | 差错 |
    |------+------+--------------------------------+------+------|
    |    0 |    0 | 回显应答                       | •    |      |
    |------+------+--------------------------------+------+------|
    |    3 |      | 目的不可达                     |      |      |
    |      |    0 | 网络不可达                     |      | •    |
    |      |    1 | 主机不可达                     |      | •    |
    |      |    2 | 协议不可达                     |      | •    |
    |      |    3 | 端口不可达                     |      | •    |
    |      |    4 | 需要进行分片但设置了不分片比特 |      | •    |
    |      |    5 | 源站选路失败                   |      | •    |
    |      |    6 | 目的网络不认识                 |      | •    |
    |      |    7 | 目的主机不认识                 |      | •    |
    |      |    8 | 源主机被隔离(作废不用)         |      | •    |
    |      |    9 | 目的网络被强制禁止             |      | •    |
    |      |   10 | 目的主机被强制禁止             |      | •    |
    |      |   11 | 由于服务类型TOS，网络不可达    |      | •    |
    |      |   12 | 由于服务类型TOS，主机不可达    |      | •    |
    |      |   13 | 由于过滤，通信被强制禁止       |      | •    |
    |      |   14 | 主机越权                       |      | •    |
    |      |   15 | 优先权中止生效                 |      | •    |
    |------+------+--------------------------------+------+------|
    |    4 |    0 | 源端被关闭(基本流控制)         |      | •    |
    |------+------+--------------------------------+------+------|
    |    5 |      | 重定向                         |      |      |
    |      |    0 | 对网络重定向                   |      | •    |
    |      |    1 | 对主机重定向                   |      | •    |
    |      |    2 | 对服务类型和网络重定向         |      | •    |
    |      |    3 | 对服务类型和主机重定向         |      | •    |
    |------+------+--------------------------------+------+------|
    |    8 |    0 | 请求回显                       | •    |      |
    |------+------+--------------------------------+------+------|
    |    9 |    0 | 路由器通告                     | •    |      |
    |   10 |    0 | 路由器请求                     | •    |      |
    |------+------+--------------------------------+------+------|
    |   11 |      | 超时                           |      |      |
    |      |    0 | 传输期间生存时间为0            |      | •    |
    |      |    1 | 在数据报组装期间生存时间为0    |      | •    |
    |------+------+--------------------------------+------+------|
    |   12 |      | 参数问题                       |      |      |
    |      |    0 | 坏的IP首部(包括各种差错)       |      | •    |
    |      |    1 | 缺少必需的选项                 |      | •    |
    |------+------+--------------------------------+------+------|
    |   13 |    0 | 时间戳请求                     | •    |      |
    |   14 |    0 | 时间戳应答                     | •    |      |
    |------+------+--------------------------------+------+------|
    |   15 |    0 | 信息请求(作废不用)             | •    |      |
    |   16 |    0 | 信息应答(作废不用)             | •    |      |
    |------+------+--------------------------------+------+------|
    |   17 |    0 | 地址掩码请求                   | •    |      |
    |   18 |    0 | 地址掩码应答                   | •    |      |
    
    表中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。因为对ICMP差错报文有时需要作特殊处理，所以需要对它们进行区分。例如，在对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文（如果没有这个限制规则，可能会遇到一个差错产生另一个差错的情况，而差错再产生差错，这样会无休止地循环下去） 
    
    当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议（根据IP数据报首部中的协议字段来判断）和用户进程（根据包含在IP数据报前8个字节中的TCP或UDP报文首部中的TCP或UDP端口号来判断）联系起来
    
    下面各种情况都不会导致产生ICMP差错报文：
+ ICMP差错报文（但是ICMP查询报文可能会产生ICMP差错报文）
+ 目的地址是广播地址或多播地址的IP数据报
+ 作为链路层广播的数据报
+ 不是IP分片的第一片
+ 源地址不是单个主机的数据报，例如源地址不能为零地址、环回地址、广播地址或多播地址
  
这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴

*** 地址掩码请求与应答 
    ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码。系统广播它的ICMP请求报文（这一过程与无盘系统在引导过程中用RARP获取IP地址是类似的，无盘系统获取子网掩码的另一个方法是BOOTP协议）。ICMP地址掩码请求和应答报文的格式如图6-4所示：
    
    #+ATTR_HTML: image :width 70% 
    [[file:pic/icmp-network-mask.png]]
    
    ICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。这样，发送端就可以把应答与请求进行匹配
    
**** 广播地址掩码请求 
     可以写一个简单的程序（命名为icmpaddrmask），它发送一份ICMP地址掩码请求报文，然后打印出所有的应答。由于一般是把请求报文发往广播地址，这里也这样做，其中目的地址（140.252.13.63）是子网140.252.13.32的广播地址：
     #+BEGIN_SRC sh :results output :exports result
  sun $ icmpaddrmask 140.252.13.63
     #+END_SRC
     
     #+RESULTS:
     #+begin_example
     received mask = ffffffe0, from 140.252.13.3 来自 本机
     received mask = ffffffe0, from 140.252.13.5 来自 bsdi
     received mask = ffff0000, from 140.252.13.4 来自 svr4
     #+end_example     
     
首先在输出中注意到的是，从svr4返回的子网掩码是错的。显然，尽管svr4接口已经设置了正确的子网掩码，但是svr4还是返回了一个普通的B类地址掩码，就好像子网并不存在一样：
     #+BEGIN_SRC sh :results output :exports result
       svr4 $ ifconfig emd0
     #+END_SRC
     
     #+RESULTS:
     #+begin_example
       emd0: flags=23<UP,BROADCAST,NOTRAILERS>
             inet 140.252.13.34 netmask ffffffe0 broadcast 140.252.13.63
     #+end_example 

由此可见svr4处理ICMP地址掩码请求过程存在差错。用tcpdump命令来查看主机bsdi上的情况，输出如图6-5所示：
    #+ATTR_HTML: image :width 70% 
    [[file:pic/icmp-netmask-tcpdump.png]]

+ 尽管在线路上什么也看不见，但是发送主机sun也能接收到ICMP应答（“来自本机”的输出行）。这是广播的一般特性：发送主机也能通过某种内部环回机制收到一份广播报文拷贝。由于术语“广播”的定义是指局域网上的所有主机，因此它必须包括发送主机在内（当以太网驱动程序识别出目的地址是广播地址后，它就把分组送到网络上，同时传一份拷贝到环回接口）
+ bsdi广播应答，而svr4却只把应答传给请求主机。通常，应答地址必须是单播地址，除非请求端的源IP地址是0.0.0.0。本例不属于这种情况，因此，把应答发送到广播地址是BSD的一个内部差错


**** 向本机发送地址掩码请求 
向本机IP地址和环回地址分别发送地址掩码请求：
     #+BEGIN_SRC sh :results output :exports result
       sun $ icmpaddrmask sun
     #+END_SRC
     
     #+RESULTS:
     #+begin_example
       received mask= ff000000, from 140.252.13.33
     #+end_example   

     #+BEGIN_SRC sh :results output :exports result
       sun $ icmpaddrmask localhost
     #+END_SRC
     
     #+RESULTS:
     #+begin_example
       received mask= ff000000, from 127.0.0.1
     #+end_example   
上述两种情况下返回的地址掩码对应的都是环回地址，即A类地址127.0.0.1。ICMP地址掩码应答必须是收到请求接口的子网掩码（这是因为多接口主机每个接口有不同的子网掩码），因此两种情况下地址掩码请求都来自于环回接口。所以说发送给本机IP地址的数据报（140.252.12.33）实际上是送到环回接口

*** 时间戳请求与应答
    
*** 端口不可达
    
** ICMP报文的4.4BSD处理
   
