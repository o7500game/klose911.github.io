#+TITLE: IP选路
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: traceroute.html   
#+HTML_LINK_HOME: tii.html
#+OPTIONS: num:nil timestamp:nil  ^:nil *:nil

选路是IP最重要的功能之一。图9-1是IP层处理过程的简单流程：

#+ATTR_HTML: image :width 70% 
[[file:pic/route-process.png]]

需要进行选路的数据报可以由本地主机产生，也可以由其他主机产生。在后一种情况下，主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就要被丢弃

图中还描述了一个路由守护程序，通常这是一个用户进程。在Unix系统中，大多数普通的守护程序都是路由程序和网关程序。在某个给定主机上运行何种路由协议，如何在相邻路由器上交换选路信息，以及选路协议是如何工作的，所有这些问题都是非常复杂的，其本身就可以用整本书来加以讨论。下一章将简单讨论动态选路和选路信息协议RIP。在本章主要的目的是了解单个IP层如何作出路由决策

图中所示的路由表经常被IP访问，但是它被路由守护程序更新的频度却要低得多。当接收到ICMP重定向报文时，路由表也要被更新，这一点将在讨论route命令时加以介绍。在本章中，还将用netstat命令来显示路由表

* 路由表
开始讨论IP选路之前，首先要理解内核是如何维护路由表的。路由表中包含的信息决定了IP层所做的所有决策。在3.3节中，曾经列出了IP搜索路由表的几个步骤：
1. 搜索匹配的主机地址
2. 搜索匹配的网络地址
3. 搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为0）

匹配主机地址步骤始终发生在匹配网络地址步骤之前

IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。IP执行选路机制，而路由守护程序则一般提供选路策略

** 简单路由表
在主机svr4上，先执行带-r选项的netstat命令列出路由表，然后以-n选项再次执行该命令，以数字格式打印出IP地址：
#+ATTR_HTML: image :width 70% 
[[file:pic/simple-route-table.png]]

*** 输出字段
**** Flags字段
对于一个给定的路由器，可以打印出五种不同的标志(flag)：
+ U：该路由可以使用
+ G：该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的
+ H：该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址（一个网络号，或者网络号与子网号的组合）
+ D：该路由是由重定向报文创建
+ M：该路由已被重定向报文修改

标志G是非常重要的，因为由它区分了间接路由和直接路由（直接路由来说是不设置标志G的）。其区别在于：
+ 发往直接路由的分组中不但具有指明目的端的IP地址，还具有其链路层地址
+ 当分组被发往一个间接路由时，IP地址指明的是最终的目的地，但是链路层地址指明的是网关（即下一站路由器）。我们在图3-4已看到这样的例子。在这个路由表例子中，有一个间接路由（设置了标志G），因此采用这一项路由的分组其IP地址是最终的目的地（140.252.13.65），但是其链路层地址必须对应于路由器140.252.13.35

H标志表明，目的地址是一个完整的主机地址。没有设置H标志说明目的地址是一个网络地址（主机号部分为0）。当为某个目的IP地址搜索路由表时，主机地址项必须与目的地址完全匹配，而网络地址项只需要匹配目的地址的网络号和子网号就可以了。另外，大多数版本的netstat命令首先打印出所有的主机路由表项，然后才是网络路由表项

**** Refcnt字段
参考记数：正在使用路由的活动进程个数。面向连接的协议如TCP在建立连接时要固定路由。如果在主机svr4和slip之间建立Telnet连接，可以看到参考记数值变为1。建立另一个Telnet连接时，它的值将增加为2，依此类推

**** Use字段
显示的是通过该路由发送的分组数。如果我们是这个路由的唯一用户，那么运行ping程序发送5个分组后，它的值将变为5

**** Interface字段
本地网络接口的名字

*** 输出解释
+ 第1行：如果目的地是140.252.13.65（slip主机），那么网关（路由器）将把分组转发给140.252.13.35（bsdi）。这正是所期望的，因为主机slip通过SLIP链路与bsdi相连接，而bsdi与该主机在同一个以太网上
+ 第2行：是环回接口，它的名字始终为lo0。没有设置G标志，因为该路由不是一个网关。H标志说明目的地址（127.0.0.1）是一个主机地址，而不是一个网络地址。由于没有设置G标志，说明这是一个直接路由，网关列给出的是外出IP地址
+ 第3行：默认路由。每个主机都有一个或多个默认路由。这一项表明，如果在表中没有找到特定的路由，就把分组发送到路由器140.252.13.33（sun主机）。这说明当前主机（svr4）利用这一个路由表项就可以通过Internet经路由器sun（及其SLIP链路）访问其他的系统

建立默认路由是一个功能很强的概念。该路由标志（UG）表明它是一个网关，这是我们所期望的。这里，我们有意称sun为路由器而不是主机，因为它被当作默认路由器来使用，它发挥的是IP转发功能，而不是主机功能

+ 最后一行：所在的以太网。H标志没有设置，说明目的地址（140.252.13.32）是一个网络地址，其主机地址部分设为0。事实上，是它的低5位设为0。由于这是一个直接路由（G标志没有被设置），网关列指出的IP地址是外出地址
netstat命令输出的最后一项还隐含了另一个信息，那就是目的地址（140.252.13.32）的子网掩码。如果要把该目的地址与140.252.13.33进行比较，那么在比较之前首先要把它与目的地址掩码（0xffffffe0）进行逻辑与。由于内核知道每个路由表项对应的接口，而且每个接口都有一个对应的子网掩码，因此每个路由表项都有一个隐含的子网掩码

*** 复杂性

主机路由表的复杂性取决于主机所在网络的拓扑结构：
1. 最简单的（也是最不令人感兴趣的）情况是主机根本没有与任何网络相连。TCP/IP协议仍然能用于这样的主机，但是只能与自己本身通信。这种情况下的路由表只包含环回接口一项
2. 接下来的情况是主机连在一个局域网上，只能访问局域网上的主机。这时路由表包含两项：一项是环回接口，另一项是局域网（如以太网）
3. 如果主机能够通过单个路由器访问其他网络（如Internet）时，那么就要进行下一步。一般情况下增加一个默认表项指向该路由器
4. 如果要新增其他的特定主机或网络路由，那么就要进行最后一步。在例子中，到主机slip的路由要通过路由器bsdi就是这样的例子

*** 路由选路
使用这个路由表为主机svr4上的一些分组例子选择路由：

+ 假定目的地址是主机sun，140.252.13.33。首先进行主机地址的匹配。路由表中的两个主机地址表项（slip和localhost）均不匹配，接着进行网络地址匹配。这一次匹配成功，找到表项140.252.13.32（网络号和子网号都相同），因此使用emd0接口。这是一个直接路由，因此链路层地址将是目的端的地址
+ 假定目的地址是主机slip，140.252.13.65。首先在路由表搜索主机地址，并找到一个匹配地址。这是一个间接路由，因此目的端的IP地址仍然是140.252.13.65，但是链路层地址必须是网关140.252.13.65的链路层地址，其接口名为emd0
+ 通过Internet给主机aw.com(192.207.117.2)发送一份数据报。首先在路由表中搜索主机地址，失败后进行网络地址匹配。最后成功地找到默认表项。该路由是一个间接路由，通过网关140.252.13.33，并使用接口名为emd0
+ 给本机发送一份数据报。有四种方法可以完成这件事，如用主机名、主机IP地址、环回名或者环回IP地址：
  #+BEGIN_SRC sh
    ftp svr4
    ftp 140.252.13.34
    ftp localhost
    ftp 127.0.0.1
  #+END_SRC
  + 在前两种情况下，对路由表的第2次搜索得到一个匹配的网络地址140.252.13.32，并把IP报文传送给以太网驱动程序。正如图2-4所示的那样，IP报文中的目的地址为本机IP地址，因此报文被送给环回驱动程序，然后由驱动程序把报文放入IP输出队列中
  + 在后两种情况下，由于指定了环回接口的名字或IP地址，第一次搜索就找到匹配的主机地址，因此报文直接被送给环回驱动程序，然后由驱动程序把报文放入IP输出队列中

** 初始化路由表 
每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。对于点对点链路和环回接口来说，路由是到达主机（设置H标志）。对于广播接口来说，如以太网，路由是到达网络

到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表。一个常用的方法是在系统引导时显式地在初始化文件中运行route命令。在主机svr4上，我们运行下面两个命令来添加路由表中的表项：

#+BEGIN_SRC sh
  route add default sun 1
  route add slip bsdi 1
#+END_SRC
+ 第3个参数（default和slip）代表目的端
+ 第4个参数代表网关（路由器）
+ 第五个参数代表路由的度量(metric)：route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志

*** 路由配置
不幸的是，几乎没有系统愿意在启动文件中包含route命令：
+ 在4.4BSD和BSD/386系统中，启动文件是/etc/netstart
+ 在SVR4系统中，启动文件是/etc/inet/rc.inet
+ 在Solaris 2.x中，启动文件是/etc/rc2.d/S69inet
+ 在SunOS 4.1.x中，启动文件是/etc/rc.local
+ 而AIX 3.2.2则使用文件/etc/rc.net

一些系统允许在某个文件中指定默认的路由器，如/etc/defaultrouter。于是在每次重新启动系统时都要在路由表中加入该默认项

初始化路由表的其他方法是运行路由守护程序或者用较新的路由器发现协议

** 较复杂的路由表
主机sun是所有主机的默认路由器，因为它有拨号SLIP链路连接到Internet上：

#+ATTR_HTML: image :width 70% 
[[file:pic/complicated-route-table.png]]

+ 前两项与主机svr4的前两项一致：通过路由器bsdi到达slip的特定主机路由，以及环回路由
+ 第3行是新加的：这是一个直接到达主机的路由(没有设置G标志，但设置了H标志)，对应于点对点的链路，即SLIP接口。如果把它与ifconfig命令的输出进行比较：

  #+BEGIN_SRC sh
    sun$ ifconfig sl0

    sl0: flags=1051<UP , POINTOPOINT , RUNNING >
    inet 140.252.1.29 --> 140.252.1.183 netmask ffffff00
  #+END_SRC

可以发现路由表中的目的地址就是点对点链路的另一端(即路由器netb), 网关地址为外出接口的本地IP地址140.252.1.29 (前面已经说过, netstat为直接路由打印出来的网关地址就是本地接口所用的IP地址)

+ 默认的路由表项是一个到达网络的间接路由(设置了G标志，但没有设置H标志)，这正是所希望的。网关地址是路由器的地址(140.252.1.183，SLIP链路的另一端), 而不是SLIP链路的本地IP地址(140.252.1.29)。其原因还是因为是间接路由，不是直接路由

还应该指出的是，netstat输出的第3和第4行(接口名为sl0)由SLIP软件在启动时创建，并在关闭时删除

* 没有达到目的地的路由
如果路由表中没有默认项，而又没有找到匹配项，这种情况下，结果取决于该IP数据报是由主机产生的还是被转发的（例如，是不是一个路由器）：
+ 如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”
+ 如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文


** ICMP主机不可达报错
当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文（格式如图6-10所示）。可以很容易发现，在网络上把接在路由器sun上的拨号SLIP链路断开，然后试图通过该SLIP链路发送分组给任何指定sun为默认路由器的主机

上一节通过在路由器sun上运行netstat命令可以看到，当接通SLIP链路启动时就要在路由表中增加一项使用SLIP链路的表项，而当断开SLIP链路时则删除该表项。这说明当SLIP链路断开时，sun的路由表中就没有默认项了。但是我们不想改变网络上其他主机的路由表，即同时删除它们的默认路由。相反，对于sun不能转发的分组，我们对它产生的ICMP主机不可达差错报文进行计数

在主机svr4上运行ping程序就可以看到这一点，它在拨号SLIP链路的另一端（拨号链路已被断开）：

#+ATTR_HTML: image :width 70% 
[[file:pic/icmp-host-unreachable.png]]
 
在主机svr4上运行tcpdump命令的输出如下图所示：
#+ATTR_HTML: image :width 70% 
[[file:pic/host-unreachable-dump.png]]

当路由器sun发现找不到能到达主机gemini的路由时，它就响应一个主机不可达的回显请求报文

如果把SLIP链路接到Internet上，然后试图ping一个与Internet没有连接的IP地址，那么应该会产生差错。但令人感兴趣的是，可以看到在返回差错报文之前，分组要在Internet上传送多远：
#+ATTR_HTML: image :width 70% 
[[file:pic/internet-host-unreachable.png]]

从上图可以看出，在发现该IP地址是无效的之前，该分组已通过了6个路由器。只有当它到达NSFNET骨干网的边界时才检测到差错。这说明，6个路由器之所以能转发分组是因为路由表中有默认项。只有当分组到达NSFNET骨干网时，路由器才能知道每个连接到Internet上的每个网络的信息。这说明许多路由器只能在局部范围内工作。而只有由顶层选路域来维护大多数Internet网站的路由信息，而不使用默认路由。在Internet上存在5个这样的顶层选路域：
1. NSFNET主干网
2. 商业互联网交换(Commercial Internet Exchange:CIX)
3. NASA科学互联网(NASA Science Internet)
4. SprintLink
5. 欧洲IP主干网(EBONE) 

** 转发还是不转发 
一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用。如何进行这样的配置呢？

大多数伯克利派生出来的系统都有一个内核变量ipforwarding，或其他类似的名字。一些系统（如BSD/386和SVR4）只有在该变量值不为0的情况下才转发数据报：
+ SunOS 4.1.x允许该变量可以有三个不同的值：
  + -1：始终不转发并且始终不改变它的值
  + 0：默认条件下不转发，但是当打开两个或更多个接口时就把该值设为1
  + 1：始终转发
+ Solaris 2.x：
  + 0：始终不转发
  + 1：始终转发
  + 2：在打开两个或更多个接口时才转发
+ 较早版本的4.2BSD主机在默认条件下可以转发数据报，这给没有进行正确配置的系统带来了许多问题。这就是内核选项为什么要设成默认的“始终不转发”的原因，除非系统管理员进行特殊设置

* ICMP重定向报错 
