#+TITLE: UDP：用户数据报协议
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: traceroute.html   
#+HTML_LINK_HOME: tii.html
#+OPTIONS: num:nil timestamp:nil  ^:nil

UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系

UDP数据报封装成一份IP数据报的格式如图11-1所示：

#+ATTR_HTML: image :width 40% 
[[file:pic/udp-packet.png]]

UDP不提供 *可靠性* ：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，似乎觉得要避免使用UDP而使用一种可靠协议如TCP

应用程序必须关心IP数据报的长度。如果它超过网络的MTU，那么就要对IP数据报进行分片。如果需要，源端到目的端之间的每个网络都要进行分片，并不只是发送端主机连接第一个网络才这样做，本章也将讨论IP分片机制

* UDP报文
  
** UDP首部
   UDP首部的各字段如图11-2所示：
   
   #+ATTR_HTML: image :width 40% 
   [[file:pic/udp-header.png]]
   
+ 端口号：标识发送进程和接收进程。由于IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的
  
  #+begin_example
       尽管相互独立，如果TCP和UDP同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本身的要求
  #+end_example
  
+ UDP长度字段：UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是OK）。事实上这个UDP长度是冗余的。IP数据报长度指的是数据报全长，因此UDP数据报长度是全长减去IP首部的长度（该值在IP首部长度字段中指定）
  
*** UDP检验和
    UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部，并不覆盖IP数据报中的任何数据。
    
    UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的
    
    尽管UDP检验和的基本计算方法与以前描述的IP首部检验和计算方法相类似（16bit字的二进制反码和），但是它们之间存在不同的地方：
+ UDP数据报的长度可以为奇数字节，但是检验和算法是把若干个16bit字相加。解决方法是必要时在最后增加填充字节0，这只是为了检验和的计算（这意味着可能增加的填充字节不被传送）
+ UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）。UDP数据报中的伪首部格式如图11-3所示：
  
  #+ATTR_HTML: image :width 60% 
  [[file:pic/udp-header.png]]
  
在该图中，特地举了一个奇数长度的数据报例子，因而在计算检验和时需要加上填充字节。注意，UDP数据报的长度在检验和计算过程中出现两次

如果检验和的计算结果为0，则存入的值为全1（65535），这在二进制反码计算中是等效的。如果传送的检验和为0，说明发送端没有计算检验和

如果发送端没有计算检验和而接收端检测到检验和有差错，那么UDP数据报就要被悄悄地丢弃。不产生任何差错报文

UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动

尽管UDP检验和是可选的，但是它们应该总是在用。在80年代，一些计算机产商在默认条件下关闭UDP检验和的功能，以提高使用UDP协议的NFS（Network File System）的速度。在单个局域网中这可能是可以接受的，但是在数据报通过路由器时，通过对链路层数据帧进行循环冗余检验（如以太网或令牌环数据帧）可以检测到大多数的差错，导致传输失败。不管相信与否，路由器中也存在软件和硬件差错，以致于修改数据报中的数据。如果关闭端到端的UDP检验和功能，那么这些差错在UDP数据报中就不能被检测出来。另外，一些数据链路层协议（如SLIP）没有任何形式的数据链路检验和

**** tcpdump输出
     很难知道某个特定系统是否打开了UDP检验和选项。应用程序通常不可能得到接收到的UDP首部中的检验和。为了得到这一点，我们在tcpdump程序中增加了一个选项，以打印出接收到的UDP检验和。如果打印出的值为0，说明发送端没有计算检验和
     
     测试网络上三个不同系统的输出如图11-4所示。运行自编的sock程序，发送一份包含9个字节数据的UDP数据报给标准回显服务器：
     
     #+ATTR_HTML: image :width 60% 
     [[file:pic/udp-dump.png]]
     
     从这里可以看出，三个系统中有两个打开了UDP检验和选项
     
     还要注意的是，在这个简单例子中，送出的数据报与收到的数据报具有相同的检验和值（第3和第4行，第5和第6行）。从图11-3可以看出，两个IP地址进行了交换，正如两个端口号一样。伪首部和UDP首部中的其他字段都是相同的，就像数据回显一样。这再次表明UDP检验和（事实上，TCP/IP协议簇中所有的检验和）是简单的16bit和。它们检测不出交换两个16bit的差错
     
**** 统计结果
     文献[Mogul 1992]提供了在一个繁忙的NFS服务器上所发生的不同检验和差错的统计结果，时间持续了40天。统计数字结果如图11-5所示：
     
     #+CAPTION: 检测到不同检验和差错的分组统计结果
     #+ATTR_HTML: :border 1 :rules all :frame boader
     | 层次 | 校验和差错数 | 近似总分组数 |
     | 以太网 | 446          | 170000000    |
     | IP     | 14           | 170000000    |
     | UDP    | 5            | 140000000    |
     | TCP    | 350          | 30000000     |
     
     最后一列是每一行的大概总数，因为太网和IP层还使用其他的协议。例如，不是所有的以太网数据帧都是IP数据报，至少以太网还要使用ARP协议。不是所有的IP数据报都是UDP或TCP数据，因为ICMP也用IP传送数据
     
     注意：TCP发生检验和差错的比例与UDP相比要高得多。这很可能是因为在该系统中的TCP连接经常是“远程”连接（经过许多路由器和网桥等中间设备），而UDP一般为本地通信
     
     #+begin_example
       从最后一行可以看出，不要完全相信数据链路（如以太网，令牌环等）的CRC检验。应该始终打开端到端的检验和功能。而且，如果你的数据很有价值，也不要完全相信UDP或TCP的检验和，因为这些都只是简单的检验和，不能检测出所有可能发生的差错
     #+end_example
     
** 示例
   用我们自己编写的sock程序生成一些可以通过tcpdump观察的UDP数据报：
   
   #+BEGIN_SRC sh :results output :exports result
  bsdi $ sock -v -u -i -n4 svr4 discard
   #+END_SRC
   
   #+RESULTS:
   #+begin_example
       connected on 140.252.13.35.1108 to 140.252.13.34.9
   #+end_example
第1次执行这个程序时，指定verbose模式(-v)来观察ephemeral端口号，指定UDP(-u)而不是默认的TCP，并且指定源模式(-i)来发送数据，而不是读写标准的输入和输出。-n4选项指明输出4份数据报（默认条件下为1024），目的主机为svr4。discard丢弃服务。每次写操作的输出长度取默认值1024

   #+BEGIN_SRC sh :results output :exports result
     bsdi $ sock -v -u -i -n4 -w0 svr4 discard

   #+END_SRC
   
   #+RESULTS:
   #+begin_example
     connected on 140.252.13.35.1110 to 140.252.13.34.9
   #+end_example
第2次运行该程序时我们指定-w0，意思是写长度为0的数据报。两个命令的tcpdump输出结果如图11-6所示：
     #+ATTR_HTML: image :width 60% 
     [[file:pic/sock-dump.png]]

+ 输出显示有四份1024字节的数据报，接着有四份长度为0的数据报。每份数据报间隔几毫秒
+ 在发送第1份数据报之前，发送端和接收端之间没有任何通信（TCP在发送数据的第1个字节之前必须与另一端建立连接）。另外，当收到数据时，接收端没有任何确认。在这个例子中，发送端并不知道另一端是否已经收到这些数据报
+ 最后要指出的是，每次运行程序时，源端的UDP端口号都发生变化。第一次是1108，然后是1110。客户程序使用ephemeral端口号一般在1024～5000之间，正如现在看到的这样


* IP分片
