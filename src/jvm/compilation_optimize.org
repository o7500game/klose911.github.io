#+TITLE: 编译器优化
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: thread_safe.html   
#+HTML_LINK_HOME: jvm.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Java语言的 *编译期* 其实是一段 _不确定_ 的操作过程，因为它可能是：
+ *前端* 编译器: 把 _java文件_ 转化为 _class文件_ 的过程
+ *后端* 运行期编译器（JIT编译器）: 把 _字节码_ 转化为 _机器码_ 的过程
+ *静态提前* 编译器（AOT编译器）：直接把 _java文件_ 编译成 _本地机器代码_ 的过程

下面列举了这3类编译过程中一些比较有代表性的编译器：
1. 前端编译器：
   + Sun的Javac
   + Eclipse JDT中的增量式编译器
2. JIT编译器：
   + HotSpot VM的C1编译器
   + HotSpot VM的C2编译器
3. AOT编译器：
   + GNU Compiler for the Java(GCJ)
   + Excelsior JET

#+BEGIN_EXAMPLE
  这3类过程中最符合大家对Java程序编译认知的应该是第一类
  这里提到的“编译期”和“编译器”都仅限于第一类编译过程

  把第二类编译过程留到以后中讨论
#+END_EXAMPLE

限制了编译范围后，对于 _优化_ 二字的定义就需要宽松一些，因为Javac这类编译器对代码的运行效率几乎没有任何优化措施。虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class文件）也同样能享受到编译器优化所带来的好处。但是Javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的 *语法糖* 来实现，而不是依赖虚拟机的底层改进来支持，可以说：
+ _即时编译器_ 在运行期的优化过程对于 *程序运行* 来说更重要
+ _前端编译器_ 在编译期的优化过程对于 *程序编码* 来说关系更加密切

* Javac编译器
 分析源码是了解一项技术的实现内幕最有效的手段，Javac编译器不像HotSpot虚拟机那样使用C++语言（包含C少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯Java的程序员了解它的编译过程带来了很大的便利

** Javac的源码与调试 
Javac的源码存放在JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac中，除了JDK自身的API外，就只用了JDK_SRC_HOME/langtools/src/share/classes/com/sum/*里面的代码，调试环境建立起来简单方便，因为基本上不需要处理依赖关系

导入了Javac的源码后，就可以运行 _com.sun.tools.javac.Main_ 的 *main()* 方法来执行编译了，与命令行中使用的Javac的命令没有什么区别

#+BEGIN_EXAMPLE
  虚拟机规范严格定义了Class文件的格式

  《JVM虚拟机规范（第二版）》中，虽然有专门的一章“Compiling for the Java Virtual Machine”，
  但都是以举例的形式描述，并没有如何把Java源码文件转变为Class文件的编译过程进行十分严格的定义，
  这导致Class文件编译在某种程度上是与具体JDK实现相关的

  在一些极端情况，可能出现一段代码Javac编译器可以编译，但是ECJ编译器就不可以编译的问题
#+END_EXAMPLE

从Sun Javac的代码来看，编译过程大致可以分为3个过程，分别是：
1.  *解析与填充符号表* 过程
2. 插入式注解处理器的 *注解处理* 过程
3. 分析与 *字节码生成* 过程

这三个步骤之间的关系与交互顺序如图所示：
     #+ATTR_HTML: image :width 70% 
     [[file:pic/javac-compilation.jpg]] 

 Javac编译动作的入口是 *com.sun.tools.javac.main.JavaCompiler* 类，上述3个过程的代码逻辑集中在这个类的 _compile()_ 和 _compile2()_ 方法中，其中主体代码如图所示，整个编译最关键的处理就由图中标注的8个方法来完成：

     #+ATTR_HTML: image :width 70% 
     [[file:pic/JavaCompiler.jpg]] 

     #+ATTR_HTML: image :width 70% 
     [[file:pic/JavaCompiler.png]] 

** 解析与填充符号表
解析步骤由 _parseFiles()_  方法完成，解析步骤包括了经典程序编译原理中的 *词法分析* 和 *语法分析* 两个过程 

*** 词法、语法分析
词法分析：将源代码的 _字符流_ 转变为 _标记_ (Token) 集合
+ 单个字符是程序编写过程的最小元素，而标记则是 *编译过程的最小元素* 
+ 关键字、变量名、字面量、运算符都可以成为标记
+ 在 Javac 的源码中词法分析过程由 *com.sun.tools.javac.parser.Scanner* 类来实现

#+BEGIN_EXAMPLE
  如 “int a=b+2” 这句代码包含了 6 个标记，分别是 int、a、=、b、+、2

  虽然关键字 int 由 3 个字符构成，但是它只是一个 Token，不可再拆分
#+END_EXAMPLE
语法分析：根据 _Token 序列_ 构造 _抽象语法树_ 的过程
+ 抽象语法树(AST)：一种用来 *描述程序代码语法结构* 的树形表示方式
  + 语法树的每一个节点都代表着程序代码中的一个语法结构(Construct)
+ 在 Javac 的源码中，语法分析过程由 *com.sun.tools.javac.parser.Parser* 类实现
+ 这个阶段产出的抽象语法树由 *com.sun.tools.javac.tree.JCTree* 类表示
#+BEGIN_EXAMPLE
  例如 包 、 类型 、 修饰符 、 运算符 、 接口 、 返回值 甚至 代码注释 等都可以是一个语法结构
#+END_EXAMPLE

下图是根据 Eclipse AST View 插件分析出来的某段代码的抽象语法树视图，可以通过这张图对抽象语法树有一个直观的认识：
     #+ATTR_HTML: image :width 70% 
     [[file:pic/javac-ast.jpg]] 

经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上

*** 填充符号表
完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是 *enterTrees()* 方法（过程 1.2）所做的事情：
+ 符号表(Symbol Table)：由一组 *符号地址* 和 *符号信息* 构成的表格，可以把它想象成哈希表中 K-V 值对的形式
+ 符号表中所登记的信息在编译的不同阶段都要用到：
  +  _语义分析_ 中，符号表所登记的内容将用于 *语义检查* （如检查一个名字的使用和原先的说明是否一致）和产生 *中间代码* 
  + _目标代码_ 生成阶段，当对符号名进行地址分配时， 符号表是 *地址分配的依据* 

#+BEGIN_EXAMPLE
  实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等
#+END_EXAMPLE

在 Javac 源代码中，填充符号表的过程由 *com.sun.tools.javac.comp.Enter* 类实现：
+ 此过程的出口是一个待处理列表（To Do List），包含了：
  + 每一个编译单元的抽象语法树的顶级节点
  + package-info.java（如果存在的话）的顶级节点

** 注解处理器
#+BEGIN_EXAMPLE
   在JDK1.5之后，Java语言提供了对 注解 (Annotation)的支持

  这些注解与普通的Java代码一样，是在 运行期间 发挥作用的
#+END_EXAMPLE

在JDK1.6中实现了 _JSR-269_ 规范，提供了一组 *插入式注解处理器的标准API* 在 *编译期间对注解* 进行处理，可以把它看做是一组 _编译器的插件_ 
+ 在这些插件里面，可以 _读取_ 、 _修改_ 、 _添加_ *抽象语法树* 中的 *任意元素*
+ 如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止：每一次循环称为一个Round

#+BEGIN_EXAMPLE
  有了编译器注解处理的标准API后，代码才有可能干涉编译器的行为

  由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间

  只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情
#+END_EXAMPLE

在Javac源码中，插入式注解处理器的初始化过程是在 _initPorcessAnnotations()_ 方法中完成的，而它的执行过程则是在 _processAnnotations()_ 方法中完成的，这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过 *com.sun.tools.javac.processing.JavacProcessingEnvironment* 类的 _doProcessing()_ 方法生成一个新的JavaCompiler对象对编译的后续步骤进行处理

** 语义分析与字节码生成
语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对 *结构上正确的源程序* 进行 *上下文有关性质的审查* ，如进行 _类型审查_ 。举个例子，假设有如下的 3 个变量定义语句：

#+BEGIN_SRC java
  int a = 1;  
  boolean b = false;  
  char c = 2; 
#+END_SRC

 后续可能出现的赋值运算：
#+BEGIN_SRC java
  int d = a + c;  
  int d = b + c;  
  char d = a + c; 
#+END_SRC

后续代码中如果出现了如上 3 种赋值运算的话，那它们都能构成结构正确的语法树，但是只有第 1 种的写法在语义上是没有问题的，能够通过编译，其余两种在 Java 语言中是不合逻辑的，无法编译

#+BEGIN_EXAMPLE
  是否合乎语义逻辑必须限定在语言与具体的上下文环境之中才有意义

  如在 C 语言中，a、b、c 的上下文定义不变，第 2、3 种写法都是可以正确编译
#+END_EXAMPLE
Javac 的编译过程中，语义分析过程分为 *标注检查* 以及 *数据及控制流分析* 两个步骤，分别由 _attribute()_ 和 _flow()_ 方法（对应图中过程 3.1 和过程 3.2）完成

*** 标注检查
标注检查步骤检查的内容包括诸如：
+ _变量使用前是否已被声明_
+ _变量与赋值之间的数据类型_ 是否能够匹配等

还有一个重要的动作称为 *常量折叠* ，如果在代码中写了如下定义：
#+BEGIN_SRC java
  int a = 1 + 2;  
#+END_SRC

那么在语法树上仍然能看到字面量 _1_ 、 _2_  以及操作符 _+_ ，但是在经过常量折叠之后，它们将会被折叠为字面量 _3_ ，如图所示，这个插入式表达式的值已经在语法树上标注出来了： _ConstantExpressionValue:3_  。由于编译期间进行了常量折叠，所以在代码里面定义  _a=1+2_  比起直接定义 _a=3_ ，并不会增加程序运行期哪怕仅仅一个 CPU 指令的运算量：

     #+ATTR_HTML: image :width 70% 
     [[file:pic/javac-constant-expression.jpg]] 

标注检查步骤在 Javac 源码中的实现类是 *com.sun.tools.javac.comp.Attr* 类和 *com.sun.tools.javac.comp.Check* 类

*** 数据及控制流分析
数据及控制流分析：对 *程序上下文逻辑更进一步的验证* ，它可以检测出：
+ 程序局部变量是在使用前是否有赋值
+ 方法的每条路径是否都有返回值
+ 是否所有的受查异常都被正确处理了等问题

编译时期的数据及控制流分析与类加载时数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验只有在编译期或运行期才能进行。下面举一个关于 final 修饰符的数据及控制流分析的例子：

#+BEGIN_SRC java
  //代码清单10-1  final语义校验
  //方法一带有final修饰
  public void foo(final int arg){
	  final int var = 0;
	  //do something
  }
 
  //方法二没有final修饰
  public void foo(int arg){
	  int var = 0;
	  //do something
  }
#+END_SRC
在这两个foo()方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第二种方法则没有
+ 在代码编写的时程序肯定会受到final修饰符的影响，不能再改变arg和var变量的值，但是 *这两段代码编译出来的Class文件是没有任何一点区别的* 
#+BEGIN_EXAMPLE
  局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用
  自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项）
  自然在Class文件中不可能知道一个局部变量是不是声明为final了

  因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障
#+END_EXAMPLE

在Javac的源码中，数据及控制流分析的入口是 _flow()_ 方法（对应图中的过程3.2），具体操作有 *com.sun.tools.javac.comp.Flow* 类来完成

*** 解语法糖
#+BEGIN_EXAMPLE
  语法糖（Syntactic Sugar），是由英国计算机科学家彼得・约翰・兰达（Perter J.Landin）发明的一个术语
  指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用

  通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会

  Java 在现代编程语言之中属于 “低糖语言”（相对于 C# 及许多其他 JVM 语言来说），尤其是 JDK 1.5 之前的版本
  “低糖” 语法也是 Java 语言被怀疑已经 “落后” 的一个表面理由
#+END_EXAMPLE
Java 中最常用的语法糖主要是前面提到过的：
+ 泛型 : 并不一定都是语法糖实现，如 C# 的泛型就是直接由 CLR 支持的
+ 变长参数
+ 自动装箱 / 拆箱等

虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为 _解语法糖_ 

在 Javac 的源码中，解语法糖的过程由 _desugar()_ 方法触发，在 *com.sun.tools.javac.comp.TransTypes* 类和 *com.sun.tools.javac.comp.Lower*  类中完成 
*** 字节码生成
字节码生成是 Javac 编译过程的最后一个阶段，在 Javac 源码里面由 *com.sun.tools.javac.jvm.Gen* 类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的 *代码添加和转换* 工作

#+BEGIN_EXAMPLE
  例如，前面多次提到的实例构造器 _<init>()_ 方法和类构造器 _<clinit>()_ 方法就是在这个阶段添加到语法树之中的
  注意：这里的实例构造器并不是指默认的构造函数
  如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected 或 private）与当前类一直的默认构造函数
  这个工作在填充符号表阶段就已经完成，这两个构造器的产生过程实际上是一个代码收敛的过程

  编译器会把语句块：
  对于实力构造器而言是 “{}” 块，对于类构造器而言是 “static{}” 块
  变量初始化（实力变量和类变量）

  调用父类的实例构造器：仅仅是实例构造器，<clinit>() 方法中无须调用父类的 <clinit>() 方法，虚拟机会自动保证父类构造器的执行
  但在 <clinit>() 方法中经常会生成调用 java.lang.Object 的 <init>() 方法的代码等操作收敛到 <init>() 和 <clinit>() 方法之中
  并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行

  上面所述的动作由 Gen.normalizeDef() 方法来实现

  除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑：
  如把字符串的加操作替换为 StringBuffer 或 StringBuilder（取决于目标代码的版本是否大于或等于 JDK 1.5）的 append() 操作等
#+END_EXAMPLE

完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给 *com.sun.tools.javac.jvm.ClassWriter* 类，由这个类的 _writeClass()_ 方法输出字节码， *生成最终的 Class 文件* ，到此为止整个编译过程宣告结束

* 语法糖
