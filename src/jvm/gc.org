#+TITLE: 垃圾回收器
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: memory.html   
#+HTML_LINK_HOME: jvm.html
#+OPTIONS: num:nil timestamp:nil

上一章介绍了Java内存运行时区域的各个部分,其中 *程序计数器* 、 *虚拟机栈* 、 *本地方法栈* 3个区域随线程而生,随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。因此这几个区域的内存分配和回收都具备确定性,在这几个区域内就不需要过多考虑回收的问题 ,因为方法结束或者线程结束时,内存自然就跟随着回收了。而 *Java堆* 和 *方法区* 则不一样，一个接口中的多个实现类需要的内存可能不一样,一个方法中的多个分支需要的内存也可能不一样,只有在程序处于运行期间时才能知道会创建哪些对象,这部分内存的分配和回收都是动态的,垃圾收集器所关注的是这部分内存

* 对象存活判定
  在堆里面存放着Java世界中几乎所有的对象实例,垃圾收集器在对堆进行回收前,第一件事情就是要确定这些对象之中哪些还 _存活_ 着 ,哪些已经 _死去_ (即不可能再被任何途径使用的对象)
  
** 引用计数算法
   为每个对象中添加一个引用计数器：
+ 每当有—个地方引用它时,计数器值就加1
+ 当引用失效时,计数器值就减1
+ 任何时刻计数器为0的对象就是不可能再被使用的
  
客观地说,引用计数算法的实现简单,判定效率也很高,在大部分情况下它都是一个不错的算法,也有一些比较著名的应用案例,例如微软公司的COM技术、使用ActionScript 3, Python等都使用了引用计数算法进行内存管理。但是至少主流的Java虚拟机里面没有选用引用计数算法来管理内存,其中最主要的原因是它 *很难解决对象之间相互循环引用的问题* 

举个简单的例子,下面代码中的 _testGC()_ 方法:对象objA和objB都有字段 _instance_ , 赋值令 *objA.instance=objB* 及 *objB.instance=objA* 。此外,这两个对象再无任何引用 ,实际上这两个对象已经不可能再被访问,但是它们因为互相引用着对方,导致它们的引用计数都不为0,于是引用计数算法无法通知GC收集器回收它们
#+BEGIN_SRC java :results output :exports result
  /**
   ,* testGC()方法执行后，objA和objB会不会被GC呢？ 
   ,* @author zzm
   ,*/
  public class ReferenceCountingGC {

          public Object instance = null;

          private static final int _1MB = 1024 * 1024;

          /**
           ,* 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过
           ,*/
          private byte[] bigSize = new byte[2 * _1MB];

          public static void testGC() {
                  ReferenceCountingGC objA = new ReferenceCountingGC();
                  ReferenceCountingGC objB = new ReferenceCountingGC();
                  objA.instance = objB;
                  objB.instance = objA;

                  objA = null;
                  objB = null;

                  // 假设在这行发生GC，objA和objB是否能被回收？
                  System.gc();
          }
  }
#+END_SRC

#+RESULTS:
: [Fu11 GC(System)[Tenured:0 K->210K(10240K),0.0149142 secs]4603K->21OK(19456K),[Perm:2999K-> 2999K(2124 8K )] ,0.0150007 secs] [Times :user=0.01 sys=0.00 ,real=0.02 secs ]																																			   
: Heap																																																								   
: def new generation total 9216K,used 82K[0x00000000055e0000 ,0x0000000005feO000 ,0x0000000005feOO00 )																																												   
: Eden space 8192K ,llused[0x00000000055e0000 ,0x00000000055f4850 ,0x0000000005de0000 )																																														   
: from space 1024K, Olusedf0x0000000005de0000 ,0x0000000005de0000 ,0x0000000005ee0000 )																																														   
: to space 1024K ,0lused[0x0000000005ee0000 ,0x0000000005ee0000 ,0x0000000005fe0000 )																																														   
: tenured generation total 1024OK,used 21OK[0x0000000005feO000 ,0x00000000069e0000 ,0x00000000069e0000 ) the space 10240K ,2lused[0x0000000005fe0000 ,0x0000000006014al8 ,0x0000000006014cO0 ,0x00000000069e0000 ) compacting perm gen total 21248K,used 3016K[0x00000000069e0000 ,0x0000000007ea0000 ,0x00000000ObdeO000 ) the space 21248K ,14lused[0x00000000069e0000 ,0x0000000006cd2398 ,0x0000000006cd2400 ,0x0000000007ea0000 ) Mo shared spaces configured.  


从运行结果中可以清楚看到，GC日志中包含 _4603K->210K_ ,意味着虚拟机并没有因为这两个对象互相引用就不回收它们,这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的

** 可达性分析算法
   在主流的商用程序语言的主流实现中, 都是称通过可达性分析来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为 _GC Roots_ 的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明此对象是不可用的。如下图所示,对象 _object 5_ 、 _object 6_ 、 _object 7_ 虽然互相有矣联,但是它们到GC Roots是不可达的 ,所以它们将会被判定为是 *可回收的对象* 
   
   #+ATTR_HTML: image :width 70% 
   [[file:pic/gc-root.png]] 
   
   
   在Java语言中可作为 *GC Roots* 的对象包括下面几种:
+ 虚拟机栈(栈帧中的本地变量表)中引用的对象
+ 方法区中类静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中JNI(native方法)引用的对象
  
  
*** 引用
    无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与 *引用* _reference_ 有关。在JDK1.2之后，Java对引用的概念进行了扩充：
+ *强引用* ：在程序代码之中普遍存在的，类似 _Object object = new Object()_ 这类的引用， *只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象*
+ *软引用* ：描述一些还在用但并非必需的对象。对于软引用关联着的对象，在 *系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收* ，如果这次回收完成还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后提供了 _SoftReference_ 类来实现软引用
+ *弱引用* ：描述非必需对象的，但是它的强度比软引用要更弱一些， *被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象* 。在JDK1.2之后提供了 _WeakReference_ 类来实现弱引用
+ *虚引用* ：　也称为 _幻影引用_ ，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 *为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知* 。在JDK1.2之后提供了 _PhantomReference_ 类来实现虚引用。
  
*** 生存还是死亡 
    即使在可达性分析算法中不可达的对象, 也并非是 _非死不可_ 的, 这时候它们暂时处于 _缓刑_ 阶段, 要真正宣告一个对象死亡, 至少要经历两次标记过程: 
+ 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被 *第一次标记并且进行一次筛选* , 筛选的条件是 *此对象是否有必要执行finalize()方法* 
  + 当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为 _没有必要执行_
  + 如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做 *F-Queue* 的队列之中
    + 稍后由一个由虚拟机自动建立的、低优先级的 *Finalizer线程* 去执行它。所谓的 _执行_ 是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是： *如果一个对象在finalize()方法中执行缓慢,或者发生了死循环将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃*
    + finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对 *F-Queue中的对象进行第二次小规模的标记*
      + 如果对象要在finalize()中成功拯救自己: 只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将被移除出 _即将回收_ 的集合
      + 如果对象这时候还没有逃脱,那基本上它就真的被回收了
	
下面代码中可以看到一个对象的finalize()被执行,但是它仍然可以存活：

#+BEGIN_SRC java :results output :exports result
  /**
   ,* 此代码演示了两点： 
   ,* 1.对象可以在被GC时自我拯救。 
   ,* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
   ,* @author zzm
   ,*/
  public class FinalizeEscapeGC {

          public static FinalizeEscapeGC SAVE_HOOK = null;

          public void isAlive() {
                  System.out.println("yes, i am still alive :)");
          }

          @Override
          protected void finalize() throws Throwable {
                  super.finalize();
                  System.out.println("finalize mehtod executed!");
                  FinalizeEscapeGC.SAVE_HOOK = this;
          }

          public static void main(String[] args) throws Throwable {
                  SAVE_HOOK = new FinalizeEscapeGC();

                  //对象第一次成功拯救自己
                  SAVE_HOOK = null;
                  System.gc();
                  // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
                  Thread.sleep(500);
                  if (SAVE_HOOK != null) {
                          SAVE_HOOK.isAlive();
                  } else {
                          System.out.println("no, i am dead :(");
                  }

                  // 下面这段代码与上面的完全相同，但是这次自救却失败了
                  SAVE_HOOK = null;
                  System.gc();
                  // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
                  Thread.sleep(500);
                  if (SAVE_HOOK != null) {
                          SAVE_HOOK.isAlive();
                  } else {
                          System.out.println("no, i am dead :(");
                  }
          }
  }
#+END_SRC

#+RESULTS:
: finalize mehtod executed ! 
: yes,i am still alive : )
: no,i am dead : (

+ SAVE_HOOK对象的finalize()方法确实被GC收集器触发过,并且在被收集前成功逃脱了
+ 代码中有两段完全一样的代码片段,执行结果却是一次逃脱成功,一次失败,这是因为 *任何一个对象的finalize()方法都只会被系统自动调用一次* , 如果对象面临下一次回收,它的finalize()方法不会被再次执行,因此第二段代码的自救行动失败了
  
#+BEGIN_EXAMPLE
  建议大家尽量避免使用finalize方法,因为它不是C/C++中的析构函数,而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协

  它的运行代价高昂,不确定性大,无法保证各个对象的调用顺序

  finalize()能做的所有工作,使用try-finally或者其他方式都可以做得更好，更及时
#+END_EXAMPLE

** 回收方法区
   很多人认为方法区(以前的永久代)是没有垃圾收集的,Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集,而且在方法区中进行垃圾收集的 _性价比_ 一般比较低。在堆中尤其是在新生代中,常规应用进行一次垃圾收集一般可以回收70%〜95%的空间,而永久代的垃圾收集效率远低于此
   
   永久代的垃圾收集主要回收两部分内容:
+ 废弃常量
+ 无用的类
  
回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例,假如一个字符串 _abc_ 已经进入了常量池中,但是当前系统没有任何一个String对象是叫做 _abc_ 的，换句话说就是没有任何String对象引用常量池中的 _abc_ 常量, 也没有其他地方引用了这个字面量,如果这时发生内存回收,而且必要的话,这个 _abc_ 常量就会被系统清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似

判定一个常量是否是 _废弃常量_ 比较简单,而要判定一个类是否是 _无用的类_ 的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 _无用的类_ :
1. 该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法
   
虚拟机可以对满足上述3个条件的无用类进行回收,这里说的仅仅是 *可以* ,而并不是和对象一样,不使用了就必然会回收。是否对类进行回收,HotSpot虚拟机提供了 _-XX:noclassgc_ 参数进行控制 ,还可以使用 _-verbose:class_ 以及 _-XX:+TraceClassLoading_ 、 _-XX:+TraceClassUnLoading_ 查看类加载和卸载信息,其中 _-verbose:class_ 和 _-XX:+TraceClassLoading_ 可以在 *Product* 版的虚拟机中使用, _-XX:+TraceClassUnLoading_ 参数需要 *FastDebug* 版的虚拟机支持

#+BEGIN_EXAMPLE
  在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出
#+END_EXAMPLE

* 垃圾回收算法
