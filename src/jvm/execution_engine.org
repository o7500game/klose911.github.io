#+TITLE: 执行引擎
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: class_loader.html   
#+HTML_LINK_HOME: jvm.html
#+OPTIONS: num:nil timestamp:nil ^:nil

*执行引擎* 是Java虚拟机最核心的组成部分之一。 _虚拟机_ 是一个相对于 _物理机_ 的概念，这两种机器都有代码执行能力，其区别：
+ 物理机的执行引擎是 *直接建立在处理器、硬件、指令集和操作系统* 层面上的
+ 虚拟机的执行引擎则是由 *自己实现的* ，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式 

在Java虚拟机规范中制定了 _虚拟机字节码执行引擎_ 的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有 _解释执行_ (通过解释器执行)和 _编译执行_ (通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的:
+ 输入：字节码文件
+ 处理：字节码解析的等效过程
+ 输出：执行结果

#+BEGIN_EXAMPLE
  有一些虚拟机(如Sun Classic VM)的内部只存在解释器，只能解释执行

  另外一些虚拟机(如BEA JRockit)的内部只存在即时编译器，只能编译执行 
#+END_EXAMPLE

* 运行时栈帧结构
  *栈帧* ( _Stack Frame_ )是用于支持虚拟机进行 *方法调用和方法执行的数据结构* ，它是虚拟机运行时数据区中的 *虚拟机栈* ( _Virtual Machine Stack_ )的栈元素。栈帧存储了方法的 
  + *局部变量表*
  + *操作数栈* 
  + *动态连接*
  + *方法返回地址* 
  + .....

  每一个方法从调用开始至执行完成的过程，都对应着 *一个栈帧在虚拟机栈里面从入栈到出栈的过程* 

  #+BEGIN_EXAMPLE
    在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中

    一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现
  #+END_EXAMPLE

  一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中， *只有位于栈顶的栈帧才是有效的* ，称为 _当前栈帧_ ( _Current Stack Frame_ )，与这个栈帧相关联的方法称为 _当前方法_ 。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示：

  #+ATTR_HTML: image :width 50% 
  [[file:pic/jvm-stack-frame.png]] 

** 局部变量表
   *局部变量表* 是一组变量值存储空间，用于存放 *方法参数和方法内部定义的局部查量* 。在Java程序编译为Class文件时，就在 _方法的Code属性_ 的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量

   局部变量表的容量以 *变量槽* ( _Slot_ )为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出 _每个Slot占用32位长度的内存空间_ 是有一些差别的，它允许Slot的长度可以 *随着处理器、操作系统或虚拟机的不同而发生变化* 。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致

   #+BEGIN_EXAMPLE
     一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress8种类型

     reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构
     但一般来说，虚拟机实现至少都应当能通过这个引用做到两点
       1. 从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引
       2. 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息


     returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址
     很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替
   #+END_EXAMPLE
   对于64位的数据类型，虚拟机会以 _高位对齐_ 的方式为其 _分配两个连续的Slot空间_ 。Java语言中明确的(reference类型则可能是32位也可能是64位)64位的数据类型只有long和double两种
   #+BEGIN_EXAMPLE
     把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类似

     不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题
   #+END_EXAMPLE

   虚拟机通过 _索引定位_ 的方式使用局部变量表，索引值的范围是从 _0开始至局部变量表最大的Slot数量_ 
   + 如果访问的是 _32位_ 数据类型的变量，索引 _n_ 就代表了使用第 _n个Slot_
   + 如果是 _64位_ 数据类型的变量，则说明会同时使用 _n_ 和 _n+1_ 两个Slot
     + 对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在 _类加载的校验阶段拋出异常_ 

   在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法(非static的方法)，那 *局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用* ，在方法中可以通过关键字 _this_ 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot

   为了尽可能节省栈帧空间，局部变量表中的Slot是可以 *重用* 的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体， *如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用* 。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接 _影响到系统的垃圾收集行为_ 

   #+BEGIN_SRC java
  public static void main(String[] args)() {
	  byte[] placeholder = new byte[64 * 1024 * 1024];
	  System.gc();
  }
   #+END_SRC
   首先向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。在虚拟机运行参数中加上 _-verbose:gc_ 来看看垃圾收集的过程，发现在 _System.gc()_ 运行后并没有回收这64MB的内存，运行结果:

   : [GC 66846K->65824K (125632K ) ,0.0032678 secs] [Full GC 65824K-> 65746K (125632K) ,0.0064131 secs] 

   因为在执行 _Systemgc()_ 时，变量 placeholder 还处于作用域之内,虚拟机自然不敢回收 placeholder 的内存。那把代码修改一下

   #+BEGIN_SRC java
  public static void main(String[] args)() {
	  {
		  byte[] placeholder = new byte[64 * 1024 * 1024];
	  }
	  System.gc();
  }
   #+END_SRC

   加入了花括号之后， placeholder 的作用域被限制在花括号之内，从代码逻辑上讲，在执行 _System.gc()_ 的时候，placeholder 已经不可能再被访问了,但执行一下这段程序,会发现运行结果如下,还是有64MB的内存没有被回收

   在调用System.gc() 之前加入—行 _int a=0;_ 
   #+BEGIN_SRC java
  public static void main(String[] args)() {
	  {
		  byte[] placeholder = new byte[64 * 1024 * 1024];
	  }
	  int a = 0;
	  System.gc();
  }
   #+END_SRC

   : [GC 66401K-> 65778K (125632K ) ,0.0035471 secs] [Full GC 65778K->218K (125632K) ,0.0140596 secs]

   placeholder能否被回收的根本原因是:局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了 placeholder 的作用域，但在此之后，没有任何对局部变量表的读写操作， *placeholder原本所占用的Slot还没有被其他变量所复用* ，所以作为GC Roots—部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微 

   #+BEGIN_EXAMPLE
     如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值(把变量对应的局部变量表Slot清空)便不见得是一个绝对无意义的操作

     这种操作可以作为一种在极特殊情形(对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件)下的“奇技”来使用

     一本非常著名的书籍《Practical Java》中把“不使用的对象应手动赋值为null”作为一条推荐的编码规则，但是并没有解释具体的原因，很长时间之内都有读者对这条规则感到疑惑
   #+END_EXAMPLE

   虽然代码示例说明了 _赋null值的操作_ 在某些情况下确实是有用的，但不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因：
   1. 从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法
   2. 从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GC Roots的枚举也与解释执行时期有巨大差别，以前面例子来看，第二种代码方式在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须写成手动操作

   局部变量不像前面介绍的类变量那样存在 _准备阶段_ 。即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样， *如果一个局部变量定义了但没有赋初始值是不能使用的* ，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值：

   #+BEGIN_SRC java
  public static void main(String[] args) {
	  int a;
	  System.out.println(a);
  }
   #+END_SRC

   : Test.java:4: error: variable a might not have been initialized
   : 		System.out.println(a);
   : 		                   ^
   : 1 error

   编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虛拟机发现而导致类加载失败

** 操作数栈
   *操作数栈* ( _Operand Stack_ )也常称为操作栈，它是一个 _后入先出_ (LIFO)栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_Stacks数据项中

   操作数栈的每一个元素可以是任意的Java数据类型，包括 _long_ 和 _double_ 。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的 *深度都不会超过在max_Stacks数据项中设定的最大值* 

   当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作
   + 做算术运算的时候是通过操作数栈来进行的
   + 调用其他方法的时候是通过操作数栈来进行参数传递

   #+BEGIN_EXAMPLE
     比如，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值

     当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈
   #+END_EXAMPLE


   操作数栈中 *元素的数据类型必须与字节码指令的序列严格匹配* ，在编译程序代码的时候， _编译器要严格保证这一点_ ，在 _类校验阶段的数据流分析_ 中还要再次验证这一点

   #+BEGIN_EXAMPLE
     以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况
   #+END_EXAMPLE


   在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。 *让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据* ，无须进行额外的参数复制传递，重叠的过程如图所示：

   #+ATTR_HTML: image :width 50% 
   [[file:pic/stack-frame-share.png]] 

   Java虚拟机的解释执行引擎称为 _基于栈的执行引擎_ ,其中所指的 _栈_ 就是 *操作数栈* 

 
** 动态连接
   每个栈帧都包含一个 *指向运行时常量池中该栈帧所属方法的引用* ，持有这个引用是为了 *支持方法调用过程中的动态连接* ( _Dynamic Linking_ )

   Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以 *常量池中指向方法的符号引用作为参数* 。这些符号引用可以被：
   + 静态解析：类加载阶段或者第一次使用的时候就转化为直接引用
   + 动态链接：在每一次运行期间转化为直接引用

** 方法返回地址
   当一个方法开始执行后，只有两种方式可以退出这个方法:
   + 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为 _正常完成出口_ (Normal Method Invocation Completion)
   + 在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用 *athrow* 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为 _异常完成出口_ (Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是 *不会给它的上层调用者产生任何返回值* 

   无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说
   1. 方法正常退出时， _调用者的PC计数器的值_ 可以作为返回地址，栈帧中 *很可能会保存这个计数器值* 
   2. 而方法异常退出时，返回地址是要通过 _异常处理器表_ 来确定的，栈帧中 *一般不会保存这部分信息*

   方法退出的过程实际上就等同于把 *当前栈帧出栈* ，因此退出时可能执行的操作有:
   + 恢复上层方法的局部变量表和操作数栈
   + 把返回值(如果有的话)压入调用者栈帧的操作数栈中
   + 调整PC计数器的值以指向方法调用指令后面的一条指令等


** 附加信息
   虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现

   #+BEGIN_EXAMPLE
     在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息
   #+END_EXAMPLE

* 方法调用
