#+TITLE: 线程安全
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: memory_model.html   
#+HTML_LINK_HOME: jvm.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+BEGIN_EXAMPLE
  在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为独立的部分来考虑：
  数据代表问题空间中的客体，程序代码则用于处理这些数据

  这种思维方式直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想

  与此相对的是，面向对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分
  这样可以让程序员能以符合现实世界的思维方式来编写和组织程序
#+END_EXAMPLE

面向过程的编程思想极大地提升了现代软件开发的生产效率和软件可以达到的规模，但是现实世界与计算机世界之间不可避免地存在一些差异。例如，人们很难想象现实中的对象在一项工作进行期间，会被不停地中断和切换，对象的属性（数据）可能会在中断期间被修改和变 *脏* ，而这些事件在计算机世界中则是很正常的事情。有时候，良好的设计原则不得不向现实做出一些让步，必须让程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。对于这部分的主题 _高效并发_ 来讲，首先需要保证并发的正确性，然后在此基础上实现高效。先从如何 *保证并发的正确性* 和如何 *实现线程安全* 讲起
* 线程安全
_线程安全_ 这个名称，相信稍有经验的程序员都会听说过，甚至在代码编写和走查的时候可能还会经常挂在嘴边，但是如何找到一个不太拗口的概念来定义线程安全却不是一件容易的事情
#+BEGIN_EXAMPLE
  在Google中搜索它的概念，找到的是类似于 ：如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的

  这样的定义并不能说它不正确，但是人们无法从中获取到任何有用的信息
#+END_EXAMPLE

《Java Concurrency In Practice》的作者Brian Goetz对 _线程安全_ 有一个比较恰当的定义： *当 _多个线程_  _访问_ 一个对象时，如果不用考虑这些线程在运行时环境下的 _调度和交替执行_ ，也不需要进行 _额外的同步_ ，或者在 _调用方进行任何其他的协调操作_ ， _调用这个对象的行为_ 都可以 _获得正确的结果_ ，那这个对象是线程安全的* 

这个定义比较严谨，它要求线程安全的代码都必须具备一个特征：代码本身 *封装了所有必要的正确性保障手段* （如 _互斥同步_ 等），令 *调用者无须关心多线程* 的问题，更 *无须自己采取任何措施* 来保证多线程的正确调用
#+BEGIN_EXAMPLE
  这点听起来简单，但其实并不容易做到

  在大多数场景中，我们都会将这个定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”
  这个定义的其他描述也能够成立的话，就可以称它是线程安全了
#+END_EXAMPLE
** Java语言中的线程安全
那接下来就讨论一下在Java语言中，线程安全具体是如何体现的？有哪些操作是线程安全的？

#+BEGIN_EXAMPLE
  这里讨论的线程安全，就限定于多个线程之间存在共享数据访问这个前提

  因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的
#+END_EXAMPLE

为了更加深入地理解线程安全，在这里可以不把线程安全当做一个 _非真即假的二元排他_ 选项来看待，按照线程安全的 _安全程度_ 由 *强至弱* 来排序，可以将Java语言中各种操作共享的数据分为以下5类：
1. 不可变
2. 绝对线程安全
3. 相对线程安全
4. 线程兼容
5. 线程对立
*** 不可变

