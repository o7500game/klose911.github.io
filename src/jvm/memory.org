#+TITLE: 内存区域
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: jvm.html   
#+HTML_LINK_HOME: jvm.html
#+OPTIONS: num:nil timestamp:nil

对于Java程序员来说,在虚拟机自动内存管理机制的帮助下,不再需要为每一个new操作去写配对的delete/free代码,不容易出现内存泄漏和内存溢出问题,由虚拟机管理内存这—切看起来都很美好。不过,也正是因为Java程序员把内存控制的权力交给了Java虚拟机, 一旦出现 *内存泄漏* 和 *溢出* 方面的问题,如果不了解虚拟机是怎样使用内存的,那么排查错误将会成为一项异常艰难的工作

* 内存
  Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途,以及创建和销毀的时间,有的区域随着虚拟机进程的启动而存在,有些区域则依赖用户线程的启动和结束而建立和销毀。根据《 Java虚拟机规范(Java SE 7版 )》的规定,Java虚拟机所管理的内存将会包括以下几个运行时数据区域,如下图所示：
  
  #+ATTR_HTML: image :width 70% 
  [[file:pic/jvm-runtime.jpg]] 

** 程序计数器（PC）
*程序计数器* （Program Counter Register）是一块较小的内存空间，它的作用可以看做是 *当前线程所执行的字节码行号指示器* ：
+ *当前线程* 所执行的字节码行号指示器
+ *每个线程都有一个*
+ 线程私有 *生命周期与线程相同* 随JVM启动而生，JVM关闭而死
+ 线程执行Java方法时，记录其正在执行的虚拟机字节码指令地址 
+ 线程执行Native方法时，计数器记录为空（Undefined）
+ 唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域

** 虚拟机栈
虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个 *栈帧* （Stack Frame）用于存储：
+ *局部变量表*
+ *操作栈*
+ *动态链接*
+ *方法出口* 等 

  #+ATTR_HTML: image :width 50% 
  [[file:pic/local-var-table.png]] 

每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程, 同样的这部分也是 *线程私有* 

*** 局部变量表
存放了编译器可知的：
+ 各种 *基本数据类型* （boolean、byte等）
+ *对象引用* （reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向另一个代表对象的句柄或其他次对象相关的位置）
+ *returnAddress* 类型（指向了一条字节码指令的地址）

局部变量表所需的 *内存空间在编译期间完成分配* 当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小

*** 错误异常
在Java虚拟机规范中，对于此区域规定了两种异常状况： 
+ 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 *StackOverflowError* 异常
+ 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 *OutOfMemoryError* 异常

** 本地方法栈
*本地方法栈* （Native Method Stacks）与虚拟机栈所发挥的作用非常类似，区别在于：虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务

与虚拟机栈一样,本地方法栈区域也会拋 *StackOverflowError* 和 *OutOfMemoryError* 异常

** Java堆
对大多数应用来说 *Java堆* （Heap）是Java虚拟机所管理的内存中最大的一块：
+ 被所有 *线程共享* 的一块内存区域
+ 在 *虚拟机启动* 时创建
+ 唯一的目的就是 *存放对象实例* ：Java对象实例以及数组都在堆上分配（渐渐不是那么 _绝对_ 了）


*** GC堆
Java堆是 *垃圾收集器管理的主要区域* 因此Java堆也常被称为 _GC堆_ 

由于现在收集器基于分代收集算法，Java堆还可以细分为： *新生代* 和 *老年代* 

*** 错误异常
根据Java虚拟机规范的规定，Java堆 *可以处于物理上不连续的内存空间中，只要逻辑上是连续的* 即可，类似磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照 *可扩展* 来实现的。 
+ 通过 *-Xmx* 和 *-Xms* 控制Heap大小 

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 *OutOfMemoryError* 异常

** 方法区
方法区与Java堆一样，是各个 *线程共享* 的内存区域，用于存储已被虚拟机加载的： 
+ *类信息*
+ *常量*
+ *静态变量*
+ *即时编译器编译后的代码* 等数据

Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 *不需要连续* 的内存和可以选择固定大小或者 *可拓展* 外，还可以选择 *不实现垃圾收集* 。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就成为了永久代。该区域的内存回收目标主要是针对常量池的回收和对类型的卸载

*** 运行时常量池
运行时常量池是 *方法区的一部分* Class文件中除了有关类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放 *编译期生成的各种字面量和符号引用* 这部分内容将在类加载后进入方法区的运行时常量池中存放

运行时常量池相对于Class文件常量池的另一个重要特征是具备 *动态性* Java语言并非不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量池放入池中

*** 错误异常
根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将拋出 *OutOfMemoryError* 异常

** 直接内存
在JDK1.4中新加入了NIO类 ,引入了一种基于Channel与Buffer的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据

*** 错误异常
本机直接内存的分配不会受到Java堆大小的限制,但是肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时,会根据实际内存设置-Xmx等参数信息,但经常忽略直接内存,使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制), 从而导致动态扩展时出现 *OutOfMemoryError* 异常

* 对象
