#+TITLE: 虚拟机实践
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: class_loader.html   
#+HTML_LINK_HOME: jvm.html
#+OPTIONS: num:nil timestamp:nil ^:nil

在Class文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。能通过程序进行操作的，主要是 *字节码生成* 与 *类加载器* 这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为了许多常用功能和程序实现的基础
* 类加载器
** Tomcat 
   主流的Java Web服务器，如 _Tomcat_ 、 _Jetty_ 、 _WebLogic_ 、 _WebSphere_ 等，都 *实现了自己定义的类加载器* (一般都不止一个)。因为一个功能健全的Web服务器，要解决如下几个问题:
   + *部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离* 

   #+BEGIN_EXAMPLE
     两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一个类库在一个服务器中只有一份，服务器应当保证两个应用程序的类库可以互相独立使用
   #+END_EXAMPLE  

   + *部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享* 
     #+BEGIN_EXAMPLE
       用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费

       这主要倒不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方法区就会很容易出现过度膨胀
     #+END_EXAMPLE

   + 服务器需要尽可能地 *保证自身的安全不受部署的Web应用程序影响* 
   #+BEGIN_EXAMPLE
     有许多主流的Java Web服务器自身也是使用Java语言来实现的

     因此，服务器本身也有类库依赖的问题

     一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立
   #+END_EXAMPLE

   + 支持 _JSP_ 应用的Web服务器，大多数都需要 *支持热部署* 功能
   #+BEGIN_EXAMPLE
     JSP文件最终要编译成Java Class才能由虚拟机执行，但JSP文件由于其纯文本存储的特性，运行时修改的概率远远大于第三方类库或程序自身的Class文件

     ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的优势来看待，因此主流的Web服务器都会支持JSP生成类的热替换

     当然也有非主流的，如运行在生产模式(Production Mode)下的Web Logic服务器默认就不会处理JSP文件的变化
   #+END_EXAMPLE

   由于存在上述问题，在部署Web应用时，单独的一个ClassPath就无法满足需求了，所以各种Web服务器都地提供了好几个ClassPath路径供用户存放第三方类库，这些路径一般都以 _lib_ 或 _classes_ 命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常，每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。以Tomcat服务器为例，看一看Tomcat具体是如何规划用户类库结构和类加载器的

   在Tomcat目录结构中，有3组目录 _/common/*_ 、 _/server/*_ 和 _/shared/*_ )可以存放Java类库，另外还可以加上Web应用程序自身的目录 _/WEB-INF/*_ ，一共4组，把Java类库放置在这些目录中的含义分别如下：
   + 放置在 _/common_ 目录中：类库可 *被Tomcat和所有的Web应用程序* 共同使用
   + 放置在 _/server_ 目录中：类库可 *被Tomcat使用* ，对所有的Web应用程序都不可见
   + 放置在 _/shared_ 目录中：类库可被 *所有的Web应用程序共同使用* ，但对Tomcat自己不可见
   + 放置在 _/WebApp/WEB-INF_ 目录中：类库 *仅仅可以被此Web应用程序* 使用，对Tomcat和其他Web应用程序都不可见

   为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的 _双亲委派模型_ 来实现，其关系如图所示：


   #+ATTR_HTML: image :width 50% 
   [[file:pic/tomcat-class-loader.png]] 

最上层的3个类加载器是JDK默认提供的类加载器，这3个加载器的作用已经介绍过了。 、 、和 则是Tomcat自己定义的类加载器，
+ *CommonClassLoader* : 加载 _/common/*_
+ *CatalinaClassLoader* : 加载 _/server/*_
+ *SharedClassLoader* : 加载 _/shared/*_
+ *WebappClassLoader* : 加载 _/WebApp/WEB-INF/*_ 中的Java类库
  + *JsperLoader* : 加载 _/WebApp/WEB-INF/*_ 中的Jsp文件

WebApp类加载器和Jsp类加载器通常会存在多个实例：
  + 每一个Web应用程序对应一个WebApp类加载器
  + 每一个JSP文件对应一个Jsp类加载器

从图中委派关系可以看出：
+ _CommonClassLoader_ 能加载的类都可以被 _CatalinaClassLoader_ 和 _SharedClassLoader_ 使用
+ _CatalinaClassLoader_ 和 _SharedClassLoader_ 自己能加载的类则与对方相互隔离
+ _WebAppClassLoader_ 可以使用 _SharedClassLoader_ 加载到的类，各个 _WebAppClassLoader_ 实例之间相互隔离
+ _JasperLoader_ 的加载范围仅仅是这个JSP文件所编译出来的那一个Class，它出现的目的就是 *为了被丢弃* :
  + 当服务器检测到JSP文件被修改时，会替掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的Hot Swap功能 

#+BEGIN_EXAMPLE
    对于Tomcat的6.x版本的默认配置下，/common、/server和/shared三个目录已经合并到一起变成/lib目录了，这个目录里的类库相当于以前/common目录中类库的作用
  
    只有指定了catalina.properties配置文件的server.loader和share.loader项后才会真正建立CatalinaClassLoader和SharedClassLoader的实例，否则会用到这两个类加载器的地方会用CommonClassLoader的实例代替

    这是Tomcat设计团队为了简化大多数的部署场景所做的一项改进，如果默认设置不能满足需要，用户可以通过修改配置文件指定server.loader和share.loader的方式重新启用Tomcat5.x的加载器架构
#+END_EXAMPLE

总结：Tomcat加载器的实现 *清晰易懂* ，并且采用了官方推荐的 _正统_ 的使用类加载器的方式

#+BEGIN_EXAMPLE
  如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring放到Common或Shared目录下让这些程序共享

  Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的，那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问不在其加载范围内的用户程序？

  可以尝试的答案是：使用线程上下文加载器
#+END_EXAMPLE

** OSGi
