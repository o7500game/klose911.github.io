#+TITLE: Effective Go
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil

 Go 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用Go编程在本质上就不同于其它语言。将现有的C++或Java程序直译为Go 程序并不能令人满意。毕竟Java程序是用Java编写的，而不是Go。 另一方面，若从Go的角度去分析问题，你就能编写出同样可行但大不相同的程序。 换句话说，要想将Go程序写得好，就必须理解其特性和风格。了解命名、格式化、 程序结构等既定规则也同样重要，这样你编写的程序才能更容易被其他程序员所理解

本文档就如何编写清晰、地道的Go代码提供了一些技巧。它是对语言规范、 Go语言之旅以及 如何使用Go编程的补充说明

* 格式化
 格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格， 但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范

在Go中另辟蹊径，让机器来处理大部分的格式化问题。 *gofmt* 程序（也可用 go fmt，它以包为处理对象而非源文件）将Go程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。若你想知道如何处理一些新的代码布局，请尝试运行 gofmt；若结果仍不尽人意，请重新组织你的程序（或提交有关 gofmt 的Bug），而不必为此纠结

举例来说，你无需花时间将结构体中的字段注释对齐，gofmt 将为你代劳。 假如有以下声明

#+BEGIN_SRC go
  type T struct {
       name string // 对象名
             value int // 对象值
  }
#+END_SRC

 gofmt 会将它按列对齐为： 

#+BEGIN_SRC go
  type T struct {
          name    string // 对象名
          value   int    // 对象值
  }
#+END_SRC

标准包中所有的Go代码都已经用 gofmt 格式化过了

还有一些关于格式化的细节，它们非常简短：
+ 缩进：使用制表符（tab）缩进，gofmt 默认也使用它。在认为 *确实有必要时再使用空格*
+ 行的长度： *Go对行的长度没有限制* 。如果一行实在太长，也可进行折行并插入适当的tab缩进
+ 括号：比起C和Java，Go所需的括号更少：控制结构（if、for 和 switch）在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁
#+BEGIN_SRC go
  x<<8 + y<<16
#+END_SRC 
 空格符表述了需要所传达的含义

* 注释 
 Go语言支持C风格的块注释 /* */ 和C++风格的行注释 //

 *行注释更为常用，而块注释则主要用作包的注释* ，当然也可在禁用一大段代码时使用

 *godoc* 既是一个程序，又是一个Web服务器，它对Go的源码进行处理，并提取包中的文档内容。 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。 这些注释的类型和风格决定了 godoc 生成的文档质量

** 包注释
+ *每个包都应包含一段包注释* ，即放置在包子句前的一个块注释
+ 对于包含多个文件的包， *包注释只需出现在其中的任一文件中即可* 
+ 包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 godoc 页面中的最上面，并为紧随其后的内容建立详细的文档

 #+BEGIN_SRC go
   /*
           regexp 包为正则表达式实现了一个简单的库。

           该库接受的正则表达式语法为：

           正则表达式:
                   串联 { '|' 串联 }
           串联:
                   { 闭包 }
           闭包:
                   条目 [ '*' | '+' | '?' ]
           条目:
                   '^'
                   '$'
                   '.'
                   字符
                   '[' [ '^' ] 字符遍历 ']'
                   '(' 正则表达式 ')'
   ,*/
   package regexp
 #+END_SRC

+  若某个包比较简单，包注释同样可以简洁些
#+BEGIN_SRC go
  // path 包实现了一些常用的工具，以便于操作用反斜杠分隔的路径.
#+END_SRC

注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示， 因此不要依赖于空格对齐，godoc 会像 gofmt 那样处理好这一切。 注释是不会被解析的纯文本，因此像HTML或其它类似于 _这样_ 的东西将按照 原样 输出，因此不应使用它们。godoc 所做的调整， 就是将已缩进的文本以等宽字体显示，来适应对应的程序片段。 fmt 包的注释就用了这种不错的效果

godoc 是否会重新格式化注释取决于上下文，因此必须确保它们看起来清晰易辨： 使用正确的拼写、标点和语句结构以及折叠长行等

** 文档注释
+ 在包中 *任何顶级声明前面的注释都将作为该声明的文档注释* 
+ 在程序中 *每个可导出（首字母大写）的名称都应该有文档注释*
+ 文档注释最好是 *完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要* 

#+BEGIN_SRC go
  // Compile 用于解析正则表达式并返回，如果成功，则 Regexp 对象就可用于匹配所针对的文本。
  func Compile(str string) (regexp *Regexp, err error) {
#+END_SRC

+ 若注释总是以名称开头，godoc 的输出就能通过 *grep* 变得更加有用

+  Go的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。 由于是整体声明，这种注释往往较为笼统
#+BEGIN_SRC go
  // 表达式解析失败后返回错误代码。
  var (
          ErrInternal      = errors.New("regexp: internal error")
          ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
          ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
          ...
  )
#+END_SRC

+  即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量

#+BEGIN_SRC go
  var (
          countLock   sync.Mutex
          inputCount  uint32
          outputCount uint32
          errorCount  uint32
  )
#+END_SRC 

* 命名
 正如命名在其它语言中的地位，它在 Go 中同样重要。有时它们甚至会影响语义： 例如， *某个名称在包外是否可见，就取决于其首个字符是否为大写字母*  因此有必要花点时间来讨论Go程序中的命名约定

** 包名
 当一个包被导入后， *包名就会成了内容的访问器*  

#+BEGIN_SRC go
  import "bytes"
#+END_SRC

之后，被导入的包就能通过 *bytes.Buffer* 来引用了。 若所有人都以相同的名称来引用其内容将大有裨益， 这也就意味着包应当有个恰当的名称：其名称应该简洁明了而易于理解。按照惯例，  *包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法* 。err 的命名就是出于简短考虑的，因为任何使用该包的人都会键入该名称。 不必担心引用次序的冲突。 *包名就是导入时所需的唯一默认名称， 它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下， 也可为导入的包选择一个别名来局部使用* 无论如何，通过文件名来判定使用的包，都是不会产生混淆的

另一个约定就是包名应为其源码目录的基本名称。在 *src/pkg/encoding/base64* 中的包应作为  *encoding/base64* 导入，其包名应为 *base64*  而非 encoding_base64 或 encodingBase64

包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。 （请勿使用 *import . 记法* ，它可以简化必须在被测试包外运行的测试， 除此之外应尽量避免使用）例如，bufio 包中的缓存读取器类型叫做 Reader 而非 BufReader，因为用户将它看做 *bufio.Reader* ，这是个清楚而简洁的名称。 此外，由于被导入的项总是通过它们的包名来确定，因此 bufio.Reader 不会与 io.Reader 发生冲突。同样，用于创建 ring.Ring 的新实例的函数（这就是Go中的构造函数）一般会称之为 *NewRing* ，但由于 Ring 是该包所导出的唯一类型，且该包也叫 ring，因此它可以只叫做 *New* ，它跟在包的后面，就像 *ring.New* 使用包结构可以帮助你选择好的名称

 另一个简短的例子是 *once.Do* ，once.Do(setup) 表述足够清晰， 使用 *once.DoOrWaitUntilDone(setup)* 完全就是画蛇添足。 长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值 

** setter
Go并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但 *若要将 Get 放到获取器的名字中，既不符合习惯，也没有必要* 。*若你有个名为 owner （小写，未导出）的字段，其获取器应当名为 Owner（大写，可导出）而非 GetOwner* 。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 *若要提供设置器方法，SetOwner 是个不错的选择* 。两个命名看起来都很合理：
#+BEGIN_SRC go
  owner := obj.Owner()
  if owner != user {
          obj.SetOwner(user)
  }
#+END_SRC 

** 接口名
 按照约定， *只包含一个方法的接口应当以该方法的名称加上-er后缀来命名*  如 Reader、Writer、 Formatter、CloseNotifier 等。

诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。 Read、Write、Close、Flush、 String 等都具有典型的签名和意义。 *为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同* 。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 *请将字符串转换方法命名为 String 而非 ToString* 

** 驼峰记法
Go中约定使用驼峰记法 *MixedCaps* 或 *mixedCaps* 

* 分号
 和C一样，Go的正式语法使用分号来结束语句；和C不同的是，这些分号并不在源码中出现。 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此因此源码中基本就不用分号了

规则是这样的： *若在新行前的最后一个标记为标识符（包括 int 和 float64 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一* 
#+BEGIN_EXAMPLE
break continue fallthrough return ++ -- ) }
#+END_EXAMPLE

则词法分析将始终在该标记后面插入分号。这点可以概括为： *如果新行前的标记为语句的末尾，则插入分号* 

分号也可在闭括号之前直接省略，因此像 
#+BEGIN_SRC go
  go func() { for { dst <- <-src } }()
#+END_SRC

 这样的语句无需分号。通常Go程序只在诸如 for 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开

 警告： *无论如何，你都不应将一个控制结构（if、for、switch 或 select）的左大括号放在下一行* 如果这样做，就会在大括号前面插入一个分号，这可能引起不需要的效果。 你应该这样写 
#+BEGIN_SRC go
  if i < f() {
          g()
  }
#+END_SRC

 而不是这样 
#+BEGIN_SRC go
  if i < f()  // 错！
  {           // 错！
          g()
  }
#+END_SRC

* 控制结构
Go中的结构控制与C有许多相似之处，但其不同之处才是独到之处：
+ Go不再使用 *do* 或 *while* 循环，只有一个更通用的 *for*
+ switch 要更灵活一点, *if 和 switch 像 for一样可接受可选的初始化语句*
+ 一个包含类型选择和多路通信复用器的新控制结构：*select* 其语法也有些许不同 *没有圆括号，而其主体必须始终使用大括号括住* 

** if
 在Go中，一个简单的 if 语句看起来像这样： 
#+BEGIN_SRC go
  if x > 0 {
          return y
  }
#+END_SRC

 强制的大括号促使你将简单的 if 语句分成多行。特别是在主体中包含 return 或 break 等控制语句时，这种编码风格的好处一比便知

由于 if 和 switch 可接受初始化语句， 因此 *用它们来设置局部变量十分常见* 

#+BEGIN_SRC go
  if err := file.Chmod(0664); err != nil {
          log.Print(err)
          return err
  }
#+END_SRC

 在Go的库中，你会发现若 if 语句不会执行到下一条语句时，亦即其 *执行体 以 break、continue、goto 或 return 结束时，不必要的 else 会被省略* 

#+BEGIN_SRC go
  f, err := os.Open(name)
  if err != nil {
          return err
  }
  codeUsing(f)
#+END_SRC

 下例是一种常见的情况，代码必须防范一系列的错误条件。若控制流成功继续， 则说明程序已排除错误。由于出错时将以return 结束， 之后的代码也就无需 else 了

#+BEGIN_SRC go
  f, err := os.Open(name)
  if err != nil {
          return err
  }
  d, err := f.Stat()
  if err != nil {
          f.Close()
          return err
  }
  codeUsing(f, d)
#+END_SRC
*** 重新声明与再次赋值
最后一个示例展示了短声明 := 如何使用。 调用了 os.Open 的声明为
#+BEGIN_SRC go
f, err := os.Open(name)
#+END_SRC

 该语句声明了两个变量 f 和 err。在几行之后，又通过 

#+BEGIN_SRC go
  d, err := f.Stat()
#+END_SRC

调用了 f.Stat。它看起来似乎是声明了 d 和 err。 注意 *尽管两个语句中都出现了 err，但这种重复仍然是合法的* ：err 在第一条语句中被声明，但在第二条语句中只是被再次赋值罢了。也就是说，调用 f.Stat 使用的是前面已经声明的 err，它只是被重新赋值了而已

在满足下列条件时，已被声明的变量 v 可出现在:= 声明中：
+ 本次声明与已声明的 v 处于同一作用域中（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量§）
+ 在初始化中与其类型相应的值才能赋予 v，且在此次声明中至少另有一个变量是新声明的
 
值得一提的是， *即便Go中的函数形参和返回值在词法上处于大括号之外， 但它们的作用域和该函数体仍然相同* 
** for
 Go的 for 循环类似于C，但却不尽相同

+ *它统一了 for 和 while，不再有 do-while 了，它有三种形式，但只有一种需要分号*

#+BEGIN_SRC go
  // 如同C的for循环
  for init; condition; post { }

  // 如同C的while循环
  for condition { }

  // 如同C的for(;;)循环
  for { }
#+END_SRC

+ 简短声明能更容易在循环中声明下标变量：
#+BEGIN_SRC go
  sum := 0
  for i := 0; i < 10; i++ {
          sum += i
  }
#+END_SRC

 + *若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， range 子句能够帮你轻松实现循环* 
#+BEGIN_SRC go
  for key, value := range oldMap {
          newMap[key] = value
  }
#+END_SRC

+  若只需要该遍历中的第一个项（键或下标），去掉第二个就行了

#+BEGIN_SRC go 
  for key := range m {
          if key.expired() {
                  delete(m, key)
          }
  }
#+END_SRC

+  若你只需要该遍历中的第二个项（值），请使用空白标识符，即下划线来丢弃第一个值
#+BEGIN_SRC go
  sum := 0
  for _, value := range array {
          sum += value
  }
#+END_SRC

对于字符串，range 能够提供更多便利。它能通过解析UTF-8， 将每个独立的Unicode码点分离出来。错误的编码将占用一个字节，并以符文U+FFFD来代替。 （名称 *符文* 和内建类型 *rune* 是Go对单个Unicode码点的成称谓。 详情见语言规范） 

#+BEGIN_SRC go  :results output :exports result
  for pos, char := range "日本\x80語" { // \x80 是个非法的UTF-8编码
          fmt.Printf("字符 %#U 始于字节位置 %d\n", char, pos)
  }
#+END_SRC

#+RESULTS:
: 字符 U+65E5 '日' 始于字节位置 0
: 字符 U+672C '本' 始于字节位置 3
: 字符 U+FFFD '?' 始于字节位置 6
: 字符 U+8A9E '語' 始于字节位置 7

+ 若想要在 for 中使用多个变量，应采用平行赋值的方式，它会拒绝 ++ 和 --
#+BEGIN_SRC go
  // 反转 a
  for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
          a[i], a[j] = a[j], a[i]
  }
#+END_SRC 
** switch
Go的 *switch* 比C的更通用。 *其表达式无需为常量或整数* case 语句会自上而下逐一进行求值直到匹配为止。若 switch 后面没有表达式，它将匹配 true，因此，可以将 if-else-if-else 链写成一个 switch，这也更符合Go的风格

#+BEGIN_SRC go
  func unhex(c byte) byte {
          switch {
          case '0' <= c && c <= '9':
                  return c - '0'
          case 'a' <= c && c <= 'f':
                  return c - 'a' + 10
          case 'A' <= c && c <= 'F':
                  return c - 'A' + 10
          }
          return 0
  }
#+END_SRC

+  switch 并不会自动下溯，但 case 可通过逗号分隔来列举相同的处理条件

#+BEGIN_SRC go
  func shouldEscape(c byte) bool {
          switch c {
          case ' ', '?', '&', '=', '#', '+', '%':
                  return true
          }
          return false
  }
#+END_SRC
*** break
break 语句可以使 switch 提前终止。不仅是 switch， 有时候也必须打破层层的循环。在Go中，我们只需将标签放置到循环外，然后 “蹦”到那里即可。下面的例子展示了二者的用法
#+BEGIN_SRC go
  Loop:
  for n := 0; n < len(src); n += size {
          switch {
          case src[n] < sizeOne:
                  if validateOnly {
                          break
                  }
                  size = 1
                  update(src[n])

          case src[n] < sizeTwo:
                  if n+1 >= len(src) {
                          err = errShortInput
                          break Loop
                  }
                  if validateOnly {
                          break
                  }
                  size = 2
                  update(src[n] + src[n+1]<<shift)
          }
  }
#+END_SRC

 *continue 语句也能接受一个可选的标签，不过它只能在循环中使用* 

通过使用两个 switch 语句对字节数组进行比较：
#+BEGIN_SRC go
  // Compare 按字典顺序比较两个字节切片并返回一个整数。
  // 若 a == b，则结果为零；若 a < b；则结果为 -1；若 a > b，则结果为 +1。
  func Compare(a, b []byte) int {
          for i := 0; i < len(a) && i < len(b); i++ {
                  switch {
                  case a[i] > b[i]:
                          return 1
                  case a[i] < b[i]:
                          return -1
                  }
          }
          switch {
          case len(a) > len(b):
                  return 1
          case len(a) < len(b):
                  return -1
          }
          return 0
  }
#+END_SRC
*** 类型选择
 switch 也可用于判断接口变量的动态类型。如 *类型选择* 通过圆括号中的关键字 *type* 使用类型断言语法。若 switch 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型

#+BEGIN_SRC go
  var t interface{}
  t = functionOfSomeType()
  switch t := t.(type) {
  default:
          fmt.Printf("unexpected type %T", t)       // %T 输出 t 是什么类型
  case bool:
          fmt.Printf("boolean %t\n", t)             // t 是 bool 类型
  case int:
          fmt.Printf("integer %d\n", t)             // t 是 int 类型
  case *bool:
          fmt.Printf("pointer to boolean %t\n", *t) // t 是 *bool 类型
  case *int:
          fmt.Printf("pointer to integer %d\n", *t) // t 是 *int 类型
  }
#+END_SRC 
* 函数

** 多值返回
 Go与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善C中一些笨拙的习惯： 将错误值返回（例如用 -1 表示 EOF）和修改通过地址传入的实参

在C中，写入操作发生的错误会用一个负数标记，而错误码会隐藏在某个不确定的位置。 而在Go中，Write 会返回写入的字节数以及一个错误： _是的，您写入了一些字节，但并未全部写入，因为设备已满_ 。在 os 包中，File.Write 的签名为： 

#+BEGIN_SRC go
  func (file *File) Write(b []byte) (n int, err error)
#+END_SRC

正如文档所述，它返回写入的字节数，并在n != len(b) 时返回一个非 nil 的 error 错误值 

+ 可以采用一种简单的方法。来避免为模拟引用参数而传入指针。 以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置 

#+BEGIN_SRC go
  func nextInt(b []byte, i int) (int, int) {
          for ; i < len(b) && !isDigit(b[i]); i++ {
          }
          x := 0
          for ; i < len(b) && isDigit(b[i]); i++ {
                  x = x*10 + int(b[i]) - '0'
          }
          return x, i
  }
#+END_SRC

 可以像下面这样，通过它扫描输入的切片 b 来获取数字 
#+BEGIN_SRC go 
  for i := 0; i < len(b); {
          x, i = nextInt(b, i)
          fmt.Println(x)
  }
#+END_SRC 

** 可命名结果形参
 Go函数的返回值或结果 *形参* 可被命名，并作为常规变量使用，就像传入的形参一样。 *命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值, 若该函数执行了一条不带实参的 return 语句，则结果形参的当前值将被返回* 

此名称不是强制性的，但它们能使代码更加简短清晰：它们就是文档。若我们命名了 nextInt 的结果，那么它返回的 int 就值如其意了 
#+BEGIN_SRC go
  func nextInt(b []byte, pos int) (value, nextPos int) {
#+END_SRC 

 由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 io.ReadFull 就是个很好的例子： 

#+BEGIN_SRC go
  func ReadFull(r Reader, buf []byte) (n int, err error) {
          for len(buf) > 0 && err == nil {
                  var nr int
                  nr, err = r.Read(buf)
                  n += nr
                  buf = buf[nr:]
          }
          return // 无需写return n, err
  }
#+END_SRC
** defer
Go的 defer 语句用于预设一个函数调用（ *推迟执行函数* ）， 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是 *解锁互斥和关闭文件* 

#+BEGIN_SRC go
  // Contents 将文件的内容作为字符串返回。
  func Contents(filename string) (string, error) {
          f, err := os.Open(filename)
          if err != nil {
                  return "", err
          }
          defer f.Close()  // f.Close 会在我们结束后运行。

          var result []byte
          buf := make([]byte, 100)
          for {
                  n, err := f.Read(buf[0:])
                  result = append(result, buf[0:n]...) // append 将在后面讨论。
                  if err != nil {
                          if err == io.EOF {
                                  break
                          }
                          return "", err  // 我们在这里返回后，f 就会被关闭。
                  }
          }
          return string(result), nil // 我们在这里返回后，f 就会被关闭。
  }
#+END_SRC

推迟诸如 Close 之类的函数调用有两点好处：
1. 它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时， 这种情况往往就会发生
2. 它意味着 _关闭_ 离 _打开_ 很近， 这总比将它放在函数结尾处要清晰明了

*被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值* 这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子

#+BEGIN_SRC go
  for i := 0; i < 5; i++ {
          defer fmt.Printf("%d ", i)
  }
#+END_SRC

被推迟的函数按照 *后进先出* （LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0。一个更具实际意义的例子是通过一种简单的方法， 用程序来跟踪函数的执行。可以编写一对简单的跟踪例程：

  #+BEGIN_SRC go
    func trace(s string)   { fmt.Println("entering:", s) }
    func untrace(s string) { fmt.Println("leaving:", s) }

    // 像这样使用它们：
    func a() {
            trace("a")
            defer untrace("a")
            // 做一些事情....
  #+END_SRC

可以充分利用这个特点，即被推迟函数的实参在 defer 执行时才会被求值。 跟踪例程可针对反跟踪例程设置实参。以下例子：

#+BEGIN_SRC go  :results output :exports result
  func trace(s string) string {
          fmt.Println("entering:", s)
          return s
  }

  func un(s string) {
          fmt.Println("leaving:", s)
  }

  func a() {
          defer un(trace("a"))
          fmt.Println("in a")
  }

  func b() {
          defer un(trace("b"))
          fmt.Println("in b")
          a()
  }

  func main() {
          b()
  }
#+END_SRC

#+RESULTS:
: entering: b
: in b
: entering: a
: in a
: leaving: a
: leaving: b

对于习惯其它语言中块级资源管理的程序员，defer 似乎有点怪异， 但它 *最有趣而强大的应用恰恰来自于其基于函数而非块的特点* 
* 数据

** new 分配

** 构造函数与复合字面

** make分配

** 数组

** 切片

***  二维切片

** 映射

** 打印

** 追加

* 初始化

** 常量

** 变量

** 初始化

* 方法

** 指针 vs 值

* 接口与其它类型

** 接口

** 类型转换

** 接口转换与类型断言

** 通用性

** 接口与方法

* 空白标识符

** 多重赋值中的空白标识符

** 未使用的导入和变量

** 为副作用而导入

** 接口检查

* 内嵌

* 并发

** 通过通信共享内存

** Go程

** 信道

** 信道中的信道

** 并行化

** 可能泄露的缓冲区

* 错误

** panic

** 恢复

* 一个Web服务器

