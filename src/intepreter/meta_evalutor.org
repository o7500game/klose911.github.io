#+TITLE: 元循环求值器
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 

用一种语言实现其自身的求值器，这叫做 *元循环* 

* 基本求值过程
1. eval:  对一个表达式 *求值*
   + 组合表达式：先 _求子表达式的值_ ，而后把 _运算符的子表达式的值_ *作用* 于 _运算参数子表达式的值_ 
2. apply: 把一组参数值 *作用* 于一个过程体
   + 复杂过程：原来环境上添加一个新的 _框架_ ，在新的框架上把 _实参值_  *绑定* 到过程的 _形参_ 上，在这个 *新的环境* 中对 _过程体_ *求值* 


在这两个过程中都可能遇到 *递归* 调用，直到：
+ 变量：从环境中获取
+ 基本过程：直接调用代码
+ 基本表达式：直接返回数，字符串，布尔值等


在一个环境中对表达式求值 -> 把参数值作用于一个过程 -> 在一个新的环境上对表达式求值  ......

 #+ATTR_HTML: image :width 40% 
  [[./pic/eval-apply.gif]]

** 核心过程
*** eval 
*eval* 以一个 _表达式_ 和 _环境_ 作为参数，对表达式进行求值：
+ 基本表达式：
  + 各种自求值表达式：直接返回，如数，字符串，布尔值等
  + 变量：从环境查询变量
+ 特殊表达式：
  + 引号表达式：返回被引用的表达式
  + 变量赋值或定义：修改环境，建立或者修改相关的约束
  + if表达式：条件部分求值，然后根据情况对相应的子表达式进行求值
  + lambda表达式：建立过程对象，包装相应的过程体，形参，和环境
  + begin表达式：依次对子表达式进行求值
  + cond表达式：转换为一系列的if表达式，求值
  + ......
+组合表达式：先 _求子表达式的值_ ，而后把 _运算符的子表达式的值_ *作用* 于 _运算参数子表达式的值_ 

#+BEGIN_SRC scheme
  (define (m-eval exp env)
    (cond ((self-evaluating? exp) exp)
	  ((variable? exp) (lookup-variable-value exp env))
	  ((quoted? exp) (text-of-quotation exp))
	  ((assignment? exp) (eval-assignment exp env))
	  ((definition? exp) (eval-definition exp env))
	  ((if? exp) (eval-if exp env))
	  ((lambda? exp)
	   (make-procedure (lambda-parameters exp) (lambda-body exp) env))
	  ((begin? exp)
	   (eval-sequence (begin-actions exp) env))
	  ((cond? exp)
	   (m-eval (cond->if exp) env))
	  ((application? exp)
	   (m-apply (m-eval (operator exp) env)
		    (list-of-values (operands exp) env)))
	  (else (error "Unknown expression type -- EVAL" exp))))
#+END_SRC

*** apply 
*apply* 以 _一个过程体_ 和 _一组参数值_ 作为变量，实现过程应用：
+ 基本过程：直接调用
+ 复杂过程：原来环境上添加一个新的 _框架_ ，在新的框架上把 _实参值_  *绑定* 到过程的 _形参_ 上，在这个 *新的环境* 中对 _过程体_ *求值* 

#+BEGIN_SRC scheme
  (define (m-apply procedure arguments)
    (cond ((primitive-procedure? procedure)
	   (apply-primitive-procedure procedure arguments))
	  ((compound-procedure? procedure)
	   (eval-sequence
	    (procedure-body procedure)
	    (extend-environment (procedure-parameters procedure)
				arguments
				(procedure-environment procedure))))
	  (else (error "Unknown procedure type -- APPLY" procedure))))
#+END_SRC

*** 获得过程参数
eval在调用apply前，需要对各实参进行求值
#+BEGIN_SRC scheme
  (define (list-of-values exps env)
    (if (no-operands? exps)
	'()
	(cons (eval (first-operand exps) env)
	      (list-of-values (rest-operands exps) env))))
#+END_SRC

#+BEGIN_EXAMPLE
  这里其实也可以用map实现，上面做法说明元循环求值器也可以使用没有高阶过程的语言来实现
#+END_EXAMPLE

*** if表达式
#+BEGIN_SRC scheme
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
	(eval (if-consequent exp) env)
	(eval (if-alternative exp) env)))
#+END_SRC

#+BEGIN_EXAMPLE
  true? 把条件表达式的求值转换成Scheme的逻辑值

  好处：元循环的逻辑值可以用任何值来表示，不需要和Schme的逻辑值保持一致
#+END_EXAMPLE

*** 顺序求值
依次进行求值，最后一个表达式的值作为返回值
#+BEGIN_SRC scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
	  (else (eval (first-exp exps) env)
		(eval-sequence (rest-exps exps) env))))
#+END_SRC

+ apply 依次对函数体和参数进行求值
+ eval：对begin表达式进行求值

*** 赋值和定义
#+BEGIN_SRC scheme
  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
			 (eval (assignment-value exp) env)
			 env)
    'ok)
#+END_SRC

#+BEGIN_SRC scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
#+END_SRC

** 表达式

*** 自求值表达式
#+BEGIN_SRC scheme
  (define (self-evaluating? exp)
    (cond ((number? exp) true)
	  ((string? exp) true)
	  (else false)))
#+END_SRC

*** 变量表达式
#+BEGIN_SRC scheme
  (define (variable? exp) (symbol? exp))
#+END_SRC

*** 表达式类型判断
#+BEGIN_SRC scheme
  (define (tagged-list? exp tag)
    (if (pair? exp)
	(eq? (car exp) tag)
	false))
#+END_SRC

*** 引用表达式
#+BEGIN_EXAMPLE
  (quote <text-of-quotation>)
#+END_EXAMPLE

#+BEGIN_SRC scheme
  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))
#+END_SRC

*** 赋值表达式
#+BEGIN_EXAMPLE
  (set! <var> <value>)
#+END_EXAMPLE

#+BEGIN_SRC scheme
  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp)
    (cadr exp))

  (define (assignment-value exp)
    (caddr exp))
#+END_SRC

*** 定义表达式
#+BEGIN_EXAMPLE
  (define <var> <value>)

  (define (<var> <parameter1> ... <parametern>)
    <body>)

  ;; 后一种形式是下面的语法糖
  (define <var>
    (lambda (<parameter1> ... <parametern>)
      <body>))
#+END_EXAMPLE

#+BEGIN_SRC scheme
  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
	(cadr exp)
	(caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
	(caddr exp)
	(make-lambda (cdadr exp)   ; formal parameters
		     (cddr exp)))) ; body
#+END_SRC

*** lambda表达式
形式上是一个以lambda开头的表

#+BEGIN_EXAMPLE
(lambda (<lambda-expressions>) (<lambda-body>)) 
#+END_EXAMPLE

#+BEGIN_SRC scheme
  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp)
    (cadr exp))

  (define (lambda-body exp)
    (cddr exp))
#+END_SRC

为definion-value提供一个lambda构造器
#+BEGIN_SRC scheme
  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))
#+END_SRC

*** if表达式
#+BEGIN_EXAMPLE
(if (<predicate>) (<consequent>) (<alternative>))  
#+END_EXAMPLE

如果 _alternative_ 表达式确实，则返回 _false_ 
#+BEGIN_SRC scheme
  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
	(cadddr exp)
	'false))
#+END_SRC

为cond -> if 提供一个构造器：
#+BEGIN_SRC scheme
  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))
#+END_SRC

*** begin表达式
#+BEGIN_SRC scheme
  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))
#+END_SRC

为cond-> if 提供一个构造器：
#+BEGIN_SRC scheme
  (define (sequence->exp seq)
    (cond ((null? seq) seq)
	  ((last-exp? seq) (first-exp seq))
	  (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))
#+END_SRC

*** cond表达式
#+BEGIN_SRC scheme
  (cond ((> x 0) x)
	((= x 0) (display 'zero) 0)
	(else (- x)))
#+END_SRC

等价于
#+BEGIN_SRC scheme
  (if (> x 0)
      x
      (if (= x 0)
	  (begin (display 'zero)
		 0)
	  (- x)))
#+END_SRC

cond表达式可以被翻译成if表达式：
#+BEGIN_SRC scheme
  (define (cond? exp) (tagged-list? exp 'cond))
  (define (cond-clauses exp) (cdr exp))
  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))
  (define (cond-predicate clause) (car clause))
  (define (cond-actions clause) (cdr clause))
  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
	'false                          ; no else clause
	(let ((first (car clauses))
	      (rest (cdr clauses)))
	  (if (cond-else-clause? first)
	      (if (null? rest)
		  (sequence->exp (cond-actions first))
		  (error "ELSE clause isn't last -- COND->IF"
			 clauses))
	      (make-if (cond-predicate first)
		       (sequence->exp (cond-actions first))
		       (expand-clauses rest))))))
#+END_SRC

*** application表达式
无法匹配上面几种的表达式：
#+BEGIN_SRC scheme
  (define (application? exp) (pair? exp))
  (define (operator exp) (car exp)) ;; 运算符
  (define (operands exp) (cdr exp)) ;;运算参数
  (define (no-operands? ops) (null? ops))
  (define (first-operand ops) (car ops))
  (define (rest-operands ops) (cdr ops))
#+END_SRC

** 数据结构

*** 谓词检测
所有 *非false* 对象都是 _逻辑真_
#+BEGIN_SRC scheme
  (define (true? x)
    (not (eq? x false)))
  (define (false? x)
    (eq? x false))
#+END_SRC

*** 过程
调用基本过程
#+BEGIN_SRC scheme
  (apply-primitive-procedure <proc> <args>)
#+END_SRC

测试是否基本过程
#+BEGIN_SRC scheme
  (primitive-procedure? <proc>)
#+END_SRC

复杂过程数据结构：
#+BEGIN_SRC scheme
  (define (make-procedure parameters body env)
    (list 'procedure parameters body env))
  (define (compound-procedure? p)
    (tagged-list? p 'procedure))
  (define (procedure-parameters p) (cadr p))
  (define (procedure-body p) (caddr p))
  (define (procedure-environment p) (cadddr p))
#+END_SRC

*** 环境
环境是一系列框架的序列，框架是一个表格，其中的项就是变量名和值的绑定， 环境的主要操作是：
+ 查找变量值：
#+BEGIN_EXAMPLE
(lookup-variable-value <var> <env>)
#+END_EXAMPLE
取得符号 _<var>_ 在环境 _<env>_ 中的约束值，如果变量未被绑定则报错
+ 添加新的框架：
#+BEGIN_EXAMPLE
(extend-environment <variables> <values> <base-env>)
#+END_EXAMPLE
新建一个框架，在这个新框架里把 _<values>_ 序列中的值分别绑定到 _<variables>_ 序列中的变量名，这个新的框架指向 _<base_env>_ 环境
+ 定义变量：
#+BEGIN_EXAMPLE
  (define-variable! <var> <value> <env>) 
#+END_EXAMPLE
在 _<env>_ 环境中的 _第一个框架_ 中添加新的绑定 ，把 _<value>_  值绑定到 _<var>_ 变量上
+ 变量赋值：
#+BEGIN_EXAMPLE
  (set-variable-value! <var> <value> <env>)
#+END_EXAMPLE
在 _<env>_ 环境中把 _<var>_ 绑定的值改为 _<value>_ ，如果变量未绑定则报错

**** 环境实现
环境用框架的表来表示，
#+BEGIN_SRC scheme
  (define (enclosing-environment env) (cdr env))
  (define (first-frame env) (car env))
  (define the-empty-environment '())
#+END_SRC

框架是表的序对，car是变量名表，cdr是变量值表
#+BEGIN_SRC scheme
  (define (make-frame variables values)
    (cons variables values))
  (define (frame-variables frame) (car frame))
  (define (frame-values frame) (cdr frame))
  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))
#+END_SRC

添加新的框架
#+BEGIN_SRC scheme
  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
	(cons (make-frame vars vals) base-env)
	(if (< (length vars) (length vals))
	    (error "Too many arguments supplied" vars vals)
	    (error "Too few arguments supplied" vars vals))))
#+END_SRC

#+BEGIN_SRC scheme
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
	(cond ((null? vars)
	       (env-loop (enclosing-environment env)))
	      ((eq? var (car vars))
	       (car vals))
	      (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
	  (error "Unbound variable" var)
	  (let ((frame (first-frame env)))
	    (scan (frame-variables frame)
		  (frame-values frame)))))
    (env-loop env))
#+END_SRC

变量赋值
#+BEGIN_SRC scheme
  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
	(cond ((null? vars)
	       (env-loop (enclosing-environment env)))
	      ((eq? var (car vars))
	       (set-car! vals val))
	      (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
	  (error "Unbound variable -- SET!" var)
	  (let ((frame (first-frame env)))
	    (scan (frame-variables frame)
		  (frame-values frame)))))
    (env-loop env))
#+END_SRC

定义变量
#+BEGIN_SRC scheme
  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
	(cond ((null? vars)
	       (add-binding-to-frame! var val frame))
	      ((eq? var (car vars))
	       (set-car! vals val))
	      (else (scan (cdr vars) (cdr vals)))))
      (scan (frame-variables frame)
	    (frame-values frame))))
#+END_SRC

** 运行
求值器递归到最后是对基本过程的调用，因此需要做一系列的设置：
+ 为每个基本过程在环境中做一个绑定，这样eval才能在求值过程中获得过程对象并传递给apply
+ 环境中还必须包含true, false等基础值的绑定

#+BEGIN_SRC scheme
  (define (setup-environment)
    (let ((initial-env
	   (extend-environment (primitive-procedure-names)
			       (primitive-procedure-objects)
			       the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))

  (define the-global-environment (setup-environment))
#+END_SRC

基本过程如何表达并不重要，但是求值器必须能分辨是否基本过程，这里用符号 'primitive来标识：
#+BEGIN_SRC scheme
  (define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))

  (define (primitive-implementation proc) (cadr proc))
#+END_SRC

定义基本过程：
#+BEGIN_SRC scheme
  (define primitive-procedures
    (list (list 'car car)
	  (list 'cdr cdr)
	  (list 'cons cons)
	  (list 'null? null?)
	  (list '+ +)
	  (list '> >)
	  (list '= =)
	  (list '* *) 
	 ;; <more primitives>
	  ))
  (define (primitive-procedure-names)
    (map car
	 primitive-procedures))

  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
	 primitive-procedures))
#+END_SRC

调用基本过程，使用基础scheme系统提供的apply方法
#+BEGIN_SRC scheme
  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))
#+END_SRC

*** 定义REPL
提示符 -> 输入 -> 读取 -> 求值 -> 打印结果 -> 提示符 
#+BEGIN_SRC scheme
  (define input-prompt ";;; M-Eval input:")
  (define output-prompt ";;; M-Eval value:")

  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output (eval input the-global-environment)))
	(announce-output output-prompt)
	(user-print output)))
    (driver-loop))

  (define (prompt-for-input string)
    (newline) (newline) (display string) (newline))

  (define (announce-output string)
    (newline) (display string) (newline))
#+END_SRC

为了避免打印复合过程的环境：
#+BEGIN_SRC scheme
  define (user-print object)
    (if (compound-procedure? object)
	(display (list 'compound-procedure
		       (procedure-parameters object)
		       (procedure-body object)
		       '<procedure-env>))
	(display object)))
#+END_SRC

启动求值器：
#+BEGIN_SRC scheme
  (define the-global-environment (setup-environment))
  (driver-loop)
#+END_SRC


