#+TITLE: 标准IO
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: standard.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章说明标准I/O库。因为不仅在UNIX而且在很多操作系统上都实现此库，所以它由ANSIC标准说明。标准I/O库处理很多细节，例如缓存分配，以优化长度执行I/O等。标准I/O库是在系统调用函数基础上构造的 

* 标准I/O
  在第3章中所有I/O函数都是针对文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后读的I/O操作
  
  对于标准I/O库，它们的操作则是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时我们已使一个流与一个文件相结合。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针
  
** 流和FILE对象
+ FILE对象: 通常是一个结构，包含了I/O库为管理该流所需要的所有信息，比如用于实际I/O的文件描述符，指向流缓存的指针，缓存的长度，当前在缓存中的字符数，出错标志等等
+ 文件指针：指向FILE对象的指针(类型为FILE*)　
  
为了引用一个流，需将文件指针作为参数传递给每个标准I/O函数

** 标准输入、标准输出和标准出错
   对一个进程预定义了三个流，它们自动地可为进程使用：标准输入、标准输出和标准出错。在3.2节中曾用文件描述符STDIN_FILENO，STDOUT_FILENO和STDERR_FILENO分别表示它们
   
   这三个标准I/O流通过预定义文件指针stdin，stdout和stderr加以引用。这三个文件指针同样定义在头文件<stdio.h>中
   
** 缓存
   标准I/O提供缓存的目的是尽可能减少使用read和write调用的数量。它也对每个I/O流自动地进行缓存管理，简化了应用程序的实现
   
   在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需要的缓存
   
   刷新(flush)：标准I/O缓存的写操作。缓存可由标准I/O例程自动地刷新(例如当填满一个缓存时)，或者可以调用函数fflush刷新一个流 
   
   标准I/O提供了三种类型的缓存: 全缓存，行缓存，无缓存
   
*** 全缓存
    当填满标准I/O缓存后才进行实际I/O操作
    
    对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的
    
*** 行缓存
    当在输入和输出中遇到新行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(用标准I/Ofputc函数)，但只有在写了一行之后才进行实际I/O操作
    
    当流涉及一个终端时(例如标准输入和标准输出)，典型地使用行缓存
    
    对于行缓存有两个限制：
1. 因为标准I/O库用来收集每一行的缓存的长度是固定的，所以只要填满了缓存，那么即使还没有写一个新行符，也进行I/O操作
2. 任何时候只要通过标准输入输出库要求从以下两种情况得到数据就会造成刷新所有行缓存输出流
  + 一个不带缓存的流：从不带缓存的一个流中进行输入要求只能从内核得到数据
  + 一个行缓存的流(它预先要求从内核得到数据)：所需的数据可能已在该缓存中，但并不要求内核在需要该数据时才进行该操作
    
*** 不带缓存
    标准I/O库不对字符进行缓存。如果用标准I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。
    
    标准出错流stderr通常是不带缓存的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符
    
*** 默认实现
    ANSIC要求下列缓存特征:
1. 当且仅当标准输入和标准输出并不涉及交互作用设备时，它们才是全缓存的
2. 标准出错决不会是全缓存的 
   
UNIX系统默认使用下列类型的缓存:
1. 标准出错是不带缓存的 
2. 如若是涉及终端设备的其他流，则它们是行缓存的，否则是全缓存的
   
*** setbuf和setvbuf函数
    setbuf和setvbuf函数：设置文件流的缓存
    #+BEGIN_SRC C
  #include <stdio.h>

  /**
     打开或关闭文件流缓存

     fp：文件指针
     buf：缓存区指针，如果为NULL则关闭缓存，反之则打开缓存

     return：若成功则为 0,若出错则为非0
  ,*/
  int setbuf(FILE* fp, char* buf);

  /**
     设置文件流的缓存

     fp：文件指针
     buf：缓存区指针
     mode：缓存类型，_IOFBF 全缓存，_IOLBF 行缓存, _IONBF 不带缓存
     size：缓存区大小

     return：若成功则为 0,若出错则为非0   
  ,*/
  int setvbuf(FILE* fp, char* buf, int mode, size_t size); 
    #+END_SRC
    
    setbuf和setvbuf参数说明
    
    +----------+----------+----------+-----------------------+----------------+
    |   函数   |   mode   |    buf   |       缓存及长度      | 缓存类型       |
    +----------+----------+----------+-----------------------+----------------+
    |          |          | nonnull  |长度为BUFSIZE的用户缓存| 全缓存或行缓存 |
    |  setbuf  |          +----------+-----------------------+----------------+
    |          |          |   NULL   |       无缓存          | 　　无缓存     |
    +----------+----------+----------+-----------------------+----------------+
    |          |          | nonnull  | 长度为size的用户缓存  |                |
    |          |  _IOFBF  +----------+-----------------------+    全缓存      |
    |          |          |   NULL   | 合适长度的系统缓存    |                |
    |  setvbuf +----------+----------+-----------------------+----------------+
    |          |          | nonnull  | 长度为size的用户缓存  |                |
    |          |  _IOLBF  +----------+-----------------------+    行缓存      |
    |          |          |   NULL   | 合适长度的系统缓存    |                |
    |          +----------+----------+-----------------------+----------------+
    |          |  _IONBF  |   忽略   |        无缓存         |     无缓存     |
    +----------+----------+----------+-----------------------+----------------+
    
*** fflush函数
    fflush：强制刷新一个流
    #+BEGIN_SRC C
  #include <stdio.h>

  /**
     强制刷新一个流，如果fp为NULL则刷新所有输出流

     fp：文件指针

     return：若成功则为0，若出错则为EOF
  ,*/
  int fflush(FILE* fp);
    #+END_SRC
    此函数使该流所有未写的数据都被传递至内核。作为一种特殊情形如若fp是NULL，则刷新所有输出流
    
* 流操作
** 打开流
   以下三个函数用于打开一个I/O流
   #+BEGIN_SRC C
     #include <stdio.h>

     /**
        根据文件路径名打开IO流

        pathname：文件路径名
        type：该I/O流的读、写方式

        return：若成功则为文件指针，若出错则为NULL
     ,*/
     FILE *fopen(const char *pathname, const char *type);
     /**
        在一个特定的流上打开一个指定的文件，如果流已经打开，那先关闭流再打开

        pathname：文件路径名
        type：该I/O流的读、写方式
        fp：特定的流

        return：若成功则为文件指针，若出错则为NULL
     ,*/
     FILE *freopen(const char *pathname, const char *type, FILE *fp);

     /**
        根据文件描述符打开IO流

        filedes：文件描述符
        type：该I/O流的读、写方式

        return：若成功则为文件指针，若出错则为NULL
     ,*/
     FILE *fdopen(int filedes, const char *type);
   #+END_SRC
+ fopen打开指定路径名的一个文件
+ freopen在一个特定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准出错
+ fdopen取一个现存的文件描述符，并使一个标准的I/O流与该描述符相结合。常用于由创建管道和网络通信通道函数获得的插述符。因为这些特殊类型的文件不能用标准I/O的fopen函数打开，首先必须先调用设备专用函数以获得一个文件描述符
*** 流读写方式
    #+CAPTION: 打开标准I/O流的type参数
    #+ATTR_HTML: :border 1 :rules all :frame boader
    | type | 说明 |
    |------+------|
    | r或rb | 为读而打开 |
    | w或wb | 使文件成为0长，或为写而创建 |
    | a或ab | 添加;为在文件尾写而打开，或为写而创建 |
    | r+或r+b或rb+ | 为读和写而打开 |
    | w+或w+b或wb+ | 使文件为0长，或为读和写而打开 |
    | a+或a+b或ab+ | 为在文件尾读和写而打开或创建 |
    
    
+ 字符b作为type的一部分，使得标准I/O可以区分文本文件和二进制文件。但是UNIX并不对这两种文件进行区分，所以无意义
+ 在使用w或a选项时，若文件不存在则自动创建，新建文件的访问模式只能通过进程的umask限制，而无法手动指定权限
+ 当用字符a打开一文件后，则每次写都将数据写到文件的当前尾端处。如若有多个进程用添加方式打开了同一文件，那么每个进程的数据都将正确地写到文件中
+ 当以r+或者w+时，具有下列限制: 
  - 如果中间没有fflush、fseek、fsetpos或rewind，则在输出的后面不能直接跟随输入
  - 如果中间没有fseek、fsetpos或rewind或者一个输出操作没有到达文件尾端，则在输入操作之后不能直接跟随输出
+ 对于fdopen选项w不能截文件为0，而由filedes的open函数决定
  
  
#+CAPTION: 打开标准I/O流的六种方式
#+ATTR_HTML: :border 1 :rules all :frame boader
| 限制           | r | w | a | r+ | w+ | a+ |
|------------------+---+---+---+----+----+----|
| 文件必须已存在 | • |   |   | •  |    |    |
| 文件截断为0 |   | • |   |    | •  |    |
|------------------+---+---+---+----+----+----|
| 流可以读     | • |   |   | •  | •  | •  |
| 流可以写     |   | • | • | •  | •  | •  |
| 流只可以在尾部写 |   |   | • |    |    | •  |
** 关闭流
   fclose：关闭一个打开的流
   #+BEGIN_SRC C
  #include <stdio.h>

  /**
     关闭一个开打的流

     fp：文件指针

     return：若成功则为0，若出错则为EOF
  ,*/
  int fclose(FILE *fp);
   #+END_SRC
   在文件被关闭之前，刷新缓存中的输出数据，缓存中的输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓存，则释放此缓存
   
   当一个进程正常终止时，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭
   
** 读写流
   一旦打开了流，则可在三种不同类型的非格式化I/O中进行选择，对其进行读、写操作：
1. 每次一个字符的I/O：一次读或写一个字符
2. 每次一行的I/O：一次读或写一行。每行都以一个新行符终止
3. 直接I/O或二进制I/O：每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度
   
*** 单字符I/O
    如果流是带缓存的，则标准I/O函数处理所有缓存
**** getc, fgetc, getchar函数
     从文件流读取单个字符
     #+BEGIN_SRC C
       #include <stdio.h>
       /**
          从文件指针读取一个字符，可以实现为宏，效率好于fgetc

          fp：文件指针

          return：若成功则为下一个字符，若已处文件尾端或出错则为EOF
       ,*/
       int getc(FILE *fp);

       /**
          从文件指针读取一个字符，不能实现为宏，效率比getc差

          fp：文件指针

          return：若成功则为下一个字符，若已处文件尾端或出错则为EOF
       ,*/
       int fgetc(FILE *fp);

       /**
          从标准输入读入一个字符，等价于getc(stdin)

          return：若成功则为下一个字符，若已处文件尾端或出错则为EOF
       ,*/
       int getchar(void);
     #+END_SRC
+ getc可以实现为宏，所以它的参数不应当是具有副作用的表达式 
+ 调用fgetc所需时间很可能长于调用getc，因为调用函数通常所需的时间长于调用宏
+ 因为fgetc一定是个函数，可以得到其地址。允许将fgetc的地址作为一个参数传送给另一个函数
+ getchar()等价于getc(stdin)
  
这三个函数以unsigned char类型转换为int的方式返回下一个字符。这样就可以返回所有可能的字符值再加上一个已发生错误或已到达文件尾端的指示值。在<stdio.h>中的常数EOF被要求是一个负值，其值经常是-1。所以不能返回结果是一个无符号字符，而必须是一个带符号整数
**** EOF判断
     不管是出错还是到达文件尾端，这三个函数都返回同样的值EOF。为了区分这两种不同的情况，必须调用ferror或feof函数：
     
+ ferror函数：判断读取文件是否出错
+ feop函数：判断读取文件是否结束
  
#+BEGIN_SRC C
  #include <stdio.h>

  /**
     读取文件是否出错

     fp：文件指针

     return：若读取出错则为非0(真)，否则为0(假)
  ,*/
  int ferror(FILE *fp);

  /**
     文件是否结束

     fp：文件指针

     return：若文件结束则为非0(真)，否则为0(假)
  ,*/
  int feof(FILE *fp);
#+END_SRC

**** 清除EOF标记
     在大多数实现的FILE对象中，为每个流保持了两个标志:
+ 出错标志
+ 文件结束标志
  
clearerr函数：清除这两个标志
#+BEGIN_SRC C
  #include <stdio.h>

  /**
     清楚文件出错和结尾两个标志

     fp：文件指针

     无返回
  ,*/
  void clearerr(FILE *fp);
#+END_SRC

**** putc, fputc, putchar函数
     输出单个字符到文件流     
     #+BEGIN_SRC C
       #include <stdio.h>

       /**
          输出一个字符到流，可实现为宏

          c：输出字符
          fp：文件指针

          return：若成功则为c，若出错则为EOF
       ,*/
       int putc(int c, FILE *fp);

       /**
          输出一个字符到流，只可实现为函数

          c：输出字符
          fp：文件指针

          return：若成功则为c，若出错则为EOF
       ,*/
       int fputc(int c, FILE *fp);

       /**
          输出一个字符到标准输出流，等价于putc(c, stdout)

          c：输出字符

          return：若成功则为c，若出错则为EOF
       ,*/
       int putchar(int c);
     #+END_SRC
     
+ putc可以实现为宏
+ fputc只能实现为函数
+ putchar(c)等价于putc(c, stdout)
  
**** ungetc函数
ungetc函数：将字符压入流中
#+BEGIN_SRC C
  #include <stdio.h>

  /**
     将字符压入流中

     c：压入的字符
     fp：文件指针

     return：若成功则为c，若出错则为EOF
  ,*/
  int ungetc(int c, FILE *fp);
#+END_SRC
下次读取字符读到的就是被ungetc压入的字符。回送的字符不一定必须是上一次读到的字符。EOF不能回送。但是当已经到达文件尾端时仍可以回送一个字符。下次读将返回该字符，再次读则返回EOF。之所以能这样做的原因是一次成功的ungetc调用会清除该流的文件结束指示

例如：读到第一个特殊字符时候，这个字符往往暂时没有用，需要先放回去，等处理完前面读出的数据后，再开始重新读

*** 行I/O
    
**** fgets, gets函数
     从文件流读取一行到缓存区
     #+BEGIN_SRC C
       #include <stdio.h>

       /**
          从一个流读取一行到最多n-1个字符到缓存区buf，缓存区以null字符结束

          buf：缓存区
          n：读取字符长度
          fp：文件指针

          return：若成功则为buf，若已处文件尾端或出错则为NULL
       ,*/
       char *fgets(char *buf, int n, FILE *fp);

       /**
          从标准输入读取一行到到缓存区buf

          buf：缓存区

          return：若成功则为buf，若已处文件尾端或出错则为NULL
       ,*/
       char *gets(char *buf);
     #+END_SRC
     
+ fgets函数：必须指定缓存的长度n。一直读到下一个新行符为止，但是不超过n-1个字符，读入的字符被送入缓存。该缓存以null字符结尾。如若该行包括最后一个新行符的字符数超过n-1，则只返回一个不完整的行，而且缓存总是以null字符结尾。对fgets的下一次调用会继续读该行
+ gets直接从标准输入流读取，会有验证缓存区溢出的问题，缓存区也不会以null字符结尾
  
**** fputs, puts函数
     缓存区输出一行到文件流
     #+BEGIN_SRC C
  #include <stdio.h>

  /**
     输出一个以null结尾的字符串到文件流，终止符null不输出，新行符\n需要包含在字符串内

     str：输出的字符串
     fp：文件指针

     return：若成功则为输出的字符数，若出错则为EOF
  ,*/
  int fputs(const char *str, FILE *fp);

  /**
     输出一个null结尾的字符串到标准输出流，终止符null不输出，自动在最后添加新行符\n

     str：输出的字符串

     return：若成功则为输出的字符数，若出错则为EOF
  ,*/
  int puts(const char *str);
     #+END_SRC
     
+ fputs函数：将一个以null符终止的字符串写到指定的流，终止符null不写出。必须手动在字符串包含新行符\n
+ puts函数：将一个以null符终止的字符串写到标准输出，终止符null不写出。自动在最后将一个新行符\n写到标准输出
+ puts函数不像gets函数那么不安全，但也最好尽量避免使用
  
*** 标准I/O效率比较
