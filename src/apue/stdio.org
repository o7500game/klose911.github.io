#+TITLE: 标准IO
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: standard.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章说明标准I/O库。因为不仅在UNIX而且在很多操作系统上都实现此库，所以它由ANSIC标准说明。标准I/O库处理很多细节，例如缓存分配，以优化长度执行I/O等。标准I/O库是在系统调用函数基础上构造的 

* 标准I/O
在第3章中所有I/O函数都是针对文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后读的I/O操作

对于标准I/O库，它们的操作则是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时我们已使一个流与一个文件相结合。当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针

** 流和FILE对象
+ FILE对象: 通常是一个结构，包含了I/O库为管理该流所需要的所有信息，比如用于实际I/O的文件描述符，指向流缓存的指针，缓存的长度，当前在缓存中的字符数，出错标志等等
+ 文件指针：指向FILE对象的指针(类型为FILE*)　

为了引用一个流，需将文件指针作为参数传递给每个标准I/O函数

** 标准输入、标准输出和标准出错
对一个进程预定义了三个流，它们自动地可为进程使用：标准输入、标准输出和标准出错。在3.2节中曾用文件描述符STDIN_FILENO，STDOUT_FILENO和STDERR_FILENO分别表示它们

这三个标准I/O流通过预定义文件指针stdin，stdout和stderr加以引用。这三个文件指针同样定义在头文件<stdio.h>中

** 缓存
标准I/O提供缓存的目的是尽可能减少使用read和write调用的数量。它也对每个I/O流自动地进行缓存管理，简化了应用程序的实现

在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需要的缓存

刷新(flush)：标准I/O缓存的写操作。缓存可由标准I/O例程自动地刷新(例如当填满一个缓存时)，或者可以调用函数fflush刷新一个流 

标准I/O提供了三种类型的缓存: 全缓存，行缓存，无缓存

*** 全缓存
当填满标准I/O缓存后才进行实际I/O操作

对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的

*** 行缓存
当在输入和输出中遇到新行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(用标准I/Ofputc函数)，但只有在写了一行之后才进行实际I/O操作

当流涉及一个终端时(例如标准输入和标准输出)，典型地使用行缓存

对于行缓存有两个限制：
1. 因为标准I/O库用来收集每一行的缓存的长度是固定的，所以只要填满了缓存，那么即使还没有写一个新行符，也进行I/O操作
2. 任何时候只要通过标准输入输出库要求从以下两种情况得到数据就会造成刷新所有行缓存输出流
  + 一个不带缓存的流：从不带缓存的一个流中进行输入要求只能从内核得到数据
  + 一个行缓存的流(它预先要求从内核得到数据)：所需的数据可能已在该缓存中，但并不要求内核在需要该数据时才进行该操作

*** 不带缓存
标准I/O库不对字符进行缓存。如果用标准I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。

标准出错流stderr通常是不带缓存的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符

*** 默认实现
ANSIC要求下列缓存特征:
1. 当且仅当标准输入和标准输出并不涉及交互作用设备时，它们才是全缓存的
2. 标准出错决不会是全缓存的 

UNIX系统默认使用下列类型的缓存:
1. 标准出错是不带缓存的 
2. 如若是涉及终端设备的其他流，则它们是行缓存的，否则是全缓存的

*** setbuf和setvbuf函数
setbuf和setvbuf函数：设置文件流的缓存
#+BEGIN_SRC C
  #include <stdio.h>

  /**
     打开或关闭文件流缓存

     fp：文件指针
     buf：缓存区指针，如果为NULL则关闭缓存，反之则打开缓存

     return：若成功则为 0,若出错则为非0
  ,*/
  int setbuf(FILE* fp, char* buf);

  /**
     设置文件流的缓存

     fp：文件指针
     buf：缓存区指针
     mode：缓存类型，_IOFBF 全缓存，_IOLBF 行缓存, _IONBF 不带缓存
     size：缓存区大小

     return：若成功则为 0,若出错则为非0   
  ,*/
  int setvbuf(FILE* fp, char* buf, int mode, size_t size); 
#+END_SRC

  setbuf和setvbuf参数说明

  +----------+----------+----------+-----------------------+----------------+
  |   函数   |   mode   |    buf   |       缓存及长度      | 缓存类型       |
  +----------+----------+----------+-----------------------+----------------+
  |          |          | nonnull  |长度为BUFSIZE的用户缓存| 全缓存或行缓存 |
  |  setbuf  |          +----------+-----------------------+----------------+
  |          |          |   NULL   |       无缓存          | 　　无缓存     |
  +----------+----------+----------+-----------------------+----------------+
  |          |          | nonnull  | 长度为size的用户缓存  |                |
  |          |  _IOFBF  +----------+-----------------------+    全缓存      |
  |          |          |   NULL   | 合适长度的系统缓存    |                |
  |  setvbuf +----------+----------+-----------------------+----------------+
  |          |          | nonnull  | 长度为size的用户缓存  |                |
  |          |  _IOLBF  +----------+-----------------------+    行缓存      |
  |          |          |   NULL   | 合适长度的系统缓存    |                |
  |          +----------+----------+-----------------------+----------------+
  |          |  _IONBF  |   忽略   |        无缓存         |     无缓存     |
  +----------+----------+----------+-----------------------+----------------+

*** fflush函数
fflush：强制刷新一个流
#+BEGIN_SRC C
  #include <stdio.h>

  /**
     强制刷新一个流，如果fp为NULL则刷新所有输出流

     fp：文件指针

     return：若成功则为0，若出错则为EOF
  ,*/
  int fflush(FILE* fp);
#+END_SRC
此函数使该流所有未写的数据都被传递至内核。作为一种特殊情形如若fp是NULL，则刷新所有输出流

* 流操作

** 打开流
