#+TITLE: 进程控制
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: env.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章介绍UNIX的进程控制：
+ 创建新进程、执行程序和进程终止
+ 进程的实际、有效和保存的用户和组ID
+ 解释器文件和system函数
+ 进程会计机制结束

* 进程标识
每个进程都有一个非负整型的唯一进程ID。因为进程ID标识符总是唯一的，常将其用做其他标识符的一部分以保证其唯一性：
1. ID 0进程：调度进程，它是内核进程，用来执行进程管理，也被称为交换进程
2. ID 1进程：通常是init进程，在自举过程结束时由内核调用/sbin/init，通常读与系统有关的初始化文件(/etc/rc*文件)，并将系统引导到一个状态(例如多用户)。init进程决不会终止，它是一个普通的用户进程(不是内核中的系统进程)，但是它以超级用户特权运行


除了进程ID每个进程还有一些其他标识符，下列函数返回这些标识符：
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     获得调用进程的进程ID　

     返回：调用进程的进程ID
  ,*/
  pid_t getpid(void);
  /**
     获得调用进程的父进程ID

     return：调用进程的父进程ID 
  ,*/
  pid_t getppid(void);

  /**
     获得调用进程的实际用户ID

     return：调用进程的实际用户ID
  ,*/
  uid_t getuid(void);

  /**
     获得调用进程的有效用户ID

     return：调用进程的有效用户ID
  ,*/
  uid_t geteuid(void);

  /**
     获得调用进程的实际组ID

     return：调用进程的实际组ID
  ,*/
  gid_t getgid(void);

  /**
     获得调用进程的有效组ID

     return：调用进程的有效组ID
  ,*/
  gid_t getegid(void); 
#+END_SRC
注意：这些函数都没有出错返回！

* 进程生命周期

** 创建进程

** 创建新进程
fork：创建新进程的唯一方法 (除了上面提到的那些特殊进程，它们是内核启动时候以特殊方式创建的)
#+BEGIN_SRC C
  #include <unistd.h>
  #include <unistd.h>

  /**
     创建新进程

     return：子进程返回0，父进程返回子进程的ID，出错返回-1
  ,*/
  pid_t fork(void);
#+END_SRC
由fork创建的新进程被称为子进程。因为子进程和父进程都会继续执行fork之后的指令，所以该函数虽然被调用一次，但却会返回两次结果。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新子进程的进程ID：
+ 将子进程ID返回给父进程的理由是：一个进程的子进程可以多于一个，没有一个函数可以使一个进程获得其所有子进程的进程ID。如果接下来父进程要使用子进程ID，那么只能在fork后记录返回的子进程ID
+ fork使子进程得到返回值0的理由是：
  1. 进程ID为0总是由调度/交换进程使用，一个子进程的进程ID不可能为0，所以可以通过fork的返回结果来判断是不是子进程
  2. 另外一个进程只会有一个父进程，子进程可以调用getppid以获得其父进程的进程ID，所以没有必要去返回父进程的ID

*** 子进程的进程环境
子进程是父进程的复制品：如果正文段是只读的，则父、子进程共享正文段。除此之外子进程获得父进程的初始化数据段、非初始化数据段、堆和栈的复制品。注意这是子进程所拥有的独立拷贝，父、子进程并不共享这些存储空间部分！

**** 写时复制
现在很多的实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着exec执行另外一个程序。而作为替代使用了在写时复制(Copy-On-Write)的技术。例如在图1里面fork函数刚刚创建子进程的时候，父、子进程的数据指向同一块物理内存，但是内核将这些内存的访问变为只读的了。当父、子进程中的任何一个想要修改数据的时候，内核会为修改区域的那块内存制作一个副本，并将自己的虚拟地址映射到物理地址的指向修改为副本的地址，从此父子进程互不干扰，效率也提高了许多。新分配的副本大小通常是虚拟存储系统中的一个“页”
  #+ATTR_HTML: image :width 90% 
  [[file:pic/child-process.png]]

*** fork实例
fork一个进程，修改相关变量并打印
    #+BEGIN_SRC C
      #include <sys/types.h>
      #include "apue.h"

      int glob = 6;
      char buf[] = "a write to stdin\n";

      int main(void)
      {
              int var;
              pid_t pid;

              var = 88;
              if(write(STDOUT_FILENO, buf, sizeof(buf) - 1) != (sizeof(buf) - 1))
                      err_sys("write error");
              printf("before fork\n"); // we don't flush stdout

              if( (pid = fork() ) < 0)
                      err_sys("fork error");
              
              else if(0 == pid) { //child process
                      // modify variable
                      glob++; 
                      var++; 
              } else { // parent process
                      sleep(2);
              }

              //child & parent share code
              printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
              exit(0);
      }
    #+END_SRC
一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。如果要求父、子进程之间相互同步，则要求某种形式的进程间通信。在这个程序中父进程使自己睡眠2秒钟，以此使子进程先执行，但2秒钟并不一定保证已经足够
#+BEGIN_SRC sh
  $ ./src/process/forkExample

  a write to stdin
  #终端是行缓存的，所以printf("before fork")直接输出
  before fork
  pid = 8898, glob = 7, var = 89 # 子进程打印改变后的变量值
  pid = 8897, glob = 6, var = 88 # 父进程打印未改变的变量值

  $ ./src/process/forkExample > temp.out

  $ cat temp.out 
  a write to stdin
  #文件是全缓存的，所以fork之前的printf把"before fork\n"放入了缓存，但并没有输出
  #fork把父进程的标准IO缓存复制了，因此在最后的prinf("pid= %d ...)也输出了before fork\n
  before fork 
  pid = 8962, glob = 7, var = 89 #子进程
  before fork
  pid = 8961, glob = 6, var = 88 #父进程
#+END_SRC
fork与I/O函数之间的关系：
+ 文件IO是不带缓存的：所以"a write to stdin"只被write函数写到标准输出一次
+ 标准I/O库是带缓存的：如果标准输出连到终端设备，则它是行缓存的，否则它是全缓存的
  1. 当以交互方式运行该程序时：因为标准输出缓存由新行符刷新，所以"before fork"只被printf输出一次
  2. 当将标准输出重新定向到一个文件时：在fork之前调用了printf("before fork")一次，但当调用fork时该行数据仍在缓存内，然后在父进程数据空间复制到子进程中时该缓存数据也被复制到子进程中。于是那时父、子进程各自有了"before fork"的缓存。所以当每个进程终止时，其缓存中的所有内容被写到相应文件中
  
因此在fork进程前请务必考虑flush所有的缓存！
*** 父、子进程的资源共享
所有由父进程打开的描述符都被复制到子进程中。父、子进程每个相同的打开描述符共享一个文件表项。所以在上面程序中重定向了父进程的标准输出时，子进程的标准输出也被同样重定向

再比如一个进程打开了三个不同文件，它们是标准输入、标准输出和标准出错。在从fork返回时，我们有了如图8-1中所示的安排
  #+ATTR_HTML: image :width 90% 
  [[file:pic/child-fd.png]]
这种共享文件的方式使父、子进程对同一文件使用了一个文件位移量。如果父、子进程写到同一描述符文件，但又没有任何形式的同步(例如使父进程等待子进程)，那么它们的输出就会相互混合，但是这种情况并不常见。在fork之后处理文件描述符有两种常见的情况：
1. 父进程等待子进程完成。父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件位移量已做了相应更新
2. 父、子进程各自执行不同的程序段。在fork之后父、子进程各自关闭它们不需使用的文件描述符，并且不干扰对方使用的文件描述符。这种方法是网络服务进程中经常使用

除了打开文件之外，很多父进程的其他性质也由子进程继承:
+ 实际用户ID、实际组ID、有效用户ID、有效组ID
+ 添加组ID
+ 进程组ID
+ 对话期ID
+ 控制终端
+ 设置-用户-ID标志和设置-组-ID标志
+ 当前工作目录
+ 根目录
+ 文件方式创建屏蔽字
+ 信号屏蔽和排列
+ 对任一打开文件描述符的在执行时关闭标志
+ 环境
+ 连接的共享存储段
+ 资源限制
*** 父、子进程的区别
+ fork的返回值
+ 进程ID
+ 不同的父进程ID
+ 子进程的tms_utime，tms_stime，tms_cutime以及tms_ustime设置为0
+ 父进程设置的锁，子进程不继承
+ 子进程的未决告警被清除
+ 子进程的未决信号集设置为空集
*** fork的常见用法
1. 一个父进程希望复制自己，使父、子进程同时执行不同的代码段。这在网络服务进程中是常见的：父进程等待委托者的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求
2. 一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程在从fork返回后立即调用exec

某些操作系统将第二种用法中的两个操作(fork之后执行exec)组合成一个，并称其为spawn。UNIX将这两个操作分开，因为在很多场合需要单独使用fork，其后并不跟随exec
*** vfork
vfork：用于创建一个新进程，而该新进程的目的是为了exec一个新程序
    #+BEGIN_SRC C
      #include <sys/types.h>
      #include <unistd.h>

      /**
         创建新进程，而该新进程是目的是为了exec一个新程序

         return：子进程返回0，父进程返回子进程的ID，出错返回-1
      ,*/
      pid_t vfork(void);
    #+END_SRC
vfork与fork的不同：
1. vfork并不将父进程的地址空间复制到子进程中，在子进程exec之前完全使用父进程的地址空间，这意味着子进程如果修改了某个变量，这个修改对父进程也是可见的！
2. vfork保证了子进程在父进程之前执行，父进程会阻塞运行直到子进程执行了exec或者exit函数。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁，特别是子进程并不继承父进程的记录锁，这时使用父进程打开的文件时可能会被阻塞！
**** vfork实例
改写fork实例
     #+BEGIN_SRC C
       #include "apue.h"

       // external variable in initialized data
       int glob = 6;

       int main(void)
       {
               // automatic variable on the stack
               int var;
               pid_t pid;

               var = 88;
               printf("before fork\n");

               if((pid = vfork()) < 0) {
                       err_sys("fork error");
               } else if(pid == 0) { //child 
                       glob++; // change variable 
                       var++; 
                       _exit(0); //child terminated
                       //exit(0) 
               }

               //parent
               printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
               exit(0);
       }
     #+END_SRC

子进程对变量glob和var做加1操作，结果改变了父进程中的变量值。因为子进程在父进程的地址空间中运行
#+BEGIN_SRC sh
  $ gcc -I/home/klose/Documents/programming/c/apue/include -c -o vforkExample.o src/process/vforkExample.c #编译c文件，注意不能有优化参数！
  $ gcc -o vforkExample vforkExample.o src/lib/libapue.a # 链接静态库文件，产生可执行文件

  $ ./vforkExample 
  before fork
  pid = 19302, glob = 7, var = 89

  $ gcc -O2 -I/home/klose/Documents/programming/c/apue/include -c -o vforkExample1.o src/process/vforkExample.c 
  $ gcc -O2 -o vforkExample1 vforkExample1.o src/lib/libapue.a

  $ ./vforkExample1 #由于优化，var被放在寄存器内，所以丢失了子线程的修改
  before fork
  pid = 19471, glob = 7, var = 88
#+END_SRC
注意：子进程对变量的改动只对保存在内存中的变量有效，而对寄存器中的变量有可能会回滚。如果编译使用了优化参数，结果可能并不同，为了保证效果可以使用volatile

因为写时复制技术的普及，实际上vfork已经是个过时的函数，尽量避免使用vfork
** 终止进程
