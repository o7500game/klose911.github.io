#+TITLE: 进程环境
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: system_file.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章主要说明：
+ 当执行程序时其main函数是如何被调用的
+ 进程终止的不同方式
+ 命令行参数是如何传送给执行程序的
+ 典型的存储器布局是什么样式
+ 如何分配另外的存储空间进程
+ 如何使用环境变量
+ longjmp和setjmp函数以及它们与栈的交互作用
+ 进程的资源限制
  
* main函数
  C程序总是从main函数开始执行，其中argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组
  #+BEGIN_SRC C
  /**
     主函数
     
     argc：命令行参数的数目
     argv：指针数组，其元素是指向各个命令行参数的字符串指针

     return：返回值
  ,*/
  int main(int argc, char *argv[]);
  #+END_SRC
  
  当内核使用一个exec函数起动C程序时，在调用main函数前先调用一个特殊的起动例程：从内核取得命令行参数和环境变量值，然后为调用main函数作好准备
  
  C语言编译的时候会调用链接器(ld)，而链接器会设置这个特殊的启动例程为可执行文件的起始地址
  
* 进程终止
图7-1显示了一个C程序是如何起动的，以及它终止的各种方式
#+ATTR_HTML: image :width 90% 
[[file:pic/process-lifecycle.png]]

有五种方式使进程终止:
+ 正常终止:
  - 从main返回
  - 调用exit
  - 调用_exit
+ 异常终止:
  - 调用abort
  - 由一个信号终止
    
上节提及的起动例程使得从main函数返回后立即调用exit函数：

如果将起动例程以C代码形式表示(实际上该例程常常用汇编语言编写)
#+BEGIN_SRC C
exit(main(argc，argv)); 
#+END_SRC

** exit和_exit
exit和_exit函数用于正常终止一个程序：
+ _exit：立刻进入内核
+ exit：先执行一些清除处理(包括调用执行各终止处理程序，关闭所有标准I/O流等)，然后进入内核
#+BEGIN_SRC C
  #include <stdlib.h>

  /**

     先执行一些清除处理，然后进入内核终止程序

     status：程序终止返回状态
  ,*/
  void exit(int status);

  #include <unistd.h>

  /**
     立刻进入内核终止程序

     status：程序返回状态
  ,*/
  void _exit(int status);
#+END_SRC
exit函数总是执行一个标准I/O库的清除关闭操作：对于所有打开流调用fclose函数，这使得缓存中的所有数据都被刷新(写到文件上)

*** 终止状态
exit和_exit都带一个整型参数，称之为终止状态。如果出现下述状况，则该进程的终止状态是末定义的：
1. 调用这些函数时不带终止状态
2. main执行了一个无返回值的return语句
3. main执行隐式返回

下列经典性的C语言程序是不完整的，其返回状态未定义
#+BEGIN_SRC C
  #include <stdio.h>

  main ()
  {
          printf ("hello, world \n");
  }
#+END_SRC

大多数UNIX shell都提供检查一个进程终止状态的方法：
#+BEGIN_SRC sh
  $ ./src/environ/hello 
  hello, world 

  # 返回状态未定义
  $ echo $?
  14
#+END_SRC

向执行此程序的进程返回终止状态0 
#+BEGIN_SRC C
  return 0;
  或者
  exit(0);
#+END_SRC

** atexit
终止处理程按序：照ANSIC的规定一个进程可以登记多至32个函数，这些函数将在调用后exit被自动调用

atexit：登记注册终止处理程序
#+BEGIN_SRC C
  #include <stdlib.h>

  /**
     注册程序终止函数

     return：若成功则为 0,若出错则为非0
   ,*/
  int atexit(void (*func)(void));
#+END_SRC
其中atexit的参数是一个函数地址，当调用此函数时无需向它传送任何参数，也不期望它返回一个值

*** 示例
以下示例说明了如何使用atexit函数。注意：main函数使用了return来隐式调用exit函数
    #+BEGIN_SRC C
      #include "apue.h"

      static void my_exit1(void);
      static void my_exit2(void);

      int main(void)
      {
              if (atexit(my_exit2) != 0)
                      err_sys("can't register my_exit2");

              if (atexit(my_exit1) != 0)
                      err_sys("can't register my_exit1");
              if (atexit(my_exit1) != 0)
                      err_sys("can't register my_exit1");

              printf("main is done\n");
              return(0);
      }

      static void my_exit1(void)
      {
              printf("first exit handler\n");
      }

      static void my_exit2(void)
      {
              printf("second exit handler\n");
      }

    #+END_SRC

exit以登记相反的顺序调用终止函数，同一函数如果被登记多次，则也会被调用多次！
#+BEGIN_SRC sh
  $ ./src/environ/doatexit 

  main is done
  first exit handler
  first exit handler
  second exit handler
#+END_SRC

** 程序启动和终止总结
+ 内核使程序执行：调用exec函数
+ 进程自愿终止：显式或隐式地调用exit或_exit函数
  - exit函数：首先调用各终止处理程序，然后按需多次调用fclose关闭所有打开流
+ 非自愿终止：通过信号量

* 命令行参数
调用exec函数可将命令行参数传递给被执行的新程序

** 打印所有命令行参数
ANSIC和POSIX.1都要求argv[argc]是一个空指针，所以循环可以通过空指针判断来中断，等价于i < argc 
#+BEGIN_SRC C
  #include <stdio.h>

  int main(int argc, char *argv[])
  {
          int i;
          //echo all command line args
          for(i = 0; argv[i] != NULL; i++)
                  printf("argv[%d]: %s\n", i, argv[i]);

          return 0;
          
  }
#+END_SRC

argv的第一个字符串：被执行的程序路径名
#+BEGIN_SRC sh
  $ ./src/environ/arg arg1 TEST foo

  argv[0]: ./src/environ/arg
  argv[1]: arg1
  argv[2]: TEST
  argv[3]: foo
#+END_SRC

* 环境变量表
每个程序都接收到一张环境表。与参数表类似，环境表也是一个字符指针数组，其中每个指针包含一个字符串的地址。全局变量environ则包含了该指针数组的地址
#+BEGIN_SRC C
  extern char **environ;
#+END_SRC
如果该环境包含五个字符串，那么它看起来可能如图7-2中所示：
#+ATTR_HTML: image :width 90% 
[[file:pic/env.png]]

+ 环境指针：environ
+ 环境表：environ指向的指针数组，以NULL结尾
+ 环境变量：各指针指向的字符串，以'\0'结尾

按照惯例环境由:
   #+BEGIN_EXAMPLE
     name=value
     #+END_EXAMPLE
这样的字符串组成，这与图7-2中所示相同。大多数环境变量名完全由大写字母组成，但这也只是一个惯例
