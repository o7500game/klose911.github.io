#+TITLE: 进程环境
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: system_file.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章主要说明：
+ 当执行程序时其main函数是如何被调用的
+ 进程终止的不同方式
+ 命令行参数是如何传送给执行程序的
+ 典型的存储器布局是什么样式
+ 如何分配另外的存储空间进程
+ 如何使用环境变量
+ longjmp和setjmp函数以及它们与栈的交互作用
+ 进程的资源限制
  
* main函数
  C程序总是从main函数开始执行，其中argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组
  #+BEGIN_SRC C
  /**
     主函数
     
     argc：命令行参数的数目
     argv：指针数组，其元素是指向各个命令行参数的字符串指针

     return：返回值
  ,*/
  int main(int argc, char *argv[]);
  #+END_SRC
  
  当内核使用一个exec函数起动C程序时，在调用main函数前先调用一个特殊的起动例程：从内核取得命令行参数和环境变量值，然后为调用main函数作好准备
  
  C语言编译的时候会调用链接器(ld)，而链接器会设置这个特殊的启动例程为可执行文件的起始地址
  
* 进程终止
  图7-1显示了一个C程序是如何起动的，以及它终止的各种方式
  #+ATTR_HTML: image :width 90% 
  [[file:pic/process-lifecycle.png]]
  
  有五种方式使进程终止:
+ 正常终止:
  - 从main返回
  - 调用exit
  - 调用_exit
+ 异常终止:
  - 调用abort
  - 由一个信号终止
    
上节提及的起动例程使得从main函数返回后立即调用exit函数：

如果将起动例程以C代码形式表示(实际上该例程常常用汇编语言编写)
#+BEGIN_SRC C
exit(main(argc，argv)); 
#+END_SRC

** exit和_exit
   exit和_exit函数用于正常终止一个程序：
+ _exit：立刻进入内核
+ exit：先执行一些清除处理(包括调用执行各终止处理程序，关闭所有标准I/O流等)，然后进入内核
#+BEGIN_SRC C
  #include <stdlib.h>

  /**

     先执行一些清除处理，然后进入内核终止程序

     status：程序终止返回状态
  ,*/
  void exit(int status);

  #include <unistd.h>

  /**
     立刻进入内核终止程序

     status：程序返回状态
  ,*/
  void _exit(int status);
#+END_SRC
exit函数总是执行一个标准I/O库的清除关闭操作：对于所有打开流调用fclose函数，这使得缓存中的所有数据都被刷新(写到文件上)

*** 终止状态
    exit和_exit都带一个整型参数，称之为终止状态。如果出现下述状况，则该进程的终止状态是末定义的：
1. 调用这些函数时不带终止状态
2. main执行了一个无返回值的return语句
3. main执行隐式返回
   
下列经典性的C语言程序是不完整的，其返回状态未定义
#+BEGIN_SRC C
  #include <stdio.h>

  main ()
  {
          printf ("hello, world \n");
  }
#+END_SRC

大多数UNIX shell都提供检查一个进程终止状态的方法：
#+BEGIN_SRC sh
  $ ./src/environ/hello 
  hello, world 

  # 返回状态未定义
  $ echo $?
  14
#+END_SRC

向执行此程序的进程返回终止状态0 
#+BEGIN_SRC C
  return 0;
  或者
  exit(0);
#+END_SRC

** atexit
   终止处理程按序：照ANSIC的规定一个进程可以登记多至32个函数，这些函数将在调用后exit被自动调用
   
   atexit：登记注册终止处理程序
   #+BEGIN_SRC C
  #include <stdlib.h>

  /**
     注册程序终止函数

     return：若成功则为 0,若出错则为非0
   ,*/
  int atexit(void (*func)(void));
   #+END_SRC
   其中atexit的参数是一个函数地址，当调用此函数时无需向它传送任何参数，也不期望它返回一个值
   
*** 示例
    以下示例说明了如何使用atexit函数。注意：main函数使用了return来隐式调用exit函数
    #+BEGIN_SRC C
      #include "apue.h"

      static void my_exit1(void);
      static void my_exit2(void);

      int main(void)
      {
              if (atexit(my_exit2) != 0)
                      err_sys("can't register my_exit2");

              if (atexit(my_exit1) != 0)
                      err_sys("can't register my_exit1");
              if (atexit(my_exit1) != 0)
                      err_sys("can't register my_exit1");

              printf("main is done\n");
              return(0);
      }

      static void my_exit1(void)
      {
              printf("first exit handler\n");
      }

      static void my_exit2(void)
      {
              printf("second exit handler\n");
      }

    #+END_SRC
    
    exit以登记相反的顺序调用终止函数，同一函数如果被登记多次，则也会被调用多次！
    #+BEGIN_SRC sh
  $ ./src/environ/doatexit 

  main is done
  first exit handler
  first exit handler
  second exit handler
    #+END_SRC
    
** 小结
+ 内核使程序执行：调用exec函数
+ 进程自愿终止：显式或隐式地调用exit或_exit函数
  - exit函数：首先调用各终止处理程序，然后按需多次调用fclose关闭所有打开流
+ 进程非自愿终止：通过信号量
  
* 命令行参数
  调用exec函数可将命令行参数传递给被执行的新程序
  
** 打印所有命令行参数
   ANSIC和POSIX.1都要求argv[argc]是一个空指针，所以循环可以通过空指针判断来中断，等价于i < argc 
   #+BEGIN_SRC C
  #include <stdio.h>

  int main(int argc, char *argv[])
  {
          int i;
          //echo all command line args
          for(i = 0; argv[i] != NULL; i++)
                  printf("argv[%d]: %s\n", i, argv[i]);

          return 0;
          
  }
   #+END_SRC
   
   argv的第一个字符串：被执行的程序路径名
   #+BEGIN_SRC sh
  $ ./src/environ/arg arg1 TEST foo

  argv[0]: ./src/environ/arg
  argv[1]: arg1
  argv[2]: TEST
  argv[3]: foo
   #+END_SRC
   
* C程序内存模型
  
** 存储器布局    
   C程序一直由下列几部分组成：
*** 正文段
    CPU执行的机器指令部分，也被称为代码段
    
    通常正文段是可共享的，所以即使是经常执行的程序(如文本编辑程序、C编译程序、shell等)在存储器中也只需有一个副本，另外正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令
*** 初始化数据段
    此段也被称为数据段，它包含了程序中需赋初值的变量
    
    任何函数之外声明会把变量的初值存放在初始化数据段中：
    #+BEGIN_SRC C
  int　maxcount=99;
    #+END_SRC
*** 非初始化数据段
    通常将此段称为bss段，在程序开始执行之前，内核将此段初始化为0
    
    例如：在函数外声明位初始化的数组
    #+BEGIN_SRC C
  long sum[1000];
    #+END_SRC
*** 栈
    自动变量以及每次函数调用时所需保存的信息都存放在此段中
    
    每次函数调用时其返回地址、以及调用者的环境信息(例如某些机器寄存器)都存放在栈中，然后新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈C函数可以递归调用
    
*** 堆
    在堆中进行动态存储分配
    
    由于历史上形成的惯例，堆位于非初始化数据段顶和栈底之间
    
*** 存储器总结
    图7-3显示了C程序在内存中的一种典型安排方式：
    #+ATTR_HTML: image :width 90% 
    [[file:pic/memory.png]]
    
    对于VAX上的4.3+BSD而言
+ 正文段从0位置开始，栈顶则在0x7fffffff之下开始，堆顶和栈底之间未用的虚地址空间很大
+ 栈一般是从高地址往低地址增长
+ 堆一般是从低地址往高地址增长
+ 末初始化数据段的内容并不存放在磁盘程序文件中，需要存放在磁盘程序文件中的段只有正文段和初始化数据段
  
#+BEGIN_SRC sh
  #size(1)命令报告正文段、数据段和bss段的长度(单位:字节)：
  $ size /usr/bin/cc /bin/sh
     text    data     bss     dec     hex filename
     7537     800       0    8337    2091 /usr/bin/cc
   712531   37360   18656  768547   bba23 /bin/sh
#+END_SRC

** 共享库
   现在很多UNIX系统支持共享库。共享库使得可执行文件中不再需要包含常用的库函数，而只需在所有进程都可存取的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态连接方法将程序与共享库函数相连接。这减少了每个可执行
   文件的长度，但增加了一些运行时间开销。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑(假定参数的数目和类型都没有发生改变)
   
** 动态内存管理
   
*** 分配内存
    ANSI C说明了三个用于存储空间动态分配的函数： 
1. malloc：分配指定字节数的存储区，此存储区中的初始值不确定
2. calloc：为指定长度的对象分配能容纳其指定个数的存储空间，该空间中的每一位(bit)都初始化为0
3. realloc：更改以前分配区的长度(增加或减少)，当增加长度时可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定
   #+BEGIN_SRC C
     #include <stdlib.h>
     /**
        根据所指定的size分配空间

        size：分配空间大小

        return：成功时返回空间的首址，失败时返回NULL
     ,*/
     void *malloc(size_t size);

     /**
        分配nobj个size大小的连续空间

        nobj：object数量
        size：object大小

        return：成功时将该段内存全部清零并返回其首址，失败时返回NULL
     ,*/
     void *calloc(size_t nobj, size_t size);

     /**
        为已分配的ptr重新分配一块大小为newsize的空间

        ptr：已经分配的空间指针
        newsize：新的空间大小

        return：成功时返回空间的首址，失败时返回NULL;
     ,*/
     void *realloc(void *ptr, size_t newsize);
   #+END_SRC
   
*** 释放内存
    free：释放ptr指向的存储空间
    #+BEGIN_SRC C
  #include <stdlib.h>
  /**
     释放指定的ptr对应的地址空间

     ptr：已经分配的地址空间指针

     return：无返回
  ,*/
  void free(void *ptr)
    #+END_SRC
    
*** 实现细节
+ 分配函数通常通过系统调用sbrk(2)实现来实现
+ 分配函数所返回的指针一定是适当对齐的，遵守最苛刻的对齐要求，使其可用于任何数据对象
+ 分配函数所返回的指针可用于任何指针，不需要强制转换
+ 大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息：分配块的长度，指向下一个分配块的指针等等
+ free函数被释放的空间通常被送入可用存储区池，以后再调用分配函数时再分配，但是这并不会减小进程的存储开销，也就是说free释放的空间并不会返回给内核，供其他程序使用
  
*** 注意事项
+ 分配函数返回的指针不应该参与任何指针运算
+ realloc可能会移动存储区，任何指向原来分配区内部的指针都可能失效
+ realloc的最后一个参数是存储区的newsize(新长度)，而不是新、旧长度之差
+ free调用完毕不会设置对应的ptr指针为NULL，若再次直接访问ptr指向的地址是不安全的操作
+ 释放一个已经释放了的块和调用free时所用的指针不是三个alloc函数的返回值都会发生段异常
+ 分配而不再使用的堆空间，应尽快通过free回收，否则会出现内存泄漏
  
  
*** alloca函数
    alloca：类似于malloc，但是不是在堆上分配空间，而是在函数对应的栈内分配空间
    
+ 优点：函数调用结束，自动释放
+ 缺点：并不是所有系统都支持
  
* 环境变量表
  每个程序都接收到一张环境表。与参数表类似，环境表也是一个字符指针数组，其中每个指针包含一个字符串的地址。全局变量environ则包含了该指针数组的地址
  #+BEGIN_SRC C
  extern char **environ;
  #+END_SRC
  如果该环境包含五个字符串，那么它看起来可能如图7-2中所示：
  #+ATTR_HTML: image :width 90% 
  [[file:pic/env.png]]
  
+ 环境指针：environ
+ 环境表：environ指向的指针数组，以NULL结尾
+ 环境变量：各指针指向的字符串，以'\0'结尾
  
按照惯例环境由:
#+BEGIN_EXAMPLE
     name=value
#+END_EXAMPLE
这样的字符串组成，这与图7-2中所示相同。大多数环境变量名完全由大写字母组成，但这也只是一个惯例

** 常见环境变量
   POSIX.1和XPG3定义了某些环境变量。表7-1列出了由这两个标准定义并受到SVR4和4.3+BSD支持的环境变量：
   #+CAPTION: 常见环境变量
   #+ATTR_HTML: :border 1 :rules all :frame boader
   +-----------+---------------------+---------------------+------------+
   |           |        标准         |         实现        |            |
   |  变量     +----------+----------+----------+----------+   说明     |
   |           |  POSIX.1 |   XPG3   |   SVR4   |  4.3+BSD |            |
   +-----------+----------+----------+----------+----------+------------+
   |  HOME     |    •     |    •     |    •     |    •     |  初始目录  |
   +-----------+----------+----------+----------+----------+------------+
   |  LANG     |    •     |    •     |    •     |          |  本地语言  |
   +-----------+----------+----------+----------+----------+------------+
   |  LC_ALL   |    •     |    •     |    •     |          |  本地编码  |
   +-----------+----------+----------+----------+----------+------------+
   |LC_COLLATE |    •     |    •     |    •     |          |  排序编码  |
   +-----------+----------+----------+----------+----------+------------+
   |LC_CTYPE   |    •     |    •     |    •     |          |  输入编码  |
   +-----------+----------+----------+----------+----------+------------+
   |LC_MONETARY|    •     |    •     |    •     |          |  货币编码  |
   +-----------+----------+----------+----------+----------+------------+
   |LC_NUMERIC |    •     |    •     |    •     |          |  数字编码  |
   +-----------+----------+----------+----------+----------+------------+
   |  LC_TIME  |    •     |    •     |    •     |          |  日期编码  |
   +-----------+----------+----------+----------+----------+------------+
   |  LOGNAME  |    •     |    •     |    •     |    •     |   登录名   |
   +-----------+----------+----------+----------+----------+-----------++
   |   PATH    |    •     |    •     |    •     |    •     |可执行文件搜|
   |           |          |          |          |          |索路径      |
   +-----------+----------+----------+----------+----------+------------+
   |   TERM    |    •     |    •     |    •     |    •     |  终端类型  |
   +-----------+----------+----------+----------+----------+------------+
   |    TZ     |    •     |    •     |    •     |    •     |  本地时区  |
   +-----------+----------+----------+----------+----------+------------+
   
** 环境变量函数
   除了取环境变量值，有时也需要设置环境变量，或者是改变现有变量的值，或者是增加新的环境变量。但并不是所有系统都支持这种能力。表7-2列出了由不同的标准及实现支持的各种函数：
   +----------+--------------------------------+---------------------+
   |          |              标准              |         实现        |
   |   变量   +----------+----------+----------+----------+----------+
   |          |  ANSI C  |  POSIX.1 |   XPG3   |   SVR4   | 4.3+BSD  |
   +----------+----------+----------+----------+----------+----------+
   |  getenv  |    •     |    •     |    •     |    •     |    •     |
   +----------+----------+----------+----------+----------+----------+
   |  putenv  |          |   可能   |    •     |    •     |    •     |
   +----------+----------+----------+----------+----------+----------+
   |  setenv  |          |          |          |          |    •     |
   +----------+----------+----------+----------+----------+----------+
   | unsetenv |          |          |          |          |    •     |
   +----------+----------+----------+----------+----------+----------+
   | clearenv |          |   可能   |          |          |          |
   +----------+----------+----------+----------+----------+----------+
   
*** getenv
    getenv：读取环境变量
    #+BEGIN_SRC C
  #include <stdlib.h>
  /**
     根据给定的环境变量名字返回其值

     name：环境变量名

     return：指向与name关联的value的指针，若未找到则为NULL
  ,*/
  char *getenv(const char *name);
    #+END_SRC
    注意：应当使用getenv从环境中取一个环境变量的值，而不是直接存取environ指针！
    
*** putsenv, setenv, unsetenv
    putenv：使用形式为name=value的字符串将其放到环境表中。如果name已经存在，则先删除其原来的定义
    #+BEGIN_SRC C
  #include <stdlib.h>

  /**
     把变量放进环境表中

     str：形式为name=value的字符串

     return：若成功则为0，若出错则为非0
   ,*/
  int putenv(char *str);
    #+END_SRC
    setenv：设置名字为name的环境变量其值为value。如果在环境中name已经存在，那么：
+ 若rewrite非0，则首先删除其现存的定义
+ 若rewrite为0，则不删除其现存定义(name不设置为新的value，而且也不出错)
  #+BEGIN_SRC C
    #include <stdlib.h>

    /**
       设置名字为name的环境变量其值为value

       name：环境变量名字
       value：要设置的环境变量值
       rewrite：是否覆盖

       return：若成功则为0，若出错则为非0
    ,*/
    int setenv(const char *name, const char *value, int rewrite);
  #+END_SRC

  unsetenv：删除环境变量名为name的定义。即使环境表中不存在对应的变量也不会出错
  #+BEGIN_SRC C
    #include <stdlib.h>

    /**
       解除环境变量定义

       name：环境变量名

       return：无返回
    ,*/
    void unsetenv(const char *name);
  #+END_SRC
*** 实现细节
环境表(指向实际name=value字符串的指针数组)和环境字符串典型地存放在进程存储空间的顶部(栈之上)

1. 删除：找到对应的字符串指针，然后将所有环境表中后面元素指向原来的下移一个位置
2. 替换：
   + 新value的长度少于或等于现存value的长度：只要在原字符串所用空间中写入新字符串
   + 如果新value的长度大于原长度：必须调用malloc为新字符串分配空间，然后将新字符写入该空间中，最后使环境表中针对name的指针指向新分配区
3. 增加：首先调用malloc为name=value分配空间，然后将该字符串写入此空间中，然后：
   + 第一次增加一个新name：必须调用malloc为新的指针表分配空间。将原来的环境表复制到新分配区，并将指向新name=value的指针存在该指针表的表尾，接着将一个NULL指针存在其后，最后使environ指向新指针表。这意味着环境表被移至堆中，但是此表中的大多数指针仍指向栈顶之上的各name=value字符串
   + 这不是第一次增加一个新name：则可知以前已调用malloc在堆中为环境表分配了空间，所以只要调用realloc分配比原空间多存放一个指针的空间。然后将该指向新name=value字符串的指针存放在该表表尾，最后在后面跟着一个NULL指针

* 栈间跳转

* 资源限制
