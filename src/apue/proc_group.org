#+TITLE: 进程关系
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: process.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章将详细地说明进程组以及POSIX.1引进的对话期新概念，还将介绍登录shell(登录时所调用的)和所有从登录shell起动的进程之间的关系 

在说明这些关系时不可能不谈及信号，而谈论信号又需要很多本章介绍的概念

* 登录
** 终端登录
在早期的UNIX系统中，例如V7，用户用哑终端(通过RS-232连到主机)进行登录。终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)。在这两种情况下登录都经由内核中的终端设备驱动程序，例如在PDP-11上常用的设备是DH-11和DZ-11。因为连到主机上的终端设备数已经确定，所以同时的登录数也就有了已知的上限。下面说明的登录过程适用于使用一个RS-232终端登录到UNIX系统中
*** 4.3+BSD
登录过程在历史上并没有多少改变。系统管理者创建一个通常名为/etc/ttys的文件，其中每个终端设备有一行，每一行说明设备名和传到getty程序的参数，这些参数说明了终端的波特率等。当系统启动时，内核创建进程ID1，也就是init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则执行程序getty。这种情况示于图9-1中：
#+ATTR_HTML: image :width 50% 
[[file:pic/console-login.png]]

图9-1中各个进程的实际用户ID和有效用户ID都是0(也就是它们都具有超级用户特权)。init以空环境执行getty程序。

getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login:”之类的信息，并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度(波特率)

当用户键入了用户名后getty就完成了，然后它以类似于下列的方式调用login程序：
#+BEGIN_SRC C
  //在gettytab文件中可能会有一些选择项使其调用其他程序，但系统默认是login程序
  execle("/usr/bin/login", "login", "-p", username, (char*)0, envp);
#+END_SRC
getty以终端名(例如TERM=foo，其中终端foo的类型取自gettytab文件)和在gettytab中的环境字符串为login创建一个环境(envp参数)。-p标志通知login保留传给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。图9-2显示了login刚被调用后这些进程的状态：
#+ATTR_HTML: image :width 50% 
[[file:pic/login-begin.png]]

因为最初的init进程具有超级用户优先权，所以图9-2中的所有进程都有超级用户优先权。图9-2中底部三个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且除了最初的init进程，所有的进程均有一个父进程ID

login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass(3)以显示提示“Password:”接着读用户键入的口令 (自然，禁止回送用户键入的口令)。它调用crypt(3)将用户键入的口令加密，并与该用户口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数 1 调用exit表示登录过程失败。父进程(init)了解到子进程的终止情况后，将再次调用fork，其后又跟随着执行getty，对此终端重复上述过程

如果用户正确登录，login就将当前工作目录更改为该用户的起始目录(chdir)。它也调用chown改变该终端的所有权，使该用户成为所有者和组所有者。将对该终端设备的存取许可权改变成：用户读、写和组写。调用setgid及initgroups设置进程的组ID。然后用login所得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)，以及一个系统默认路径(PATH)。最后login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell，其方式类似于:
#+BEGIN_SRC C
  //argv[0]的第一个字符-是一个标志，表示该shell被调用为登录shell。shell可以查看此字符，并相应地修改其起动过程
  execl("/bin/sh", "-sh", (char *) 0);
#+END_SRC
login所做的比上面说的要多。它可选地打印message-of-the-day文件，检查新邮件以及其他一些功能

因为setuid是由超级用户调用的，它更改所有三个用户ID:实际、有效和保存的用户ID。login在较早时间调用的setgid对所有三个组ID也有同样效果

到此为止登录用户的登录shell开始运行。其父进程ID是init进程ID(进程ID 1)，所以当此登录shell终止时，init会得到通知(接到SIGCHLD信号)，它会对该终端重复全部上述过程。登录shell的文件描述符0，1和2设置为终端设备。图9-3显示了这种安排：
#+ATTR_HTML: image :width 50% 
[[file:pic/finish-login.png]]

现在登录shell读对应的启动文件(Bourneshell和KornShell是.profile，Cshell是.cshrc和.login)。这些配置文件通常改变某些环境变量，加上一些环境变量。例如很多用户设置他们自己的PATH，常常提示实际终端类型(TERM)。当执行完启动文件后，用户最后得到shell的提示符，并能键入命令
*** SVR4
SVR4支持两种形式的终端登录：
+ getty：这与上面所说明的一样，通常用于控制台
+ ttymon：用于其他终端的登录

ttymon是名为服务存取设施(ServiceAccessFacility，SAF)的一部分。只简单说明从init到登录shell之间工作过程，最后结果与图9-3中所示相似。init是sac(服务存取控制器)的父进程，sac调用fork，然后其子进程执行ttymon程序，此时系统进入多用户状态。ttymon监视列于配置文件中的所有终端端口，当用户键入登录名时，它调用一次fork。在此之后该子进程又执行登录用户的登录shell，于是到达了图9-3中所示的位置。一个区别是登录shell的父进程现在是ttymon，而在getty登录中，登录shell的父进程是init

** 网络登录 
终端登录中init知道哪些终端设备可用来进行登录，并为每个设备生成一个getty进程。但是对网络登录则情况有所不同，所有登录都经由内核的网络界面驱动程序(例如以太网驱动程序)，事先并不知道将会有多少这样的登录。不是使一个进程等待每一个可能的登录，而是必须等待一个网络连接请求的到达。在4.3+BSD中，有一个称为inetd的进程，它等待大多数网络连接。本书将说明4.3+BSD的网络登录中所涉及的进程序列

*** 4.3+BSD
作为系统起动的一部分init调用一个shell，使其执行shell脚本etc/rc。由此shell脚本起动一个精灵进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后该子进程执行适当的程序

假定到达了一个对于TELNET服务器的TCP连接请求。TELNET是使用TCP协议的远程登录应用程序。在另一个主机(它通过某种形式的网络，连接到服务器主机上)上的用户，或在同一个主机上的一个用户籍起动TELNET客户进程(client)起动登录过程：
#+BEGIN_SRC sh
  $ telnet hostname
#+END_SRC
该客户进程打开一个到名为hostname的主机的TCP连接，在hostname主机上起动的程序被称为TELNET服务器。然后客户进程和服务器进程之间使用TELNET应用协议通过TCP连接交换数据。所发生的是起动客户进程的用户现在登录到了服务器进程所在的主机。(自然用户需要在服务器进程主机上有一个有效的账号)。图9-4显示了在执行TELNET服务器进程(称为telnetd)中所涉及的进程序列
#+ATTR_HTML: image :width 50% 
[[file:pic/telnetd.png]]

然后telnetd进程打开一个伪终端设备，并用fork生成一个子进程。父进程处理通过网络连接的通信，子进程则执行login程序。父、子进程通过伪终端相连接。在调用exec之前，子进程使其文件描述符0，1，2与伪终端相连。如果登录正确，login就执行9.2节中所述的同样步骤—更改当前工作目录为起始目录，设置登录用户的组ID和用户ID，以及登录用户的初始环境。然后login用exec将其自身替换为登录用户的登录shell。图9-5显示了到达这一点时的进程安排：
#+ATTR_HTML: image :width 50% 
[[file:pic/network-login.png
]]

很明显在伪终端设备驱动程序和终端实际用户之间有很多事情在进行着，以后说明伪终端时，再介绍与这种安排相关的所有进程

*** SVR4
SVR4中网络登录的情况与4.3+BSD中的几乎一样。同样使用了inetd服务器进程，但是在SVR4中inetd是作为一种服务由服务存取控制器sac调用的，其父进程不是init。最后得到的结果与图9-5中一样

** 登录总结
登录需要理解的重点是：当通过终端或网络登录时得到一个登录shell，其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上。接着会了解到这一登录shell是一个POSIX.1对话期的开始，而此终端或伪终端则是会话期的控制终端

* 进程组
每个进程除了有一进程ID之外还属于一个进程组。进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID：它是一个正整数，并可存放在pid_t数据类型中

每个进程组有一个组长进程。组长进程的标识是，其进程组ID等于其进程ID

在讨论信号时，将说明如何将一个信号送给一个进程(由其进程ID标识)或送给一个进程组(由进程组ID标识)。同样waitpid则可被用来等待一个进程或者指定进程组中的一个进程
** getpgrp
getpgrp：返回调用进程的进程组ID
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     返回调用进程的进程组ID

     pid：进程ID

     return：pid所属进程组的组ID
  ,*/
  pid_t getpgid(pid_t pid);
#+END_SRC
进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以参加另一个进程组

** setgpid
setgpid：参加一个现存的进程组或者创建一个新进程组
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     设置pid进程的进程组ID为pgid

     pid：进程ID
     pgid：进程组ID

     return：若成功则为0，出错为-1
  ,*/
  int setpgid(pid_t pid, pid_t pgid);
#+END_SRC
将pid进程的进程组ID设置为pgid

一个进程只能为它自己或它的子进程设置进程组ID：
+ 如果pid是0，则让调用者的进程ID成为进程组ID
+ 如果pgid是0，则由pid指定的进程ID成为进程组ID
+ 如果这两个参数相等，则由pid指定的进程变成进程组组长
+ 在它的子进程调用了exec后，就不能再设置该子进程的进程组ID
+ 如果系统不支持作业控制，此函数返回出错，errno设置为ENOSYS
 
在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，然后使子进程设置其自己的进程组ID。虽然这些调用中有一个是冗余的，但这样做可以保证父、子进程在进一步操作之前，子进程都进入了该进程组。如果不这样做的话，就会产生一个竞态条件，因为它依赖于哪一个进程先执行！

* 会话期
对话期是一个或多个进程组的集合

图9.6中一个会话期有三个进程组：
#+ATTR_HTML: image :width 90% 
[[file:pic/session.png]]

通常是由shell的管道线将几个进程编成一组的，例如上图中的安排可能是由下列形式的shell命令形成的：
#+BEGIN_SRC sh
$ proc1 | proc2 & 
$ proc3 | proc4 | proc5
#+END_SRC

** setsid
setsid：创建一个新的会话期

#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     创建一个新的会话期

     return：若成功则为进程组ID，若出错则为-1
   ,*/
  pid_t setsid(void);
#+END_SRC
如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新对话期：
1. 此进程变成该新对话期的对话期首进程(创建该对话期的进程)，也是该新对话期中的唯一进程
2. 此进程成为一个新进程组的组长进程，新进程组ID也是此调用进程的进程ID
3. 此进程没有控制终端，如果在调用setsid之前此进程有一个控制终端，那么这种关系也被解除

如果此调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不出错，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，所以这就保证了子进程不是一个进程组的组长

* 控制终端
  对话期和进程组有一些其他特性:
+ 一个对话期可以有一个单独的控制终端，这通常是在其上登录的终端设备或伪终端设备
+ 控制进程：建立与控制终端连接的对话期首进程
+ 一个对话期中的几个进程组可被分成一个前台进程组以及一个或几个后台进程组
+ 无论何时键入中断键(常常是Ctrl-C)或退出键(常常是Ctrl-\)，就会造成将中断信号或退出信号送至前台进程组的所有进程
+ 如果终端界面检测到调制解调器已经脱开连接，则将挂断信号送至控制进程(对话期首进程)
  
这些特性示于图9-7中：
#+ATTR_HTML: image :width 90% 
[[file:pic/terminal.png]]

通常不必担心控制终端，登录时将自动建立控制终端

有时不管标准输入、标准输出是否重新定向，程序都要与控制终端交互作用。保证程序读写控制终端的方法是打开文件/dev/tty，在内核中，此特殊文件是控制终端的同义语。自然，如果程序没有控制终端，则打开此设备将失败

典型的例子是用于读口令的getpass(3)函数(终端回送被关闭)，这一函数由crypt(1)程序调用，而此程序则可用于管道中。例如将文件salaries解密，然后经由管道将输出送至打印程序：
#+BEGIN_SRC sh
$ crypt < salaries | lpr
#+END_SRC
因为crypt从其标准输入读取salaries文件，所以标准输入不能用于输入口令。但是crypt的一个设计特征是每次运行此程序时，都会从控制终端/dev/tty读取加密口令，这样也就不需要将口令存放在文件中

** tcgetpgrp, tcsetpgrp
+ tcgetpgrp：返回拥有控制终端的前台进程组的组ID
+ tcsetpgrp：设置控制终端的前台进程组的组ID
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     返回某个文件描述符相关联的控制终端的前台进程组的组ID

     filedes：文件描述符

     return：若成功则为前台进程组ID，若出错则为-1
  ,*/
  pid_t tcgetpgrp(int filedes);

  /**
     设置filedes所打开的控制终端的前台进程组ID为pgrpid

     filedes：与某个tty相关联的文件描述符
     pgrpid：某个tty下的一个对话期中的一个进程组的ID

     return：成功返回0，失败返回-1
  ,*/
  int tcsetpgrp(int filedes, pid_t pgrpid);
#+END_SRC
这两个函数用来通知内核哪一个进程组是前台进程组，而内核中的终端设备驱动程序也能知道将终端输入和终端产生的信号送到何处

只有支持作业控制，这两个函数才被定义，否则直接报错

* 作业控制
  作业控制是伯克利在1980年左右加到UNIX的一个新特性。它允许在一个终端上起动多个作业(进程组)，控制哪一个作业可以存取该终端，以及哪些作业在后台运行。作业控制要求三种形式的支持：
1. 支持作业控制的shell
2. 内核中的终端驱动程序必须支持作业控制
3. 必须提供对某些作业控制信号的支持
   
从shell使用作业控制功能角度观察，可以在前台或后台起动一个作业，而一个作业只是几个进程的集合，通常是一个进程管道

比如，以下命令在前台起动了只有一个进程的一个作业：
#+BEGIN_SRC sh
  $ vi main.c
#+END_SRC

而下面的命令在后台起动了两个作业，这两个后台作业所调用的进程都在后台运行着
#+BEGIN_SRC sh
  $ pr *.c | lpr &

  $ make all &
#+END_SRC
当起动一个后台作业时，shell赋与它一个作业标识，并打印一个或几个进程ID。下面的操作过程显示了Bash Shell是如何处理的：
#+BEGIN_SRC sh
  $ make all > Make.out &
  [1] 1475

  $ pr *.c | lpr &
  [2] 1490

  $ 键入回车
  [2] + Done pr *.c | lpr &
  [1] + Done make all > Make.out &
#+END_SRC
make是作业号1，所起动的进程ID是1475。下一个管道线是作业号2，其第一个进程的进程ID是1490。当作业已完成而且键入回车时，shell通知我们作业已经完成。键入回车是为了让shell打印其提示符，shell并不在任何随意的时间打印后台作业的状态改变，它只在打印其提示符之前这样做。如果不这样处理，则当我们正输入一行时，它也可能输出

** 信号
   可以键入一个影响前台作业的特殊字符，比如挂起键(一般采用Ctrl-Z)与终端进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP送至前台进程组中的所有进程，后台进程组作业则不受影响。实际上有三个特殊字符可使终端驱动程序产生信号，并将它们送至前台进程组，它们是:
+ 中断字符(一般采用DELETE或Ctrl-C)产生SIGINT
+ 退出字符(一般采用Ctrl-\)产生SIGQUIT
+ 挂起字符(一般采用Ctrl-Z)产生SIGTSTP
  
*** 后台进程读取中断输入
    只有前台作业接收终端输入，如果后台作业试图读终端，那么这并不是一个错误，但是终端驱动程序检测这种情况，会发送一个特定信号SIGTTIN给后台作业。这通常会停止此后台作业，而有关用户则会得到这种情况的通知，然后就可将此作业转为前台作业运行，使得它可以读终端输入。下列操作过程显示了这一点：
    #+BEGIN_SRC sh
  $ cat > temp.foo & #在后台启动,但将从标准输入读
  [1] 1681

  $ 键入回车
  [1] + Stopped (tty input) cat > temp.foo &

  $ fg %1 #使1号作业成为前台作业
  cat > temp.foo #shell告诉我们现在哪一个作业在前台
  hello, world #输入1行
  ˆD #键入文件结束符

  $ cat temp.foo #检查该行已送入文件
  hello, world
    #+END_SRC
    shell在后台起动cat进程，但是当cat试图读其标准输入(控制终端)时，终端驱动程序知道它是个后台作业，于是将SIGTTIN信号送至该后台作业。shell检测到其子进程的状态改变，并通知用户该作业已被停止。然后，用shell的fg命令将此停止的作业送入前台运行。这样使shell将此作业转为前台进程组(tcsetpgrp)，并将继续信号(SIGCONT)送给该进程组。因为该作业现在前台进程组中，所以它可以读控制终端
    
*** 后台进程向中断输出
    这是一个我们可以允许或禁止的选择项。通常可以用stty(1)命令改变这一选择项。下面显示了这种操作过程：
    
    #+BEGIN_SRC sh
  $ cat temp.foo & #在后台执行
  [1] 1719
  $ hello, world #在提示符后出现后台作业的输出
                 #键入回车
  [1] + Done   cat temp.foo &

  $ stty tostop #禁止后台作业向控制终端输出

  $ cat temp.foo & #在后台再次执行
  [1] 1721 
  $ #键入回车,发现作业已停止
  [1] + Stopped(tty output) cat temp.foo &

  $ fg %1 #将停止的作业恢复为前台作业
  cat temp.foo #shell告诉我们现在哪一个作业在前台
  hello, world #该作业的输出
    #+END_SRC
    
** 总结
   图9-8摘录了已说明的作业控制的某些功能。穿过终端驱动程序框的实线表示：终端I/O和终端产生的信号总是从前台进程组连接到实际终端，而对应于SIGTTOU信号的虚线表示后台进程组进程的输出是否出现在终端是可选择的
   #+ATTR_HTML: image :width 60% 
   [[file:pic/job-controll.png]]
   
* shell执行程序
注意：关于管道的内容已经过时，在现在的sh和bash几乎都是看到先执行第一个命令，再依次执行每一条命令！！！
** Bourne shell 
   Bourne shell不支持作业控制
   
*** 前台进程
    #+BEGIN_SRC sh
    $ ps -xj
    #父进程ID 进程ID 进程组ID 会话期ID 终端进程组ID 命令
    PPID PID PGID SID TPGID COMMAND
    1    163 163  163 163   -sh
    163  163 163  163 163   ps 
    #+END_SRC
    shell和ps命令两者位于同一对话期和前台进程组(163)中。因为163是在TPGID列中显示的进程组，所以称其为前台进程组。ps的父进程是shell，登录shell是由login作为其父进程的 
    
    "进程与终端进程组ID(TPGID列)"相关联是用词不当。进程并没有终端进程组。进程属于一个进程组，而进程组属于一个对话期。对话期可能有，也可能没有控制终端。如果它确有一个控制终端，则此终端设备知道其前台进程的进程组ID。这一值可以用tcsetpgrp函数在终端驱动程序中设置。前台进程组ID是终端的一个属性，而不是进程的属性。取自终端设备驱动程序的该值是ps在TPGID列中打印的值。如果ps发现此对话期没有控制终端，则它在该列打印-1 
    
*** 后台进程
    由于Bourne shell不支持作业控制，所以唯一改变的只有ps命令的进程ID
    #+BEGIN_SRC sh
      $ ps -xj &

      PPID  PID  PGID  SID  TPGID  COMMAND
      1     163  163   163  163    -sh
      163   169  163   163  163    ps
    #+END_SRC
    
*** 管道
    管道中的最后一个进程是shell的子进程，该管道中的第一个进程则是最后一个进程的子进程。
    #+BEGIN_SRC sh
      $ ps -xj | cat1

      PPID  PID  PGID  SID  TPGID  COMMAND
      1     163  163   163  163    -sh
      163   200  163   163  163    cat1
      200   201  163   163  163    ps 
    #+END_SRC
    
    shell首先会fork一个sh副本然后exec执行管道中最后一个命令，然后此副本再为管道线中的每条命令各fork一个sh进程，再依次exec执行管道中每个命令。例如，在一条管道中执行三个进程：
    #+BEGIN_SRC sh
  $ ps -xj | cat1 | cat2

  PPID  PID  PGID  SID  TPGID  COMMAND
  1     163  163   163  163    -sh
  163   202  163   163  163    cat2
  202   203  163   163  163    ps
  202   204  163   163  163    cat1
    #+END_SRC
    
    图9-9显示了上面所发生的情况：
    #+ATTR_HTML: image :width 80% 
    [[file:pic/bourne-pipeline.png]]
    
    对Bourne shell来说后台执行管道线的唯一区别也是进程ID发生变化
*** 后台进程读取控制终端
    #+BEGIN_SRC sh
      $ cat > temp.foo &
    #+END_SRC
    如果该进程自己不重新定向标准输入，则Bourne shell自动将后台进程的标准输入重新定向到/dev/null。读/dev/null则产生一个文件结束。这意味着后台cat进程立即读到文件尾，并正常结束 
    
    如果一个后台进程打开/dev/tty并且读该控制终端，又将怎样呢？对此问题的回答是依赖系统实现。但是这很可能不是想要的。例如：
    #+BEGIN_SRC sh
  $ crypt < salaries | lpr &
    #+END_SRC
    有可能当执行这条后台管道时，crypt在终端上打印提示符“Password:”，但是shell读取了我们所输入的加密码口令，并企图执行其中一条命令。我们输送给shell的下一行，则被crypt进程取为口令行，于是salaries也就不能正确地被译码，结果将一堆没有用的信息送到了打印机。在这里，我们有了两个进程，它们试图同时读同一设备，其结果则依赖于系统。这也正好说明了作业控制以较好的方式处理一个终端在多个进程间的转接
** Bash
Bash支持作业控制，依次执行刚才的命令：
*** 前台进程
    #+BEGIN_SRC sh
      $ ps -xj

      PPID PID PGID SID TPGID COMMAND
      1    700 700  700 708   -bash
      700  708 708  700 708   ps
    #+END_SRC
Bash将前台作业(ps)放入了它自己的进程组(708)。ps命令是进程组组长进程，并是该进程组的唯一进程。进一步而言，此进程组具有控制终端，所以它是前台进程。而登录shell在执行ps命令时是后台进程组。但需要注意的是，这两个进程组700和708都是同一对话期的成员
*** 后台进程
    #+BEGIN_SRC sh
      $ ps -xj &

      PPID PID PGID SID TPGID COMMAND
      1    700 700  700 700   -bash
      700  709 709  700 700   ps
    #+END_SRC
ps命令被放入它自己的进程组，但是此时进程组(709)不再是前台进程组。这是一个后台进程组。TPGID为700指示前台进程组是登录shell
*** 前台管道
    #+BEGIN_SRC sh
      $ ps -xj | cat1

      PPID  PID  PGID  SID  TPGID  COMMAND
      1     700  700   700  710    -bash
      700   710  710   700  710    ps
      710   711  710   700  710    cat1
    #+END_SRC
ps和cat1都在一个新进程组(710)中，这是一个前台进程组。和类似的Bourne shell实例之间能另一个区别是：Bourne　shell首先创建将执行管道线中最后一条命令的进程，而bash是fork　bash的副本并exec执行第一个命令
*** 后台管道
Bash以与Bourne shell相同的方式产生后台管道进程
    #+BEGIN_SRC sh
      $ ps -xj | cat1 &

      PPID  PID  PGID  SID  TPGID  COMMAND
      1     700  700   700  700    -bash
      700   712  712   700  700    cat1
      712   713  712   700  700    ps
    #+END_SRC
cat1和ps都处在后台进程组712中，先创建最后一个命令cat1，再创建命令ps

* 孤儿进程组
+ 孤儿进程：一个父进程已终止的进程，这种进程由init进程托管
+ 孤儿进程组：该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属对话期的成员

一个进程组不是孤儿进程组的条件是：该组中存在一个进程,其父进程在同一会话的其它进程组中。如果进程组不是孤儿进程组，那么在属于同一对话期的另一个组中的父进程就有机会重新起动该组中停止的进程

孤儿进程组将被置于后台执行
** 实例
考虑一个进程，它fork了一个子进程然后终止。这在系统中是经常发生的，并无异常之处，但是在父进程终止时，如果该子进程停止(作业控制)，则子进程就成了孤儿进程组。程序9-1是这种情况的一个例子：
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <errno.h>
  #include <fcntl.h>
  #include <signal.h>
  #include "apue.h"

  static void sig_hup(int);
  static void pr_ids(char *);

  int main(void)
  {
          char c;
          pid_t pid;

          pr_ids("parent");
          if( (pid = fork()) < 0)
                  err_sys("fork error");

          else if(pid > 0) { 
                  sleep(5);//父进程先休眠，使得子进程有机会先运行
                  exit(0); 
          } else {
                  pr_ids("child");
                  signal(SIGHUP, sig_hup); //处理挂断信号
                  kill(getpid(), SIGTSTP); //发送信号使得子进程停止
                  pr_ids("child"); //变成孤儿进程组后，转入后台运行
                  if(read(STDIN_FILENO, &c, 1) != 1)
                          //后台进程组读取控制终端输入会产生SIGTTIN信号，导致读取报错errno=EIO
                          printf("read error from control terminal, errno = %d\n", errno
                                 exit(0);
                                 }        
          }

          static void sig_hup(int signo)
          {
                  printf("SIGHUP received, pid = %d\n", getpid());
                  return;
            
          }

          static void pr_ids(char *name)
          {
                  printf("%s: pid = %d, ppid = %d, pgrp = %d\n",
                         name, getpid(), getppid(), tcgetpgrp(STDIN_FILENO));
                  fflush(stdout);
          }
#+END_SRC

图9-10显示了父进程已经fork了子进程后的情况：
#+ATTR_HTML: image :width 50% 
[[file:pic/orphan-process-group.png]]

假定使用了一个作业控制shell。shell将前台进程放在一个进程组中(本例中是512)，shell则留在自己的组内(442)。子进程继承其父进程(512)的进程组。在fork之后:
1. 父进程睡眠5秒钟，让子进程在父进程终止之前运行
2. 子进程为挂断信号(SIGHUP)建立信号处理程序。这样就能观察到SIGHUP信号是否已送到子进程
3. 子进程用kill函数向其自身发送停止信号(SIGTSTP)，停止了子进程，类似于用终端挂起字符(Ctrl-Z)停止一个前台作业
4. 当父进程终止时，该子进程成为孤儿进程，父进程ID成为1，也就是init进程
5. 现在子进程成为一个孤儿进程组的成员：因为进程组中所有进程的进程(如进程513的父进程1)属于另一个对话期，所以此进程组是孤儿进程组
6. POSIX.1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号(SIGHUP)，接着又向其发送继续信号(SIGCONT)
7. 在处理了挂断信号后，子进程继续。对挂断信号的系统默认动作是终止该进程，所以提供一个信号处理程序以捕捉该信号

测试结果：
#+BEGIN_SRC sh
  $ a.out
  parent: pid = 512, ppid = 442, pgrp = 512
  child: pid = 513, ppid = 512, pgrp = 512
  $ SIGHUP received, pid = 513
  child: pid = 513, ppid = 1, pgrp = 512
  read error from control terminal, errno = 5
#+END_SRC
注意：
+ 因为两个进程登录shell和子进程都写向终端，所以shell提示符和子进程的输出一起出现
+ 子进程的父进程ID变成1，成为了孤儿进程
+ 父进程终止时，子进程变成后台进程组，而父进程是由shell作为前台作业执行的
+ sig_hup函数中的printf会在pr_ids函数中的printf之前执行
+ 在子进程中调用pr_ids后，程序企图读标准输入。当后台进程组试图读控制终端时，则对该后台进程组产生SIGTTIN，这导致read返回出错，其errno设置为EIO(其值是5)

* BSD实现
图9-11显示了BSD中进程，进程组，会话期，控制终端等各种数据结构：
#+ATTR_HTML: image :width 80% 
[[file:pic/proc-group-bsd.jpg]]

** session结构
每个对话期都分配了一个session结构：
+ s_count：该对话期中的进程组数。当此计数器减至0时，则可释放此结构
+ s_leader：指向对话期首进程proc结构的指针。4.3+BSD不保持对话期ID字段，而SVR4则保持此字段
+ s_ttyvp：指向控制终端vnode结构的指针
+ s_ttyp：指向控制终端tty结构的指针 

在调用setsid时，在内核中分配一个新的对话期结构。s_count设置为1，s_leader设置为调用进程的proc结构的指针，因为新对话期没有控制终端，所以s_ttyvp和s_ttyp设置为空指针

** tty结构
每个终端设备和每个伪终端设备均在内核中分配这样一个tty结构：
+ t_session：指向将此终端作为控制终端的session结构(注意：session结构也会指向tty结构)。终端在失去载波信号时需要使用此指针将挂起信号送给对话期首进程
+ t_pgrp：指向前台进程组的pgrp结构。终端驱动程序用此字段将信号送向前台进程组。由输入特殊字符(中断、退出和挂起)而产生的三个信号被送至前台进程组
+ t_termios：包含所有这些特殊字符和与该终端有关信息的结构
+ t_winsize：包含终端窗口当前尺寸的winsize结构

注意：为了找到特定对话期的前台进程组，内核从session结构开始，然后用s_ttyp得到控制终端的tty结构，然后用t_pgrp得到前台进程组的pgrp结构

** pgrp结构
pgrp结构包含一个进程组的信息：
+ pg_id：进程组ID
+ pg_session：指向此进程组所属的session结构
+ pg_mem：是指向此进程组第一个进程proc结构的指针

** proc结构
proc结构包含一个进程的所有信息：
+ p_pid：进程ID
+ p_pptr：指向父进程proc结构的指针
+ p_pgrp：指向本进程所属的进程组的pgrp结构
+ p_pgrpnxt：指向进程组中下一个进程的指针，进程组中最后一个进程的p_pgrpnxt为NULL指针

** vnode结构
在打开控制终端设备时分配vnode结构，进程对/dev/tty的所有访问都通过vnode结构

在BSD中实际i节点是v节点的一部分，而SVR4实现中v节点存在i节点中

[[file:signal.org][Next：信号]]

[[file:process.org][Previous：进程控制]]

[[file:apue.org][Home：目录]]
