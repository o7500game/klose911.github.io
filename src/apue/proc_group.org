#+TITLE: 进程关系
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: process.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章将详细地说明进程组以及POSIX.1引进的对话期新概念，还将介绍登录shell(登录时所调用的)和所有从登录shell起动的进程之间的关系 

在说明这些关系时不可能不谈及信号，而谈论信号又需要很多本章介绍的概念

* 登录
** 终端登录
在早期的UNIX系统中，例如V7，用户用哑终端(通过RS-232连到主机)进行登录。终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)。在这两种情况下登录都经由内核中的终端设备驱动程序，例如在PDP-11上常用的设备是DH-11和DZ-11。因为连到主机上的终端设备数已经确定，所以同时的登录数也就有了已知的上限。下面说明的登录过程适用于使用一个RS-232终端登录到UNIX系统中
*** 4.3+BSD
登录过程在历史上并没有多少改变。系统管理者创建一个通常名为/etc/ttys的文件，其中每个终端设备有一行，每一行说明设备名和传到getty程序的参数，这些参数说明了终端的波特率等。当系统启动时，内核创建进程ID1，也就是init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则执行程序getty。这种情况示于图9-1中：
#+ATTR_HTML: image :width 50% 
[[file:pic/console-login.png]]

图9-1中各个进程的实际用户ID和有效用户ID都是0(也就是它们都具有超级用户特权)。init以空环境执行getty程序。

getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login:”之类的信息，并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度(波特率)

当用户键入了用户名后getty就完成了，然后它以类似于下列的方式调用login程序：
#+BEGIN_SRC C
  //在gettytab文件中可能会有一些选择项使其调用其他程序，但系统默认是login程序
  execle("/usr/bin/login", "login", "-p", username, (char*)0, envp);
#+END_SRC
getty以终端名(例如TERM=foo，其中终端foo的类型取自gettytab文件)和在gettytab中的环境字符串为login创建一个环境(envp参数)。-p标志通知login保留传给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。图9-2显示了login刚被调用后这些进程的状态：
#+ATTR_HTML: image :width 50% 
[[file:pic/login-begin.png]]

因为最初的init进程具有超级用户优先权，所以图9-2中的所有进程都有超级用户优先权。图9-2中底部三个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且除了最初的init进程，所有的进程均有一个父进程ID

login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass(3)以显示提示“Password:”接着读用户键入的口令 (自然，禁止回送用户键入的口令)。它调用crypt(3)将用户键入的口令加密，并与该用户口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数 1 调用exit表示登录过程失败。父进程(init)了解到子进程的终止情况后，将再次调用fork，其后又跟随着执行getty，对此终端重复上述过程

如果用户正确登录，login就将当前工作目录更改为该用户的起始目录(chdir)。它也调用chown改变该终端的所有权，使该用户成为所有者和组所有者。将对该终端设备的存取许可权改变成：用户读、写和组写。调用setgid及initgroups设置进程的组ID。然后用login所得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)，以及一个系统默认路径(PATH)。最后login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell，其方式类似于:
#+BEGIN_SRC C
  //argv[0]的第一个字符-是一个标志，表示该shell被调用为登录shell。shell可以查看此字符，并相应地修改其起动过程
  execl("/bin/sh", "-sh", (char *) 0);
#+END_SRC
login所做的比上面说的要多。它可选地打印message-of-the-day文件，检查新邮件以及其他一些功能

因为setuid是由超级用户调用的，它更改所有三个用户ID:实际、有效和保存的用户ID。login在较早时间调用的setgid对所有三个组ID也有同样效果

到此为止登录用户的登录shell开始运行。其父进程ID是init进程ID(进程ID 1)，所以当此登录shell终止时，init会得到通知(接到SIGCHLD信号)，它会对该终端重复全部上述过程。登录shell的文件描述符0，1和2设置为终端设备。图9-3显示了这种安排：
#+ATTR_HTML: image :width 50% 
[[file:pic/finish-login.png]]

现在登录shell读对应的启动文件(Bourneshell和KornShell是.profile，Cshell是.cshrc和.login)。这些配置文件通常改变某些环境变量，加上一些环境变量。例如很多用户设置他们自己的PATH，常常提示实际终端类型(TERM)。当执行完启动文件后，用户最后得到shell的提示符，并能键入命令
*** SVR4终端登录
SVR4支持两种形式的终端登录：
+ getty：这与上面所说明的一样，通常用于控制台
+ ttymon：用于其他终端的登录

ttymon是名为服务存取设施(ServiceAccessFacility，SAF)的一部分。只简单说明从init到登录shell之间工作过程，最后结果与图9-3中所示相似。init是sac(服务存取控制器)的父进程，sac调用fork，然后其子进程执行ttymon程序，此时系统进入多用户状态。ttymon监视列于配置文件中的所有终端端口，当用户键入登录名时，它调用一次fork。在此之后该子进程又执行登录用户的登录shell，于是到达了图9-3中所示的位置。一个区别是登录shell的父进程现在是ttymon，而在getty登录中，登录shell的父进程是init

** 网络登录 
终端登录中init知道哪些终端设备可用来进行登录，并为每个设备生成一个getty进程。但是对网络登录则情况有所不同，所有登录都经由内核的网络界面驱动程序(例如以太网驱动程序)，事先并不知道将会有多少这样的登录。不是使一个进程等待每一个可能的登录，而是必须等待一个网络连接请求的到达。在4.3+BSD中，有一个称为inetd的进程，它等待大多数网络连接。本书将说明4.3+BSD的网络登录中所涉及的进程序列

*** 4.3+BSD
作为系统起动的一部分init调用一个shell，使其执行shell脚本etc/rc。由此shell脚本起动一个精灵进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后该子进程执行适当的程序

假定到达了一个对于TELNET服务器的TCP连接请求。TELNET是使用TCP协议的远程登录应用程序。在另一个主机(它通过某种形式的网络，连接到服务器主机上)上的用户，或在同一个主机上的一个用户籍起动TELNET客户进程(client)起动登录过程：
#+BEGIN_SRC sh
  $ telnet hostname
#+END_SRC
该客户进程打开一个到名为hostname的主机的TCP连接，在hostname主机上起动的程序被称为TELNET服务器。然后客户进程和服务器进程之间使用TELNET应用协议通过TCP连接交换数据。所发生的是起动客户进程的用户现在登录到了服务器进程所在的主机。(自然用户需要在服务器进程主机上有一个有效的账号)。图9-4显示了在执行TELNET服务器进程(称为telnetd)中所涉及的进程序列
#+ATTR_HTML: image :width 50% 
[[file:pic/telnetd.png]]

然后telnetd进程打开一个伪终端设备，并用fork生成一个子进程。父进程处理通过网络连接的通信，子进程则执行login程序。父、子进程通过伪终端相连接。在调用exec之前，子进程使其文件描述符0，1，2与伪终端相连。如果登录正确，login就执行9.2节中所述的同样步骤—更改当前工作目录为起始目录，设置登录用户的组ID和用户ID，以及登录用户的初始环境。然后login用exec将其自身替换为登录用户的登录shell。图9-5显示了到达这一点时的进程安排：
#+ATTR_HTML: image :width 50% 
[[file:pic/network-login.png
]]

很明显在伪终端设备驱动程序和终端实际用户之间有很多事情在进行着，以后说明伪终端时，再介绍与这种安排相关的所有进程

*** SVR4
SVR4中网络登录的情况与4.3+BSD中的几乎一样。同样使用了inetd服务器进程，但是在SVR4中inetd是作为一种服务由服务存取控制器sac调用的，其父进程不是init。最后得到的结果与图9-5中一样

** 登录总结
登录需要理解的重点是：当通过终端或网络登录时得到一个登录shell，其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上。接着会了解到这一登录shell是一个POSIX.1对话期的开始，而此终端或伪终端则是会话期的控制终端

* 进程组
