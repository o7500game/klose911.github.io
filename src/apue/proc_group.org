#+TITLE: 进程关系
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: process.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章将详细地说明进程组以及POSIX.1引进的对话期新概念，还将介绍登录shell(登录时所调用的)和所有从登录shell起动的进程之间的关系 

在说明这些关系时不可能不谈及信号，而谈论信号又需要很多本章介绍的概念

* 登录
** 终端登录
在早期的UNIX系统中，例如V7，用户用哑终端(通过RS-232连到主机)进行登录。终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)。在这两种情况下登录都经由内核中的终端设备驱动程序，例如在PDP-11上常用的设备是DH-11和DZ-11。因为连到主机上的终端设备数已经确定，所以同时的登录数也就有了已知的上限。下面说明的登录过程适用于使用一个RS-232终端登录到UNIX系统中
*** 4.3+BSD
登录过程在历史上并没有多少改变。系统管理者创建一个通常名为/etc/ttys的文件，其中每个终端设备有一行，每一行说明设备名和传到getty程序的参数，这些参数说明了终端的波特率等。当系统启动时，内核创建进程ID1，也就是init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则执行程序getty。这种情况示于图9-1中：
#+ATTR_HTML: image :width 50% 
[[file:pic/console-login.png]]

图9-1中各个进程的实际用户ID和有效用户ID都是0(也就是它们都具有超级用户特权)。init以空环境执行getty程序。

getty对终端设备调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login:”之类的信息，并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度(波特率)

当用户键入了用户名后getty就完成了，然后它以类似于下列的方式调用login程序：
#+BEGIN_SRC C
  //在gettytab文件中可能会有一些选择项使其调用其他程序，但系统默认是login程序
  execle("/usr/bin/login", "login", "-p", username, (char*)0, envp);
#+END_SRC
getty以终端名(例如TERM=foo，其中终端foo的类型取自gettytab文件)和在gettytab中的环境字符串为login创建一个环境(envp参数)。-p标志通知login保留传给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。图9-2显示了login刚被调用后这些进程的状态：
#+ATTR_HTML: image :width 50% 
[[file:pic/login-begin.png]]

因为最初的init进程具有超级用户优先权，所以图9-2中的所有进程都有超级用户优先权。图9-2中底部三个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且除了最初的init进程，所有的进程均有一个父进程ID

login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass(3)以显示提示“Password:”接着读用户键入的口令 (自然，禁止回送用户键入的口令)。它调用crypt(3)将用户键入的口令加密，并与该用户口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数 1 调用exit表示登录过程失败。父进程(init)了解到子进程的终止情况后，将再次调用fork，其后又跟随着执行getty，对此终端重复上述过程

如果用户正确登录，login就将当前工作目录更改为该用户的起始目录(chdir)。它也调用chown改变该终端的所有权，使该用户成为所有者和组所有者。将对该终端设备的存取许可权改变成：用户读、写和组写。调用setgid及initgroups设置进程的组ID。然后用login所得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)，以及一个系统默认路径(PATH)。最后login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell，其方式类似于:
#+BEGIN_SRC C
  //argv[0]的第一个字符-是一个标志，表示该shell被调用为登录shell。shell可以查看此字符，并相应地修改其起动过程
  execl("/bin/sh", "-sh", (char *) 0);
#+END_SRC
login所做的比上面说的要多。它可选地打印message-of-the-day文件，检查新邮件以及其他一些功能

因为setuid是由超级用户调用的，它更改所有三个用户ID:实际、有效和保存的用户ID。login在较早时间调用的setgid对所有三个组ID也有同样效果

到此为止登录用户的登录shell开始运行。其父进程ID是init进程ID(进程ID 1)，所以当此登录shell终止时，init会得到通知(接到SIGCHLD信号)，它会对该终端重复全部上述过程。登录shell的文件描述符0，1和2设置为终端设备。图9-3显示了这种安排：
#+ATTR_HTML: image :width 50% 
[[file:pic/finish-login.png]]

现在登录shell读对应的启动文件(Bourneshell和KornShell是.profile，Cshell是.cshrc和.login)。这些配置文件通常改变某些环境变量，加上一些环境变量。例如很多用户设置他们自己的PATH，常常提示实际终端类型(TERM)。当执行完启动文件后，用户最后得到shell的提示符，并能键入命令
*** SVR4
SVR4支持两种形式的终端登录：
+ getty：这与上面所说明的一样，通常用于控制台
+ ttymon：用于其他终端的登录

ttymon是名为服务存取设施(ServiceAccessFacility，SAF)的一部分。只简单说明从init到登录shell之间工作过程，最后结果与图9-3中所示相似。init是sac(服务存取控制器)的父进程，sac调用fork，然后其子进程执行ttymon程序，此时系统进入多用户状态。ttymon监视列于配置文件中的所有终端端口，当用户键入登录名时，它调用一次fork。在此之后该子进程又执行登录用户的登录shell，于是到达了图9-3中所示的位置。一个区别是登录shell的父进程现在是ttymon，而在getty登录中，登录shell的父进程是init

** 网络登录 
终端登录中init知道哪些终端设备可用来进行登录，并为每个设备生成一个getty进程。但是对网络登录则情况有所不同，所有登录都经由内核的网络界面驱动程序(例如以太网驱动程序)，事先并不知道将会有多少这样的登录。不是使一个进程等待每一个可能的登录，而是必须等待一个网络连接请求的到达。在4.3+BSD中，有一个称为inetd的进程，它等待大多数网络连接。本书将说明4.3+BSD的网络登录中所涉及的进程序列

*** 4.3+BSD
作为系统起动的一部分init调用一个shell，使其执行shell脚本etc/rc。由此shell脚本起动一个精灵进程inetd。一旦此shell脚本终止，inetd的父进程就变成init。inetd等待TCP/IP连接请求到达主机，而当一个连接请求到达时，它执行一次fork，然后该子进程执行适当的程序

假定到达了一个对于TELNET服务器的TCP连接请求。TELNET是使用TCP协议的远程登录应用程序。在另一个主机(它通过某种形式的网络，连接到服务器主机上)上的用户，或在同一个主机上的一个用户籍起动TELNET客户进程(client)起动登录过程：
#+BEGIN_SRC sh
  $ telnet hostname
#+END_SRC
该客户进程打开一个到名为hostname的主机的TCP连接，在hostname主机上起动的程序被称为TELNET服务器。然后客户进程和服务器进程之间使用TELNET应用协议通过TCP连接交换数据。所发生的是起动客户进程的用户现在登录到了服务器进程所在的主机。(自然用户需要在服务器进程主机上有一个有效的账号)。图9-4显示了在执行TELNET服务器进程(称为telnetd)中所涉及的进程序列
#+ATTR_HTML: image :width 50% 
[[file:pic/telnetd.png]]

然后telnetd进程打开一个伪终端设备，并用fork生成一个子进程。父进程处理通过网络连接的通信，子进程则执行login程序。父、子进程通过伪终端相连接。在调用exec之前，子进程使其文件描述符0，1，2与伪终端相连。如果登录正确，login就执行9.2节中所述的同样步骤—更改当前工作目录为起始目录，设置登录用户的组ID和用户ID，以及登录用户的初始环境。然后login用exec将其自身替换为登录用户的登录shell。图9-5显示了到达这一点时的进程安排：
#+ATTR_HTML: image :width 50% 
[[file:pic/network-login.png
]]

很明显在伪终端设备驱动程序和终端实际用户之间有很多事情在进行着，以后说明伪终端时，再介绍与这种安排相关的所有进程

*** SVR4
SVR4中网络登录的情况与4.3+BSD中的几乎一样。同样使用了inetd服务器进程，但是在SVR4中inetd是作为一种服务由服务存取控制器sac调用的，其父进程不是init。最后得到的结果与图9-5中一样

** 登录总结
登录需要理解的重点是：当通过终端或网络登录时得到一个登录shell，其标准输入、输出和标准出错连接到一个终端设备或者伪终端设备上。接着会了解到这一登录shell是一个POSIX.1对话期的开始，而此终端或伪终端则是会话期的控制终端

* 进程组
每个进程除了有一进程ID之外还属于一个进程组。进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID：它是一个正整数，并可存放在pid_t数据类型中

每个进程组有一个组长进程。组长进程的标识是，其进程组ID等于其进程ID

在讨论信号时，将说明如何将一个信号送给一个进程(由其进程ID标识)或送给一个进程组(由进程组ID标识)。同样waitpid则可被用来等待一个进程或者指定进程组中的一个进程
** getpgrp
getpgrp：返回调用进程的进程组ID
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     返回调用进程的进程组ID

     pid：进程ID

     return：pid所属进程组的组ID
  ,*/
  pid_t getpgid(pid_t pid);
#+END_SRC
进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以参加另一个进程组

** setgpid
setgpid：参加一个现存的进程组或者创建一个新进程组
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     设置pid进程的进程组ID为pgid

     pid：进程ID
     pgid：进程组ID

     return：若成功则为0，出错为-1
  ,*/
  int setpgid(pid_t pid, pid_t pgid);
#+END_SRC
将pid进程的进程组ID设置为pgid

一个进程只能为它自己或它的子进程设置进程组ID：
+ 如果pid是0，则让调用者的进程ID成为进程组ID
+ 如果pgid是0，则由pid指定的进程ID成为进程组ID
+ 如果这两个参数相等，则由pid指定的进程变成进程组组长
+ 在它的子进程调用了exec后，就不能再设置该子进程的进程组ID
+ 如果系统不支持作业控制，此函数返回出错，errno设置为ENOSYS
 
在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，然后使子进程设置其自己的进程组ID。虽然这些调用中有一个是冗余的，但这样做可以保证父、子进程在进一步操作之前，子进程都进入了该进程组。如果不这样做的话，就会产生一个竞态条件，因为它依赖于哪一个进程先执行！

* 会话期
对话期是一个或多个进程组的集合

图9.6中一个会话期有三个进程组：
#+ATTR_HTML: image :width 90% 
[[file:pic/session.png]]

通常是由shell的管道线将几个进程编成一组的，例如上图中的安排可能是由下列形式的shell命令形成的：
#+BEGIN_SRC sh
$ proc1 | proc2 & 
$ proc3 | proc4 | proc5
#+END_SRC

** setsid
setsid：创建一个新的会话期

#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     创建一个新的会话期

     return：若成功则为进程组ID，若出错则为-1
   ,*/
  pid_t setsid(void);
#+END_SRC
如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新对话期：
1. 此进程变成该新对话期的对话期首进程(创建该对话期的进程)，也是该新对话期中的唯一进程
2. 此进程成为一个新进程组的组长进程，新进程组ID也是此调用进程的进程ID
3. 此进程没有控制终端，如果在调用setsid之前此进程有一个控制终端，那么这种关系也被解除

如果此调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不出错，通常先调用fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，所以这就保证了子进程不是一个进程组的组长

* 控制终端
对话期和进程组有一些其他特性:
+ 一个对话期可以有一个单独的控制终端，这通常是在其上登录的终端设备或伪终端设备
+ 控制进程：建立与控制终端连接的对话期首进程
+ 一个对话期中的几个进程组可被分成一个前台进程组以及一个或几个后台进程组
+ 无论何时键入中断键(常常是Ctrl-C)或退出键(常常是Ctrl-\)，就会造成将中断信号或退出信号送至前台进程组的所有进程
+ 如果终端界面检测到调制解调器已经脱开连接，则将挂断信号送至控制进程(对话期首进程)

这些特性示于图9-7中：
#+ATTR_HTML: image :width 90% 
[[file:pic/terminal.png]]

通常不必担心控制终端，登录时将自动建立控制终端

有时不管标准输入、标准输出是否重新定向，程序都要与控制终端交互作用。保证程序读写控制终端的方法是打开文件/dev/tty，在内核中，此特殊文件是控制终端的同义语。自然，如果程序没有控制终端，则打开此设备将失败

典型的例子是用于读口令的getpass(3)函数(终端回送被关闭)，这一函数由crypt(1)程序调用，而此程序则可用于管道中。例如将文件salaries解密，然后经由管道将输出送至打印程序：
#+BEGIN_SRC sh
$ crypt < salaries | lpr
#+END_SRC
因为crypt从其标准输入读取salaries文件，所以标准输入不能用于输入口令。但是crypt的一个设计特征是每次运行此程序时，都会从控制终端/dev/tty读取加密口令，这样也就不需要将口令存放在文件中

** tcgetpgrp, tcsetpgrp
+ tcgetpgrp：返回拥有控制终端的前台进程组的组ID
+ tcsetpgrp：设置控制终端的前台进程组的组ID
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>

  /**
     返回某个文件描述符相关联的控制终端的前台进程组的组ID

     filedes：文件描述符

     return：若成功则为前台进程组ID，若出错则为-1
  ,*/
  pid_t tcgetpgrp(int filedes);

  /**
     设置filedes所打开的控制终端的前台进程组ID为pgrpid

     filedes：与某个tty相关联的文件描述符
     pgrpid：某个tty下的一个对话期中的一个进程组的ID

     return：成功返回0，失败返回-1
  ,*/
  int tcsetpgrp(int filedes, pid_t pgrpid);
#+END_SRC
这两个函数用来通知内核哪一个进程组是前台进程组，而内核中的终端设备驱动程序也能知道将终端输入和终端产生的信号送到何处

只有支持作业控制，这两个函数才被定义，否则直接报错

* 作业控制
