#+TITLE: 信号
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: proc_group.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil

信号是软件中断，提供了一种处理异步事件的方法：例如终端用户键入中断键，则会通过信号机制停止一个程序

UNIX的早期版本，就已经有信号机制，但是这些系统所提供的信号模型并不可靠。信号可能被丢失，而且在执行临界区代码时，进程很难关闭所选择的信号。4.3BSD和SVR3对信号模型都作了更改，增加了可靠信号机制。但是这两种更改之间并不兼容。幸运的是POSIX.1对可靠信号例程进行了标准化

本章先对信号机制进行综述，并说明每种信号的一般用法。然后分析早期实现的问题，最后说明解决这些问题的方法

* 基础概念
每个信号都有一个名字，这些名字都以三个字符SIG开头。例如，SIGABRT是异常终止信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，当由alarm函数设置的时间已经超过后产生此信号。SVR4和4.3+BSD均有31种不同的信号

在头文件<signal.h>中，这些信号都被定义为正整数(信号编号)。没有一个信号其编号为0，因为信号编号0有特殊的应用，POSIX.1将此种信号编号值称为空信号

** 信号产生条件
很多条件可以产生一个信号：
+ 当用户按某些特殊键时产生信号，在终端上按DELETE键通常产生中断信号(SIGINT)。这是停止一个已失去控制程序的方法
+ 硬件异常产生信号：除数为0、无效的存储访问等等。这些条件通常由硬件检测到，并将其通知内核，然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无效存储访问的进程产生一个SIGSEGV
+ 进程用kill(2)系统调用可将信号发送给另一个进程或进程组。自然有些限制：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户
+ 用户可用kill(1)命令将信号发送给其他进程，这是是kill系统调用的命令，常用此命令终止一个失控的后台进程
+ 当检测到某种软件条件已经发生，并将其通知有关进程时也产生信号。这里并不是指硬件产生条件(如被0除)，而是软件条件。例如SIGURG(在网络连接上传来非规定波特率的数据)、SIGPIPE(在管道的读进程已终止后一个进程写此管道)，以及SIGALRM(进程所设置的闹钟时间已经超时)

** 信号处理
信号是异步事件的经典实例，产生信号的事件对进程而言是随机出现的，进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号：大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略，它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是为了向超级用户提供一种使进程终止或停止的可靠方法。另外如果忽略某些由硬件异常产生的信号(例如非法存储访问或除以0)，则进程的行为是未定义的
2. 捕捉信号：为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。例如，若编写一个命令解释器，当用户用键盘产生中断信号时，很可能希望返回到程序的主循环，终止系统正在为该用户执行的命令。如果捕捉到SIGCHLD信号，则表示子进程已经终止，所以此信号的捕捉函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。又例如，如果进程创建了临时文件，那么可能要为SIGTERM信号编写一个信号捕捉函数以清除临时文件(kill命令传送的系统默认信号是终止信号)
3. 执行系统默认动作：表10-1给出了对每一种信号的系统默认动作。注意，对大多数信号的系统默认动作是终止该进程

** 常见信号
表10-1列出所有信号的名字，说明，以及对于信号的系统默认动作，作业表示这是作业控制信号(仅当支持作业控制时，才要求此种信号)：
  #+CAPTION: UNIX信号
  #+ATTR_HTML: :border 1 :rules all :frame boader
| 名字      | 说明             | 默认           | 支持系统      |
| SIGABRT   | 异常终止(abort)  | 终止+core      | ANSIC + POSIX |
| SIGALRM   | 超时(alarm)      | 终止           | POSIX         |
| SIGBUS    | 硬件故障         | 终止+core      |               |
| SIGCHLD   | 子进程状态改变   | 忽略           | 作业          |
| SIGCONT   | 使得暂停进程继续 | 继续/忽略      | 作业          |
| SIGEMT    | 硬件故障         | 终止+core      |               |
| SIGFPE    | 算术异常         | 终止+core      | ANSIC + POSIX |
| SIGHUP    | 链接断开         | 终止           | POSIX         |
| SIGILL    | 非法硬件指令     | 终止+core      | ANSIC + POSIX |
| SIGINT    | 终端中断符       | 终止           | ANSIC + POSIX |
| SIGIO     | 异步IO           | 忽略/终止      |               |
| SIGIOT    | 硬件故障         | 终止+core      |               |
| SIGKILL   | 终止             | 终止           | POSIX         |
| SIGPIPE   | 写入无读进程管道 | 终止           | POSIX         |
| SIGPOLL   | 可轮询事件       | 终止           | SVR4          |
| SIGPROF   | profile时间超时  | 终止           |               |
| SIGPWR    | 电源失效/重启    | 忽略           | SVR4          |
| SIGQUIT   | 终端退出符       | 终止+core      | POSIX         |
| SIGSEGV   | 无效内存引用     | 终止+core      | ANSIC + POSIX |
| SIGSTOP   | 停止             | 暂停           | 作业          |
| SIGSYS    | 无效系统调用     | 终止+core      |               |
| SIGTERM   | 终止             | 终止           | ANSIC + POSIX |
| SIGTRAP   | 硬件故障         | 终止+core      |               |
| SIGTSTP   | 终端停止符       | 暂停           | 作业          |
| SIGTTIN   | 后端读取tty      | 暂停           | 作业          |
| SIGTTOUT  | 后端写tty        | 暂停           | 作业          |
| SIGURG    | 紧急数据         | 忽略           |               |
| SIGUSR1   | 用户自定义1      | 终止           | POSIX         |
| SIGUSR2   | 用户自定义2      | 终止           | POSIX         |
| SIGVTALRM | 虚拟时间闹钟 | 终止         |               |
| SIGWINCH  | 终端窗口大小变化 | 忽略         |               |
| SIGXCPU   | 超过CPU限制  | 终止+core/忽略 |               |
| SIGXFSZ   | 超过文件长度限制 | 终止+core/忽略 |               |

*** core文件
在系统默认动作列，“终止+core”表示在进程当前工作目录的core文件中复制了该进程的存储图像。大多数UNIX调试程序都使用core文件以检查进程在终止时的状态。在下列条件下不产生core文件: 
+ 进程是设置-用户-ID，而且当前用户并非程序文件的所有者
+ 进程是设置-组-ID，而且当前用户并非该程序文件的组所有者
+ 用户没有写当前工作目录的许可权
+ 文件太大(RLIMIT_CORE)

core文件的许可权通常是用户读/写，组读和其他读

*** 常用信号说明
+ SIGABRT：调用abort函数时产生此信号，进程异常终止
+ SIGALRM：超过用alarm函数设置的时间时产生此信号，若由setitimer(2)函数设置的间隔时间已经过时，那么也产生此信号
+ SIGBUS：一个实现定义的硬件故障
+ SIGCHLD：在一个进程终止或停止时，SIGCHLD信号被送给其父进程。按系统默认，将忽略此信号。如果父进程希望了解其子进程的这种状态改变，则应捕捉此信号。信号捕捉函数中通常要调用wait函数以取得子进程ID和其终止状态
+ SIGCONT：作业控制信号，送给需要继续运行的处于停止状态的进程。如果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行，否则默认动作是忽略此信号。例如vi编辑程序在捕捉到此信号后，重新绘制终端屏幕
+ SIGEMT：一个实现定义的硬件故障
+ SIGFPE：一个算术运算异常，例如除以0，浮点溢出等
+ SIGHUP：如果终端界面检测到一个连接断开，则将此信号送给与该终端相关的控制进程。此信号被送给session结构中s_leader字段所指向的进程。仅当终端的CLOCAL标志没有设置时，在上述条件下才产生此信号
  注意：接到此信号的对话期首进程可能在后台，这区别于通常由终端产生的信号(中断、退出和挂起)，这些信号总是传递给前台进程组。如果对话期前进程终止，则也产生此信号。在这种情况，此信号送给前台进程组中的每一个进程

  通常用此信号通知精灵进程以再读它们的配置文件。选用SIGHUP的理由是：因为一个精灵进程不会有一个控制终端，而且通常决不会接收到这种信号
+ SIGILL：进程已执行一条非法硬件指令
+ SIGINFO：一种4.3+BSD信号，当用户按状态键(一般采用Ctrl-T)时，终端驱动程序产生此信号并送至前台进程组中的每一个进程(见图9-8)。此信号通常造成在终端上显示前台进程组中各进程的状态信息
+ SIGINT：当用户按中断键(一般采用DELETE或Ctrl-C)时，终端驱动程序产生此信号并送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它
+ SIGIO：一个异步I/O事件发生
+ SIGIOT：一个实现定义的硬件故障
+ SIGKILL：两个不能被捕捉或忽略信号中的一个，它向系统管理员提供了一种可以杀死任一进程的可靠方法
+ SIGPIPE：如果在读进程已终止时写管道，则产生此信号，当套接口的一端已经终止时，若进程写该套接口也产生此信号
+ SIGPOLL：SVR4信号，当在一个可轮询设备上发生一特定事件时产生此信号，它与4.3+BSD的SIGIO和SIGURG信号类似
+ SIGPROF：当setitimer(2)函数设置的统计间隔时间已经超过时产生
+ SIGPWR：SVR4信号，它依赖于系统。它主要用于具有不间断电源(UPS)的系统上
  如果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下，系统依靠蓄电池电源继续运行，所以无须作任何处理。但是如果蓄电池也将不能支持工作，则软件通常会再次接到通知，此时，它在15~30秒内使系统各部分都停止运行。此时应当传递SIGPWR信号。在大多数系统中使接到蓄电池电压过低的进程将信号SIGPWR发送给init进程，然后由init处理停机操作。很多系统init实现在inittab文件中提供了两个记录项用于此种目的：powerfail以及powerwait 
  目前已能获得低价格的UPS系统，它用RS-232串行连接能够很容易地将蓄电池电压过低的条件通知系统，于是这种信号也就更加重要了
+ SIGQUIT：当用户在终端上按退出键(一般采用Ctrl-\)时，产生此信号，并送至前台进程组中的所有进程。此信号不仅终止前台进程组(如SIGINT所做的那样)，同时产生一个core文件
+ SIGSEGV：进程进行了一次无效的内存访问
+ SIGSTOP：作业控制信号，它停止一个进程。它类似于交互停止信号(SIGTSTP)，两个不能被捕捉或忽略信号中的一个
+ SIGSYS：一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，但其指示系统调用类型的参数却是无效的
+ SIGTERM：由kill(1)命令发送的系统默认终止信号
+ SIGTRAP：一个实现定义的硬件故障
+ SIGTSTP：交互停止信号，当用户在终端上按挂起键(一般采用Ctrl-Z)时，终端驱动程序产生此信号
+ SIGTTIN：当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。在下列例外情形下不产生此信号，此时读操作返回出错，errno设置为EIO：
  1. 读进程忽略或阻塞此信号
  2. 读进程所属的进程组是孤儿进程组 
+ SIGTTOU：当一个后台进程组进程试图写其控制终端时产生此信号。与上面所述的SIGTTIN信号不同，一个进程可以选择为允许后台进程写控制终端。如果不允许后台进程写，在这两种情况下不产生此信号，写操作返回出错，errno设置为EIO：
  1. 写进程忽略或阻塞此信号
  2. 写进程所属进程组是孤儿进程组

不论是否允许后台进程写，某些除写以外的下列终端操作也能产生此信号：tcsetattr，tcsendbreak，tcdrain，tcflush，tcflow以及tcsetpgrp
+ SIGURG：通知进程已经发生一个紧急情况。在网络连接上，接到非规定波特率的数据时，此信号可选择地产生
+ SIGUSR1：一个用户定义的信号，可用于应用程序
+ SIGUSR2：这是一个用户定义的信号，可用于应用程序
+ SIGVTALRM：当一个由setitimer(2)函数设置的虚拟间隔时间已经超过时产生此信号
+ SIGWINCH：SVR4和4.3+BSD内核保持与每个终端或伪终端相关联的窗口的大小，一个进程可以用ioctl函数得到或设置窗口的大小。如果一个进程用ioctl的设置-窗口-大小命令更改了窗口大小，则内核将SIGWINCH信号送至前台进程组
+ SIGXCPUS：如果进程超过了其软CPU时间限制，则产生此信号
+ SIGXFSZ：如果进程超过了其软文件长度限制，则产生此信号

* signal函数
signal函数：为某个特定信号设置处理函数
#+BEGIN_SRC C
  #include <signal.h>
  /**
     声明sighandler_t是一个函数指针类型，其参数是一个int，没有返回值的函数指针
  ,*/
  typedef void (*sighandler_t)(int);
  /**
     为信号signo注册一个特定的处理函数handler

     signo：信号编号
     handler：函数指针，参数是一个int类型，无返回值。SIG_IGN：忽略指定信号、SIG_DFL：系统默认处理信号、或者是自定义信号处理函数的地址

     return：成功则为之前的信号处理函数，若出错则为SIG_ERR
  ,*/
  sighandler_t signal(int signo, sighandler_t handler);

  void (*signal(int signo, void (*handler)(int))(int);
#+END_SRC

signal函数要求两个参数：
+ 第一个参数signo：一个整型数，表10-1中的信号名
+ 第二个参数handler：一个函数指针，它指向的函数需要一个整型参数，无返回值，其含义是指向要设置的信号处理函数的指针
  + 常数SIG_IGN：内核表示忽略此信号，SIGKILL和SIGSTOP不能忽略
  + 常数SIG_DFL：系统默认动作
  + 接到信号后要调用的函数的地址：此函数为信号处理程序或信号捕捉函数，调用此函数为捕捉信号

signal的返回值也是一个函数指针，指向的函数需要一个整形参数，无返回值，其含义是指向以前的信号处理函数的指针

#+BEGIN_SRC C
  /* Fake signal functions.  */
  #define SIG_ERR ((__sighandler_t) -1)       /* Error return.  */
  #define SIG_DFL ((__sighandler_t) 0)        /* Default action.  */
  #define SIG_IGN ((__sighandler_t) 1)        /* Ignore signal.  */

  #define SIG_ERR (void (*)()) -1
  #define SIG_DFL (void (*)()) 0
  #define SIG_IGN (void (*)()) 1 
#+END_SRC
这些常数可用于表示"指向函数的指针，该函数要一个整型参数，而且无返回值"。signal的第二个参数及其返回值就可用它们表示。这些常数所使用的三个值不一定要是-1，0和1。它们必须是三个值而决不能是任一可说明函数的地址。大多数UNIX系统使用上面所示的值

** signal实例
捕捉两个用户定义的信号并打印信号编号：
    #+BEGIN_SRC C
      #include <signal.h>
      #include "apue.h"

      //信号处理函数，一个函数对应两个信号SIGUSR1和SIGUSR2
      static void sig_usr(int);

      int main(void) 
      {
              //注册信号处理函数
              if ( SIG_ERR == signal(SIGUSR1, sig_usr))
                      err_sys("can't catch signal SIG_USR1");
              if( SIG_ERR == signal(SIGUSR2, sig_usr))
                      err_sys("can't catch signal SIG_USR2");

              for (; ; )
                      pause();
              
      }

      static void sig_usr(int signo)
      {
              if (SIGUSR1 == signo)
                      printf("received SIGUSR1\n");
              else if (SIGUSR2 == signo)
                      printf("received SIGUSR2\n");
              else
                      err_dump("received signal %d \n", signo);
              return ;
              
      }
    #+END_SRC

测试结果：
#+BEGIN_SRC sh
  $ ./src/signal/sigusr1 & #后台启动进程
  [1] 10225 # 支持作业控制shell打印作业号和进程号

  $ kill -USR1 10225 # 向进程发送信号SIGUSR1 
  received SIGUSR1

  $ kill -USR2 10225 # 向进程发送信号SIGUSR2
  received SIGUSR2

  $ kill 10225 #　向进程发送信号SIGTERM
  [1]+  Terminated ./src/signal/sigusr1
#+END_SRC
当向该进程发送SIGTERM信号后，该进程就终止，因为它不捕捉此信号，而对此信号的系统默认动作是终止

** exec启动程序
当执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为系统默认动作，除非调用exec的进程忽略该信号

exec函数将原先设置为要捕捉的信号都更改为默认动作，其他信号的状态则不变。一个进程原先要捕捉的信号，当其执行一个新程序后，就自然地不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义

对于一个非作业控制shell，当在后台执行一个进程时，例如：
#+BEGIN_SRC sh
  $ cc main.c &
#+END_SRC
shell自动将后台进程中对中断和退出信号的处理方式设置为忽略，于是当按中断键时就不会影响到后台进程。如果没有这样的处理，那么当按中断键时，它不但终止前台进程，也终止所有后台进程

很多捕捉这两个信号的交互程序具有下列形式的代码:
#+BEGIN_SRC C
  void sig_int(int);
  void sig_quit(int);

  if (signal(SIGINT, SIG_IGN) != SIG_IGN)
          signal(SIGINT, sig_int);
  if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
          signal(SIGQUIT, sig_quit);
#+END_SRC
这样处理后，仅当SIGINT和SIGQUIT当前并不忽略，进程才捕捉它们

从signal的这两个调用中也可以看到这种函数的限制：只有通过改变信号的处理方式就才能获得信号的当前处理方式

** fork创建进程
当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程存储图像，所以信号捕捉函数的地址在子进程中是有意义的

* 不可靠性
在早期的UNIX版本中(例如V7)，信号是不可靠的。不可靠：一个信号发生了，但进程却可能不知道这个信号
** 丢失信号
早期版本中的一个问题是在进程每次处理信号时，随即将信号动作复置为默认值，因此早期的信号处理如下：
#+BEGIN_SRC C
  static int sig_int();
  //...
  signal(SIGINT, sig_int);
  //...

  int sig_int(int signo)
  {
          //此时SIGINT信号处理动作已经恢复成默认，必须再次注册sig_int函数
          signal(SIGINT, sig_int);
          //处理SIGINT信号
  }
#+END_SRC
问题在于：在信号发生之后到信号处理程序中调用signal函数之间有一个时间窗口。在此段时间中可能发生另一次同样中断信号，第二个信号会造成执行默认动作，而对中断信号则是终止该进程！

** 无法阻塞信号
那时进程对信号的控制能力也很低，它能捕捉信号或忽略它，但有些很需要的功能它却并不具备。例如，有时用户希望通知内核阻塞一种信号：不要忽略该信号，在其发生时记住它，然后在进程作好了准备时再通知它。这种阻塞信号的能力当时并不具备。同样内核也无法关闭某种信号，只能忽略它　

主函数调用pause函数使自己睡眠，直到捕捉到一个信号。当信号被捕捉到后，信号处理程序将标志sig_int_flag设置为非0。在信号处理程序返回之后，内核将该进程唤醒，它检测到该标志为非0，然后执行它所需做的
#+BEGIN_SRC C
  int sig_int_flag = 0; //如果捕捉到SIGINT信号，则非0
  int sig_int(int);  //SIGINT信号处理函数

  int main()
  {
          //注册SIGINT信号处理函数
          signal(SIGINT, sig_int);

          //...
          
          while(sig_int_flag == 0)
                  pause();//一直睡眠直到某个信号发生
          //...
  }

  int sig_int(int signo)
  {
          //再次注册信号处理函数
          signal(SIGINT, sig_int);

          //设置标志变量，使得main函数离开while循环
          sig_int_flag = 1;
  }
#+END_SRC
问题在于：如果在测试sig_int_flag之后，调用pause之前发生信号，此时sig_int_flag已经变为1，但是程序还是会调用pause，如果以后再无此信号发生，则此进程可能会一直睡眠，因此这次发生的信号也就丢失了！

这种类型的程序段在大多数情况下会正常工作，使得我们认为它们正确，而实际上却并不是如此

* 可中断的系统调用
早期UNIX系统的一个特性是：如果在进程执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为EINTR。这样处理的理由是因为一个信号发生了，进程捕捉到了它，这意味着已经发生了某种事情，所以是个好机会应当唤醒阻塞的系统调用

系统调用分成两类：低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的一类系统调用，它们包括:
+ 在读某些类型的文件时，如果数据并不存在则可能会使调用者永远阻塞。例如管道、终端设备以及网络设备
+ 在写这些类型的文件时，如果不能立即接受这些数据，则也可能会使调用者永远阻塞
+ 打开文件，在某种条件发生之前也可能会使调用者阻塞。例如，打开终端设备，它要等待直到所连接的调制解调器回答了电话
+ pause(调用进程睡眠直至捕捉到一个信号)和wait
+ 某些ioctl操作
+ 某些进程间通信函数

在这些低速系统调用中一个例外是与磁盘I/O有关的系统调用。虽然读、写一个磁盘文件可能暂时阻塞调用者(在磁盘驱动程序将请求排入队列，然后在适当时间执行请求期间)，但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态。

使用中断系统调用这种方法来处理的一种情况是：一个进程起动了读终端操作，而使用该终端设备的用户却离开该终端很长时间。在这种情况下进程可能处于阻塞状态几个小时甚至数天，除非系统停机，否则一直如此

必须用显式方法处理可中断的系统调用带来的出错返回。典型的代码序列，假定进行一个读操作，它被中断，我们希望重新起动它如下列样式：
#+BEGIN_SRC C
  again:
  if ((n = read(fd, buff, BUFFSIZE)) < 0) {
          if (errno == EINTR)
                  goto again;
  /* just an interrupted system call */
  /* handle other errors */
  }
#+END_SRC
为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引进了某些被中断的系统调用的自动再起动。自动再起动的系统调用包括:ioctl、read、readv、write、writev、wait和waitpid。正如前述，其中前五个函数只有对低速设备进行操作时才会被信号中断。而wait和waitpid在捕捉到信号时总是被中断

某些应用程序并不希望这些函数被中断后再起动，因为这种自动再起动的处理方式也会带来问题，为此4.3BSD允许进程在每个信号各别处理的基础上不使用此功能

4.2BSD引进自动再起动功能的一个理由是：有时用户并不知道所使用的输入、输出设备是否是低速设备。如果编写的程序可以用交互方式运行，则它可能读、写终端低速设备。如果在程序中捕捉信号，而系统却不提供再起动功能，则对每次读、写系统调用就要进行是否出错返回的测试，如果是被中断的，则再进行读、写

表10-2列出了几种实现所提供的信号功能及它们的语义
  +--------------------------------+----------+----------+----------+------------+
  |                                |          | 信号处理 | 阻塞信号 | 被中断系统 |
  |            函数                |   系统   |  函数是否|   的能力 |    调用的再|
  |                                |          | 再包装   |          |  启动      |
  +--------------------------------+----------+----------+----------+------------+
  |                                |  V7, SVR2|          |          |            |
  |            signal              |  SVR3,   |          |          |   决不     |
  |                                |  SVR4    |          |          |            |
  +--------------------------------+----------+----------+----------+------------+
  |   sigset, sighold, sigrelse,   |  SVR3,   |          |          |            |
  |                                |          |    •     |    •     |   决不     |
  |     sigignore, sigpause        |  SVR4    |          |          |            |
  +--------------------------------+----------+----------+----------+------------+
  |   signal, sigvec, sigblock,    |  4.2BSD  |    •     |    •     |   总是     |
  |                                +----------+----------+----------+------------+
  |   sigsetmask, sigpause         |  4.3BSD  |    •     |    •     |   默认     |
  +--------------------------------+----------+----------+----------+------------+
  |                                |  POSIX.1 |    •     |    •     |   未说明   |
  |   sigaction, sigprocmask,      +----------+----------+----------+------------+
  |                                |   SVR4   |    •     |    •     |    可选    |
  |   sigpending, sigsuspend       +----------+----------+----------+------------+
  |                                |  4.3BSD  |    •     |    •     |    可选    |
  +--------------------------------+----------+----------+----------+------------+

* 可再入函数
进程捕捉到信号并继续执行时，它首先执行该信号处理程序中的指令。如果从信号处理程序正常返回(例如没有调用exit或longjmp)，则继续执行在捕捉到信号时进程正在执行的正常指令序列

但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。如果进程正在执行malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号插入执行该信号处理程序，其中又调用malloc，这时会发生什么？又比如进程正在执行getpwnam这种将其结果存放在静态存储单元中的函数，而插入执行的信号处理程序中又调用这样的函数，这时又会发生什么呢？在malloc例子中，可能会对进程造成破坏，因为malloc通常为它所分配的存储区保持一个连接表，而插入执行信号处理程序时，进程可能正在更改此连接表。而在getpwnam的例子中，正常返回给调用者的信息可能由返回至信号处理程序的信息覆盖

函数是不可再入的原因为：
+ 使用静态数据结构
+ 调用malloc或free函数
+ 标准I/O函数，标准I/O库的很多实现都以不可再入方式使用全局数据结构

信号处理程序中即使调用了POSIX定义的可再入的函数，但因为每个进程只有一个errno变量，所以仍可能修改了其原先的值。一个信号处理程序，它恰好在main刚设置errno之后被调用。如果该信号处理程序调用read，则它可能更改errno的值，从而取代了刚由main设置的值。因此，作为一个通用的规则，应当在信号处理程序前保存，而在其后恢复errno

** 信号处理函数中调用不可再入函数
信号处理程序my_alarm调用不可再入函数getpwnam，而my_alarm每秒钟被调用一次：
#+BEGIN_SRC C
  #include "apue.h"
  #include <pwd.h>

  static void my_alarm(int signo)
  {
          struct passwd *rootptr;

          printf("in signal handler\n");
          if ((rootptr = getpwnam("root")) == NULL)
                  err_sys("getpwnam(root) error");
          alarm(1);
  }

  int main(void)
  {
          struct passwd   *ptr;

          signal(SIGALRM, my_alarm);
          alarm(1);
          for ( ; ; ) {
                  if ((ptr = getpwnam("sar")) == NULL)
                          err_sys("getpwnam error");
                  if (strcmp(ptr->pw_name, "sar") != 0)
                          printf("return value corrupted!, pw_name = %s\n",
                                 ptr->pw_name);
          }
  }
#+END_SRC
运行此程序时，其结果具有随意性：通常在信号处理程序第一次返回时，该程序将由SIGSEGV信号终止。检查core文件，从中可以看到main函数已调用getpwnam，而且当信号处理程序调用此同一函数时，某些内部指针出了问题。偶然，此程序会运行若干秒，然后因产生SIGSEGV信号而终止。在捕捉到信号后，若main函数仍正确运行，其返回值却有时错误，有时正确。有时在信号处理程序中调用getpwnam会出错返回，其出错值为EBADF(无效文件描述符)

从此实例中可以看出：若在信号处理程序中调用一个不可再入函数，则其结果是不可预见的！

* 可靠信号机制
