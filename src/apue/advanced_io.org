#+TITLE: 高级IO
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: signal.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章内容包括：
+ 非阻塞IO
+ SVR4的流机制
+ IO多路转接(select和poll函数)
+ readv和writev函数
+ 存储映照I/O(mmap)
+ 记录锁
  
接下来的进程间通信(IPC)要使用这里所述的很多概念和函数
* 非阻塞IO
  在上一章曾将系统调用分成两类：低速系统调用和其他。低速系统调用是可能会使进程永远阻塞的一类系统调用，比如读写未准备好的伪终端，网络，管道等
  
  虽然读、写磁盘文件会使调用在短暂时间内阻塞，但并不能将它们视为“低速”。
  
  非阻塞I/O：是使调用不会永远阻塞的I/O操作，如果这种操作不能完成，则立即出错返回，表示该操作如继续执行将继续阻塞下去
  
  对于一个给定的描述符有两种方法对其指定非阻塞I/O: 
1. 如果是调用open以获得该描述符，则可指定O_NONBLOCK标志
2. 对于已经打开的一个描述符，则可调用fcntl打开O_NONBLOCK文件状态标志
   
对于一个非阻塞的文件描述符，如果没有数据可读写，则read和write将直接返回-1，并设置errno为EAGAIN
** 轮询
   下面程序从标准输入读100000字节，并试图将它们写到标准输出上。该程序先将标准输出设置为非阻塞的，然后用轮询进行输出，每次写的结果都在标准出错上打印。函数clr-fl清除一个或多个标志位：
   #+BEGIN_SRC C
  #include <errno.h>
  #include <fcntl.h>
  #include "apue.h"

  char buf[100000];

  int main(void)
  {
          int ntowrite, nwrite;
          char *ptr;

          ntowrite = read(STDIN_FILENO, buf, sizeof(buf));
          fprintf(stderr, "read %d bytes\n", ntowrite);

          set_fl(STDOUT_FILENO, O_NONBLOCK);  /* set nonblocking */

          ptr = buf;
          while (ntowrite > 0) {
                  errno = 0;
                  nwrite = write(STDOUT_FILENO, ptr, ntowrite);
                  fprintf(stderr, "nwrite = %d, errno = %d\n", nwrite, errno);

                  if (nwrite > 0) {
                          ptr += nwrite;
                          ntowrite -= nwrite;
                  }
          }

          clr_fl(STDOUT_FILENO, O_NONBLOCK);  /* clear nonblocking */

          exit(0);
  }
   #+END_SRC
   
   注意：在linux上的测试结果显示并没有如想象中的调用多次非阻塞写操作，而是只有一次写操作
   
   虽然关于非阻塞IO内容可能已经过时，但是程序中出现的轮询却还一直被用在各种非阻塞操作中。轮询往往会导致浪费CPU时间，一种更加有效的方法是使用非阻塞描述符的I/O多路转接
   
* 流机制
  除了SVR4及其后代如Solaris之外流机制并不是很常用，现在更多被使用的是BSD的socket机制
  
* I/O多路转接
  当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞I/O：
  #+BEGIN_SRC C
  while ( (n = read(STDIN_FILENO, buf, BUFSIZ)) > 0 )
          if( write(STDOUT_FILENO, buf, n) != n)
                  err_sys("write error");
  #+END_SRC
  这种形式的阻塞I/O到处可见。但是如果必须读两个描述符又将如何呢？　如果仍旧使用阻塞I/O，那么就可能长时间阻塞在一个描述符上，而另一个描述符虽有很多数据却不能得到及时处理。所以为了处理这种情况显然需要另一种不同的技术
  
  首先观察一个调制解调器拨号程序(telnet)的工作情况。该程序读终端(标准输入)，将所得数据写到调制解调器(telnetd)上，同时读调制解调器，将所得数据写到终端上(标准输出)。图12-1显示这种工作情况：
  #+ATTR_HTML: image :width 90% 
  [[file:pic/modem-dialer.gif]] 
  
** 读和写各使用一个进程
   处理这种特殊问题的一种方法是设置两个进程，每个进程处理一条数据通路。图12-2中显示了这种安排：
   #+ATTR_HTML: image :width 90% 
   [[file:pic/modem-processes.gif]] 
   
   如果使用两个进程，则可使每个进程都执行阻塞read。但是也产生了这两个进程间相互配合问题。如果子进程接收到文件结束符(由于电话线的一端已经挂断，使调制解调器也挂断)，那么该子进程终止，然后父进程接收到SIGCHLD信号。但是，如若父进程终止(用户在终端上键入了文件结束符)，那么父进程应通知子进程停止工作。为此可以使用一个信号(例如SIGUSR1)。这使程序变得更加复杂
   
** 使用非阻塞IO 
   另一个方式是仍旧使用一个进程执行该程序，但调用非阻塞I/O读取数据，其基本思想是：将两个输入描述符都设置为非阻塞的，对第一个描述符发一个read。如果该输入上有数据，则读数据并处理它。如果无数据可读，则read立即返回。然后对第二个描述符作用样的处理。在此之后，等待若干秒再读第一个描述符。这种形式的循环称为轮询。
   
   这种方法的不足之处是浪费CPU时间：
+ 大多数时间实际上是无数据可读，但是仍不断反复执行read，这浪费了CPU时间
+ 在每次循环后要等多长时间再执行下一轮循环也很难确定
  
轮询技术在支持非阻塞I/O的系统上都可使用，但是在多任务系统中应当避免使用

# ** 异步IO
# 还有一种技术称之为异步I/O，其基本思想是进程告诉内核，当一个描述符已准备好可以进行I/O时，用一个信号通知它。这种技术有两个问题：
# 1. 并非所有系统都支持这种机制，现在它还不是POSIX的组成部分。SVR4为此技术提供SIGPOLL信号，但是仅当描述符引用流设备时才能工作。4.3+BSD有一个类似的信号SIGIO，但是仅当描述符引用终端设备或网络时才能工作
# 2. 这种信号对每个进程而言只有1个。如果使该信号对两个描述符都起作用，那么在接到此信号时进程无法判别是哪一个描述符已准备好可以进行I/O。为了确定是哪一个描述符已准备好，仍需将这两个描述符都设置为非阻塞的，并顺序试执行I/O

** 多路转接
   一种比较好的技术是使用I/O多路转接，其基本思想是：先构造一张有关描述符的表，然后调用一个函数，它要到这些描述符中的一个已准备好进行I/O时才返回。 在返回时它告诉进程哪一个描述符已准备好可以进行I/O
   
*** select函数
    select函数可以在SVR4和4.3+BSD之下可以执行I/O多路转接，传向select的参数告诉内核:
+ 所关心的描述符
+ 对于每个描述符所关心的条件：是否读一个给定的描述符？是否想写一个给定的描述符？是否关心一个描述符的异常条件？等
+ 希望等待多长时间：永远等待，等待一个固定量时间，或完全不等待
   
从select返回时，内核告诉我们：
+ 已准备好的描述符的数量
+ 哪一个描述符已准备好读、写或异常条件
   
使用这种返回值，就可调用相应的I/O函数(一般是read或write)，并且确知该函数不会阻塞

#+BEGIN_SRC C
  #include <sys/select.h> 

  /**
     使用select函数进行IO多路转接

     maxfdp1：readfds, writefds, exceptfds三个描述符中大的fd值加1
     readfds：指向读文件描述符集的指针
     writefds：指向写文件描述符集的指针
     exceptfds：指向异常文件描述符集的指针
     tvptr：指向等待时间结构的指针

     return：准备就绪的描述符数字，若超时则为0，若出错则为-1
  ,*/
  int select(int maxfdp1,
             fd_set *readfds, fd_set *write_fds, fd_set *exceptfds,
             struct timeval *tvptr);
#+END_SRC

**** fd_set数据类型
     指向描述符集的指针：
+ readfds：关心的可读的各个描述符
+ writefds：关心的可写描述符号各个描述符
+ exceptfds：关心的处于异常条件的各个描述符
  
每个描述符集存放在一个fd_set数据类型中，这种数据类型的实现可见图12-9，它为每一可能的描述符保持了一位：
#+ATTR_HTML: image :width 90% 
[[file:pic/fd-set.jpg]] 

对fg_set数据类型可以进行的处理是:
+ 分配一个这种类型的变量
+ 将这种类型的一个变量赋与同类型的另一个变量
+ 对于这种类型的变量使用下列四个宏:
  #+BEGIN_SRC C
    int FD_ISSET(int fd, fd_set *set); // 测试某文件描述符对应的位是否被设置
    void FD_SET(int fd, fd_set *set); // 设置某文件描述符对应的位
    void FD_CLR(int fd, fd_set *set); // 清除某文件描述符对应的位
    void FD_ZERO(fd_set *set); //清除其所有位
  #+END_SRC
select中间三个参数中的任意一个(或全部)可以是空指针，这表示对相应条件并不关心。如果所有三个指针都是空指针，则select提供了较sleep更精确的计时器

**** maxfdp1参数
     第一个参数maxfdp1的意思是”最大fd加1“，在三个描述符集中找出最高描述符编号值，然后加1。也可将第一个参数设置为FD_SETSIZE，它说明了最大的描述符数(经常是256或1024)。但是对大多数应用程序而言此值太大了，大多数应用程序只使用3~10个描述符。如果将第三个参数设置为最高描述符编号值加1，内核就只需在此范围内寻找打开的位，而不必在数百位的大范围内搜索
     
     #+BEGIN_SRC C
  fd_set readset, writeset;
  FD_ZERO(&readset);
  FD_ZERO(&writeset);

  FD_SET(0, &readset);
  FD_SET(3, &readset);
  FD_SET(1, &writeset);
  FD_SET(2, &writeset);

  select(4, &readset, &writeset, NULL, NULL);
     #+END_SRC
     
     图12-10显示了这两个描述符集的情况：
     #+ATTR_HTML: image :width 90% 
     [[file:pic/fd-set-sample.jpg]] 
     
     因为描述符编号从0开始，所以要在最大描述符编号值上加1，实际上是要检查的描述符数量
     
**** timeval结构
     最后一个参数tvptr是一个指向timeval结构的指针，它指定愿意等待的时间：
     #+BEGIN_SRC C
       struct timeval{
               long tv_sec; /* seconds */
               long tv_usec; /* and microseconds */
       };
     #+END_SRC
     
     有以下三种情况：
+ 永远等待
#+BEGIN_SRC C
tvptr = NULL 
#+END_SRC
当所指定的描述符中的一个已准备好或捕捉到一个信号则返回，否则无限期等待

+ 完全不等待
#+BEGIN_SRC C
  tvptr->tv_sec = 0 && tvptr->tv_usec = 0
#+END_SRC
测试所有指定的描述符并立即返回。这是得到多个描述符的状态而不阻塞select函数的轮询方法

+ 等待指定的秒数和微秒数
#+BEGIN_SRC C
  tvptr->tv_sec !=0 || tvptr->tv_usec != 0
#+END_SRC
当指定的描述符之一已准备好，或当指定的时间值已经超过时立即返回，与第一种情况一样，等待可被捕捉到的信号中断

**** 返回值
     select有三个可能的返回值：
+ -1：出错，例如在所指定的描述符都没有准备好时捕捉到一个信号，并且errno设置为EINTR
+ 0：没有描述符准备好，而且指定的时间已经超过
+ >0：已经准备好的描述符数，在这种情况下三个描述符集中仍旧打开的位是对应于已准备好的描述符位
   
对于“准备好”的意思要作一些更具体的说明：
+ 若对读集中的一个描述符的read不会阻塞，则此描述符是准备好的
+ 若对写集中的一个描述符的write不会阻塞，则此描述符是准备好的
+ 若对异常条件集(exceptfds)中的一个描述符有一个未决异常条件，则此描述符是准备好的。而异常条件包括:
  - 在网络连接上到达指定波特率外的数据
  - 在处于数据包方式的伪终端上发生了某些条件
    
一个描述符阻塞与否并不影响select是否阻塞，也就是说如果希望读一个非阻塞描述符，并且以超时值为5秒调用select，则select最多阻塞5秒。相类似如果指定一个无限的超时值，则select阻塞到对该描述符数据准备好，或捕捉到一个信号

如果在一个描述符上碰到了文件结束，则select认为该描述符是可读的。然后调用read，它返回0，这是UNIX指示到达文件结尾处的方法。很多人错误地认为，当到达文件结尾处时，select会指示一个异常条件

**** pselect函数
     pselect函数是select的变体：
     #+BEGIN_SRC C
       #include <sys/select.h>

       int pselect(int nfds,
                   fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
                   const struct timespec *timeout,
                   const sigset_t *sigmask);
     #+END_SRC
     主要区别：
+ 定时采用了纳秒级的timespec结构
+ timespec参数声明为const
+ 使用信号集屏蔽不需要的信号
*** poll函数
    
* readv和writev
  
* mmap
  
* 记录锁
