#+TITLE: 高级IO
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: signal.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil
本章内容包括：
+ 非阻塞IO
+ SVR4的流机制
+ IO多路转接(select和poll函数)
+ readv和writev函数
+ 存储映照I/O(mmap)
+ 记录锁
  
接下来的进程间通信(IPC)要使用这里所述的很多概念和函数
* 非阻塞IO
  在上一章曾将系统调用分成两类：低速系统调用和其他。低速系统调用是可能会使进程永远阻塞的一类系统调用，比如读写未准备好的伪终端，网络，管道等
  
  虽然读、写磁盘文件会使调用在短暂时间内阻塞，但并不能将它们视为“低速”。
  
  非阻塞I/O：是使调用不会永远阻塞的I/O操作，如果这种操作不能完成，则立即出错返回，表示该操作如继续执行将继续阻塞下去
  
  对于一个给定的描述符有两种方法对其指定非阻塞I/O: 
1. 如果是调用open以获得该描述符，则可指定O_NONBLOCK标志
2. 对于已经打开的一个描述符，则可调用fcntl打开O_NONBLOCK文件状态标志
   
对于一个非阻塞的文件描述符，如果没有数据可读写，则read和write将直接返回-1，并设置errno为EAGAIN
** 轮询
   下面程序从标准输入读100000字节，并试图将它们写到标准输出上。该程序先将标准输出设置为非阻塞的，然后用轮询进行输出，每次写的结果都在标准出错上打印。函数clr-fl清除一个或多个标志位：
   #+BEGIN_SRC C
  #include <errno.h>
  #include <fcntl.h>
  #include "apue.h"

  char buf[100000];

  int main(void)
  {
          int ntowrite, nwrite;
          char *ptr;

          ntowrite = read(STDIN_FILENO, buf, sizeof(buf));
          fprintf(stderr, "read %d bytes\n", ntowrite);

          set_fl(STDOUT_FILENO, O_NONBLOCK);  /* set nonblocking */

          ptr = buf;
          while (ntowrite > 0) {
                  errno = 0;
                  nwrite = write(STDOUT_FILENO, ptr, ntowrite);
                  fprintf(stderr, "nwrite = %d, errno = %d\n", nwrite, errno);

                  if (nwrite > 0) {
                          ptr += nwrite;
                          ntowrite -= nwrite;
                  }
          }

          clr_fl(STDOUT_FILENO, O_NONBLOCK);  /* clear nonblocking */

          exit(0);
  }
   #+END_SRC
   
   注意：在linux上的测试结果显示并没有如想象中的调用多次非阻塞写操作，而是只有一次写操作
   
   虽然关于非阻塞IO内容可能已经过时，但是程序中出现的轮询却还一直被用在各种非阻塞操作中。轮询往往会导致浪费CPU时间，一种更加有效的方法是使用非阻塞描述符的I/O多路转接
   
* 流机制
  除了SVR4及其后代如Solaris之外流机制并不是很常用，现在更多被使用的是BSD的socket机制
  
* I/O多路转接
  当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞I/O：
  #+BEGIN_SRC C
  while ( (n = read(STDIN_FILENO, buf, BUFSIZ)) > 0 )
          if( write(STDOUT_FILENO, buf, n) != n)
                  err_sys("write error");
  #+END_SRC
  这种形式的阻塞I/O到处可见。但是如果必须读两个描述符又将如何呢？　如果仍旧使用阻塞I/O，那么就可能长时间阻塞在一个描述符上，而另一个描述符虽有很多数据却不能得到及时处理。所以为了处理这种情况显然需要另一种不同的技术
  
  首先观察一个调制解调器拨号程序(telnet)的工作情况。该程序读终端(标准输入)，将所得数据写到调制解调器(telnetd)上，同时读调制解调器，将所得数据写到终端上(标准输出)。图12-1显示这种工作情况：
  #+ATTR_HTML: image :width 90% 
  [[file:pic/modem-dialer.gif]] 
  
** 读和写各使用一个进程
   处理这种特殊问题的一种方法是设置两个进程，每个进程处理一条数据通路。图12-2中显示了这种安排：
   #+ATTR_HTML: image :width 90% 
   [[file:pic/modem-processes.gif]] 
   
   如果使用两个进程，则可使每个进程都执行阻塞read。但是也产生了这两个进程间相互配合问题。如果子进程接收到文件结束符(由于电话线的一端已经挂断，使调制解调器也挂断)，那么该子进程终止，然后父进程接收到SIGCHLD信号。但是，如若父进程终止(用户在终端上键入了文件结束符)，那么父进程应通知子进程停止工作。为此可以使用一个信号(例如SIGUSR1)。这使程序变得更加复杂
   
** 使用非阻塞IO 
   另一个方式是仍旧使用一个进程执行该程序，但调用非阻塞I/O读取数据，其基本思想是：将两个输入描述符都设置为非阻塞的，对第一个描述符发一个read。如果该输入上有数据，则读数据并处理它。如果无数据可读，则read立即返回。然后对第二个描述符作用样的处理。在此之后，等待若干秒再读第一个描述符。这种形式的循环称为轮询。
   
   这种方法的不足之处是浪费CPU时间：
+ 大多数时间实际上是无数据可读，但是仍不断反复执行read，这浪费了CPU时间
+ 在每次循环后要等多长时间再执行下一轮循环也很难确定
  
轮询技术在支持非阻塞I/O的系统上都可使用，但是在多任务系统中应当避免使用

** 多路转接
   一种比较好的技术是使用I/O多路转接，其基本思想是：先构造一张有关描述符的表，然后调用一个函数，它要到这些描述符中的一个已准备好进行I/O时才返回。 在返回时它告诉进程哪一个描述符已准备好可以进行I/O
   
*** select函数
    select函数可以在SVR4和4.3+BSD之下可以执行I/O多路转接，传向select的参数告诉内核:
+ 所关心的描述符
+ 对于每个描述符所关心的条件：是否读一个给定的描述符？是否想写一个给定的描述符？是否关心一个描述符的异常条件？等
+ 希望等待多长时间：永远等待，等待一个固定量时间，或完全不等待
   
从select返回时，内核告诉我们：
+ 已准备好的描述符的数量
+ 哪一个描述符已准备好读、写或异常条件
   
使用这种返回值，就可调用相应的I/O函数(一般是read或write)，并且确知该函数不会阻塞

#+BEGIN_SRC C
  #include <sys/select.h> 

  /**
     使用select函数进行IO多路转接

     maxfdp1：readfds, writefds, exceptfds三个描述符中大的fd值加1
     readfds：指向读文件描述符集的指针
     writefds：指向写文件描述符集的指针
     exceptfds：指向异常文件描述符集的指针
     tvptr：指向等待时间结构的指针

     return：准备就绪的描述符数字，若超时则为0，若出错则为-1
  ,*/
  int select(int maxfdp1,
             fd_set *readfds, fd_set *write_fds, fd_set *exceptfds,
             struct timeval *tvptr);
#+END_SRC

**** fd_set数据类型
     指向描述符集的指针：
+ readfds：关心的可读的各个描述符
+ writefds：关心的可写描述符号各个描述符
+ exceptfds：关心的处于异常条件的各个描述符
  
每个描述符集存放在一个fd_set数据类型中，这种数据类型的实现可见图12-9，它为每一可能的描述符保持了一位：
#+ATTR_HTML: image :width 90% 
[[file:pic/fd-set.jpg]] 

对fg_set数据类型可以进行的处理是:
+ 分配一个这种类型的变量
+ 将这种类型的一个变量赋与同类型的另一个变量
+ 对于这种类型的变量使用下列四个宏:
  #+BEGIN_SRC C
    int FD_ISSET(int fd, fd_set *set); // 测试某文件描述符对应的位是否被设置
    void FD_SET(int fd, fd_set *set); // 设置某文件描述符对应的位
    void FD_CLR(int fd, fd_set *set); // 清除某文件描述符对应的位
    void FD_ZERO(fd_set *set); //清除其所有位
  #+END_SRC
select中间三个参数中的任意一个(或全部)可以是空指针，这表示对相应条件并不关心。如果所有三个指针都是空指针，则select提供了较sleep更精确的计时器

**** maxfdp1参数
     第一个参数maxfdp1的意思是”最大fd加1“，在三个描述符集中找出最高描述符编号值，然后加1。也可将第一个参数设置为FD_SETSIZE，它说明了最大的描述符数(经常是256或1024)。但是对大多数应用程序而言此值太大了，大多数应用程序只使用3~10个描述符。如果将第三个参数设置为最高描述符编号值加1，内核就只需在此范围内寻找打开的位，而不必在数百位的大范围内搜索
     
     #+BEGIN_SRC C
  fd_set readset, writeset;
  FD_ZERO(&readset);
  FD_ZERO(&writeset);

  FD_SET(0, &readset);
  FD_SET(3, &readset);
  FD_SET(1, &writeset);
  FD_SET(2, &writeset);

  select(4, &readset, &writeset, NULL, NULL);
     #+END_SRC
     
     图12-10显示了这两个描述符集的情况：
     #+ATTR_HTML: image :width 90% 
     [[file:pic/fd-set-sample.jpg]] 
     
     因为描述符编号从0开始，所以要在最大描述符编号值上加1，实际上是要检查的描述符数量
     
**** timeval结构
     最后一个参数tvptr是一个指向timeval结构的指针，它指定愿意等待的时间：
     #+BEGIN_SRC C
       struct timeval{
               long tv_sec; /* seconds */
               long tv_usec; /* and microseconds */
       };
     #+END_SRC
     
     有以下三种情况：
+ 永远等待
#+BEGIN_SRC C
tvptr = NULL 
#+END_SRC
当所指定的描述符中的一个已准备好或捕捉到一个信号则返回，否则无限期等待

+ 完全不等待
#+BEGIN_SRC C
  tvptr->tv_sec = 0 && tvptr->tv_usec = 0
#+END_SRC
测试所有指定的描述符并立即返回。这是得到多个描述符的状态而不阻塞select函数的轮询方法

+ 等待指定的秒数和微秒数
#+BEGIN_SRC C
  tvptr->tv_sec !=0 || tvptr->tv_usec != 0
#+END_SRC
当指定的描述符之一已准备好，或当指定的时间值已经超过时立即返回，与第一种情况一样，等待可被捕捉到的信号中断

**** 返回值
     select有三个可能的返回值：
+ -1：出错，例如在所指定的描述符都没有准备好时捕捉到一个信号，并且errno设置为EINTR
+ 0：没有描述符准备好，而且指定的时间已经超过
+ >0：已经准备好的描述符数，在这种情况下三个描述符集中仍旧打开的位是对应于已准备好的描述符位
   
对于“准备好”的意思要作一些更具体的说明：
+ 若对读集中的一个描述符的read不会阻塞，则此描述符是准备好的
+ 若对写集中的一个描述符的write不会阻塞，则此描述符是准备好的
+ 若对异常条件集(exceptfds)中的一个描述符有一个未决异常条件，则此描述符是准备好的。而异常条件包括:
  - 在网络连接上到达指定波特率外的数据
  - 在处于数据包方式的伪终端上发生了某些条件
    
一个描述符阻塞与否并不影响select是否阻塞，也就是说如果希望读一个非阻塞描述符，并且以超时值为5秒调用select，则select最多阻塞5秒。相类似如果指定一个无限的超时值，则select阻塞到对该描述符数据准备好，或捕捉到一个信号

如果在一个描述符上碰到了文件结束，则select认为该描述符是可读的。然后调用read，它返回0，这是UNIX指示到达文件结尾处的方法。很多人错误地认为，当到达文件结尾处时，select会指示一个异常条件

**** pselect函数
     pselect函数是select的变体：
     #+BEGIN_SRC C
       #include <sys/select.h>

       int pselect(int nfds,
                   fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
                   const struct timespec *timeout,
                   const sigset_t *sigmask);
     #+END_SRC
     主要区别：
+ 定时采用了纳秒级的timespec结构
+ timespec参数声明为const
+ 使用信号集屏蔽不需要的信号
*** poll函数
SVR4的poll函数类似于select，但是其调用形式则有所不同
#+BEGIN_SRC C
  #include <poll.h>

  /**
     
   ,*/
  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
#+END_SRC
**** pollfd结构
与select不同，poll不是为每个条件构造一个描述符集，而是构造一个pollfd结构数组，每个数组元素指定一个描述符编号以及对其所关心的条件：
#+BEGIN_SRC C
  struct pollfd
  {
          int fd; /* 文件描述符号或<0表示忽略*/
          short events;      /* 关心的事件,由用户程序设置 */
          short revents;     /* 已经发生的事件,由系统设置 */
  }
#+END_SRC
events成员应该被设置为表12-1中所示值的一个或几个。这些值告诉内核对该描述符关心的是什么。同样返回时，内核设置revents成员，以说明对该描述符发生了什么事件：

   #+CAPTION: poll的events和revents标志
   #+ATTR_HTML: :border 1 :rules all :frame boader
| 名称       | 从events得到的输入 | 从revents得到的结果 | 说明                             |
| POLLIN     | •                  | •                   | 读取出高优先级之外的数据，不阻塞 |
| POLLRDNORM | •                  | •                   | 读取普通数据(优先级为0)，不阻塞  |
| POLLRDBAND | •                  | •                   | 读取非0优先级波段数据，不阻塞    |
| POLLPRI    | •                  | •                   | 读取高优先级数据，不阻塞         |
| POLLOUT    | •                  | •                   | 写普通数据，不阻塞               |
| POLLWRNORM | •                  | •                   | 和POLLOUT相同                    |
| POLLWRBAND | •                  | •                   | 写非0优先级数据，不阻塞          |
| POLLERR    |                    | •                   | 已经出错                         |
| POLLHUP    |                    | •                   | 已经挂断                         |
| POLLNVAL   |                    | •                   | 描述符无效                       |

头四行测试可读性，接着三行测试可写性，最后三行则是异常条件。最后三行是由内核在返回时设置的。即使在events字段中没有指定这三个值，如果相应条件发生，则在revents中也返回它们

当一个描述符被挂断后(POLLHUP)，就不能再写向该描述符。但是仍可能从该描述符读取到数据

注意：poll没有更改events成员，这与select不同，select修改其参数以指示哪一个描述符已准备好了
**** nfds参数
nfds参数表明fds数组的元素数目
**** timeout参数
timeout参数说明想要等待多少时间。有三种不同的情形: 

+ 永远等待：
#+BEGIN_SRC C
  timeout = INFTIM
#+END_SRC
常数INFTIM定义在<stropts.h>，其值通常是-1。当所指定的描述符中的一个已准备好，或捕捉到一个信号则返回

+ 不等待：
#+BEGIN_SRC C
  timeout = 0
#+END_SRC
测试所有描述符并立即返回。这是得到很多个描述符的状态而不阻塞poll函数的轮询方法

+ 等待timeout毫秒：
#+BEGIN_SRC C
  timeout > 0
#+END_SRC
当指定的描述符之一已准备好或指定的时间值已超过时立即返回。同样可以被一个信号中断
**** 返回值
     poll也有三个可能的返回值：
+ -1：出错，例如在所指定的描述符都没有准备好时捕捉到一个信号，并且errno设置为EINTR
+ 0：没有描述符准备好，而且指定的时间已经超过
+ >0：准备就绪的描述符数，在这种情况下三个描述符集中仍旧打开的位是对应于已准备好的描述符位

不论一个描述符是否阻塞,并不影响poll是否阻塞

文件结束与挂断之间的区别：如果正在终端输入数据，并键入文件结束字符，POLLIN被打开，于是就可读文件结束指示(read返回0)，POLLHUP在revents中没有打开。如果读调制解调器，并且电话线已挂断，则在revents中将接到POLLHUP
*** 中断性
中断的系统调用的自动再起动是由4.2+BSD引进的，但当时select函数是不再起动的。这种特性延续到4.3+BSD，即使指定了SA_RESTART也是为此。但是，在SVR4之下，如果指定了SA_RESTART，那么select和poll也是自动再起动的。为了将软件移植到SVR4时阻止这一点，如果信号可能中断select或poll，则总是使用signal_intr函数

** 异步IO
还有一种技术称之为异步I/O，基本思想是进程告诉内核，当一个描述符已准备好可以进行I/O时，用一个信号通知进程。这种技术有两个问题：
1. 并非所有系统都支持这种机制，现在它还不是POSIX的组成部分。SVR4为此技术提供SIGPOLL信号，但是仅当描述符引用流设备时才能工作。4.3+BSD有一个类似的信号SIGIO，但是仅当描述符引用终端设备或网络时才能工作
2. 这种信号对每个进程而言只有1个。如果使该信号对两个描述符都起作用，那么在接到此信号时进程无法判别是哪一个描述符已准备好可以进行I/O。为了确定是哪一个描述符已准备好，仍需将这两个描述符都设置为非阻塞的，并顺序试执行I/O

系统只是告诉某个事件发生在文件描述符，但并不告诉关于文件描述符状态变化的任何信息，需要主动地使用select或poll来查询描述符状态

*** BSD实现
BSD实现异步IO使用的信号是SIGIO和SIGURG。SIGIO是通用异步信号，而SIGURG是通知进程在网络连接上有非规定波特率数据

为了使用SIGIO的话，需要执行下面三个步骤：
1. 调用signal为SIGIO建立处理函数
2. 使用F_SETOWN为fd设置进程和进程组。因为一旦fd触发信号的话，系统是要决定信号投递到哪个进程和进程组的
3. 使用F_SETFL来设置O_ASYNC文件状态标志，仅仅用于终端或者是网络的描述符

对于SIGURG只需要设置前面两个步骤，信号仅仅是用于支持非规定波特率数据的网络连接描述符产生的

**** 实例
使用SIGIO信号实现异步IO
     #+BEGIN_SRC C
       #include <unistd.h>
       #include <fcntl.h>
       #include <signal.h>
       #include <stdio.h>

       static int id = 0;

       void sig_handler(int signo){
               printf("%d received(%d)\n",strsignal(signo),id);
               id++;
       }

       int main(){
               signal(SIGIO,sig_handler);
               fcntl(0,F_SETOWN,getpid());
               fcntl(0,F_SETFL,fcntl(0,F_GETFL) | O_ASYNC);
               pause();
               return 0;
       }
     #+END_SRC

* readv和writev
readv和writev函数用于在一个函数调用中读、写多个非连续缓存
+ readv：散布读
+ writev：聚集写
#+BEGIN_SRC C
  #include <sys/types.h> 
  #include <sys/uio.h>

  /**
     从fileds中读入的数据按顺序逐块分散存储在iov指向的iovcnt个缓冲区中

     fileds：文件描述符
     iov：指向缓存区结构数组的第一个元素
     iovcnt：缓存区结构数组的元素数目

     return：已读取的字节数，若出错则为-1
  ,*/
  ssize_t readv(int filedes, const struct iovec *iov, int iovcnt);

  /**
     将iovcnt个缓冲区的数据按顺序逐块连续的写入fileds

     fileds：文件描述符
     iov：指向缓存区结构数组的第一个元素
     iovcnt：缓存区结构数组的元素数目

     return：已写出的字节数，若出错则为-1
  ,*/
  ssize_t writev(int filedes, const struct iovec *iov, int iovcnt);
#+END_SRC

** iovec结构
iovec结构用来说明缓存区：
   #+BEGIN_SRC C
     struct iovec
     {
             void *iov_base;    /* 缓冲区起始地址 */
             size_t iov_len;    /* 缓冲区长度 */
     }
   #+END_SRC
图12-11显示了readv和writev的参数和iovec结构之间的关系：

#+ATTR_HTML: image :width 90% 
[[file:pic/iovec.png]] 

+ writev以顺序iov[ 0 ]，iov[ 1 ]至iov[ iovcnt-1 ]从缓存中聚集输出数据。writev返回输出的字节总数，等于所有缓存长度之和
+ readv则将读入的数据按上述同样顺序散布到缓存中，总是先填满一个缓存，然后再填写下一个。readv返回读得的总字节数，如果遇到文件结尾，已无数据可读，则返回0


** 性能测试
有三种方法可以实现从两个缓存区写入一个文件:
1. 调用write两次，一次一个缓存
2. 分配一个大到足以包含两个缓存的新缓存。将两个缓存的内容复制到新缓存中。然后对该缓存调用wrtre一次
3. 调用writev输出两缓存

测试结果显示：调用两次write几乎是另外两种方法的2倍时间，采用缓存复制后用一个write与采用一个writev所用CPU时间几乎一样，但一般说来，因为前者还需要分配一个临时缓存用于存储及复制，所以后者更复杂

* 存储映射IO
存储映射I/O使一个磁盘文件与存储空间中的一个缓存相映射。于是当从缓存中取数据就相当于读文件中的相应字节，而将数据存入缓存，则相应字节就自动地写入文件。这样，就可以在不使用read和write的情况下执行I/O

** mmap函数
mmap函数：告诉内核将一个给定的文件映射到一个存储区域中

#+BEGIN_SRC C
  #include <sys/types.h>
  #include <sys/mman.h>

  /**
     磁盘文件映射到内存中的缓冲区

     addr：缓存区的首地址，一般为NULL，表示系统自己分配，应为系统虚拟内存页的整数倍
     len：缓存区长度
     prot：文件保护模式，PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC的任意或逻辑的组合
     flag：MAP_FIXED 要求系统使用指定的 addr,不建议使用此标志
           MAP_SHARED 修改缓冲区即为直接修改文件
           MAP_PRIVATE(缓冲区仅仅是文件的副本
     filedes：文件描述符
     off：文件中的起始位置，应为系统虚拟内存页的整数倍

     return：若成功则为映射区的起始地址，若出错则为-1
  ,*/
  void *mmap(void *addr, size_t len, int prot, int flag, int filedes, off_t off);
#+END_SRC
返回值：该映射区的起始地址
*** 参数说明
+ addr：映射存储区的起始地址，通常将其设置为NULL，这表示由系统选择该映射区的起始地址
+ filedes：要被映射文件的描述符。在映射该文件到一个地址空间之前，先要打开该文件
+ len：映射的字节数
+ off：要映射字节在文件中的起始位移量

**** prot参数
prot参数说明映射存储区的保护要求：
   #+CAPTION: 存储映射区的保护
   #+ATTR_HTML: :border 1 :rules all :frame boader
| prot       | 说明       |
| PROT_READ  | 区域可读   |
| PROT_WRITE | 区域可写   |
| PROT_EXEC  | 区域可执行 |
| PROT_NONE  | 区域可存取(BSD无此选项) |

对于映射存储区所指定的保护要求与文件的open方法匹配。例如，若该文件是只读打开的，那么对映射存储区就不能指定PROT_WRITE 
**** flag参数
flag参数影响映射存储区的多种属性：
+ MAP_FIXED：返回值必须等于addr。因为这不利于可移植性，所以不鼓励使用此标志。如果未指定此标志，而且addr非0，则内核只把addr视为何处设置映射区的一种建议。通过将addr指定为NULL可获得最大可移植性
+ MAP_SHARED：本进程对映射区所进行的存储操作的配置。指定存储操作修改映射文件，这意味着存储操作相当于对该文件write
+ MAP_PRIVATE：对映射区的存储操作导致创建该映射文件的一个副本。所有后来对该映射区的存访都是存访该副本，而不是原始文件
**** off和addr参数限制
下图显示了一个存储映射文件：
#+ATTR_HTML: image :width 90% 
[[file:pic/mmap.png]] 

off和addr的值通常应当是系统虚存页长度的倍数，一般这2个值都是NULL或0，所以这不会造成太大的问题 

因为映射文件的起动位移量受系统虚存页长度的限制，那么如果映射区的长度不是页长度的整数倍时，将如何呢？假定文件长12字节，系统页长为512字节，则系统通常提供512字节的映射区，其中后500字节被设为0。可以修改这500字节，但任何变动都不会在文件中反映出来
*** 信号和进程
与映射存储区相关有两个信号：
+ SIGSEGV：通常用于指示进程试图存取它不能存取的存储区。如果进程企图存数据到用mmap指定为只读的映射存储区，那么也产生此信号
+ SIGBUS：如果存取映射区的某个部分，而在存储时这一部分已不存在，则产生此信号。例如用文件长度映射一个文件，但在存访该映射区之前，另一个进程已将该文件截短，此时如果进程企图存取对应于该文件尾端部分的映射区，则接收到SIGBUS信号

进程在fork和exec后：
+ fork：子进程继承存储映射区，这是因为子进程复制父进程地址空间，而存储映射区是该地址空间中的一部分
+ exec：新程序则不继承此存储映射区

** munmap函数
munmap函数：解除内存映射
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <sys/mman.h>

  /**
     解除存储映射

     addr：缓存区首地址
     len：缓存区长度

     return：若成功则为0，若出错则为-1
  ,*/
  int munmap(caddr_t addr, size_t len);
#+END_SRC
进程终止时或调用了munmap之后，存储映射区就被自动去除

注意：关闭文件描述符filedes并不解除映射区

** msync函数
调用munmap并不使映射区的内容写到磁盘文件上，调用msync函数才使修改后的数据反应到映射的磁盘文件中　
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <sys/mman.h>

  /**
     使修改后的数据更新到映射的磁盘文件中

     addr：映射缓存区首地址
     len：映射缓存区长度
     flags：更新方式 MS_ASYNC(异步更新，立即返回)，MS_SYNC(同步更新，更新完成后才返回)
  ,*/
  void msync(void *addr, size_t len, int flags);
#+END_SRC

** 使用内存映射拷贝文件
下面程序用存储映射I/O复制一个文件。首先打开两个文件，然后调用fstat得到输入文件的长度。在调用mmap和设置输出文件长度时都需使用输入文件长度，因此调用lseek，然后写一个字节以设置输出文件的长度。如果不设置输出文件的长度，则对输出文件调用mmap也可以，但是对相关存储区的第一次存访会产生SIGBUS。也可使用ftruncate函数来设置输出文件的长度，但是并非所有系统都支持该函数扩充文件长度

然后对每个文件调用mmap，将文件映射到存储区，最后调用memcpy将输入缓存的内容复制到输出缓存。在从输入缓存(src)取数据字节时，内核自动读输入文件，同样在将数据存入输出缓存(dst)时，内核自动将数据写到输出文件中

#+BEGIN_SRC C
  #include "apue.h"
  #include <fcntl.h>
  #include <sys/mman.h>

  int main(int argc, char *argv[])
  {
          int         fdin, fdout;
          void        *src, *dst;
          struct stat statbuf;

          if (argc != 3)
                  err_quit("usage: %s <fromfile> <tofile>", argv[0]);

          if ((fdin = open(argv[1], O_RDONLY)) < 0)
                  err_sys("can't open %s for reading", argv[1]);

          if ((fdout = open(argv[2], O_RDWR | O_CREAT | O_TRUNC,
                            FILE_MODE)) < 0)
                  err_sys("can't creat %s for writing", argv[2]);

          if (fstat(fdin, &statbuf) < 0)  /* need size of input file */
                  err_sys("fstat error");

          /* set size of output file */
          if (lseek(fdout, statbuf.st_size - 1, SEEK_SET) == -1)
                  err_sys("lseek error");
          if (write(fdout, "", 1) != 1)
                  err_sys("write error");

          if ((src = mmap(0, statbuf.st_size, PROT_READ, MAP_SHARED,
                          fdin, 0)) == MAP_FAILED)
                  err_sys("mmap error for input");

          if ((dst = mmap(0, statbuf.st_size, PROT_READ | PROT_WRITE,
                          MAP_SHARED, fdout, 0)) == MAP_FAILED)
                  err_sys("mmap error for output");

          memcpy(dst, src, statbuf.st_size);  /* does the file copy */
          exit(0);
  }
#+END_SRC

测试：
#+BEGIN_SRC sh
  #使用cp和mmap拷贝一个1.2G长度的文件
  $ time cp ~/Movie/La\ La\ Land/La\ La\ Land.mkv ./ 

  real    0m23.824s
  user    0m0.010s
  sys     0m2.170s

  $ time ./mcopy ~/Movie/La\ La\ Land/La\ La\ Land.mkv ./a.mkv

  real    0m16.796s
  user    0m0.186s
  sys     0m1.079s
#+END_SRC

测试结果显示将一个普通文件复制到另一个普通文件中时，存储映射I/O比较快。但是有一些限制，如不能用在某些设备之间(例如网络设备或终端设备)进行复制。并且对被复制的文件进行映射后，也要注意该文件的长度是否改变。尽管如此有很多应用程序会从存储映射I/O得到好处，因为它处理的是内存而不是读、写一个文件，所以常常可以简化算法

* 记录锁
当两个人同时编辑一个文件时，其后果将如何呢？在很多UNIX系统中，该文件的最后状态取决于写该文件的最后一个进程。但是对于有些应用程序，例如数据库，有时进程需要确保它正在单独写一个文件。为了向进程提供这种功能，较新的UNIX系统提供了记录锁机制

记录锁的功能是：一个进程正在读或修改文件的某个部分时，可以阻止其他进程修改同一文件区。对于UNIX，“记录”这个定语也是误用，因为UNIX内核根本没有使用文件记录这种概念。一个更适合的术语可能是“区域锁”，因为它锁定的只是文件的一个区域(也可能是整个文件)

** 历史
下面表列出了各种UNIX系统提供的不同形式的记录锁：
   #+CAPTION: 各种UNIX系统支持的记录锁形式
   #+ATTR_HTML: :border 1 :rules all :frame boader
| 系统        | 建议性 | 强制性 | fcntl | lockf | flock |
| POSIX.1     | •      |        | •     |       |       |
| XPG3        | •      |        | •     |       |       |
| SVR2        | •      |        | •     | •     |       |
| SVR3,SVR4   | •      | •      | •     | •     |       |
| 4.3BSD      | •      |        |       |       | •     |
| 4.3BSD Reno | •      |        | •     |       | •     |

POSIX.1选择了以fcntl函数为基础的系统V风格的记录锁，这种风格也得到4.3BSDReno版本的支持:

+ fcntl函数可以锁文件中的任一区域，大至整个文件，小至单个字节
+ 早期的伯克利版只支持flock函数，此函数只锁整个文件，而不锁文件中的一个区域
+ 系统V的lockf函数只是fcntl函数的一个界面

** fcntl记录锁
第三章已经给出了fcntl函数的原型：
#+BEGIN_SRC C
  #include <sys/types.h>
  #include <unistd.h>
  #include <fcntl.h>

  /**
     改变已经打开文件的性质

     filedes：文件描述符
     cmd：功能
     args：可选参数

     return：成功依赖于cmd，失败-1
  ,*/
  int fcntl(int filedes, int cmd, .../* int arg*/);
#+END_SRC
对于记录锁：
+ cmd：
  1. F_GETLK
  2. F_SETLK
  3. F_SETLKW
+ 第三个参数flockptr是一个指向flock结构的指针

*** flock结构
记录锁结构：
    #+BEGIN_SRC C
      struct flock {
              short l_type;      /* 包括 F_RDLOCK, F_WRLOCK, F_UNLOCK */
              off_t l_start;     /* 锁的起点 */
              short l_whence;    /* 包括 SEEK_SET, SEEK_CUR, SEEK_END */
              off_t l_len;       /* 为 0 时,表示从起点到 EOF */
              pid_t l_pid;       /* 拥有此锁的进程 PID */
      }
    #+END_SRC

**** 锁类型
锁类型：
  1. F_RDLCK：共享读锁
  2. F_WRLCK：独占性写锁
  3. F_UNLCK：解锁一个区域

多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上的写锁则只能由一个进程独用。更进一步，如果在一个给定字节上已经有一把或多把读锁，则不能在该字节上再加写锁，如果在一个字节上已经有一把独占性的写锁，则不能再对它加任何读锁。下表中示出了这些规则：
  +----------+---------------------+
  |          |        锁类型       |
  | 区域当前 +----------+----------+
  |          |   读锁   |    写锁  |
  +----------+----------+----------+
  |   无锁   |   允许   |   允许   |
  +----------+----------+----------+
  |一至多把读|   允许   |   拒绝   |
  +----------+----------+----------+
  | 一把写锁 |   拒绝   |   拒绝   |
  +----------+----------+----------+

+ 加读锁时，该文件描述符必须是读打开
+ 加写锁时，该文件描述符必须是写打开

**** 锁区域
+ 要加锁或解锁的区域的起始地址由l_start和l_whence两者决定：
  1. l_start是相对位移量(字节)
  2. l_whence则决定了相对位移量的起点
+ 区域的长度由l_len表示

注意：
+ 该区域可以在当前文件尾端处开始或越过其尾端处开始，但是不能在文件起始位置之前开始或越过该起始位置
+ 如果l_len为0，则表示锁的区域从其起点开始直至最大可能位置为止。不管添写到该文件中多少数据，都处于锁的范围
+ 为了锁整个文件，通常的方法是将l_start说明为0，l_whence说明为SEEK_SET，l_len说明为0

*** cmd命令
以下说明fcntl函数的三种命令：
1. F_GETLK：测试由flockptr所描述的锁是否被另外一把锁所排斥(阻塞)
  - 如果存在一把锁，它阻止创建由flockptr所描述的锁，则这把现存的锁的信息写到flockptr指向的结构中
  - 如果不存在这种情况，则除了将l_type设置为F_UNLCK之外，flockptr所指向结构中的其他信息保持不变
2. F_SETLK：设置由flockptr所描述的锁
  - 如果试图建立一把按上述兼容性规则并不允许的锁，则fcntl立即出错返回，此时errno设置为EACCES或EAGAIN
  - 也用来清除由flockptr说明的锁(l_type为F_UNLCK)
3. F_SETLKW：F_SETLK的阻塞版本
  - 如果由于存在其他锁，那么按兼容性规则由flockptr所要求的锁不能被创建，则调用进程睡眠，如果捕捉到信号则睡眠中断

使用过程中要注意：
+ 用F_GETLK测试能否建立一把锁，然后用F_SETLK和F_SETLKW企图建立一把锁，这两者不是一个原子操作。在这两个操作之间可能会有另一个进程插入并建立一把相关的锁，使原来测试到的情况发生变化
+ 如果不希望在建立锁时可能产生的长期阻塞，则应使用F_SETLK，并对返回结果进行测试，以判别是否成功地建立了所要求的锁
+ 在设置或释放文件上的一把锁时，系统按需组合或裂开相邻区：
  + 若对字节0~99设置一把读锁，然后对字节0~49设置一把写锁，则有两个加锁区:0~49字节(写锁)及50~99(读锁)
  + 若100~199字节是加锁的区，需解锁第150字节，则内核将维持两把锁，一把用于100~149字节，另一把用于151~199字节

**** 要求和释放一把锁
为了避免每次分配flock结构，然后又填入各项信息，可以用函数lock_reg来处理这些细节：
#+BEGIN_SRC C
  #include "apue.h"
  #include <fcntl.h>

  int lock_reg(int fd, int cmd, int type,
               off_t offset, int whence, off_t len)
  {
          struct flock    lock;

          lock.l_type = type;     /* F_RDLCK, F_WRLCK, F_UNLCK */
          lock.l_start = offset;  /* byte offset, relative to l_whence */
          lock.l_whence = whence; /* SEEK_SET, SEEK_CUR, SEEK_END */
          lock.l_len = len;       /* #bytes (0 means to EOF) */

          return(fcntl(fd, cmd, &lock));
  }
#+END_SRC
使用下面五个宏来简化调用：
#+BEGIN_SRC C
  #define read_lock(fd, offset, whence, len)                          \
          lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
  #define readw_lock(fd, offset, whence, len)                             \
          lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
  #define write_lock(fd, offset, whence, len)                         \
          lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
  #define writew_lock(fd, offset, whence, len)                            \
          lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
  #define un_lock(fd, offset, whence, len)                            \
          lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))
#+END_SRC
用与lseek函数同样的顺序定义这些宏中的三个参数

**** 测试一把锁
lock_test函数用来测试一把锁：
#+BEGIN_SRC C
  #include "apue.h"
  #include <fcntl.h>

  pid_t lock_test(int fd, int type, off_t offset, int whence, off_t len)
  {
          struct flock    lock;

          lock.l_type = type;     /* F_RDLCK or F_WRLCK */
          lock.l_start = offset;  /* byte offset, relative to l_whence */
          lock.l_whence = whence; /* SEEK_SET, SEEK_CUR, SEEK_END */
          lock.l_len = len;       /* #bytes (0 means to EOF) */

          if (fcntl(fd, F_GETLK, &lock) < 0)
                  err_sys("fcntl error");

          if (lock.l_type == F_UNLCK)
                  return(0);      /* false, region isn't locked by another proc */
          return(lock.l_pid); /* true, return pid of lock owner */
  }
#+END_SRC
如果存在一把锁阻止由参数说明的锁，则此函数返回持有这把现存锁的进程的ID，否则此函数返回0。通常用下面两个宏来调用此函数：
#+BEGIN_SRC C
  #define is_read_lockable(fd, offset, whence, len)                   \
          (lock_test((fd), F_RDLCK, (offset), (whence), (len)) == 0)
  #define is_write_lockable(fd, offset, whence, len)                  \
          (lock_test((fd), F_WRLCK, (offset), (whence), (len)) == 0)
#+END_SRC

*** 死锁
如果两个进程相互等待对方持有并且不释放(锁定)的资源时，则这两个进程就处于死锁状态。如果一个进程已经控制了文件中的一个加锁区域，然后它又试图对另一个进程控制的区域加锁，则它就会睡眠，在这种情况下，有发生死锁的可能性

**** 死锁实例
子进程锁字节0，父进程锁字节1。然后它们中的每一个又试图锁对方已经加锁的字节。在该程序中使用了父子进程同步方法(TELL_xxx和WAIT_xxx)，使得对方都能建立第一把锁：
#+BEGIN_SRC C
  #include "apue.h"
  #include <fcntl.h>

  static void lockabyte(const char *name, int fd, off_t offset)
  {
          if (writew_lock(fd, offset, SEEK_SET, 1) < 0)
                  err_sys("%s: writew_lock error", name);
          printf("%s: got the lock, byte %ld\n", name, offset);
  }

  int main(void)
  {
          int     fd;
          pid_t   pid;

          /*
           ,* Create a file and write two bytes to it.
           ,*/
          if ((fd = creat("templock", FILE_MODE)) < 0)
                  err_sys("creat error");
          if (write(fd, "ab", 2) != 2)
                  err_sys("write error");

          TELL_WAIT();
          if ((pid = fork()) < 0) {
                  err_sys("fork error");
          } else if (pid == 0) {          /* child */
                  lockabyte("child", fd, 0);
                  TELL_PARENT(getppid()); // 等待父进程
                  WAIT_PARENT();
                  lockabyte("child", fd, 1);
          } else {                        /* parent */
                  lockabyte("parent", fd, 1);
                  TELL_CHILD(pid); //等待子进程
                  WAIT_CHILD();
                  lockabyte("parent", fd, 0);
          }
          exit(0);
  }
#+END_SRC

测试结果：
#+BEGIN_SRC sh
  $ ./deadlock 
  parent: got the lock, byte 1
  child: got the lock, byte 0
  parent: writew_lock error: Resource deadlock avoided 
  child: got the lock, byte 1

#+END_SRC
检测到死锁时，内核必须选择一个进程收到出错返回。在本例中，选择了父进程，这是一个实现细节。当此程序在另一个系统上运行时有可能是子进程接到出错信息

** 锁的隐含继承和释放
关于记录锁的自动继承和释放有三条规则:
+ 锁与进程、文件两方面有关：
   1. 当一个进程终止时，它所建立的锁全部释放
   2. 任何时候关闭一个描述符时，则该进程通过这一描述符可以存访的文件上的任何一把锁都被释放(这些锁都是该进程设置的)

如果执行下列四步:
#+BEGIN_SRC C
  fd1 = open(pathname /*, ...*/);
  read_lock(fd1 /*, ...*/);
  fd2 = dup(fd1) ;
  close(fd2) ;
#+END_SRC
则在close(fd2)后，在fd1上设置的锁被释放。如果将dup代换为open，其效果也一样:
#+BEGIN_SRC C
    fd1 = open(pathname /*, ...*/);
    read_lock(fd1 /*, ...*/);
    fd2 = open(fd1) ;
    close(fd2) ;
#+END_SRC

+ 由fork产生的子程序不继承父进程所设置的锁：若一个进程得到一把锁，然后调用fork，那么对于父进程获得的锁而言，子进程被视为另一个进程，对于从父进程处继承过来的任一描述符，子进程要调用fcntl以获得它自己的锁。如果子进程继承父进程的锁，则父、子进程就可以同时写同一个文件，而锁的作用就是为了阻止多个进程同时写同一个文件(或同一文件区域)。

+ 在执行exec后，新程序可以继承原执行程序的锁

** BSD的实现
