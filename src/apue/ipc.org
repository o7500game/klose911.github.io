#+TITLE: 进程间通信
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: daemon.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil

第8章说明了进程控制原语并且观察了如何调用多个进程。但是这些进程之间交换信息的唯一方法是经由fork或exec传送打开文件，或通过文件系统。本章将说明进程之间相互通信的其他技术IPC

UNIX IPC已经是而且继续是各种进程通信方式的统称，其中极少能在所有UNIX的实现中进行移植。表14-1列出了不同实现所支持的不同形式的IPC：
#+CAPTION: UNIX IPC
#+ATTR_HTML: :border 1 :rules all :frame boader
| IPC类型        | POSIX.1 | XPG3 | V7 | SVR2 | SVR3.2 | SVR4 | 4.3BSD | 4.3+BSD |
| 管道(半双工)   | •       | •    | •  | •    | •      | •    | •      | •       |
| FIFO(命令管道) | •       | •    |    | •    | •      | •    |        | •       |
| 流管道(全双工) |         |      |    |      | •      | •    | •      | •       |
| 命令流管道     |         |      |    |      | •      | •    | •      | •       |
| 消息队列       |         | •    |    | •    | •      | •    |        |         |
| 信号量         |         | •    |    | •    | •      | •    |        |         |
| 共享内存       |         | •    |    | •    | •      | •    |        |         |
| 套接口         |         |      |    |      |        | •    | •      | •       |
| 流             |         |      |    |      | •      | •    |        |         |
正如上表所示，不管哪一种UNIX实现，都可依靠的唯一一种IPC是半双工的管道。表中前7种IPC通常限于同一台主机的各个进程间的IPC。最后两种：套接口和流，则支持不同主机上各个进程间IPC。虽然中间三种形式的IPC(消息队列、信号量以及共享存储器)在表中说明为只受到系统V的支持，但是在大多数制造商所支持的，从伯克利UNIX导出的UNIX系统中(例如，SunOS以及Ultrix)已经添加了这三种形式的IPC

本章将讨论经典的IPC：
+ 管道
+ FIFO
+ 消息队列
+ 信号量
+ 共享内存
  
* 管道
  管道是UNIX IPC的最老形式，并且所有UNIX系统都提供此种通信机制，管道有两种限制; 
1. 半双工的：数据只能在一个方向上流动
2. 只能在具有公共祖先的进程之间使用：通常一个管道由一个进程创建，然后该进程调用fork，此后父、子进程之间就可应用该管道
   
尽管有这两种限制，半双工管道仍是最常用的IPC形式

** pipe函数
   pipe函数：创建管道
   #+BEGIN_SRC C
    #include <unistd.h>

    /**
       创建管道
       
       filedes：文件描述符数组，iledes[0]为读而打开，filedes[1]为写而打开，
                filedes[1]的输出是filedes[0]的输入

       return：若成功则为0，若出错则为-1
    ,*/
    int pipe(int filedes[2]);
   #+END_SRC
   由参数filedes数组返回两个文件描述符：
+ filedes[0]为读而打开
+ filedes[1]为写而打开，filedes[1]的输出正好是filedes[0]的输入
  
有两种方法来描绘一个管道，左半图显示了管道的两端在一个进程中相互连接，右半图则说明数据通过内核在管道中流动：
#+ATTR_HTML: image :width 90% 
[[file:pic/pipe.jpg]] 

fstat函数对管道的每一端都返回一个FIFO类型的文件描述符，可以用S_ISFIFO宏来测试管道

单个进程中的管道几乎没有任何用处。通常调用pipe的进程接着调用fork，这样就创建了从父进程到子进程或反之的IPC通道。下图显示了这种情况：
#+ATTR_HTML: image :width 70% 
[[file:pic/pipe-fork.jpg]] 

fork之后做什么取决于我们想要有的数据流的方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程则关闭写端(fd[1])。图14-3显示了描述符的最后安排：
#+ATTR_HTML: image :width 70% 
[[file:pic/pipe-fork-close.jpg]] 

当管道的一端被关闭后，下列规则起作用：
1. 当读一个写端已被关闭的管道时，在所有数据都被读取后，read返回0，以指示达到了文件结束处(从技术方面考虑，管道的写端还有进程时，就不会产生文件的结束。可以复制一个管道的描述符，使得有多个进程具有写打开文件描述符。但是，通常一个管道只有一个读进程，一个写进程)
2. 如果写一个读端已被关闭的管道，则产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write出错返回，errno设置为EPIPE
   
注意：在写管道时，常数PIPE_BUF规定了内核中管道缓存器的大小。如果对管道进行write调用，而且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或FIFO)的write操作穿插进行。但是若有多个进程同时写一个管道(FIFO)，而且某个或某些进程要求写的字节数超过PIPE_BUF字节数，则数据可能会与其他写操作的数据相穿插

*** 实例：创建管道
    创建了一个从父进程到子进程的管道，并且父进程经由该管道向子进程传送数据：
    #+BEGIN_SRC C
  #include "apue.h"

  int main(void)
  {
          int     n;
          int     fd[2];
          pid_t   pid;
          char    line[MAXLINE];

          if (pipe(fd) < 0)
                  err_sys("pipe error");

          if ((pid = fork()) < 0) {
                  err_sys("fork error");
          } else if (pid > 0) {       /* parent */
                  close(fd[0]);// close read tunnel of pipe in parent process
                  if(write(fd[1], "hello world\n", 12) < 0)
                          err_sys("write to pipe error");
          } else {                /* child */
                  close(fd[1]); // close write tunnel of pipe in child process
                  n = read(fd[0], line, MAXLINE);
                  if(write(STDOUT_FILENO, line, n) < 0)
                          err_sys("write to console error");
          }
      
          exit(0);
  }
    #+END_SRC
    上面程序对管道描述符调用read和write。更为普遍的是将管道描述符复制为标准输入和标准输出。在此之后通常子进程调用exec，执行另一个程序，该程序从标准输入(已创建的管道)或将数据写至其标准输出(管道)
    
    测试结果：
    #+BEGIN_SRC sh
  $ ./src/ipc/pipe1

  hello world
    #+END_SRC
    
*** 实例：分页展示文件
    下面程序的功能是每次一页显示已产生的输出。已经有很多UNIX公用程序具有分页功能，因此无需再构造一个新的分页程序，而是调用用户最喜爱的分页程序。为了避免先将所有数据写到一个临时文件中，然后再调用系统中的有关程序显示该文件，将输出通过管道直接送到分页程序。为此先创建一个管道，一个子进程，使子进程的标准输入成为管道的读端，然后exec用户喜爱的分页程序:
    #+BEGIN_SRC C
      #include "apue.h"
      #include <sys/wait.h>

      #define DEF_PAGER   "/usr/bin/less"     /* default pager program */

      int main(int argc, char *argv[])
      {
              int     n;
              int     fd[2];
              pid_t   pid;
              char    *pager, *argv0;
              char    line[MAXLINE];
              FILE    *fp;

              if (argc != 2)
                      err_quit("usage: a.out <pathname>");

              if ((fp = fopen(argv[1], "r")) == NULL)
                      err_sys("can't open %s", argv[1]);
              if (pipe(fd) < 0)
                      err_sys("pipe error");

              if ((pid = fork()) < 0) {
                      err_sys("fork error");
              } else if (pid > 0) {                               /* parent */
                      close(fd[0]);       /* close read end */

                      /* parent copies argv[1] to pipe */
                      while (fgets(line, MAXLINE, fp) != NULL) {
                              n = strlen(line);
                              if (write(fd[1], line, n) != n)
                                      err_sys("write error to pipe");
                      }
                      if (ferror(fp))
                              err_sys("fgets error");

                      close(fd[1]);   /* close write end of pipe for reader */

                      if (waitpid(pid, NULL, 0) < 0)
                              err_sys("waitpid error");
                      exit(0);
              } else {                                        /* child */
                      close(fd[1]);   /* close write end */
                      if (fd[0] != STDIN_FILENO) { // standard input descriptor point to fd[0]
                              if (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO)
                                      err_sys("dup2 error to stdin");
                              close(fd[0]);   /* don't need this after dup2 */
                      }

                      /* get arguments for execl() */
                      if ((pager = getenv("PAGER")) == NULL)
                              pager = DEF_PAGER;
                      if ((argv0 = strrchr(pager, '/')) != NULL)
                              argv0++;        /* step past rightmost slash */
                      else
                              argv0 = pager;  /* no slash in pager */

                      if (execl(pager, argv0, (char *)0) < 0)
                              err_sys("execl error for %s", pager);
              }
              exit(0);
      }
    #+END_SRC
    在调用fork之前先创建一个管道。fork之后父进程关闭其读端，子进程关闭其写端。子进程然后调用dup2，使其标准输入指向管道的读端。当执行分页程序时，其标准输入将是管道的读端：
    
    #+BEGIN_SRC sh
  $ ./src/ipc/most2 Makefile

  # Makefile.in generated by automake 1.15 from Makefile.am.
  # Makefile.  Generated from Makefile.in by configure.

  # Copyright (C) 1994-2014 Free Software Foundation, Inc.

  # This Makefile.in is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.

  # This program is distributed in the hope that it will be useful,
  # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
  # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  # PARTICULAR PURPOSE.



  am__is_gnu_make = { \
    if test -z '$(MAKELEVEL)'; then \
      false; \
    elif test -n '$(MAKE_HOST)'; then \
      true; \
    elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
  : #分页开始
    #+END_SRC
    
    将一个描述符复制到另一个时，在子进程中，fd[0]复制到标准输入，应当注意该描述符的值并不已经是所希望的值。如果该描述符已经具有所希望的值，并且我们先调用dup2，然后调用close则将关闭此进程中只有该单个描述符所代表的打开文件。在本程序中，如果shell没有打开标准输入，那么程序开始处的fopen应已使用描述符0，也就是最小未使用的描述符，所以fd[0]决不会等于标准输入。尽管如此，只要先调用dup2，然后调用close以复制一个描述符到另一个，作为一种保护性的编程措施，总是先将两个描述符进行比较
    
    先使用环境变量PAGER获得用户分页程序名称的。如果操作没有成功，则使用系统默认值。这是环境变量的常见用法
    
*** 实例：父子进程同步
    以前使用信号实现了TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT以及WAIT_CHILD。下面则是一个使用管道的实现：
    #+BEGIN_SRC C
  #include "apue.h"

  static int  pfd1[2], pfd2[2];

  void TELL_WAIT(void)
  {
          if (pipe(pfd1) < 0 || pipe(pfd2) < 0)
                  err_sys("pipe error");
  }

  void TELL_PARENT(pid_t pid)
  {
          if (write(pfd2[1], "c", 1) != 1)
                  err_sys("write error");
  }

  void WAIT_PARENT(void)
  {
          char    c;

          if (read(pfd1[0], &c, 1) != 1)
                  err_sys("read error");

          if (c != 'p')
                  err_quit("WAIT_PARENT: incorrect data");
  }

  void TELL_CHILD(pid_t pid)
  {
          if (write(pfd1[1], "p", 1) != 1)
                  err_sys("write error");
  }

  void WAIT_CHILD(void)
  {
          char    c;

          if (read(pfd2[0], &c, 1) != 1)
                  err_sys("read error");

          if (c != 'c')
                  err_quit("WAIT_CHILD: incorrect data");
  }
    #+END_SRC
    在fork之前创建了两个管道。父进程在调用TELL_CHILD时经由上一个管道写一个字符'P'，子进程在调用TELL_PARENT时，经由下一个管道写一个字符'C'。相应的WAIT_XXX函数调用read读一个字符，没有读到字符时阻塞(睡眠等待)：
    #+ATTR_HTML: image :width 70% 
    [[file:pic/pipe-tell-wait.jpg]] 
    
    注意：每一个管道都有一个额外的读取进程，这没有关系。也就是说除了子进程从pfd1[0]读取，父进程也有上一个管道的读端。因为父进程并没有执行对该管道的读操作，所以这不会产生任何影响
    
** popen和pclose函数
   常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其发送输入，标准I/O库为实现这些操作提供了两个函数popen和pclose
   
   popen实现的操作是：
1. 创建一个管道
2. fork一个子进程
3. 关闭管道的不使用端
4. exec一个shell以执行命令
5. 等待命令终止
#+BEGIN_SRC C
  #include <stdio.h>
  /**
     创建一个子进程，用于执行指定的shell命令
     可以将此子进程的标准输入或标准输出为管道,该管道的另一端为调用进程中返回的管道文件流指针所引用

     cmdstring：要执行的shell命令
     type：为"r"时，子进程所执行命令的标准输出为管道的输入端,该管道的输出端为popen的返回值
     为"w"时，子进程执行的命令的标准输入为管道的输出端,该管道的输入端为popen的返回值
           
     return：若成功则为文件指针，若出错则为NULL
  ,*/
  FILE *popen(const char *cmdstring, const char *type);
#+END_SRC
函数popen先执行fork，然后调用exec以执行cmdstring，并且返回一个标准I/O文件指针：
+ 如果type是"r"，则文件指针连接到cmdstring的标准输出(见图14-5)
+ 如果type是"w"，则文件指针连接到cmdstring的标准输入(见图14-6)
#+ATTR_HTML: image :width 90% 
[[file:pic/popen.jpg]] 

pclose函数关闭标准I/O流：
#+BEGIN_SRC C
  #include <stdio.h>


  /**
     关闭popen打开的文件指针

     fp：popen打开的文件指针

     return：cmdstring的终止状态，若出错则为-1
     ,,*/
  int pclose(FILE *fp);
#+END_SRC
pclose函数会等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose返回的终止状态与shell执行exit(127)一样

cmdstring由Bourne shell以下列方式执行：
#+BEGIN_SRC sh
  $ sh -c cmdstring
#+END_SRC
这表示shell将扩展cmdstring中的任何特殊字符。例如可以使用：
#+BEGIN_SRC C
  fp = popen("ls *.c", "r");
#+END_SRC
或者
#+BEGIN_SRC C
  fp = popen("cmd 2>&1", "w");
#+END_SRC

*** 使用popen实现分页读取文件
    shell命令${PAGER:-more}的意思是：如果shell变量PAGER已经定义，且其值非空，则使用其值，否则使用字符串more
    #+BEGIN_SRC C
      #include "apue.h"
      #include <sys/wait.h>

      #define PAGER   "${PAGER:-more}" /* environment variable, or default */

      int main(int argc, char *argv[])
      {
              char    line[MAXLINE];
              FILE    *fpin, *fpout;

              if (argc != 2)
                      err_quit("usage: a.out <pathname>");
              if ((fpin = fopen(argv[1], "r")) == NULL)
                      err_sys("can't open %s", argv[1]);

              if ((fpout = popen(PAGER, "w")) == NULL)
                      err_sys("popen error");

              /* copy argv[1] to pager */
              while (fgets(line, MAXLINE, fpin) != NULL) {
                      if (fputs(line, fpout) == EOF)
                              err_sys("fputs error to pipe");
              }
              if (ferror(fpin))
                      err_sys("fgets error");
              if (pclose(fpout) == -1)
                      err_sys("pclose error");

              exit(0);
      }
    #+END_SRC    
*** 实现popen和pclose函数
实现popen和pclose函数需要考虑很多细节：
+ 每次调用popen时，应当记住所创建的子进程的进程ID，以及其文件描述符或FILE指针。因此选择在数组childpid中保存子进程ID，并用文件描述符作为其下标
+ 当以FILE指针作为参数调用pclose时，可以调用标准I/O函数fileno以得到文件描述符，然后取得子进程ID，并用于调用waitpid
+ 因为一个进程可能调用popen多次，所以在动态分配childpid数组时(第一次调用popen时)，其长度必须容纳与文件描述符数相同的进程数

根据POSIX要求子进程必须从头逐个检查childpid数组的各元素，关闭仍旧打开的任一描述符，因为fork的子进程可能继承了父进程以前popen所形成的管道
#+BEGIN_SRC C
  #include "apue.h"
  #include <errno.h>
  #include <fcntl.h>
  #include <sys/wait.h>

  /*
   ,* Pointer to array allocated at run-time.
   ,*/
  static pid_t *childpid = NULL;

  /*
   ,* From our open_max(), {Prog openmax}.
   ,*/
  static int maxfd;

  FILE *popen(const char *cmdstring, const char *type)
  {
          int     i;
          int     pfd[2];
          pid_t   pid;
          FILE    *fp;

          /* only allow "r" or "w" */
          if ((type[0] != 'r' && type[0] != 'w') || type[1] != 0) {
                  errno = EINVAL;     /* required by POSIX */
                  return(NULL);
          }

          if (childpid == NULL) {     /* first time through */
                  /* allocate zeroed out array for child pids */
                  maxfd = open_max();
                  if ((childpid = calloc(maxfd, sizeof(pid_t))) == NULL)
                          return(NULL);
          }

          if (pipe(pfd) < 0)
                  return(NULL);   /* errno set by pipe() */

          if ((pid = fork()) < 0) {
                  return(NULL);   /* errno set by fork() */
          } else if (pid == 0) {                          /* child */
                  if (*type == 'r') {
                          close(pfd[0]);
                          if (pfd[1] != STDOUT_FILENO) {
                                  dup2(pfd[1], STDOUT_FILENO);
                                  close(pfd[1]);
                          }
                  } else {
                          close(pfd[1]);
                          if (pfd[0] != STDIN_FILENO) {
                                  dup2(pfd[0], STDIN_FILENO);
                                  close(pfd[0]);
                          }
                  }

                  /* close all descriptors in childpid[] */
                  for (i = 0; i < maxfd; i++)
                          if (childpid[i] > 0)
                                  close(i);

                  execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);
                  _exit(127);
          }

          /* parent continues... */
          if (*type == 'r') {
                  close(pfd[1]);
                  if ((fp = fdopen(pfd[0], type)) == NULL)
                          return(NULL);
          } else {
                  close(pfd[0]);
                  if ((fp = fdopen(pfd[1], type)) == NULL)
                          return(NULL);
          }

          childpid[fileno(fp)] = pid; /* remember child pid for this fd */
          return(fp);
  }

  int pclose(FILE *fp)
  {
          int     fd, stat;
          pid_t   pid;

          if (childpid == NULL) {
                  errno = EINVAL;
                  return(-1);     /* popen() has never been called */
          }

          fd = fileno(fp);
          if ((pid = childpid[fd]) == 0) {
                  errno = EINVAL;
                  return(-1);     /* fp wasn't opened by popen() */
          }

          childpid[fd] = NULL;
          if (fclose(fp) == EOF)
                  return(-1);

          while (waitpid(pid, &stat, 0) < 0)
                  if (errno != EINTR)
                          return(-1); /* error other than EINTR from waitpid() */

          return(stat);   /* return child's termination status */
  }
#+END_SRC
若pclose的调用者已经为信号SIGCHLD设置了一个信号处理程序，则waitpid将返回一个EINTR。因为允许调用者捕捉此信号(或者任何其他可能中断waitpid调用的信号)，所以当waitpid被一个捕捉到的信号中断时，那就必须再次调用waitpid

*** 用popen变换输入
考虑一个应用程序，它向标准输出写一个提示，然后从标准输入读1行。使用popen可以在应用程序和输入之间插入一个程序以对输入进行变换处
理。图14-7显示了进程的安排：
#+ATTR_HTML: image :width 70% 
[[file:pic/filter-input.jpg]] 

下面是一个简单的过滤程序，它只是将输入复制到输出，在复制时将任一大写字符变换为小写字符。在写了一行之后，对标准输出进行了刷清(用fflush)：
#+BEGIN_SRC C
  #include "apue.h"
  #include <ctype.h>

  int main(void)
  {
          int     c;

          while ((c = getchar()) != EOF) {
                  if (isupper(c))
                          c = tolower(c);
                  if (putchar(c) == EOF)
                          err_sys("output error");
                  if (c == '\n')
                          fflush(stdout);
          }
          exit(0);
  }
#+END_SRC
对该过滤程序进行编译，其可执行目标代码存放在文件myuclc中。在下面程序中通过popen调用myuclc完成对输入的过滤：
#+BEGIN_SRC C
  #include "apue.h"
  #include <sys/wait.h>

  int main(void)
  {
      char    line[MAXLINE];
      FILE    *fpin;

      if ((fpin = popen("myuclc", "r")) == NULL)
          err_sys("popen error");
      for ( ; ; ) {
          fputs("prompt> ", stdout);
          fflush(stdout);
          if (fgets(line, MAXLINE, fpin) == NULL) /* read from pipe */
              break;
          if (fputs(line, stdout) == EOF)
              err_sys("fputs error to pipe");
      }
      if (pclose(fpin) == -1)
          err_sys("pclose error");
      putchar('\n');
      exit(0);
  }
#+END_SRC
测试结果：
#+BEGIN_SRC sh
  $ ./src/ipc/popen1 
  prompt> HELLO WORLD
  hello world
  prompt> ^C
#+END_SRC
因为标准输出通常是按行进行缓存的，而提示并不包含新行符，所以在写了提示之后，需要调用fflush

** 协同进程
UNIX过滤程序从标准输入读取数据，对其进行适当处理后写到标准输出。几个过滤进程通常在shell管道命令中线性地连接。当同一个程序产生某个过滤程序的输入，同时又读取该过
滤程序的输出时，则该过滤程序就成为协同进程：

协同进程通常在shell的后台运行，其标准输入和标准输出通过管道连接到另一个程序。虽然要求初始化一个协同进程，并将其输入和输出连接到另一个进程的shell语法是十分奇特的，但是协同进程的工作方式在C程序中也是非常有用的

进程先创建两个管道，协同进程的标准输入和协同进程的标准输出。图14-8显示了这种安排：
#+ATTR_HTML: image :width 90% 
[[file:pic/coprocess.jpg]] 

+ popen提供连接到另一个进程的标准输入或标准输出的一个单行管道
+ 协同进程有连接到另一个进程的两个单行管道

*** 对两个数求和的简单过滤
下面程序从标准输入读两个数，计算它们的和，然后将结果写至标准输出:
    #+BEGIN_SRC C
      #include "apue.h"

      int main(void)
      {
              int     n, int1, int2;
              char    line[MAXLINE];

              while ((n = read(STDIN_FILENO, line, MAXLINE)) > 0) {
                      line[n] = 0;        /* null terminate */
                      if (sscanf(line, "%d%d", &int1, &int2) == 2) {
                              sprintf(line, "%d\n", int1 + int2);
                              n = strlen(line);
                              if (write(STDOUT_FILENO, line, n) != n)
                                      err_sys("write error");
                      } else {
                              if (write(STDOUT_FILENO, "invalid args\n", 13) != 13)
                                      err_sys("write error");
                      }
              }
              exit(0);
      }
    #+END_SRC
从其标准输入读入两个数之后调用add2协同进程，从协同进程送来的值则写到其标准输出，在程序中创建了两个管道，父、子进程各自关闭它们不需使用的端口。创建两个管道的理由是:一个用做协同进程的标准输入，另一个则用做它的标准输出。然后在调用execl之前，子进程调用dup2使管道描述符移至其标准输入和输出： 
#+BEGIN_SRC C
  #include "apue.h"

  static void sig_pipe(int);      /* our signal handler */

  int main(void)
  {
          int     n, fd1[2], fd2[2];
          pid_t   pid;
          char    line[MAXLINE];

          if (signal(SIGPIPE, sig_pipe) == SIG_ERR)
                  err_sys("signal error");

          if (pipe(fd1) < 0 || pipe(fd2) < 0)
                  err_sys("pipe error");

          if ((pid = fork()) < 0) {
                  err_sys("fork error");
          } else if (pid > 0) {                           /* parent */
                  close(fd1[0]);
                  close(fd2[1]);

                  while (fgets(line, MAXLINE, stdin) != NULL) {
                          n = strlen(line);
                          if (write(fd1[1], line, n) != n)
                                  err_sys("write error to pipe");
                          if ((n = read(fd2[0], line, MAXLINE)) < 0)
                                  err_sys("read error from pipe");
                          if (n == 0) {
                                  err_msg("child closed pipe");
                                  break;
                          }
                          line[n] = 0;    /* null terminate */
                          if (fputs(line, stdout) == EOF)
                                  err_sys("fputs error");
                  }

                  if (ferror(stdin))
                          err_sys("fgets error on stdin");
                  exit(0);
          } else {                                    /* child */
                  close(fd1[1]);
                  close(fd2[0]);
                  if (fd1[0] != STDIN_FILENO) {
                          if (dup2(fd1[0], STDIN_FILENO) != STDIN_FILENO)
                                  err_sys("dup2 error to stdin");
                          close(fd1[0]);
                  }

                  if (fd2[1] != STDOUT_FILENO) {
                          if (dup2(fd2[1], STDOUT_FILENO) != STDOUT_FILENO)
                                  err_sys("dup2 error to stdout");
                          close(fd2[1]);
                  }
                  if (execl("./add2", "add2", (char *)0) < 0)
                          err_sys("execl error");
          }
          exit(0);
  }

  static void sig_pipe(int signo)
  {
          printf("SIGPIPE caught\n");
          exit(1);
  }
#+END_SRC
测试：
#+BEGIN_SRC sh
  $ ./pipe4  
  1
  invalid args
  2 3
  5
  4 5
  SIGPIPE caught
#+END_SRC
当pipe4进程正等待输入时杀死add2协同进程，然后输入两个数，进行写操作时，由于该管道无读进程，于是调用信号处理函数sig_pipe

**** 使用标准IO改写add2
在协同进程add2中，使用了UNIX的I/O:read和write。现在使用标准I/O改写该协同进程：
#+BEGIN_SRC C
  #include "apue.h"

  int main(void)
  {
      int     int1, int2;
      char    line[MAXLINE];

      while (fgets(line, MAXLINE, stdin) != NULL) {
          if (sscanf(line, "%d%d", &int1, &int2) == 2) {
              if (printf("%d\n", int1 + int2) == EOF)
                  err_sys("printf error");
          } else {
              if (printf("invalid args\n") == EOF)
                  err_sys("printf error");
          }
      }
      exit(0);
  }
#+END_SRC

测试结果：
#+BEGIN_SRC sh
  $ ./spipe4 
  1 2 #死锁
#+END_SRC
若pipe4调用此新的协同进程，则它不再工作。问题出在系统默认的标准I/O缓存机制上：当add2stdio被调用时，对标准输入的第一个fgets引起标准I/O库分配一个缓存，并选择缓
存的类型。因为标准输入是个管道，所以isatty为假，于是标准I/O库由系统默认是全缓存的。对标准输出也有同样的处理。当add2stdio从其标准输入读取而发生堵塞时，pipe4从管道读时也
发生堵塞，于是产生了死锁

对将要执行的这样一个协同进程可以设置buf，可以在add2stdio程序的while循环之前加上如下代码:
#+BEGIN_SRC C
  if (setvbuf(stdin, NULL, _IOLBF, 0) != 0)
          err_sys("setvbuf error");

  if (setvbuf(stdout, NULL, _IOLBF, 0)!= 0)
          err_sys("setvbuf error");
#+END_SRC
这使得当有一行可用时fgets即返回，并使得当输出一新行符时，printf即执行fflush操作

这种设置往往要求对协同进程进程代码修改，但在使用一个第三方的协同进程时不一定可以满足，更一般解决方法是使被调用的协同进程认为它的标准输入和输出被连接到一个伪终端。这使得协同进程中的标准I/O例程对这两个I/O流进行行缓存

** FIFO
FIFO被称为命名管道。管道只能由相关进程使用，它们共同的祖先进程创建了管道，但是通过FIFO不相关的进程也能交换数据

*** mkfifo函数
曾经提及FIFO是一种文件类型，而stat结构的成员st_mode的编码指明文件是否是FIFO类型，并且可以用S_ISFIFO宏对此进行测试

mkfifo函数：创建命名管道，类似于创建文件，事实上FIFO的路径名存在于文件系统中
#+BEGIN_SRC C
  #include <sys/stat.h>
  /**
     创建命名管道

     pathname：管道文件名
     mode：可选择参数，当oflag包含O_CREAT的时候，表示创建文件的权限

     return：若成功则为0，若出错则为-1
  ,*/
  int mkfifo(const char *pathname, mode_t mode);
#+END_SRC
+ mode参数：规格说明与open函数中的mode相同
+ FIFO文件的用户和组的所有权与第四章所描述的相同

*** FIFO文件
一旦已经用mkfifo创建了一个FIFO，就可用open打开它。确实，一般的文件I/O函数close、read、write、unlink等都可用于FIFO
 
当打开一个FIFO时，非阻塞标志(O_NONBLOCK)产生下列影响:
+ 在一般情况中(没有说明O_NONBLOCK)，只读打开要阻塞到某个其他进程为写打开此FIFO。类似为写而打开一个FIFO要阻塞到某个其他进程为读而打开它
+ 如果指定了O_NONBLOCK，则只读打开立即返回。但是如果没有进程已经为读而打开一个FIFO，那么只写打开将出错返回，其errno是ENXIO。 

类似于管道，如果写一个尚无进程为读而打开的FIFO，则产生信号SIGPIPE。若某个FIFO的最后一个写进程关闭了该FIFO，则将为该FIFO的读进程产生一个文件结束标志

一个给定的FIFO有多个写进程是常见的。这就意味着如果不希望多个进程所写的数据互相穿插，则需考虑原子写操作。正如对于管道一样，常数PIPE_BUF说明了可被原子写到FIFO的最大数据量

*** FIFO用途
+ shell命令使用以便将数据从一条管道线传送到另一条，为此无需创建中间临时文件
+ 用于客户机-服务器应用程序中，以在客户机和服务器之间传递数据


**** 复制输出流
FIFO可被用于复制串行管道命令之间的输出流，于是也就不需要写数据到中间磁盘文件中，类似于使用管道以避免中间磁盘文件。但是管道只能用于进程间的线性连接，而FIFO因为具有名字，所以它可用于非线性连接

考虑这样一个操作过程，它需要对一个经过过滤的输入流进行两次处理。图14-9表示了这种安排：
#+ATTR_HTML: image :width 60% 
[[file:pic/fifo-two-handler.jpg]] 

使用FIFO以及UNIX程序tee(1)，就可以实现这样的过程而无需使用临时文件。tee程序将其标准输入同时复制到其标准输出以及其命令行中包含的命名文件中：
#+BEGIN_SRC sh
  $ mkfifo fifo1 # 创建管道文件fifo1
  $ prog3 < fifo1 & # 后台启动prog3等待fifo1的输出
  $ prog1 < infile | tee fifo1 | prog2 # 启动progl, 用tee将其输出发送到fifo1和prog2
#+END_SRC
创建FIFO，然后在后台起动prog3，它从FIFO读数据。然后起动progl，用tee将其输出发送到FIFO和prog2。图14-10显示了有关安排：
#+ATTR_HTML: image :width 60% 
[[file:pic/fifo-tee.jpg]]  

**** 简单客户-服务器通信
FIFO的另一个应用是在客户机和服务器之间传送数据。如果有一个服务器，它与很多客户机有关，每个客户机都可将其请求写到一个该服务器创建的众所周知的FIFO中(所有需与服务器联系的客户机都知道该FIFO的路径名)。因为对于该FIFO有多个写进程，客户机发送给服务器的请求其长度要小于PIPE_BUF字节。这样就能避免客户机各次写之间的穿插。图14-11显示了这种安排：
#+ATTR_HTML: image :width 60% 
[[file:pic/fifo-client-send-request.jpg]]  

在这种类型的客户机-服务器通信中使用FIFO的问题是：服务器如何将回答送回各个客户机。不能使用单个FIFO，因为服务器会发出对各个客户机请求的响应，而请求者却不可能知
道什么时候去读才能恰恰得到对它的响应。一种解决方法是每个客户机都在其请求中发送其进程ID。然后服务器为每个客户机创建一个FIFO，所使用的路径名是以客户机的进程ID为基础
的。例如，服务器可以用名字/tmp/serv1.XXXXX创建FIFO，其中XXXXX被替换成客户机的进程ID。图14-12显示了这种安排：
#+ATTR_HTML: image :width 60% 
[[file:pic/fifo-client-server.jpg]]  

这种安排可以工作，但也有一些不足之处：
+ 是服务器不能判断一个客户机是否崩溃终止，这就使得客户机专用的FIFO会遗留在文件系统中
+ 服务器必须捕捉SIGPIPE信号，因为客户机在发送一个请求后没有读取响应就可能终止，于是留下一个有写进程(服务器)而无读进程的客户机专用FIFO

按照图14-12中的安排，如果服务器以只读方式打开众所周知的FIFO(因为它只需读该FIFO)，则每次客户机数从1变成0，服务器就将在FIFO中读到一个文件结束标记。为使服务器免于处理这种情况，一种常见的技巧是使服务器以读-写方式打开该FIFO

* 系统V IPC
  
** 消息队列
   
** 信号量
   
** 共享内存
