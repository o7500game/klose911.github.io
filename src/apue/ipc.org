#+TITLE: 进程间通信
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: daemon.html   
#+HTML_LINK_HOME: apue.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil

第8章说明了进程控制原语并且观察了如何调用多个进程。但是这些进程之间交换信息的唯一方法是经由fork或exec传送打开文件，或通过文件系统。本章将说明进程之间相互通信的其他技术IPC

UNIX IPC已经是而且继续是各种进程通信方式的统称，其中极少能在所有UNIX的实现中进行移植。表14-1列出了不同实现所支持的不同形式的IPC：
#+CAPTION: UNIX IPC
#+ATTR_HTML: :border 1 :rules all :frame boader
| IPC类型        | POSIX.1 | XPG3 | V7 | SVR2 | SVR3.2 | SVR4 | 4.3BSD | 4.3+BSD |
| 管道(半双工)   | •       | •    | •  | •    | •      | •    | •      | •       |
| FIFO(命令管道) | •       | •    |    | •    | •      | •    |        | •       |
| 流管道(全双工) |         |      |    |      | •      | •    | •      | •       |
| 命令流管道     |         |      |    |      | •      | •    | •      | •       |
| 消息队列       |         | •    |    | •    | •      | •    |        |         |
| 信号量         |         | •    |    | •    | •      | •    |        |         |
| 共享内存       |         | •    |    | •    | •      | •    |        |         |
| 套接口         |         |      |    |      |        | •    | •      | •       |
| 流             |         |      |    |      | •      | •    |        |         |
正如上表所示，不管哪一种UNIX实现，都可依靠的唯一一种IPC是半双工的管道。表中前7种IPC通常限于同一台主机的各个进程间的IPC。最后两种：套接口和流，则支持不同主机上各个进程间IPC。虽然中间三种形式的IPC(消息队列、信号量以及共享存储器)在表中说明为只受到系统V的支持，但是在大多数制造商所支持的，从伯克利UNIX导出的UNIX系统中(例如，SunOS以及Ultrix)已经添加了这三种形式的IPC

本章将讨论经典的IPC：
+ 管道
+ FIFO
+ 消息队列
+ 信号量
+ 共享内存

* 管道
管道是UNIX IPC的最老形式，并且所有UNIX系统都提供此种通信机制，管道有两种限制; 
1. 半双工的：数据只能在一个方向上流动
2. 只能在具有公共祖先的进程之间使用：通常一个管道由一个进程创建，然后该进程调用fork，此后父、子进程之间就可应用该管道

尽管有这两种限制，半双工管道仍是最常用的IPC形式

** pipe函数
pipe函数：创建管道
#+BEGIN_SRC C
    #include <unistd.h>

    /**
       创建管道
       
       filedes：文件描述符数组，iledes[0]为读而打开，filedes[1]为写而打开，
                filedes[1]的输出是filedes[0]的输入

       return：若成功则为0，若出错则为-1
    ,*/
    int pipe(int filedes[2]);
#+END_SRC
由参数filedes数组返回两个文件描述符：
+ filedes[0]为读而打开
+ filedes[1]为写而打开，filedes[1]的输出正好是filedes[0]的输入

有两种方法来描绘一个管道，左半图显示了管道的两端在一个进程中相互连接，右半图则说明数据通过内核在管道中流动：
#+ATTR_HTML: image :width 90% 
[[file:pic/pipe.jpg]] 

fstat函数对管道的每一端都返回一个FIFO类型的文件描述符，可以用S_ISFIFO宏来测试管道

单个进程中的管道几乎没有任何用处。通常调用pipe的进程接着调用fork，这样就创建了从父进程到子进程或反之的IPC通道。下图显示了这种情况：
#+ATTR_HTML: image :width 70% 
[[file:pic/pipe-fork.jpg]] 

fork之后做什么取决于我们想要有的数据流的方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程则关闭写端(fd[1])。图14-3显示了描述符的最后安排：
#+ATTR_HTML: image :width 70% 
[[file:pic/pipe-fork-close.jpg]] 

当管道的一端被关闭后，下列规则起作用：
1. 当读一个写端已被关闭的管道时，在所有数据都被读取后，read返回0，以指示达到了文件结束处(从技术方面考虑，管道的写端还有进程时，就不会产生文件的结束。可以复制一个管道的描述符，使得有多个进程具有写打开文件描述符。但是，通常一个管道只有一个读进程，一个写进程)
2. 如果写一个读端已被关闭的管道，则产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write出错返回，errno设置为EPIPE

注意：在写管道时，常数PIPE_BUF规定了内核中管道缓存器的大小。如果对管道进行write调用，而且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或FIFO)的write操作穿插进行。但是若有多个进程同时写一个管道(FIFO)，而且某个或某些进程要求写的字节数超过PIPE_BUF字节数，则数据可能会与其他写操作的数据相穿插

*** 实例：创建管道
创建了一个从父进程到子进程的管道，并且父进程经由该管道向子进程传送数据：
#+BEGIN_SRC C
  #include "apue.h"

  int main(void)
  {
          int     n;
          int     fd[2];
          pid_t   pid;
          char    line[MAXLINE];

          if (pipe(fd) < 0)
                  err_sys("pipe error");

          if ((pid = fork()) < 0) {
                  err_sys("fork error");
          } else if (pid > 0) {       /* parent */
                  close(fd[0]);// close read tunnel of pipe in parent process
                  if(write(fd[1], "hello world\n", 12) < 0)
                          err_sys("write to pipe error");
          } else {                /* child */
                  close(fd[1]); // close write tunnel of pipe in child process
                  n = read(fd[0], line, MAXLINE);
                  if(write(STDOUT_FILENO, line, n) < 0)
                          err_sys("write to console error");
          }
      
          exit(0);
  }
#+END_SRC
上面程序对管道描述符调用read和write。更为普遍的是将管道描述符复制为标准输入和标准输出。在此之后通常子进程调用exec，执行另一个程序，该程序从标准输入(已创建的管道)或将数据写至其标准输出(管道)

测试结果：
#+BEGIN_SRC sh
  $ ./src/ipc/pipe1

  hello world
#+END_SRC

*** 文件复制到分页程序
下面程序的功能是每次一页显示已产生的输出。已经有很多UNIX公用程序具有分页功能，因此无需再构造一个新的分页程序，而是调用用户最喜爱的分页程序。为了避免先将所有数据写到一个临时文件中，然后再调用系统中的有关程序显示该文件，将输出通过管道直接送到分页程序。为此先创建一个管道，一个子进程，使子进程的标准输入成为管道的读端，然后exec用户喜爱的分页程序:
    #+BEGIN_SRC C
      #include "apue.h"
      #include <sys/wait.h>

      #define DEF_PAGER   "/usr/bin/less"     /* default pager program */

      int main(int argc, char *argv[])
      {
              int     n;
              int     fd[2];
              pid_t   pid;
              char    *pager, *argv0;
              char    line[MAXLINE];
              FILE    *fp;

              if (argc != 2)
                      err_quit("usage: a.out <pathname>");

              if ((fp = fopen(argv[1], "r")) == NULL)
                      err_sys("can't open %s", argv[1]);
              if (pipe(fd) < 0)
                      err_sys("pipe error");

              if ((pid = fork()) < 0) {
                      err_sys("fork error");
              } else if (pid > 0) {                               /* parent */
                      close(fd[0]);       /* close read end */

                      /* parent copies argv[1] to pipe */
                      while (fgets(line, MAXLINE, fp) != NULL) {
                              n = strlen(line);
                              if (write(fd[1], line, n) != n)
                                      err_sys("write error to pipe");
                      }
                      if (ferror(fp))
                              err_sys("fgets error");

                      close(fd[1]);   /* close write end of pipe for reader */

                      if (waitpid(pid, NULL, 0) < 0)
                              err_sys("waitpid error");
                      exit(0);
              } else {                                        /* child */
                      close(fd[1]);   /* close write end */
                      if (fd[0] != STDIN_FILENO) { // standard input descriptor point to fd[0]
                              if (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO)
                                      err_sys("dup2 error to stdin");
                              close(fd[0]);   /* don't need this after dup2 */
                      }

                      /* get arguments for execl() */
                      if ((pager = getenv("PAGER")) == NULL)
                              pager = DEF_PAGER;
                      if ((argv0 = strrchr(pager, '/')) != NULL)
                              argv0++;        /* step past rightmost slash */
                      else
                              argv0 = pager;  /* no slash in pager */

                      if (execl(pager, argv0, (char *)0) < 0)
                              err_sys("execl error for %s", pager);
              }
              exit(0);
      }
    #+END_SRC
在调用fork之前先创建一个管道。fork之后父进程关闭其读端，子进程关闭其写端。子进程然后调用dup2，使其标准输入指向管道的读端。当执行分页程序时，其标准输入将是管道的读端：

#+BEGIN_SRC sh
  $ ./src/ipc/most2 Makefile

  # Makefile.in generated by automake 1.15 from Makefile.am.
  # Makefile.  Generated from Makefile.in by configure.

  # Copyright (C) 1994-2014 Free Software Foundation, Inc.

  # This Makefile.in is free software; the Free Software Foundation
  # gives unlimited permission to copy and/or distribute it,
  # with or without modifications, as long as this notice is preserved.

  # This program is distributed in the hope that it will be useful,
  # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
  # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  # PARTICULAR PURPOSE.



  am__is_gnu_make = { \
    if test -z '$(MAKELEVEL)'; then \
      false; \
    elif test -n '$(MAKE_HOST)'; then \
      true; \
    elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
  : #分页开始
#+END_SRC

将一个描述符复制到另一个时，在子进程中，fd[0]复制到标准输入，应当注意该描述符的值并不已经是所希望的值。如果该描述符已经具有所希望的值，并且我们先调用dup2，然后调用close则将关闭此进程中只有该单个描述符所代表的打开文件。在本程序中，如果shell没有打开标准输入，那么程序开始处的fopen应已使用描述符0，也就是最小未使用的描述符，所以fd[0]决不会等于标准输入。尽管如此，只要先调用dup2，然后调用close以复制一个描述符到另一个，作为一种保护性的编程措施，总是先将两个描述符进行比较

先使用环境变量PAGER获得用户分页程序名称的。如果操作没有成功，则使用系统默认值。这是环境变量的常见用法

*** 进程间同步
以前使用信号实现了TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT以及WAIT_CHILD。下面则是一个使用管道的实现：
#+BEGIN_SRC C
  #include "apue.h"

  static int  pfd1[2], pfd2[2];

  void TELL_WAIT(void)
  {
          if (pipe(pfd1) < 0 || pipe(pfd2) < 0)
                  err_sys("pipe error");
  }

  void TELL_PARENT(pid_t pid)
  {
          if (write(pfd2[1], "c", 1) != 1)
                  err_sys("write error");
  }

  void WAIT_PARENT(void)
  {
          char    c;

          if (read(pfd1[0], &c, 1) != 1)
                  err_sys("read error");

          if (c != 'p')
                  err_quit("WAIT_PARENT: incorrect data");
  }

  void TELL_CHILD(pid_t pid)
  {
          if (write(pfd1[1], "p", 1) != 1)
                  err_sys("write error");
  }

  void WAIT_CHILD(void)
  {
          char    c;

          if (read(pfd2[0], &c, 1) != 1)
                  err_sys("read error");

          if (c != 'c')
                  err_quit("WAIT_CHILD: incorrect data");
  }
#+END_SRC
在fork之前创建了两个管道。父进程在调用TELL_CHILD时经由上一个管道写一个字符'P'，子进程在调用TELL_PARENT时，经由下一个管道写一个字符'C'。相应的WAIT_XXX函数调用read读一个字符，没有读到字符时阻塞(睡眠等待)：
#+ATTR_HTML: image :width 70% 
[[file:pic/pipe-tell-wait.jpg]] 

注意：每一个管道都有一个额外的读取进程，这没有关系。也就是说除了子进程从pfd1[0]读取，父进程也有上一个管道的读端。因为父进程并没有执行对该管道的读操作，所以这不会产生任何影响

** FIFO

* 系统V IPC

** 消息队列

** 信号量

** 共享内存
