#+TITLE: 停机问题
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+OPTIONS: num:nil timestamp:nil 

#+BEGIN_EXAMPLE
  停机问题：给定一个只需要一个输入的程序 P，以及一个对象 x，判断程序 P 在以 x 作为输入时是否会停机

  能否用代码实现一个函数 S ，它的参数是 P 和 x ：
  1. 如果P(x) 停机，则 S 返回 true
  2. 如果P(x) 死循环，则 S 返回 false 
#+END_EXAMPLE

* 非正式证明
  假设可以编写一个过程 stop? ，如果 P(x) 能停机 ，则 stop? 返回 #t , 否则返回 #f 

  #+BEGIN_EXAMPLE
    (define (stop? P x)
      ....) 
  #+END_EXAMPLE

  死循环定义为：
  #+BEGIN_SRC scheme
  (define (loop-forever x)
    (loop-forever x)) 
  #+END_SRC

  显然有：
  #+BEGIN_SRC scheme
  (stop? loop-forever 1) ; => #f 
  #+END_SRC

  现在定义一个辅助过程 diag ：
  #+BEGIN_SRC scheme
  (define (diag x)
      (if (stop? x x)
	  (loop-forever)
	  42))
  #+END_SRC

  接下来的问题就是：  *(diag diag)* 的值是多少？ 
  + 如果(diag diag) 触发死循环 ，意味着 (stop? diag diag)为 true ，根据 stop? 的定义，推理得 diag(diag) 应该停机，这和 (diag diag) 产生死循环相悖
  + 如果(diag diag) 返回 42 ，意味着 (stop? diag diag) 为 false ，根据 stop? 的定义，可以得到 diag(diag) 不会停机，这个 (diag diag) 返回 42 相悖

  根据上面的分析，可以推理出： *过程 _stop?_ 可以被编写*  这个假设是 *错误的* 

  #+BEGIN_EXAMPLE
    停机问题是一个不可被计算的函数，这意味着存在一个函数，可以被定义，但是无法被编程
  #+END_EXAMPLE

* 哥德尔不完备定律
  把思绪回到1931年，那个数学界风起云涌的年代，一个名不经传的20出头的学生，在他的博士论文中证明了一个惊天动地的结论
  #+BEGIN_EXAMPLE
    在那个年代，希尔伯特的数学天才就像太阳的光芒一般夺目，在关于数学严格化的大纷争中希尔伯特带领的形式主义派系技压群雄，得到许多当时有名望的数学家的支持

    希尔伯特希望借助于 形式化 的手段，抽掉数学证明中的意义
    把数学证明抽象成一堆无意义的符号转换，就连人类赖以自豪的逻辑推导，也不过只是一堆堆符号转换而已

    这样一来，一个日常所谓的，带有直观意义和解释的数学系统就变成了一个纯粹由无意义符号表达的、公理加上推导规则所构成的形式系统
    而数学证明呢，只不过是在这个系统内玩的一个文字游戏

    令人惊讶的是，这样一种做法，真的是可行的！数学的意义，似乎竟然真的可以被抽掉！
    另一方面，一个形式系统具有非常好的性质，平时人们证明一个定理所动用的推导，变成了纯粹机械的符号变换

    希尔伯特希望能够证明，在任一个无矛盾的形式系统中所能表达的所有陈述都要么能够证明要么能够证伪
    这看起来是个非常直观的结论，因为一个结论要么是真要么是假
    而它在它所处的领域/系统中当然应该能够证明或证伪了（只要我们能够揭示出该系统中足够多的真理）
  #+END_EXAMPLE

  然而，哥德尔的证明无情的击碎了这一企图，哥德尔的证明揭示出， *任何足够强到蕴含了皮亚诺算术系统（PA）的一致（即无矛盾）的系统都是不完备的* ，所谓不完备也就是说在 *系统内存在一个为真但无法在系统内推导出的命题* 。这在当时的数学界揭起了轩然大波，其证明不仅具有数学意义，而且蕴含了深刻的哲学意义。从那时起这一不完备性定理就被引申到自然科学乃至人文科学的各个角落…至今还没有任何一个数学定理居然能够产生这么广泛而深远的影响

  哥德尔的证明非常的长，达到了200多页纸，但其中很大的成分是用在了一些辅助性的工作上面，比如占据超过1/3纸张的是关于一个形式系统如何映射到自然数，也就是说，如何 _把一个形式系统中的所有公式都表示为自然数_ ，并可以 _从一自然数反过来得出相应的公式_ 。这其实就是 *编码* ，现在看来是很显然的：
  + 因为一个程序就可以被编码成 _二进制数_ ，反过来也可以 _解码_ 。但是在当时这是一个全新的思想，也是最关键的辅助性工作之一
  + 这正是 *程序即数据* 的最初想法 

  现在要证明哥德尔的不完备性定理，只需在假定的 _形式系统 T_ 内表达出一个为 _真_ 但无法在 _T_ 内 *推导* 出（证明）的 _命题_ 。于是哥德尔构造了这样一个命题 P :  *T 系统内无法证明 P* ，这里的系统 T 当然就是命题 P 所处的形式系统

  #+BEGIN_EXAMPLE
    哥德尔构造的命题其实就是 “我不可以被证明”，跟著名的说谎者悖论非常相似，只是把“说谎”改成了“不可以被证明”
  #+END_EXAMPLE

  如果这个命题能够在 T 内表达出来，就可以得出 _P为真但无法在T内推导出来_ 的结论，从而证明 T 的不完备性 ：
  1. 假设 _T 可以证明出 P_ ，而因为 P 说的就是 _P不可在系统T内证明_ ，于是又得到 *T 无法证明出P* ，产生矛盾
  2. 这说明假设 _T可以证明P_ 是错误的，根据排中律，得到 _T不可以证明P_
  3. 由于P说的正是“T系统内无法证明P”，所以 P 就成了一个 *正确的命题，同时无法由T内证明* ！

  #+BEGIN_EXAMPLE
    如果你足够敏锐，你会发现上面这番推理本身不就是证明吗？其证明的结果不就是 P 是正确的？

    然而实际上这番证明是位于 T 系统之外的，它用到了一个关于T系统的假设“T是一致（无矛盾）的”

    这个假设并非T系统里面的内容，所以刚才其实是在T系统之外推导出了P是正确的

    这跟 P 不能在 T 之内推导出来并不矛盾。所以别担心，一切都正常
  #+END_EXAMPLE

  那么，剩下来最关键的问题就是 *如何用形式语言在T内表达出这个P* ，上面的理论虽然漂亮，但如果 P 根本没法在 T 内表达出来，又如何能证明 _T 内存在这个为真但无法被证明的 P_ 呢？

  于是，就有了哥德尔证明里面最核心的构造，哥德尔构造了这样一个公式：
  #+BEGIN_EXAMPLE
    N(n) is unprovable in T
  #+END_EXAMPLE

  这个公式由两部分构成：
  + _n_ : 这个公式的自由变量，它是一个 *自然数* ，一旦给定，那么这个 *公式就变成一个明确的命题*
  + _N_ : 从 _n_  *解码* 出的货真价实的（常见的符号形式的） _公式_  
    + 哥德尔的证明第一部分就是把公式编码
  + _is unprovable in T_ ：一个谓词，这里没有用 _形式语言_ 而是用 *自然语言* 表达出来的
    + 哥德尔证明了它是可以用形式语言表达出来的，大致思路就是：一个形式系统中的符号数目是有限的，它们构成这个形式系统的符号表
    + 可以依次枚举出所有长度为1的串，长度为2的串，长度为3的串…
    + 根据 _形式系统_ 给出的 *语法规则* ，可以检查每个串是否是 *良构* 的公式，其实也就是说，是否符合语法规则
      + 一个形式系统是需要语法规则的，比如逻辑语言形式化之后就会看到 _P->Q_ 是良构，而 _->PQ_ 则不是
      + 因而可以 *枚举出所有的良构的公式来* 
    + 观察到 _形式系统中的证明_ 也不过就是由一个个的 _良构公式构成的序列_ 
      + 推导的过程，不就是一个公式接一个公式嘛，而良构公式构成的序列本身同样也是由 _符号表内的符号构成的串_ 
      + 所以只需枚举所有的串，对每一个串检查它是否是一个由良构公司构成的序列（证明）：
	+ 如果是，则记录下这个良构公式序列（证明）的最后一个良构公式，也就是它的 _结论_ 。这样便枚举出了 *所有的可由 T 推导出的定理*
    + 为了表达出 _X is unprovable in T_ ，本质上只需说 *不存在这样一个自然数 S，它所解码出来的良构序列以 X 为终结* ！

  现在用 *UnPr(X)* 来表达 _X is unprovable in T_ ，于是哥德尔的公式变成了：
  #+BEGIN_EXAMPLE
    UnPr( N(n) )
  #+END_EXAMPLE

  现在，到了最关键的部分，首先把这个 _公式_ 简记为 *G(n)* ：
  #+BEGIN_EXAMPLE
    G(n) : UnPr( N(n) )

    但别忘了 G 内有一个自由变量 n，所以G现在还不是一个命题，而只是一个公式，所以谈不上真假
  #+END_EXAMPLE

  由于 G 也是个 _良构的公式_ ，所以它也有自己的 _编码 g_ ，当然 g 是一个自然数，现在我们把 *g 作为 G 的参数* ，也就是说， *把 G 里面的自由变量 n替换为 g* ，于是得到一个真正的 *命题* ：
  #+BEGIN_EXAMPLE
    G(g) : UnPr( G(g) )
  #+END_EXAMPLE

  用自然语言来说，这个命题 _G(g)_ 说的就是 *我是不可在T内证明的* 。而一开始已经讲过了如何用这个命题来推断出 *G(g) 为真但无法在 T 内证明* ，于是这就证明了 _哥德尔的不完备性定理_ 

  #+BEGIN_EXAMPLE
    哥德尔的不完备性定理被称为20世纪数学最重大的发现

    现在知道为真但无法在系统内证明的命题不仅仅是这个诡异的“哥德尔命题”，还有很多真正有意义的明确命题
    其中最著名的就是连续统假设，此外哥德巴赫猜想也有可能是个没法在数论系统中证明的真命题
  #+END_EXAMPLE

** 从哥德尔公式到 Y 组合子
   哥德尔的不完备性定理证明了 *数学是一个未完结的学科* ，永远有 *需要以人的头脑从系统之外去用独有的直觉发现的东西* 
   #+BEGIN_EXAMPLE
     罗杰・彭罗斯在《The Emperor' s New Mind》中用它来证明人工智能的不可实现

     当然，这个结论是很受质疑的。但哥德尔的不完备性定理的确还有很多很多的有趣推论，数学的和哲学上的
   #+END_EXAMPLE

   哥德尔的不完备性定理最深刻的地方就是它揭示了 *自指（或称 _递归调用自身_ 等等）结构的普遍存在性* ，再来看一看哥德尔命题的绝妙构造：

   #+BEGIN_EXAMPLE
     G(n) : UnPr( N(n) )

   #+END_EXAMPLE

   注意：这里的 _UnPr_ 其实是一个 *形式化的谓词* ，它不一定要说“X在T内可证明”，可以把它 *泛化为一个 _一般化_ 的谓词*  _P_ ：

   #+BEGIN_EXAMPLE
     G(n) : P( N(n) )

   #+END_EXAMPLE

   对于任意一个单参的谓词P，都存在上面这个哥德尔公式。然后算出这个哥德尔公式的 _自然数编码 g_ ，然后把它扔给G，就得到：
   #+BEGIN_EXAMPLE
     G(g) : P( G(g) )

   #+END_EXAMPLE

   _Y 组合子_ 的构造不就是这样一个形式，把 _G_ 和 _P_ 都看成 *一元函数* ， _G(g)_ 正是 _P_ 这个函数的 *不动点* 么！于是，从哥德尔的证明里面直接看到了Y 组合子！

* 对角线方法
